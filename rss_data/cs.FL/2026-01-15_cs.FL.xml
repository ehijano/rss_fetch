<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Jan 2026 05:00:26 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 15 Jan 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Reversible Weighted Automata over Finite Rings and Monoids with Commuting Idempotents</title>
      <link>https://arxiv.org/abs/2601.09409</link>
      <description>arXiv:2601.09409v1 Announce Type: new 
Abstract: Reversible weighted automata are introduced and considered in a specific setting where the weights are taken from a nontrivial locally finite commutative ring such as a finite field. It is shown that the supports of series realised by such automata are precisely the rational languages such that the idempotents in their syntactic monoids commute. In particular, this is true for reversible weighted automata over the finite field $\mathbb{F}_2$, where the realised series can be directly identified with such languages. A new automata-theoretic characterisation is thus obtained for the variety of rational languages corresponding to the pseudovariety of finite monoids $\mathbf{ECom}$, which also forms the Boolean closure of the reversible languages in the sense of J.-\'E. Pin. The problem of determining whether a rational series over a locally finite commutative ring can be realised by a reversible weighted automaton is decidable as a consequence.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.09409v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 15 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Peter Kostol\'anyi, Andrej Ravinger</dc:creator>
    </item>
    <item>
      <title>Formally Verifying Noir Zero Knowledge Programs with NAVe</title>
      <link>https://arxiv.org/abs/2601.09372</link>
      <description>arXiv:2601.09372v1 Announce Type: cross 
Abstract: Zero-Knowledge (ZK) proof systems are cryptographic protocols that can (with overwhelming probability) demonstrate that the pair $(X, W)$ is in a relation $R$ without revealing information about the private input $W$. This membership checking is captured by a complex arithmetic circuit: a set of polynomial equations over a finite field. ZK programming languages, like Noir, have been proposed to simplify the description of these circuits. A developer can write a Noir program using traditional high-level constructs that can be compiled into a lower-level ACIR (Abstract Circuit Intermediate Representation), which is essentially a high-level description of an arithmetic circuit. In this paper, we formalise some of the ACIR language using SMT-LIB and its extended theory of finite fields. We use this formalisation to create an open-source formal verifier for the Noir language using the SMT solver cvc5. Our verifier can be used to check whether Noir programs behave appropriately. For instance, it can be used to check whether a Noir program has been properly constrained, that is, the finite-field polynomial equations generated truly capture the intended relation. We evaluate our verifier over 4 distinct sets of Noir programs, demonstrating its practical applicability and identifying a hard-to-check constraint type that charts an improvement path for our verification framework.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.09372v1</guid>
      <category>cs.CR</category>
      <category>cs.FL</category>
      <category>cs.SE</category>
      <pubDate>Thu, 15 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pedro Antonino, Namrata Jain</dc:creator>
    </item>
    <item>
      <title>An Elementary Proof of the FMP for Kleene Algebra</title>
      <link>https://arxiv.org/abs/2212.10931</link>
      <description>arXiv:2212.10931v4 Announce Type: replace 
Abstract: Kleene Algebra (KA) is a useful tool for proving that two programs are equivalent. Because KA's equational theory is decidable, it integrates well with interactive theorem provers. This raises the question: which equations can we (not) prove using the laws of KA? Moreover, which models of KA are complete, in the sense that they satisfy exactly the provable equations? Kozen (1994) answered these questions by characterizing KA in terms of its language model. Concretely, equivalences provable in KA are exactly those that hold for regular expressions.
  Pratt (1980) observed that KA is complete w.r.t. relational models, i.e., that its provable equations are those that hold for any relational interpretation. A less known result due to Palka (2005) says that finite models are complete for KA, i.e., that provable equivalences coincide with equations satisfied by all finite KAs. Phrased contrapositively, the latter is a finite model property (FMP): any unprovable equation is falsified by a finite KA. Both results can be argued using Kozen's theorem, but the implication is mutual: given that KA is complete w.r.t. finite (resp. relational) models, Palka's (resp. Pratt's) arguments show that it is complete w.r.t. the language model.
  We embark on a study of the different complete models of KA, and the connections between them. This yields a novel result subsuming those of Palka and Pratt, namely that KA is complete w.r.t. finite relational models. Next, we put an algebraic spin on Palka's techniques, which yield a new elementary proof of the finite model property, and by extension, of Kozen's and Pratt's theorems. In contrast with earlier approaches, this proof relies not on minimality or bisimilarity of automata, but rather on representing the regular expressions involved in terms of transformation automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.10931v4</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 15 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tobias Kapp\'e</dc:creator>
    </item>
    <item>
      <title>Scalable and Approximation-free Symbolic Control for Unknown Euler-Lagrange Systems</title>
      <link>https://arxiv.org/abs/2509.19859</link>
      <description>arXiv:2509.19859v2 Announce Type: replace-cross 
Abstract: We propose a novel symbolic control framework for enforcing temporal logic specifications in Euler-Lagrange systems that addresses the key limitations of traditional abstraction-based approaches. Unlike existing methods that require exact system models and provide guarantees only at discrete sampling instants, our approach relies only on bounds on system parameters and input constraints, and ensures correctness for the full continuous-time trajectory. The framework combines scalable abstraction of a simplified virtual system with a closed-form, model-free controller that guarantees trajectories satisfy the original specification while respecting input bounds and remaining robust to unknown but bounded disturbances. We provide feasibility conditions for the construction of confinement regions and analyze the trade-off between efficiency and conservatism. Case studies on pendulum dynamics, a two-link manipulator, and multi-agent systems, including hardware experiments, demonstrate that the proposed approach ensures both correctness and safety while significantly reducing computational time and memory requirements. These results highlight its scalability and practicality for real-world robotic systems where precise models are unavailable and continuous-time guarantees are essential.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.19859v2</guid>
      <category>eess.SY</category>
      <category>cs.FL</category>
      <category>cs.SC</category>
      <category>cs.SY</category>
      <pubDate>Thu, 15 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ratnangshu Das, Shubham Sawarkar, Pushpak Jagtap</dc:creator>
    </item>
  </channel>
</rss>
