<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 04 Mar 2025 05:01:04 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Mapping words to powers by morphisms</title>
      <link>https://arxiv.org/abs/2503.00960</link>
      <description>arXiv:2503.00960v1 Announce Type: new 
Abstract: We characterize the words that can be mapped to arbitrarily high powers by injective morphisms. For all other words, we prove a linear upper bound for the highest power that they can be mapped to, and this bound is optimal up to a constant factor if there is no restriction on the size of the alphabet. We also prove that, for any integer $n \geq 2$, deciding whether a given word can be mapped to an $n$th power by a nonperiodic morphism is NP-hard and in PSPACE, and so is deciding whether a given word can be mapped to a nonprimitive word by a nonperiodic morphism.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.00960v1</guid>
      <category>cs.FL</category>
      <category>math.CO</category>
      <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Aleksi Saarela</dc:creator>
    </item>
    <item>
      <title>Lexicographic transductions of finite words</title>
      <link>https://arxiv.org/abs/2503.01746</link>
      <description>arXiv:2503.01746v1 Announce Type: new 
Abstract: Regular transductions over finite words have linear input-to-output growth. This class of transductions enjoys many characterizations. Recently, regular transductions have been extended by Boja\'nczyk to polyregular transductions, which have polynomial growth, and are characterized by pebble transducers and MSO interpretations. Another class of interest is that of transductions defined by streaming string transducers or marble transducers, which have exponential growth and are incomparable with polyregular transductions.
  In this paper, we consider MSO set interpretations (MSOSI) over finite words which were introduced by Colcombet and Loeding. MSOSI are a natural candidate for the class of "regular transductions with exponential growth", and are rather well-behaved. However MSOSI lack, for now, two desirable properties that regular and polyregular transductions have. The first property is being described by an automaton model, which is closely related to the second property of regularity preserving meaning preserving regular languages under inverse image. We first show that if MSOSI are (effectively) regularity preserving then any automatic $\omega$-word has a decidable MSO theory, an almost 20 years old conjecture of B\'ar\'any.
  Our main contribution is the introduction of a class of transductions of exponential growth, which we call lexicographic transductions. We provide three different presentations for this class: 1) as the closure of simple transductions (recognizable transductions) under a single operator called maplex; 2) as a syntactic fragment of MSOSI (but the regular languages are given by automata instead of formulas); 3) we give an automaton based model called nested marble transducers, which generalize both marble transducers and pebble transducers. We show that this class enjoys many nice properties including being regularity preserving.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.01746v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Emmanuel Filiot, Pierre-Alain Reynier, Nathan Lhote</dc:creator>
    </item>
    <item>
      <title>Taming Infinity one Chunk at a Time: Concisely Represented Strategies in One-Counter MDPs</title>
      <link>https://arxiv.org/abs/2503.00788</link>
      <description>arXiv:2503.00788v1 Announce Type: cross 
Abstract: Markov decision processes (MDPs) are a canonical model to reason about decision making within a stochastic environment. We study a fundamental class of infinite MDPs: one-counter MDPs (OC-MDPs). They extend finite MDPs via an associated counter taking natural values, thus inducing an infinite MDP over the set of configurations (current state and counter value). We consider two characteristic objectives: reaching a target state (state-reachability), and reaching a target state with counter value zero (selective termination). The synthesis problem for the latter is not known to be decidable and connected to major open problems in number theory. Furthermore, even seemingly simple strategies (e.g., memoryless ones) in OC-MDPs might be impossible to build in practice (due to the underlying infinite configuration space): we need finite, and preferably small, representations.
  To overcome these obstacles, we introduce two natural classes of concisely represented strategies based on a (possibly infinite) partition of counter values in intervals. For both classes, and both objectives, we study the verification problem (does a given strategy ensure a high enough probability for the objective?), and two synthesis problems (does there exist such a strategy?): one where the interval partition is fixed as input, and one where it is only parameterized. We develop a generic approach based on a compression of the induced infinite MDP that yields decidability in all cases, with all complexities within PSPACE.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.00788v1</guid>
      <category>cs.GT</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>math.PR</category>
      <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Michal Ajdar\'ow, James C. A. Main, Petr Novotn\'y, Mickael Randour</dc:creator>
    </item>
    <item>
      <title>The Narayana Morphism and Related Words</title>
      <link>https://arxiv.org/abs/2503.01026</link>
      <description>arXiv:2503.01026v1 Announce Type: cross 
Abstract: The Narayana morphism $\nu$ maps $0 \rightarrow 01$, $1 \rightarrow 2$, $2 \rightarrow 0$ and has a fixed point $\mathbf{n} = n_0 n_1 n_2 \cdots = {\tt 0120010120120}\cdots$. In this paper we study the properties of this word and related words using automata theory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.01026v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <category>math.NT</category>
      <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeffrey Shallit</dc:creator>
    </item>
    <item>
      <title>Formally Discovering and Reproducing Network Protocols Vulnerabilities</title>
      <link>https://arxiv.org/abs/2503.01538</link>
      <description>arXiv:2503.01538v1 Announce Type: cross 
Abstract: The rapid evolution of cyber threats has increased the need for robust methods to discover vulnerabilities in increasingly complex and diverse network protocols. This paper introduces Network Attack-centric Compositional Testing (NACT), a novel methodology designed to discover new vulnerabilities in network protocols and create scenarios to reproduce these vulnerabilities through attacker models. NACT integrates composable attacker specifications, formal specification mutations, and randomized constraint-solving techniques to generate sophisticated attack scenarios and test cases. The methodology enables comprehensive testing of both single-protocol and multi-protocol interactions. Through case studies involving a custom minimalist protocol (MiniP) and five widely used QUIC implementations, NACT is shown to effectively identify, reproduce, and find new real-world vulnerabilities such as version negotiation abuse. Additionally, by comparing the current and older versions of these QUIC implementations, NACT demonstrates its ability to detect both persistent vulnerabilities and regressions. Finally, by supporting cross-protocol testing within a black-box testing framework, NACT provides a versatile approach to improve the security of network protocols.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.01538v1</guid>
      <category>cs.CR</category>
      <category>cs.FL</category>
      <category>cs.NI</category>
      <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-031-79007-2_22</arxiv:DOI>
      <dc:creator>Christophe Crochet, John Aoga, Axel Legay</dc:creator>
    </item>
    <item>
      <title>Combinatorics on words and generating Dirichlet series of automatic sequences</title>
      <link>https://arxiv.org/abs/2401.13524</link>
      <description>arXiv:2401.13524v4 Announce Type: replace-cross 
Abstract: Generating series are crucial in enumerative combinatorics, analytic combinatorics, and combinatorics on words. Though it might seem at first view that generating Dirichlet series are less used in these fields than ordinary and exponential generating series, there are many notable papers where they play a fundamental role, as can be seen in particular in the work of Flajolet and several of his co-authors. In this paper, we study Dirichlet series of integers with missing digits or blocks of digits in some integer base $b$; i.e., where the summation ranges over the integers whose expansions form some language strictly included in the set of all words over the alphabet $\{0, 1, \dots, b-1\}$ that do not begin with a $0$. We show how to unify and extend results proved by Nathanson in 2021 and by K\"ohler and Spilker in 2009. En route, we encounter several sequences from Sloane's On-Line Encyclopedia of Integer Sequences, as well as some famous $b$-automatic sequences or $b$-regular sequences. We also consider a specific sequence that is not $b$-regular.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.13524v4</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jean-Paul Allouche, Jeffrey Shallit, Manon Stipulanti</dc:creator>
    </item>
    <item>
      <title>InductionBench: LLMs Fail in the Simplest Complexity Class</title>
      <link>https://arxiv.org/abs/2502.15823</link>
      <description>arXiv:2502.15823v3 Announce Type: replace-cross 
Abstract: Large language models (LLMs) have shown remarkable improvements in reasoning and many existing benchmarks have been addressed by models such as o1 and o3 either fully or partially. However, a majority of these benchmarks emphasize deductive reasoning, including mathematical and coding tasks in which rules such as mathematical axioms or programming syntax are clearly defined, based on which LLMs can plan and apply these rules to arrive at a solution. In contrast, inductive reasoning, where one infers the underlying rules from observed data, remains less explored. Such inductive processes lie at the heart of scientific discovery, as they enable researchers to extract general principles from empirical observations. To assess whether LLMs possess this capacity, we introduce InductionBench, a new benchmark designed to evaluate the inductive reasoning ability of LLMs. Our experimental findings reveal that even the most advanced models available struggle to master the simplest complexity classes within the subregular hierarchy of functions, highlighting a notable deficiency in current LLMs' inductive reasoning capabilities. Coda and data are available https://github.com/Wenyueh/inductive_reasoning_benchmark.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.15823v3</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <pubDate>Tue, 04 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Wenyue Hua, Tyler Wong, Sun Fei, Liangming Pan, Adam Jardine, William Yang Wang</dc:creator>
    </item>
  </channel>
</rss>
