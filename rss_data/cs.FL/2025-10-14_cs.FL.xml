<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Oct 2025 04:00:59 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Bringing Algebraic Hierarchical Decompositions to Concatenative Functional Languages</title>
      <link>https://arxiv.org/abs/2510.12481</link>
      <description>arXiv:2510.12481v1 Announce Type: new 
Abstract: Programming languages tend to evolve over time to use more and more concepts from theoretical computer science. Still, there is a gap between programming and pure mathematics. Not all theoretical results have realized their promising applications. The algebraic decomposition of finite state automata (Krohn-Rhodes Theory) constructs an emulating hierarchical structure from simpler components for any computing device. These decompositions provide ways to understand and control computational processes, but so far the applications were limited to theoretical investigations. Here, we study how to apply algebraic decompositions to programming languages. We use recent results on generalizing the algebraic theory to the categorical level (from semigroups to semigroupoids) and work with the special class of concatenative functional programming languages. As a first application of semigroupoid decompositions, we start to design a family of programming languages with an explicit semigroupoid representation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.12481v1</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Attila Egri-Nagy</dc:creator>
    </item>
    <item>
      <title>Flavors of Quantifiers in Hyperlogics</title>
      <link>https://arxiv.org/abs/2510.12298</link>
      <description>arXiv:2510.12298v1 Announce Type: cross 
Abstract: Hypertrace logic is a sorted first-order logic with separate sorts for time and execution traces. Its formulas specify hyperproperties, which are properties relating multiple traces. In this work, we extend hypertrace logic by introducing trace quantifiers that range over the set of all possible traces. In this extended logic, formulas can quantify over two kinds of trace variables: constrained trace variables, which range over a fixed set of traces defined by the model, and unconstrained trace variables, which can be assigned to any trace. In comparison, hyperlogics such as HyperLTL have only constrained trace quantifiers. We use hypertrace logic to study how different quantifier patterns affect the decidability of the satisfiability problem. We prove that hypertrace logic without constrained trace quantifiers is equivalent to monadic second-order logic of one successor (S1S), and therefore satisfiable, and that the trace-prefixed fragment (all trace quantifiers precede all time quantifiers) is equivalent to HyperQPTL. Moreover, we show that all hypertrace formulas where the only alternation between constrained trace quantifiers is from an existential to a universal quantifier are equisatisfiable to formulas without constraints on their trace variables and, therefore, decidable as well. Our framework allows us to study also time-prefixed hyperlogics, for which we provide new decidability and undecidability results</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.12298v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marek Chalupa, Thomas A. Henzinger, Ana Oliveira da Costa</dc:creator>
    </item>
    <item>
      <title>Can ChatGPT support software verification?</title>
      <link>https://arxiv.org/abs/2311.02433</link>
      <description>arXiv:2311.02433v2 Announce Type: replace-cross 
Abstract: Large language models have become increasingly effective in software engineering tasks such as code generation, debugging and repair. Language models like ChatGPT can not only generate code, but also explain its inner workings and in particular its correctness. This raises the question whether we can utilize ChatGPT to support formal software verification.
  In this paper, we take some first steps towards answering this question. More specifically, we investigate whether ChatGPT can generate loop invariants. Loop invariant generation is a core task in software verification, and the generation of valid and useful invariants would likely help formal verifiers. To provide some first evidence on this hypothesis, we ask ChatGPT to annotate 106 C programs with loop invariants. We check validity and usefulness of the generated invariants by passing them to two verifiers, Frama-C and CPAchecker. Our evaluation shows that ChatGPT is able to produce valid and useful invariants allowing Frama-C to verify tasks that it could not solve before. Based on our initial insights, we propose ways of combining ChatGPT (or large language models in general) and software verifiers, and discuss current limitations and open issues.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.02433v2</guid>
      <category>cs.SE</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Christian Jan{\ss}en, Cedric Richter, Heike Wehrheim</dc:creator>
    </item>
    <item>
      <title>Balanced Fibonacci word rectangles, and beyond</title>
      <link>https://arxiv.org/abs/2509.25994</link>
      <description>arXiv:2509.25994v2 Announce Type: replace-cross 
Abstract: Following a recent paper of Anselmo et al., we consider $m \times n$ rectangular matrices formed from the Fibonacci word, and we show that their balance properties can be solved with a finite automaton. We also generalize the result to every Sturmian characteristic word corresponding to a quadratic irrational. Finally, we also examine the analogous question for the Tribonacci word.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.25994v2</guid>
      <category>math.NT</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <category>math.CO</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeffrey Shallit, Ingrid Vukusic</dc:creator>
    </item>
  </channel>
</rss>
