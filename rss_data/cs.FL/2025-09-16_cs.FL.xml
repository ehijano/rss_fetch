<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Sep 2025 04:03:04 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>A Unifying Approach to Picture Automata</title>
      <link>https://arxiv.org/abs/2509.12077</link>
      <description>arXiv:2509.12077v1 Announce Type: new 
Abstract: A directed acyclic graph (DAG) can represent a two-dimensional string or picture. We propose recognizing picture languages using DAG automata by encoding 2D inputs into DAGs. An encoding can be input-agnostic (based on input size only) or input-driven (depending on symbols). Three distinct input-agnostic encodings characterize classes of picture languages accepted by returning finite automata, boustrophedon automata, and online tessellation automata. Encoding a string as a simple directed path limits recognition to regular languages. However, input-driven encodings allow DAG automata to recognize some context-sensitive string languages and outperform online tessellation automata in two dimensions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.12077v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yvo Ad Meeres, Franti\v{s}ek Mr\'az</dc:creator>
    </item>
    <item>
      <title>Enhanced Data Race Prediction Through Modular Reasoning</title>
      <link>https://arxiv.org/abs/2504.10813</link>
      <description>arXiv:2504.10813v1 Announce Type: cross 
Abstract: There are two orthogonal methodologies for efficient prediction of data races from concurrent program runs: commutativity and prefix reasoning. There are several instances of each methodology in the literature, with the goal of predicting data races using a streaming algorithm where the required memory does not grow proportional to the length of the observed run, but these instances were mostly created in an ad hoc manner, without much attention to their unifying underlying principles. In this paper, we identify and formalize these principles for each category with the ultimate goal of paving the way for combining them into a new algorithm which shares their efficiency characteristics but offers strictly more prediction power. In particular, we formalize three distinct classes of races predictable using commutativity reasoning, and compare them. We identify three different styles of prefix reasoning, and prove that they predict the same class of races, which provably contains all races predictable by any commutativity reasoning technique.
  Our key contribution is combining prefix reasoning and commutativity reasoning in a modular way to introduce a new class of races, granular prefix races, that are predictable in constant-space and linear time, in a streaming fashion. This class of races includes all races predictable using commutativity and prefix reasoning techniques. We present an improved constant-space algorithm for prefix reasoning alone based on the idea of antichains (from language theory). This improved algorithm is the stepping stone that is required to devise an efficient algorithm for prediction of granular prefix races. We present experimental results to demonstrate the expressive power and performance of our new algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.10813v1</guid>
      <category>cs.PL</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Zhendong Ang, Azadeh Farzan, Umang Mathur</dc:creator>
    </item>
    <item>
      <title>A Hierarchy of Nondeterminism</title>
      <link>https://arxiv.org/abs/2209.09866</link>
      <description>arXiv:2209.09866v5 Announce Type: replace 
Abstract: We study three levels in a hierarchy of nondeterminism: A nondeterministic automaton $\mathcal{A}$ is determinizable by pruning (DBP) if we can obtain a deterministic automaton equivalent to $\mathcal{A}$ by removing some of its transitions. Then, $\mathcal{A}$ is history deterministic (HD) if its nondeterministic choices can be resolved in a way that only depends on the past. Finally, $\mathcal{A}$ is semantically deterministic (SD) if different nondeterministic choices in $\mathcal{A}$ lead to equivalent states. Some applications of automata in formal methods require deterministic automata, yet in fact can use automata with some level of nondeterminism. For example, DBP automata are useful in the analysis of online algorithms, and HD automata are useful in synthesis and control. For automata on finite words, the three levels in the hierarchy coincide. We study the hierarchy for B\"uchi, co-B\"uchi, and weak automata on infinite words. We show that the hierarchy is strict, study the expressive power of the different levels in it, as well as the complexity of deciding the membership of a language in a given level. Finally, we describe a probability-based analysis of the hierarchy, which relates the level of nondeterminism with the probability that a random run on a word in the language is accepting. We relate the latter to nondeterministic automata that can be used when reasoning about probabilistic systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2209.09866v5</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Bader Abu Radi, Orna Kupferman, Ofer Leshkowitz</dc:creator>
    </item>
    <item>
      <title>Reset thresholds of transformation monoids</title>
      <link>https://arxiv.org/abs/2309.08321</link>
      <description>arXiv:2309.08321v2 Announce Type: replace 
Abstract: Motivated by the \v{C}ern\'y conjecture for automata, we introduce the concept of monoidal automata, which allows the formulation of the \v{C}ern\'y conjecture for monoids. We show upper bounds on the reset threshold of monoids with certain properties. In particular, we obtain a quadratic upper bound if the transformation monoid contains a primitive group of permutations and a singular of maximal rank with only one point of contraction.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.08321v2</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1007/s10559-024-00660-z</arxiv:DOI>
      <arxiv:journal_reference>Rystsov, I., Szyku{\l}a, M. Reset Thresholds of Transformation Monoids. Cybernetics and Systems Analysis 60, 189--197 (2024)</arxiv:journal_reference>
      <dc:creator>Igor Rystsov, Marek Szyku{\l}a</dc:creator>
    </item>
    <item>
      <title>Characterizations of Monadic Second Order Definable Context-Free Sets of Graphs</title>
      <link>https://arxiv.org/abs/2310.04764</link>
      <description>arXiv:2310.04764v5 Announce Type: replace 
Abstract: We give a characterization of the sets of graphs that are both
  \emph{definable} in Counting Monadic Second Order Logic (CMSO) and
  \emph{context-free}, i.e., least solutions of Hyperedge-Replacement
  (HR) grammars introduced by Courcelle and Engelfriet
  \cite{courcelle_engelfriet_2012}. We prove the equivalence of these
  sets with:
  %
  (a) \emph{recognizable} sets (in the algebra of graphs with
  HR-operations) of bounded tree-width; we refine this condition
  further and show equivalence with recognizability in a finitely
  generated subalgebra of the HR-algebra of graphs;
  %
  (b) \emph{parsable} sets, for which there is a definable transduction from
  graphs to a set of derivation trees labelled by HR operations, such
  that the set of graphs is the image of the set of derivation trees
  under the canonical evaluation of the HR operations;
  %
  (c) images of recognizable unranked sets of trees under a definable
  transduction, whose inverse is also definable.
  %
  We rely on a novel connection between two seminal results, a logical
  characterization of context-free graph languages in terms of
  tree-to-graph definable transductions, by Courcelle and
  Engelfriet and a proof that an
  optimal-width tree decomposition of a graph can be built by an
  definable transduction, by Boja\'{n}czyk and
  Pilipczuk.</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.04764v5</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Radu Iosif, Florian Zuleger</dc:creator>
    </item>
    <item>
      <title>Certified Symbolic Finite Transducers: Formalization and Applications to String Analysis</title>
      <link>https://arxiv.org/abs/2504.07203</link>
      <description>arXiv:2504.07203v2 Announce Type: replace 
Abstract: Finite Automata (FAs) are fundamental components in the domains of programming languages. For instance, regular expressions, which are pivotal in languages such as JavaScript and Python, are frequently implemented using FAs. Finite Transducers (FTs) extend the capabilities of FAs by enabling the transformation of input strings into output strings, thereby providing a more expressive framework for operations that encompass both recognition and transformation. Despite the various formalizations of FAs in proof assistants such as Coq and Isabelle/HOL, these formalizations often fall short in terms of applicability to real-world scenarios. A more pragmatic approach involves the formalization of symbolic FAs and FTs, where transition labels are symbolic and potentially infinite. While the formalization of symbolic FAs has been explored in the work of CertiStr, the formalization of symbolic FTs in interactive proof assistants remains largely unexplored due to the increased complexity challenges. In this paper, we aim to formalize symbolic FTs within the Isabelle/HOL framework. This formalization is refinement-based and is designed to be extensible with various symbolic representations of transition labels. To assess its performance, we applied the formalized symbolic FTs to an SMT string solver for modeling replacement operations. The experimental results indicate that the formalized symbolic transducer can efficiently and effectively solve string constraints with replacement operations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.07203v2</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shuanglong Kan, Anthony W. Lin</dc:creator>
    </item>
    <item>
      <title>Languages of Boundedly-Ambiguous Vector Addition Systems with States</title>
      <link>https://arxiv.org/abs/2504.07669</link>
      <description>arXiv:2504.07669v2 Announce Type: replace 
Abstract: The aim of this paper is to deliver broad understanding of a class of languages of boundedly-ambiguous VASS, that is k-ambiguous VASS for some natural k. These are languages of Vector Addition Systems with States with the acceptance condition defined by the set of accepting states such that each accepted word has at most k accepting runs. We develop tools for proving that a given language is not accepted by any k-ambiguous VASS. Using them we show a few negative results: lack of some closure properties of languages of k-ambiguous VASS and undecidability of the k-ambiguity problem, namely the question whether a given VASS language is a language of some k-ambiguous VASS. Finally, we show that the regularity problem is decidable for k-ambiguous VASS.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.07669v2</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Wojciech Czerwi\'nski, {\L}ukasz Orlikowski</dc:creator>
    </item>
  </channel>
</rss>
