<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jul 2024 04:00:13 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 04 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>LOGIC-LM++: Multi-Step Refinement for Symbolic Formulations</title>
      <link>https://arxiv.org/abs/2407.02514</link>
      <description>arXiv:2407.02514v1 Announce Type: new 
Abstract: In this paper we examine the limitations of Large Language Models (LLMs) for complex reasoning tasks. While current approaches leverage formal languages as intermediate representation of reasoning problems, they struggle with generating intermediate formal specifications and refining these representations. To address these issues, this paper proposes Logic-LM++, an improvement on Logic-LM. It uses the ability of LLMs to do pairwise comparisons, allowing the evaluation of the refinements suggested by the LLM. The paper demonstrates that Logic-LM++ outperforms Logic-LM and LLM based techniques on natural language reasoning tasks on two datasets, FOLIO and AR-LSAT. Logic-LM++ show an average improvement of 13.5% on standard prompting, 11% on chain of thought prompting and 5% on Logic-LM.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.02514v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shashank Kirtania, Priyanshu Gupta, Arjun Radhakirshna</dc:creator>
    </item>
    <item>
      <title>Functional variant of Polynomial Analogue of Gandy's Fixed Point Theorem</title>
      <link>https://arxiv.org/abs/2407.02515</link>
      <description>arXiv:2407.02515v1 Announce Type: new 
Abstract: In this work, a functional variant of the polynomial analogue of the classical Gandy's fixed point theorem is obtained. Sufficient conditions have been found to ensure that the complexity of the recursive function does not go beyond the polynomial. In 2021, we proved a polynomial analogue of the classical Gandy's fixed point theorem. This became an important impetus for the construction of p-complete programming languages. And such a language was first built by us in 2022. The main result of that work was: a solution of the problem P=L. Next are the followers of the works on building a new high-level language and the idea of building a general programming methodology. But there was one gap in our research: classes of recursive functions whose complexity was polynomial were not described. In this work we found sufficient conditions for such functions. In many ways, the main ideas of this work are similar to the ideas that we used in the proof of the polynomial analogue of Gandy's fixed point theorem. But there are also striking differences. Functions, as such, differ quite strongly from predicates precisely in the multitude of their values. If a predicate is either true or false, then a function can generally take on a variety of values. Moreover, even if there are not many values, but there is recursion and simple multiplication, then powers and factorials may arise during the calculations, which, of course, can violate the polynomial computational complexity of this function. Therefore, finding these restrictions on recursive functions that would be soft enough for the class of functions to be large, and at the same time tough enough not to go beyond polynomiality, has been a problem for us for the last 3 years, after the proof of the polynomial analogue Gandy's fixed point theorem in the case of predicate extensions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.02515v1</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <category>math.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andrey Nechesov</dc:creator>
    </item>
    <item>
      <title>Automated Verification of Higher-Order Probabilistic Programs via a Dependent Refinement Type System</title>
      <link>https://arxiv.org/abs/2407.02975</link>
      <description>arXiv:2407.02975v1 Announce Type: new 
Abstract: Verification of higher-order probabilistic programs is a challenging problem. We present a verification method that supports several quantitative properties of higher-order probabilistic programs. Usually, extending verification methods to handle the quantitative aspects of probabilistic programs often entails extensive modifications to existing tools, reducing compatibility with advanced techniques developed for qualitative verification. In contrast, our approach necessitates only small amounts of modification, facilitating the reuse of existing techniques and implementations. On the theoretical side, we propose a dependent refinement type system for a generalised higher-order fixed point logic (HFL). Combined with continuation-passing style encodings of properties into HFL, our dependent refinement type system enables reasoning about several quantitative properties, including weakest pre-expectations, expected costs, moments of cost, and conditional weakest pre-expectations for higher-order probabilistic programs with continuous distributions and conditioning. The soundness of our approach is proved in a general setting using a framework of categorical semantics so that we don't have to repeat similar proofs for each individual problem. On the empirical side, we implement a type checker for our dependent refinement type system that reduces the problem of type checking to constraint solving. We introduce admissible predicate variables and integrable predicate variables to constrained Horn clauses (CHC) so that we can soundly reason about the least fixed points and samplings from probability distributions. Our implementation demonstrates that existing CHC solvers developed for non-probabilistic programs can be extended to a solver for the extended CHC with only small efforts. We also demonstrate the ability of our type checker to verify various concrete examples.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.02975v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Satoshi Kura, Hiroshi Unno</dc:creator>
    </item>
    <item>
      <title>The Complexity of Data-Free Nfer</title>
      <link>https://arxiv.org/abs/2407.03155</link>
      <description>arXiv:2407.03155v1 Announce Type: new 
Abstract: Nfer is a Runtime Verification language for the analysis of event traces that applies rules to create hierarchies of time intervals. This work examines the complexity of the evaluation and satisfiability problems for the data-free fragment of nfer. The evaluation problem asks whether a given interval is generated by applying rules to a known input, while the satisfiability problem asks if an input exists that will generate a given interval. By excluding data from the language, we obtain polynomial-time algorithms for the evaluation problem and for satisfiability when only considering inclusive rules. Furthermore, we show decidability for the satisfiability problem for cycle-free specifications and undecidability for satisfiability of full data-free nfer.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.03155v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sean Kauffman, Kim Guldstrand Larsen, Martin Zimmermann</dc:creator>
    </item>
    <item>
      <title>Gradual Verification for Smart Contracts</title>
      <link>https://arxiv.org/abs/2311.13351</link>
      <description>arXiv:2311.13351v2 Announce Type: replace-cross 
Abstract: Blockchains facilitate secure resource transactions through smart contracts, yet these digital agreements are prone to vulnerabilities, particularly when interacting with external contracts, leading to substantial monetary losses. Traditional verification techniques fall short in providing comprehensive security assurances, especially against re-entrancy attacks, due to the unavailable implementations of external contracts. This paper introduces an incremental approach: gradual verification. We combine static and dynamic verification techniques to enhance security, guarantee soundness and flexibility, and optimize resource usage in smart contract interactions. By implementing a prototype for gradually verifying Algorand smart contracts via the pyTEAL language, we demonstrate the effectiveness of our approach, contributing to the safe and efficient execution of smart contracts.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.13351v2</guid>
      <category>cs.CR</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Haojia Sun, Kunal Singh, Jan-Paul Ramos-D\'avila, Jonathan Aldrich, Jenna DiVincenzo</dc:creator>
    </item>
    <item>
      <title>Small unsatisfiable $k$-CNFs with bounded literal occurrence</title>
      <link>https://arxiv.org/abs/2405.16149</link>
      <description>arXiv:2405.16149v2 Announce Type: replace-cross 
Abstract: We obtain the smallest unsatisfiable formulas in subclasses of $k$-CNF (exactly $k$ distinct literals per clause) with bounded variable or literal occurrences. Smaller unsatisfiable formulas of this type translate into stronger inapproximability results for MaxSAT in the considered formula class. Our results cover subclasses of 3-CNF and 4-CNF; in all subclasses of 3-CNF we considered we were able to determine the smallest size of an unsatisfiable formula; in the case of 4-CNF with at most 5 occurrences per variable we decreased the size of the smallest known unsatisfiable formula. Our methods combine theoretical arguments and symmetry-breaking exhaustive search based on SAT Modulo Symmetries (SMS), a recent framework for isomorph-free SAT-based graph generation. To this end, and as a standalone result of independent interest, we show how to encode formulas as graphs efficiently for SMS.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.16149v2</guid>
      <category>cs.DM</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Tianwei Zhang, Tom\'a\v{s} Peitl, Stefan Szeider</dc:creator>
    </item>
  </channel>
</rss>
