<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Nov 2025 03:49:01 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Improved Additive Approximation Algorithms for APSP</title>
      <link>https://arxiv.org/abs/2511.04775</link>
      <description>arXiv:2511.04775v1 Announce Type: new 
Abstract: The All-Pairs Shortest Paths (APSP) is a foundational problem in theoretical computer science. Approximating APSP in undirected unweighted graphs has been studied for many years, beginning with the work of Dor, Halperin and Zwick [SICOMP'01]. Many recent works have attempted to improve these original algorithms using the algebraic tools of fast matrix multiplication. We improve on these results for the following problems.
  For $+2$-approximate APSP, the state-of-the-art algorithm runs in $O(n^{2.259})$ time [D\"urr, IPL 2023; Deng, Kirkpatrick, Rong, Vassilevska Williams, and Zhong, ICALP 2022]. We give an improved algorithm in $O(n^{2.2255})$ time.
  For $+4$ and $+6$-approximate APSP, we achieve time complexities $O(n^{2.1462})$ and $O(n^{2.1026})$ respectively, improving the previous $O(n^{2.155})$ and $O(n^{2.103})$ achieved by [Saha and Ye, SODA 2024].
  In contrast to previous works, we do not use the big hammer of bounded-difference $(\min,+)$-product algorithms. Instead, our algorithms are based on a simple technique that decomposes the input graph into a small number of clusters of constant diameter and a remainder of low degree vertices, which could be of independent interest in the study of shortest paths problems. We then use only standard fast matrix multiplication to obtain our improvements.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.04775v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ce Jin, Yael Kirkpatrick, Micha{\l} Stawarz, Virginia Vassilevska Williams</dc:creator>
    </item>
    <item>
      <title>Optimal Parallel Basis Finding in Graphic and Related Matroids</title>
      <link>https://arxiv.org/abs/2511.04826</link>
      <description>arXiv:2511.04826v1 Announce Type: new 
Abstract: We study the parallel complexity of finding a basis of a graphic matroid under independence-oracle access. Karp, Upfal, and Wigderson (FOCS 1985, JCSS 1988) initiated the study of this problem and established two algorithms for finding a spanning forest: one running in $O(\log m)$ rounds with $m^{\Theta(\log m)}$ queries, and another, for any $d \in \mathbb{Z}^+$, running in $O(m^{2/d})$ rounds with $\Theta(m^d)$ queries. A key open question they posed was whether one could simultaneously achieve polylogarithmic rounds and polynomially many queries. We give a deterministic algorithm that uses $O(\log m)$ adaptive rounds and $\mathrm{poly}(m)$ non-adaptive queries per round to return a spanning forest on $m$ edges, and complement this result with a matching $\Omega(\log m)$ lower bound for any (even randomized) algorithm with $\mathrm{poly}(m)$ queries per round. Thus, the adaptive round complexity for graphic matroids is characterized exactly, settling this long-standing problem. Beyond graphs, we show that our framework also yields an $O(\log m)$-round, $\mathrm{poly}(m)$-query algorithm for any binary matroid satisfying a smooth circuit counting property, implying, among others, an optimal $O(\log m)$-round parallel algorithms for finding bases of cographic matroids.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.04826v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Sanjeev Khanna, Aaron Putterman, Junkai Song</dc:creator>
    </item>
    <item>
      <title>Tight Bounds for Sampling q-Colorings via Coupling from the Past</title>
      <link>https://arxiv.org/abs/2511.04982</link>
      <description>arXiv:2511.04982v1 Announce Type: new 
Abstract: The Coupling from the Past (CFTP) paradigm is a canonical method for perfect sampling. For uniform sampling of proper $q$-colorings in graphs with maximum degree $\Delta$, the bounding chains of Huber (STOC 1998) provide a systematic framework for efficiently implementing CFTP algorithms within the classical regime $q \ge (1 + o(1))\Delta^2$. This was subsequently improved to $q &gt; 3\Delta$ by Bhandari and Chakraborty (STOC 2020) and to $q \ge (8/3 + o(1))\Delta$ by Jain, Sah, and Sawhney (STOC 2021).
  In this work, we establish the asymptotically tight threshold for bounding-chain-based CFTP algorithms for graph colorings. We prove a lower bound showing that all such algorithms satisfying the standard contraction property require $q \ge 2.5\Delta$, and we present an efficient CFTP algorithm that achieves this asymptotically optimal threshold $q \ge (2.5 + o(1))\Delta$ via an optimal design of bounding chains.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.04982v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Tianxing Ding, Hongyang Liu, Yitong Yin, Can Zhou</dc:creator>
    </item>
    <item>
      <title>Language Generation and Identification From Partial Enumeration: Tight Density Bounds and Topological Characterizations</title>
      <link>https://arxiv.org/abs/2511.05295</link>
      <description>arXiv:2511.05295v1 Announce Type: new 
Abstract: The success of large language models (LLMs) has motivated formal theories of language generation and learning. We study the framework of \emph{language generation in the limit}, where an adversary enumerates strings from an unknown language $K$ drawn from a countable class, and an algorithm must generate unseen strings from $K$. Prior work showed that generation is always possible, and that some algorithms achieve positive lower density, revealing a \emph{validity--breadth} trade-off between correctness and coverage. We resolve a main open question in this line, proving a tight bound of $1/2$ on the best achievable lower density. We then strengthen the model to allow \emph{partial enumeration}, where the adversary reveals only an infinite subset $C \subseteq K$. We show that generation in the limit remains achievable, and if $C$ has lower density $\alpha$ in $K$, the algorithm's output achieves density at least $\alpha/2$, matching the upper bound. This generalizes the $1/2$ bound to the partial-information setting, where the generator must recover within a factor $1/2$ of the revealed subset's density. We further revisit the classical Gold--Angluin model of \emph{language identification} under partial enumeration. We characterize when identification in the limit is possible -- when hypotheses $M_t$ eventually satisfy $C \subseteq M \subseteq K$ -- and in the process give a new topological formulation of Angluin's characterization, showing that her condition is precisely equivalent to an appropriate topological space having the $T_D$ separation property.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.05295v1</guid>
      <category>cs.DS</category>
      <category>cs.CL</category>
      <category>cs.DM</category>
      <category>cs.LG</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jon Kleinberg, Fan Wei</dc:creator>
    </item>
    <item>
      <title>Awesome graph parameters</title>
      <link>https://arxiv.org/abs/2511.05285</link>
      <description>arXiv:2511.05285v1 Announce Type: cross 
Abstract: For a graph $G$, we denote by $\alpha(G)$ the size of a maximum independent set and by $\omega(G)$ the size of a maximum clique in $G$. Our paper lies on the edge of two lines of research, related to $\alpha$ and $\omega$, respectively. One of them studies $\alpha$-variants of graph parameters, such as $\alpha$-treewidth or $\alpha$-degeneracy. The second line deals with graph classes where some parameters are bounded by a function of $\omega(G)$. A famous example of this type is the family of $\chi$-bounded classes, where the chromatic number $\chi(G)$ is bounded by a function of $\omega(G)$.
  A Ramsey-type argument implies that if the $\alpha$-variant of a graph parameter $\rho$ is bounded by a constant in a class $\mathcal{G}$, then $\rho$ is bounded by a function of $\omega$ in $\mathcal{G}$. If the reverse implication also holds, we say that $\rho$ is awesome. Otherwise, we say that $\rho$ is awful. In the present paper, we identify a number of awesome and awful graph parameters, derive some algorithmic applications of awesomeness, and propose a number of open problems related to these notions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.05285v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kenny Be\v{s}ter \v{S}torgel, Cl\'ement Dallard, Vadim Lozin, Martin Milani\v{c}, Viktor Zamaraev</dc:creator>
    </item>
    <item>
      <title>Reconstructing Riemannian Metrics From Random Geometric Graphs</title>
      <link>https://arxiv.org/abs/2511.05434</link>
      <description>arXiv:2511.05434v1 Announce Type: cross 
Abstract: Random geometric graphs are random graph models defined on metric measure spaces. A random geometric graph is generated by first sampling points from a metric space and then connecting each pair of sampled points independently with a probability that depends on their distance.
  In recent work of Huang, Jiradilok, and Mossel~\cite{HJM24}, the authors study the problem of reconstructing an embedded manifold form a random geometric graph sampled from the manifold, where edge probabilities depend monotonically on the Euclidean distance between the embedded points. They show that, under mild regularity assumptions on the manifold, the sampling measure, and the connection probability function, it is possible to recover the pairwise Euclidean distances of the embedded sampled points up to a vanishing error as the number of vertices grows.
  In this work we consider a similar and arguably more natural problem where the metric is the Riemannian metric on the manifold. Again points are sampled from the manifold and a random graph is generated where the connection probability is monotone in the Riemannian distance. Perhaps surprisingly we obtain stronger results in this setup.
  Unlike the previous work that only considered dense graph we provide reconstruction algorithms from sparse graphs with average degree $n^{1/2}{\rm polylog}(n)$, where $n$ denotes the number of vertices. Our algorithm is also a more efficient algorithm for distance reconstruction with improved error bounds. The running times of the algorithm is
  $O(n^2\,{\rm polylog}(n))$ which up to polylog factor matches the size of the input graph.
  Our distance error also nearly matches the volumetric lower bounds for distance estimation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.05434v1</guid>
      <category>math.PR</category>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Han Huang, Pakawut Jiradilok, Elchanan Mossel</dc:creator>
    </item>
    <item>
      <title>A Survey of Approximability Results for Traveling Salesman Problems using the TSP-T3CO Definition Scheme</title>
      <link>https://arxiv.org/abs/2311.00604</link>
      <description>arXiv:2311.00604v3 Announce Type: replace 
Abstract: The traveling salesman (or salesperson) problem, short TSP, is a problem of strong interest to many researchers from mathematics, economics, and computer science. Manifold TSP variants occur in nearly every scientific field and application domain: engineering, physics, biology, life sciences, and manufacturing just to name a few. Several thousand papers are published on theoretical research or application-oriented results each year. This paper provides the first systematic survey on the best currently known approximability and inapproximability results for well-known TSP variants such as the "standard" TSP, Path TSP, Bottleneck TSP, Maximum Scatter TSP, Generalized TSP, Clustered TSP, Traveling Purchaser Problem, Profitable Tour Problem, Quota TSP, Prize-Collecting TSP, Orienteering Problem, Time-dependent TSP, TSP with Time Windows, and the Orienteering Problem with Time Windows. The foundation of our survey is the definition scheme T3CO, which we propose as a uniform, easy-to-use and extensible means for the formal and precise definition of TSP variants. Applying T3CO to formally define the variant studied by a paper reveals subtle differences within the same named variant and also brings out the differences between the variants more clearly. We achieve the first comprehensive, concise, and compact representation of approximability results by using T3CO definitions. This makes it easier to understand the approximability landscape and the assumptions under which certain results hold. Open gaps become more evident and results can be compared more easily.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.00604v3</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1007/s10479-025-06641-5</arxiv:DOI>
      <arxiv:journal_reference>Annals of Operations Research 351 (2025) 2129-2190</arxiv:journal_reference>
      <dc:creator>Sophia Saller, Jana Koehler, Andreas Karrenbauer</dc:creator>
    </item>
    <item>
      <title>Deterministic Dynamic Edge Colouring</title>
      <link>https://arxiv.org/abs/2402.13139</link>
      <description>arXiv:2402.13139v2 Announce Type: replace 
Abstract: Given a dynamic graph $G$ with $n$ vertices and $m$ edges subject to insertion an deletions of edges, we show how to maintain a $(1+\varepsilon)\Delta$-edge-colouring of $G$ without the use of randomisation.
  More specifically, we show a deterministic dynamic algorithm with an amortised update time of $2^{\tilde{O}_{\log \varepsilon^{-1}}(\sqrt{\log n})}$ using $(1+\varepsilon)\Delta$ colours. If $\varepsilon^{-1} \in 2^{O(\log^{0.49} n)}$, then our update time is sub-polynomial in $n$.
  While there exists randomised algorithms maintaining colourings with the same number of colours [Christiansen STOC'23, Duan, He, Zhang SODA'19, Bhattacarya, Costa, Panski, Solomon SODA'24] in polylogarithmic and even constant update time, this is the first deterministic algorithm to go below the greedy threshold of $2\Delta-1$ colours for all input graphs.
  On the way to our main result, we show how to dynamically maintain a shallow hierarchy of degree-splitters with both recourse and update time in $n^{o(1)}$. We believe that this algorithm might be of independent interest.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.13139v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Aleksander B. G. Christiansen</dc:creator>
    </item>
    <item>
      <title>In-and-Out: Algorithmic Diffusion for Sampling Convex Bodies</title>
      <link>https://arxiv.org/abs/2405.01425</link>
      <description>arXiv:2405.01425v3 Announce Type: replace 
Abstract: We present a new random walk for uniformly sampling high-dimensional convex bodies. It achieves state-of-the-art runtime complexity with stronger guarantees on the output than previously known, namely in R\'enyi divergence (which implies TV, $\mathcal{W}_2$, KL, $\chi^2$). The proof departs from known approaches for polytime algorithms for the problem -- we utilize a stochastic diffusion perspective to show contraction to the target distribution with the rate of convergence determined by functional isoperimetric constants of the target distribution.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.01425v3</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <category>math.ST</category>
      <category>stat.ML</category>
      <category>stat.TH</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yunbum Kook, Santosh S. Vempala, Matthew S. Zhang</dc:creator>
    </item>
    <item>
      <title>Enumeration algorithms for combinatorial problems using Ising machines: When should we stop exploring energy landscapes?</title>
      <link>https://arxiv.org/abs/2412.00284</link>
      <description>arXiv:2412.00284v2 Announce Type: replace 
Abstract: Combinatorial problems such as combinatorial optimization and constraint satisfaction problems arise in decision-making across various fields of science and technology. In real-world applications, when multiple optimal or constraint-satisfying solutions exist, enumerating all these solutions is often desirable, as it provides flexibility in decision-making. However, combinatorial problems and their enumeration versions pose significant computational challenges due to combinatorial explosion. To address these challenges, we propose enumeration algorithms for combinatorial optimization and constraint satisfaction problems using Ising machines. Ising machines are specialized devices designed to efficiently solve combinatorial problems by exploring the energy landscape of an Ising model. Ising machines typically sample lower-energy solutions with higher probability. Our enumeration algorithms repeatedly perform such sampling to collect all desirable solutions. The crux of the proposed algorithms lies in their stopping criteria for sampling-based energy landscape exploration, which are derived from probability theory. In particular, the proposed algorithms have theoretical guarantees that the failure probability of enumeration is bounded above by a user-specified value, provided that lower-cost solutions are sampled more frequently and equal-cost solutions are sampled with equal probability. Many physics-based Ising machines are expected to (approximately) satisfy these conditions. As a demonstration, we applied our algorithm using simulated annealing to maximum clique enumeration on random graphs. We found that our algorithm enumerates all maximum cliques in large, dense graphs faster than a conventional branch-and-bound algorithm specifically designed for maximum clique enumeration. These findings underscore the effectiveness and potential of our proposed approach.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.00284v2</guid>
      <category>cs.DS</category>
      <category>quant-ph</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yuta Mizuno, Mohammad Ali, Tamiki Komatsuzaki</dc:creator>
    </item>
    <item>
      <title>On the Parallel Complexity of Finding a Matroid Basis</title>
      <link>https://arxiv.org/abs/2507.08194</link>
      <description>arXiv:2507.08194v2 Announce Type: replace 
Abstract: A fundamental question in parallel computation, posed by Karp, Upfal, and Wigderson (FOCS 1985, JCSS 1988), asks: \emph{given only independence-oracle access to a matroid on $n$ elements, how many rounds are required to find a basis using only polynomially many queries?} This question generalizes, among others, the complexity of finding bases of linear spaces, partition matroids, and spanning forests in graphs. In their work, they established an upper bound of $O(\sqrt{n})$ rounds and a lower bound of $\widetilde{\Omega}(n^{1/3})$ rounds for this problem, and these bounds have remained unimproved since then.
  In this work, we make the first progress in narrowing this gap by designing a parallel algorithm that finds a basis of an arbitrary matroid in $\tilde{O}(n^{7/15})$ rounds (using polynomially many independence queries per round) with high probability, surpassing the long-standing $O(\sqrt{n})$ barrier. Our approach introduces a novel matroid decomposition technique and other structural insights that not only yield this general result but also lead to a much improved new algorithm for the class of \emph{partition matroids} (which underlies the $\widetilde\Omega(n^{1/3})$ lower bound of Karp, Upfal, and Wigderson). Specifically, we develop an $\tilde{O}(n^{1/3})$-round algorithm, thereby settling the round complexity of finding a basis in partition matroids.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.08194v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Sanjeev Khanna, Aaron Putterman, Junkai Song</dc:creator>
    </item>
    <item>
      <title>Fault-Tolerant Approximate Distance Oracles with a Source Set</title>
      <link>https://arxiv.org/abs/2511.01239</link>
      <description>arXiv:2511.01239v2 Announce Type: replace 
Abstract: Our input is an undirected weighted graph $G = (V,E)$ on $n$ vertices along with a source set $S\subseteq V$. The problem is to preprocess $G$ and build a compact data structure such that upon query $Qu(s,v,f)$ where $(s,v) \in S\times V$ and $f$ is any faulty edge, we can quickly find a good estimate (i.e., within a small multiplicative stretch) of the $s$-$v$ distance in $G-f$.
  The work of Bil{\`{o}} et al. (Algorithmica 2022) on multiple-edge fault-tolerant approximate shortest path trees implies a compact oracle for the above problem with a stretch of at most 3 and with query answering time $O(\log^2 n)$. We show a very simple construction of an $S\times V$ approximate distance oracle with $O(1)$ query answering time; its size is $\widetilde{O}(|S|n + n^{3/2})$ and multiplicative stretch is at most 5. A single-edge fault-tolerant $ST$-distance oracle from the work of Bil{\`{o}} et al. (STACS 2018) plays a key role in our construction. We also give a construction of a fault-tolerant $S \times V$ approximate distance oracle of size $\widetilde{O}(|S|n + n^{4/3})$ with multiplicative stretch at most 13 and as before, with $O(1)$ query answering time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.01239v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dipan Dey, Telikepalli Kavitha</dc:creator>
    </item>
    <item>
      <title>An Improved Quality Hierarchical Congestion Approximator in Near-Linear Time</title>
      <link>https://arxiv.org/abs/2511.03716</link>
      <description>arXiv:2511.03716v2 Announce Type: replace 
Abstract: A single-commodity congestion approximator for a graph is a compact data structure that approximately predicts the edge congestion required to route any set of single-commodity flow demands in a network. A hierarchical congestion approximator (HCA) consists of a laminar family of cuts in the graph and has numerous applications in approximating cut and flow problems in graphs, designing efficient routing schemes, and managing distributed networks.
  There is a tradeoff between the running time for computing an HCA and its approximation quality. The best polynomial-time construction in an $n$-node graph gives an HCA with approximation quality $O(\log^{1.5}n \log \log n)$. Among near-linear time algorithms, the best previous result achieves approximation quality $O(\log^4 n)$. We improve upon the latter result by giving the first near-linear time algorithm for computing an HCA with approximation quality $O(\log^2 n \log \log n)$. Additionally, our algorithm can be implemented in the parallel setting with polylogarithmic span and near-linear work, achieving the same approximation quality. This improves upon the best previous such algorithm, which has an $O(\log^9n)$ approximation quality.
  Crucial for achieving a near-linear running time is a new partitioning routine that, unlike previous such routines, manages to avoid recursing on large subgraphs. To achieve the improved approximation quality, we introduce the new concept of border routability of a cut and provide an improved sparsest cut oracle for general vertex weights.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.03716v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Monika Henzinger, Robin M\"unk, Harald R\"acke</dc:creator>
    </item>
    <item>
      <title>Formalizing the notions of non-interactive and interactive algorithms</title>
      <link>https://arxiv.org/abs/2405.19037</link>
      <description>arXiv:2405.19037v4 Announce Type: replace-cross 
Abstract: An earlier paper gives an account of a quest for a satisfactory formalization of the classical informal notion of an algorithm. That notion only covers algorithms that are deterministic and non-interactive. In this paper, an attempt is made to generalize the results of that quest first to a notion of an algorithm that covers both deterministic and non-deterministic algorithms that are non-interactive and then further to a notion of an algorithm that covers both deterministic and non-deterministic algorithms that are interactive. The notions of an non-interactive proto-algorithm and an interactive proto-algorithm are introduced. Non-interactive algorithms and interactive algorithms are expected to be equivalence classes of non-interactive proto-algorithms and interactive proto-algorithms, respectively, under an appropriate equivalence relation. On both non-interactive proto-algorithms and interactive proto-algorithms, three equivalence relations are defined. Two of them are deemed to be bounds for an appropriate equivalence relation and the third is likely an appropriate one.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.19037v4</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <category>cs.LO</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <arxiv:DOI>10.47743/SACS.2025.2.211</arxiv:DOI>
      <arxiv:journal_reference>Scientific Annals of Computer Science vol. 35(2):211-249 (2025)</arxiv:journal_reference>
      <dc:creator>C. A. Middelburg</dc:creator>
    </item>
    <item>
      <title>Greedy Algorithm for Structured Bandits: A Sharp Characterization of Asymptotic Success / Failure</title>
      <link>https://arxiv.org/abs/2503.04010</link>
      <description>arXiv:2503.04010v3 Announce Type: replace-cross 
Abstract: We study the greedy (exploitation-only) algorithm in bandit problems with a known reward structure. We allow arbitrary finite reward structures, while prior work focused on a few specific ones. We fully characterize when the greedy algorithm asymptotically succeeds or fails, in the sense of sublinear vs. linear regret as a function of time. Our characterization identifies a partial identifiability property of the problem instance as the necessary and sufficient condition for the asymptotic success. Notably, once this property holds, the problem becomes easy -- any algorithm will succeed (in the same sense as above), provided it satisfies a mild non-degeneracy condition. Our characterization extends to contextual bandits and interactive decision-making with arbitrary feedback. Examples demonstrating broad applicability and extensions to infinite reward structures are provided.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04010v3</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Aleksandrs Slivkins, Yunzong Xu, Shiliang Zuo</dc:creator>
    </item>
    <item>
      <title>A Perfectly Truthful Calibration Measure</title>
      <link>https://arxiv.org/abs/2508.13100</link>
      <description>arXiv:2508.13100v2 Announce Type: replace-cross 
Abstract: Calibration requires that predictions are conditionally unbiased and, therefore, reliably interpretable as probabilities. A calibration measure quantifies how far a predictor is from perfect calibration. As introduced by Haghtalab et al. (2024), a calibration measure is truthful if it is minimized in expectation when a predictor outputs the ground-truth probabilities. Predicting the true probabilities guarantees perfect calibration, but in reality, when calibration is evaluated on a random sample, all known calibration measures incentivize predictors to lie in order to appear more calibrated. Such lack of truthfulness motivated Haghtalab et al. (2024) and Qiao and Zhao (2025) to construct approximately truthful calibration measures in the sequential prediction setting, but no perfectly truthful calibration measure was known to exist even in the more basic batch setting.
  We design a simple, perfectly and strictly truthful, sound and complete calibration measure in the batch setting: averaged two-bin calibration error (ATB). ATB is quadratically related to two existing calibration measures: the smooth calibration error smCal and the lower distance to calibration distCal. The simplicity in our definition of ATB makes it efficient and straightforward to compute, allowing us to give the first linear-time calibration testing algorithm, improving a result of Hu et al. (2024). We also introduce a general recipe for constructing truthful measures based on the variance additivity of independent random variables, which proves the truthfulness of ATB as a special case and allows us to construct other truthful calibration measures such as quantile-binned l_2-ECE.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.13100v2</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <category>stat.ML</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jason Hartline, Lunjia Hu, Yifan Wu</dc:creator>
    </item>
    <item>
      <title>Performance of Gaussian Boson Sampling on Planted Bipartite Clique Detection</title>
      <link>https://arxiv.org/abs/2510.12774</link>
      <description>arXiv:2510.12774v2 Announce Type: replace-cross 
Abstract: We investigate whether Gaussian Boson Sampling (GBS) can provide a computational advantage for solving the planted biclique problem, which is a graph problem widely believed to be classically hard when the planted structure is small. Although GBS has been heuristically and experimentally observed to favor sampling dense subgraphs, its theoretical performance on this classically hard problem remains largely unexplored. We focus on a natural statistic derived from GBS output: the frequency with which a node appears in GBS samples, referred to as the node weight. We rigorously analyze whether this signal is strong enough to distinguish planted biclique nodes from background nodes. Our analysis characterizes the distribution of node weights under GBS and quantifies the bias introduced by the planted structure. The results reveal a sharp limitation: when the planted biclique size falls within the conjectured hard regime, the natural fluctuations in node weights dominate the bias signal, making detection unreliable using simple ranking strategies. These findings provide the first rigorous evidence that planted biclique detection may remain computationally hard even under GBS-based quantum computing, and they motivate further investigation into more advanced GBS-based algorithms or other quantum approaches for this problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.12774v2</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Yu-Zhen Janice Chen, Laurent Massouli\'e, Don Towsley</dc:creator>
    </item>
    <item>
      <title>Boolean function monotonicity testing requires (almost) $n^{1/2}$ queries</title>
      <link>https://arxiv.org/abs/2511.04558</link>
      <description>arXiv:2511.04558v2 Announce Type: replace-cross 
Abstract: We show that for any constant $c&gt;0$, any (two-sided error) adaptive algorithm for testing monotonicity of Boolean functions must have query complexity $\Omega(n^{1/2-c})$. This improves the $\tilde\Omega(n^{1/3})$ lower bound of [CWX17] and almost matches the $\tilde{O}(\sqrt{n})$ upper bound of [KMS18].</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.04558v2</guid>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Mark Chen, Xi Chen, Hao Cui, William Pires, Jonah Stockwell</dc:creator>
    </item>
  </channel>
</rss>
