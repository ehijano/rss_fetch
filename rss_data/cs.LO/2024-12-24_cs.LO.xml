<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 24 Dec 2024 05:53:13 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Formal Modeling and Verification of Publisher-Subscriber Paradigm in ROS 2</title>
      <link>https://arxiv.org/abs/2412.16186</link>
      <description>arXiv:2412.16186v1 Announce Type: new 
Abstract: The Robot Operating System (ROS) is one of the most popular middleware for developing robot applications, but it is subject to major shortcomings when applied to real-time robotic systems in safety-critical environments. For this reason, ROS 2 was released in 2017 for implementing real-time capabilities in distributed robotic systems while supporting the most prominent aspects of the original ROS. There is still not much work done to provide formal guarantees and correctness of a ROS program. In this paper, we propose a framework to address this challenging problem of guaranteeing the correct behaviour of robotic systems. We propose a formal modelling of a ROS 2 program, and also describe the program using a network of timed automata. We then prove that the sets of executions of a ROS program in the model and in the network of timed automata are the same. Thus to analyze a publisher-subscriber scenario of ROS 2 program, our algorithm first converts the program into the model, and then into the network of timed automata. The applicability and validity of our approach are verified by conducting several experiments on a simplified system and an actual robotic system, and the results and limitations are discussed.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16186v1</guid>
      <category>cs.LO</category>
      <category>cs.RO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jahid Chowdhury Choton, Lipsy Gupta, Pavithra Prabhakar</dc:creator>
    </item>
    <item>
      <title>Quantified Linear and Polynomial Arithmetic Satisfiability via Template-based Skolemization</title>
      <link>https://arxiv.org/abs/2412.16226</link>
      <description>arXiv:2412.16226v1 Announce Type: new 
Abstract: The problem of checking satisfiability of linear real arithmetic (LRA) and non-linear real arithmetic (NRA) formulas has broad applications, in particular, they are at the heart of logic-related applications such as logic for artificial intelligence, program analysis, etc. While there has been much work on checking satisfiability of unquantified LRA and NRA formulas, the problem of checking satisfiability of quantified LRA and NRA formulas remains a significant challenge. The main bottleneck in the existing methods is a computationally expensive quantifier elimination step. In this work, we propose a novel method for efficient quantifier elimination in quantified LRA and NRA formulas. We propose a template-based Skolemization approach, where we automatically synthesize linear/polynomial Skolem functions in order to eliminate quantifiers in the formula. The key technical ingredients in our approach are Positivstellens\"atze theorems from algebraic geometry, which allow for an efficient manipulation of polynomial inequalities. Our method offers a range of appealing theoretical properties combined with a strong practical performance. On the theory side, our method is sound, semi-complete, and runs in subexponential time and polynomial space, as opposed to existing sound and complete quantifier elimination methods that run in doubly-exponential time and at least exponential space. On the practical side, our experiments show superior performance compared to state-of-the-art SMT solvers in terms of the number of solved instances and runtime, both on LRA and on NRA benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16226v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Krishnendu Chatterjee, Ehsan Kafshdar Goharshady, Mehrdad Karrabi, Harshit J Motwani, Maximilian Seeliger, {\DJ}or{\dj}e \v{Z}ikeli\'c</dc:creator>
    </item>
    <item>
      <title>On the Power and Limitations of Examples for Description Logic Concepts</title>
      <link>https://arxiv.org/abs/2412.17345</link>
      <description>arXiv:2412.17345v1 Announce Type: new 
Abstract: Labeled examples (i.e., positive and negative examples) are an attractive medium for communicating complex concepts. They are useful for deriving concept expressions (such as in concept learning, interactive concept specification, and concept refinement) as well as for illustrating concept expressions to a user or domain expert. We investigate the power of labeled examples for describing description-logic concepts. Specifically, we systematically study the existence and efficient computability of finite characterisations, i.e. finite sets of labeled examples that uniquely characterize a single concept, for a wide variety of description logics between EL and ALCQI, both without an ontology and in the presence of a DL-Lite ontology. Finite characterisations are relevant for debugging purposes, and their existence is a necessary condition for exact learnability with membership queries.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.17345v1</guid>
      <category>cs.LO</category>
      <category>cs.LG</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.24963/ijcai.2024/395</arxiv:DOI>
      <arxiv:journal_reference>Proceedings of the 33rd International Joint Conference on Artificial Intelligence (2024), pp.3567-3575</arxiv:journal_reference>
      <dc:creator>Balder ten Cate, Raoul Koudijs, Ana Ozaki</dc:creator>
    </item>
    <item>
      <title>Temporal Explorability Games</title>
      <link>https://arxiv.org/abs/2412.16328</link>
      <description>arXiv:2412.16328v1 Announce Type: cross 
Abstract: Temporal graphs extend ordinary graphs with discrete time that affects the availability of edges. We consider solving games played on temporal graphs where one player aims to explore the graph, i.e., visit all vertices. The complexity depends majorly on two factors: the presence of an adversary and how edge availability is specified.
  We demonstrate that on static graphs, where edges are always available, solving explorability games is just as hard as solving reachability games. In contrast, on temporal graphs, the complexity of explorability coincides with generalized reachability (NP-complete for one-player and PSPACE- complete for two player games). We further show that if temporal graphs are given symbolically, even one-player reachability and thus explorability and generalized reachability games are PSPACE-hard. For one player, all these are also solvable in PSPACE and for two players, they are in PSPACE, EXP and EXP, respectively.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16328v1</guid>
      <category>cs.GT</category>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pete Austin, Nicolas Mazzocchi, Sougata Bose, Patrick Totzke</dc:creator>
    </item>
    <item>
      <title>The Tractability Border of Reachability in Simple Vector Addition Systems with States</title>
      <link>https://arxiv.org/abs/2412.16612</link>
      <description>arXiv:2412.16612v1 Announce Type: cross 
Abstract: Vector Addition Systems with States (VASS), equivalent to Petri nets, are a well-established model of concurrency. The central algorithmic challenge in VASS is the reachability problem: is there a run from a given starting state and counter values to a given target state and counter values? When the input is encoded in binary, reachability is computationally intractable: even in dimension one, it is NP-hard.
  In this paper, we comprehensively characterise the tractability border of the problem when the input is encoded in unary. For our main result, we prove that reachability is NP-hard in unary encoded 3-VASS, even when structure is heavily restricted to be a simple linear path scheme. This improves upon a recent result of Czerwi\'nski and Orlikowski (2022), in both the number of counters and expressiveness of the considered model, as well as answers open questions of Englert, Lazi\'c, and Totzke (2016) and Leroux (2021).
  The underlying graph structure of a simple linear path scheme (SLPS) is just a path with self-loops at each node. We also study the exceedingly weak model of computation that is SPLS with counter updates in {-1,0,+1}. Here, we show that reachability is NP-hard when the dimension is bounded by O(\alpha(k)), where \alpha is the inverse Ackermann function and k bounds the size of the SLPS.
  We complement our result by presenting a polynomial-time algorithm that decides reachability in 2-SLPS when the initial and target configurations are specified in binary. To achieve this, we show that reachability in such instances is well-structured: all loops, except perhaps for a constant number, are taken either polynomially many times or almost maximally. This extends the main result of Englert, Lazi\'c, and Totzke (2016) who showed the problem is in NL when the initial and target configurations are specified in unary.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16612v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1109/FOCS61266.2024.00086</arxiv:DOI>
      <dc:creator>Dmitry Chistikov, Wojciech Czerwi\'nski, Filip Mazowiecki, {\L}ukasz Orlikowski, Henry Sinclair-Banks, Karol W\k{e}grzycki</dc:creator>
    </item>
    <item>
      <title>Quantitative Equality in Substructural Logic via Lipschitz Doctrines</title>
      <link>https://arxiv.org/abs/2110.05388</link>
      <description>arXiv:2110.05388v4 Announce Type: replace 
Abstract: Substructural logics naturally support a quantitative interpretation of formulas, as they are seen as consumable resources. Distances are the quantitative counterpart of equivalence relations: they measure how much two objects are similar, rather than just saying whether they are equivalent or not. Hence, they provide the natural choice for modelling equality in a substructural setting. In this paper, we develop this idea, using the categorical language of Lawvere's doctrines. We work in a minimal fragment of Linear Logic enriched by graded modalities, which are needed to write a resource sensitive substitution rule for equality, enabling its quantitative interpretation as a distance. We introduce both a deductive calculus and the notion of Lipschitz doctrine to give it a sound and complete categorical semantics. The study of 2-categorical properties of Lipschitz doctrines provides us with a universal construction, which generates examples based for instance on metric spaces and quantitative realisability. Finally, we show how to smoothly extend our results to richer substructural logics, up to full Linear Logic with quantifiers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2110.05388v4</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Francesco Dagnino, Fabio Pasquali</dc:creator>
    </item>
    <item>
      <title>Quantitative Verification with Neural Networks</title>
      <link>https://arxiv.org/abs/2301.06136</link>
      <description>arXiv:2301.06136v4 Announce Type: replace 
Abstract: We present a data-driven approach to the quantitative verification of probabilistic programs and stochastic dynamical models. Our approach leverages neural networks to compute tight and sound bounds for the probability that a stochastic process hits a target condition within finite time. This problem subsumes a variety of quantitative verification questions, from the reachability and safety analysis of discrete-time stochastic dynamical models, to the study of assertion-violation and termination analysis of probabilistic programs. We rely on neural networks to represent supermartingale certificates that yield such probability bounds, which we compute using a counterexample-guided inductive synthesis loop: we train the neural certificate while tightening the probability bound over samples of the state space using stochastic optimisation, and then we formally check the certificate's validity over every possible state using satisfiability modulo theories; if we receive a counterexample, we add it to our set of samples and repeat the loop until validity is confirmed. We demonstrate on a diverse set of benchmarks that, thanks to the expressive power of neural networks, our method yields smaller or comparable probability bounds than existing symbolic methods in all cases, and that our approach succeeds on models that are entirely beyond the reach of such alternative techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2301.06136v4</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.CONCUR.2023.22</arxiv:DOI>
      <dc:creator>Alessandro Abate, Alec Edwards, Mirco Giacobbe, Hashan Punchihewa, Diptarko Roy</dc:creator>
    </item>
    <item>
      <title>Multi-Structural Games and Beyond</title>
      <link>https://arxiv.org/abs/2301.13329</link>
      <description>arXiv:2301.13329v5 Announce Type: replace 
Abstract: Multi-structural (MS) games are combinatorial games that capture the number of quantifiers of first-order sentences. On the face of their definition, MS games differ from Ehrenfeucht-Fraisse (EF) games in two ways: first, MS games are played on two sets of structures, while EF games are played on a pair of structures; second, in MS games, Duplicator can make any number of copies of structures. In the first part of this paper, we perform a finer analysis of MS games and develop a closer comparison of MS games with EF games. In particular, we point out that the use of sets of structures is of the essence and that when MS games are played on pairs of structures, they capture Boolean combinations of first-order sentences with a fixed number of quantifiers. After this, we focus on another important difference between MS games and EF games, namely, the necessity for Spoiler to play on top of a previous move in order to win some MS games. Via an analysis of the types realized during MS games, we delineate the expressive power of the variant of MS games in which Spoiler never plays on top of a previous move. In the second part we focus on simultaneously capturing number of quantifiers and number of variables in first-order logic. We show that natural variants of the MS game do *not* achieve this. We then introduce a new game, the quantifier-variable tree game, and show that it simultaneously captures the number of quantifiers and number of variables. We conclude by generalizing this game to a family of games, the *syntactic games*, that simultaneously capture reasonable syntactic measures and the number of variables.</description>
      <guid isPermaLink="false">oai:arXiv.org:2301.13329v5</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marco Carmosino, Ronald Fagin, Neil Immerman, Phokion Kolaitis, Jonathan Lenchner, Rik Sengupta</dc:creator>
    </item>
    <item>
      <title>Symbolic Infinite-State LTL Synthesis</title>
      <link>https://arxiv.org/abs/2307.09776</link>
      <description>arXiv:2307.09776v2 Announce Type: replace 
Abstract: Recently interest has increased in applying reactive synthesis to more practical richer-than-Boolean domains. One of the major challenges in this area is to establish when certain repeating behaviour terminates in a desired state when the number of steps is unbounded. This isolated problem, by itself, is already undecidable, and forms part of the overall difficulty of this kind of synthesis tasks. Relatively successful approaches exist for deterministic games with at most B{\"u}chi conditions. Our contribution goes beyond, being the first effective approach for solving symbolic synthesis problems with full LTL objectives, based on novel liveness refinements guided by the underlying game. Our CEGAR-based approach relies on a sound boolean abstraction of the problem, spuriousness checking of abstract counterstrategies through invariant checking, and extracting fresh safety or liveness properties of the concrete game from counterexamples. The latter are used to refine the abstraction, which is used to re-attempt synthesis. Our discrete synthesis tool outperforms the state-of-the-art on LIA benchmarks from literature. We also introduce benchmarks that are out of scope for all other approaches.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.09776v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Shaun Azzopardi, Nir Piterman, Luca Di Stefano, Gerardo Schneider</dc:creator>
    </item>
    <item>
      <title>Non-deterministic, probabilistic, and quantum effects through the lens of event structures (Technical report)</title>
      <link>https://arxiv.org/abs/2408.14563</link>
      <description>arXiv:2408.14563v3 Announce Type: replace 
Abstract: In this paper, we consider event structures and their probabilistic and quantum extensions as originally defined by Winskel. If these structures have already been part of sophisticated computational models, they have rarely been directly studied as an immediate model of execution traces of programs. This paper offers such an analysis. We propose a simple imperative operational framework and show how to derive soundness and adequacy results with event structures considered as a semantics. We show how event structures naturally handle non-deterministic, probabilistic and quantum effects.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.14563v3</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>V\'itor Fernandes, Marc de Visme, Beno\^it Valiron</dc:creator>
    </item>
    <item>
      <title>A Theoretical Review on Solving Algebra Problems</title>
      <link>https://arxiv.org/abs/2411.00031</link>
      <description>arXiv:2411.00031v2 Announce Type: replace 
Abstract: Solving algebra problems (APs) continues to attract significant research interest as evidenced by the large number of algorithms and theories proposed over the past decade. Despite these important research contributions, however, the body of work remains incomplete in terms of theoretical justification and scope. The current contribution intends to fill the gap by developing a review framework that aims to lay a theoretical base, create an evaluation scheme, and extend the scope of the investigation. This paper first develops the State Transform Theory (STT), which emphasizes that the problem-solving algorithms are structured according to states and transforms unlike the understanding that underlies traditional surveys which merely emphasize the progress of transforms. The STT, thus, lays the theoretical basis for a new framework for reviewing algorithms. This new construct accommodates the relation-centric algorithms for solving both word and diagrammatic algebra problems. The latter not only highlights the necessity of introducing new states but also allows revelation of contributions of individual algorithms obscured in prior reviews without this approach.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00031v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.SC</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Xinguo Yu, Weina Cheng, Chuanzhi Yang, Ting Zhang</dc:creator>
    </item>
    <item>
      <title>Decision algorithms for fragments of real analysis. II. A theory of differentiable functions with convexity and concavity predicates</title>
      <link>https://arxiv.org/abs/2412.16091</link>
      <description>arXiv:2412.16091v2 Announce Type: replace 
Abstract: We address the decision problem for a fragment of real analysis involving differentiable functions with continuous first derivatives. The proposed theory, besides the operators of Tarski's theory of reals, includes predicates for comparisons, monotonicity, convexity, and derivative of functions over bounded closed intervals or unbounded intervals.
  Our decision algorithm is obtained by showing that satisfiable formulae of our theory admit canonical models in which functional variables are interpreted as piecewise exponential functions. These can be implicitly described within the decidable Tarski's theory of reals.
  Our satisfiability test generalizes previous decidability results not involving derivative operators.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16091v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Domenico Cantone, Gianluca Cincotti</dc:creator>
    </item>
    <item>
      <title>Decomposition horizons and a characterization of stable hereditary classes of graphs</title>
      <link>https://arxiv.org/abs/2209.11229</link>
      <description>arXiv:2209.11229v3 Announce Type: replace-cross 
Abstract: The notions of bounded-size and quasibounded-size decompositions with bounded treedepth base classes are central to the structural theory of graph sparsity introduced by two of the authors years ago, and provide a characterization of both classes with bounded expansions and nowhere dense classes. Strong connections of this theory with model theory led to considering first-order transductions, which are logically defined graph transformations, and to initiate a comparative study of combinatorial and model theoretical properties of graph classes, with an emphasis on the model theoretical notions of dependence (or NIP) and stability. In this paper, we first prove that every hereditary class with quasibounded-size decompositions with dependent (resp.\ stable) base classes is itself dependent (resp.\ stable). This result is obtained in a more general study of ``decomposition horizons'', which are class properties compatible with quasibounded-size decompositions. We deduce that hereditary classes with quasibounded-size decompositions with bounded shrubdepth base classes are stable. In the second part of the paper, we prove the converse. Thus, we characterize stable hereditary classes of graphs as those hereditary classes that admit quasibounded-size decompositions with bounded shrubdepth base classes. This result is obtained by proving that every hereditary stable class of graphs admits almost nowhere dense quasi-bush representations, thus answering positively a conjecture of Dreier et al. These results have several consequences. For example, we show that every graph $G$ in a stable, hereditary class of graphs $\mathscr C$ has a clique or a stable set of size $\Omega_{\mathscr C,\epsilon}(|G|^{1/2-\epsilon})$, for every $\epsilon&gt;0$, which is tight in the sense that it cannot be improved to $\Omega_{\mathscr C}(|G|^{1/2})$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2209.11229v3</guid>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <category>math.CO</category>
      <category>math.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Samuel Braunfeld, Jaroslav Ne\v{s}et\v{r}il, Patrice Ossona de Mendez, Sebastian Siebertz</dc:creator>
    </item>
    <item>
      <title>Worst-Case Input Generation for Concurrent Programs under Non-Monotone Resource Metrics</title>
      <link>https://arxiv.org/abs/2309.01261</link>
      <description>arXiv:2309.01261v4 Announce Type: replace-cross 
Abstract: Worst-case input generation aims to automatically generate inputs that exhibit the worst-case performance of programs. It has several applications, and can, for example, detect vulnerabilities to denial-of-service (DoS) attacks. However, it is non-trivial to generate worst-case inputs for concurrent programs, particularly for resources like memory where the peak cost depends on how processes are scheduled. This article presents the first sound worst-case input generation algorithm for concurrent programs under non-monotone resource metrics like memory. The key insight is to leverage resource-annotated session types and symbolic execution. Session types describe communication protocols on channels in process calculi. Equipped with resource annotations, resource-annotated session types not only encode cost bounds but also indicate how many resources can be reused and transferred between processes. This information is critical for identifying a worst-case execution path during symbolic execution. The algorithm is sound: if it returns any input, it is guaranteed to be a valid worst-case input. The algorithm is also relatively complete: as long as resource-annotated session types are sufficiently expressive and the background theory for SMT solving is decidable, a worst-case input is guaranteed to be returned. A simple case study of a web server's memory usage demonstrates the utility of the worst-case input generation algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.01261v4</guid>
      <category>cs.PL</category>
      <category>cs.DC</category>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Long Pham, Jan Hoffmann</dc:creator>
    </item>
    <item>
      <title>A correspondence between the time and space complexity</title>
      <link>https://arxiv.org/abs/2311.01184</link>
      <description>arXiv:2311.01184v2 Announce Type: replace-cross 
Abstract: We investigate the correspondence between the time and space recognition complexity of languages. For this purpose, we will code the long-continued computations of deterministic two-tape Turing machines by the relatively short-length quantified Boolean formulae. The modified Meyer and Stockmeyer method will appreciably be used for this simulation. It will be proved using this modeling that the complexity classes Deterministic Exponential Time and Deterministic Polynomial Space coincide. It will also be proven that any language recognized in polynomial time can be recognized in almost logarithmic space. Furthermore, this allows us slightly to improve the early founded lower complexity bound of decidable theories that are nontrivial relative to some equivalence relation (this relation may be equality) -- each of these theories is consistent with the formula, which asserts that there are two non-equivalent elements.
  Keywords: computational complexity, the coding of computations through formulae, exponential time, polynomial space, the lower complexity bound of the language recognition</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.01184v2</guid>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ivan V. Latkin</dc:creator>
    </item>
    <item>
      <title>Demystifying $\mu$</title>
      <link>https://arxiv.org/abs/2401.01096</link>
      <description>arXiv:2401.01096v2 Announce Type: replace-cross 
Abstract: We explore the theory of illfounded and cyclic proofs for the propositional {modal $\mu$-calculus}. A fine analysis of {provability} for classical and intuitionistic modal logic provides a novel bridge between finitary, cyclic and illfounded conceptions of proof and re-enforces the importance of two normal form theorems for the logic: guardedness and disjunctiveness.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.01096v2</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Bahareh Afshari, Graham E. Leigh, Guillermo Men\'endez Turata</dc:creator>
    </item>
    <item>
      <title>Enhancing Reasoning Capabilities of LLMs via Principled Synthetic Logic Corpus</title>
      <link>https://arxiv.org/abs/2411.12498</link>
      <description>arXiv:2411.12498v2 Announce Type: replace-cross 
Abstract: Large language models (LLMs) are capable of solving a wide range of tasks, yet they have struggled with reasoning. To address this, we propose $\textbf{Additional Logic Training (ALT)}$, which aims to enhance LLMs' reasoning capabilities by program-generated logical reasoning samples. We first establish principles for designing high-quality samples by integrating symbolic logic theory and previous empirical insights. Then, based on these principles, we construct a synthetic corpus named $\textbf{Formal Logic Deduction Diverse}$ ($\textbf{FLD}$$_{\times 2}$), comprising numerous samples of multi-step deduction with unknown facts, diverse reasoning rules, diverse linguistic expressions, and challenging distractors. Finally, we empirically show that ALT on FLD$_{\times2}$ substantially enhances the reasoning capabilities of state-of-the-art LLMs, including LLaMA-3.1-70B. Improvements include gains of up to 30 points on logical reasoning benchmarks, up to 10 points on math and coding benchmarks, and 5 points on the benchmark suite BBH.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.12498v2</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Terufumi Morishita, Gaku Morio, Atsuki Yamaguchi, Yasuhiro Sogawa</dc:creator>
    </item>
  </channel>
</rss>
