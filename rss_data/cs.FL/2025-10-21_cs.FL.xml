<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 Oct 2025 01:45:50 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Inference of Deterministic Finite Automata via Q-Learning</title>
      <link>https://arxiv.org/abs/2510.17386</link>
      <description>arXiv:2510.17386v1 Announce Type: new 
Abstract: Traditional approaches to inference of deterministic finite-state automata (DFA) stem from symbolic AI, including both active learning methods (e.g., Angluin's L* algorithm and its variants) and passive techniques (e.g., Biermann and Feldman's method, RPNI). Meanwhile, sub-symbolic AI, particularly machine learning, offers alternative paradigms for learning from data, such as supervised, unsupervised, and reinforcement learning (RL). This paper investigates the use of Q-learning, a well-known reinforcement learning algorithm, for the passive inference of deterministic finite automata. It builds on the core insight that the learned Q-function, which maps state-action pairs to rewards, can be reinterpreted as the transition function of a DFA over a finite domain. This provides a novel bridge between sub-symbolic learning and symbolic representations. The paper demonstrates how Q-learning can be adapted for automaton inference and provides an evaluation on several examples.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.17386v1</guid>
      <category>cs.FL</category>
      <category>cs.AI</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Elaheh Hosseinkhani, Martin Leucker</dc:creator>
    </item>
    <item>
      <title>Castor Ministerialis</title>
      <link>https://arxiv.org/abs/2510.17438</link>
      <description>arXiv:2510.17438v1 Announce Type: new 
Abstract: The famous problem of Busy Beavers can be stated as the question on how long a $n$-state Turing machine (using a 2-symbol alphabet or -- in a generalization -- a $m$-symbol alphabet) can run if it is started on the blank tape before it holds. Thus, not halting Turing machines are excluded. For up to four states the answer to this question is well-known. Recently, it could be verified that the widely assumed candidate for five states is in fact the champion. And there is progress in searching for good candidates with six or more states.
  We investigate a variant of this problem: Additionally to the requirement that the Turing machines have to start from the blank tape we only consider such Turing machines that hold on the blank tape, too. For this variant we give definitive answers on how long such a Turing machine with up to five states can run, analyze the behavior of a six-states candidate and give some findings on the generalization of Turing-machines with $m$-symbol alphabet.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.17438v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christian Hercher</dc:creator>
    </item>
    <item>
      <title>Non-interference analysis of bounded labeled Petri nets</title>
      <link>https://arxiv.org/abs/2510.17582</link>
      <description>arXiv:2510.17582v1 Announce Type: new 
Abstract: This paper focuses on a fundamental problem on information security of bounded labeled Petri nets: non-interference analysis. As in hierarchical control, we assume that a system is observed by users at different levels, namely high-level users and low-level users. The output events produced by the firing of transitions are also partitioned into high-level output events and low-level output events. In general, high-level users can observe the occurrence of all the output events, while low-level users can only observe the occurrence of low-level output events. A system is said to be non-interferent if low-level users cannot infer the firing of transitions labeled with high-level output events by looking at low-level outputs. In this paper, we study a particular non-interference property, namely strong non-deterministic non-interference (SNNI), using a special automaton called SNNI Verifier, and propose a necessary and sufficient condition for SNNI.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.17582v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Ning Ran, Zhengguang Wu, Shaokang Zhang, Zhou He, Carla Seatzu</dc:creator>
    </item>
    <item>
      <title>Expressive Reward Synthesis with the Runtime Monitoring Language</title>
      <link>https://arxiv.org/abs/2510.16185</link>
      <description>arXiv:2510.16185v2 Announce Type: cross 
Abstract: A key challenge in reinforcement learning (RL) is reward (mis)specification, whereby imprecisely defined reward functions can result in unintended, possibly harmful, behaviours. Indeed, reward functions in RL are typically treated as black-box mappings from state-action pairs to scalar values. While effective in many settings, this approach provides no information about why rewards are given, which can hinder learning and interpretability. Reward Machines address this issue by representing reward functions as finite state automata, enabling the specification of structured, non-Markovian reward functions. However, their expressivity is typically bounded by regular languages, leaving them unable to capture more complex behaviours such as counting or parametrised conditions. In this work, we build on the Runtime Monitoring Language (RML) to develop a novel class of language-based Reward Machines. By leveraging the built-in memory of RML, our approach can specify reward functions for non-regular, non-Markovian tasks. We demonstrate the expressiveness of our approach through experiments, highlighting additional advantages in flexible event-handling and task specification over existing Reward Machine-based methods.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.16185v2</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>stat.ML</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Donnelly, Angelo Ferrando, Francesco Belardinelli</dc:creator>
    </item>
    <item>
      <title>Multihead Finite-State Compression</title>
      <link>https://arxiv.org/abs/2510.17544</link>
      <description>arXiv:2510.17544v1 Announce Type: cross 
Abstract: This paper develops multihead finite-state compression, a generalization of finite-state compression, complementary to the multihead finite-state dimensions of Huang, Li, Lutz, and Lutz (2025). In this model, an infinite sequence of symbols is compressed by a compressor that produces outputs according to finite-state rules, based on the symbols read by a constant number of finite-state read heads moving forward obliviously through the sequence. The main theorem of this work establishes that for every sequence and every positive integer $h$, the infimum of the compression ratios achieved by $h$-head finite-state information-lossless compressors equals the $h$-head finite-state predimension of the sequence. As an immediate corollary, the infimum of these ratios over all $h$ is the multihead finite-state dimension of the sequence.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.17544v1</guid>
      <category>cs.IT</category>
      <category>cs.FL</category>
      <category>math.IT</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Neil Lutz</dc:creator>
    </item>
    <item>
      <title>The Tribonacci constant and finite automata</title>
      <link>https://arxiv.org/abs/2510.10834</link>
      <description>arXiv:2510.10834v2 Announce Type: replace 
Abstract: We show that there is no automaton accepting the Tribonacci representations of $n$ and $x$ in parallel, where $\psi = 1.839\cdots$ is the Tribonacci constant, and $x= \lfloor n \psi \rfloor$. Similarly, there is no Tribonacci automaton generating the Sturmian characteristic word with slope $\psi-1$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.10834v2</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <category>math.NT</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeffrey Shallit</dc:creator>
    </item>
    <item>
      <title>Balanced Fibonacci word rectangles, and beyond</title>
      <link>https://arxiv.org/abs/2509.25994</link>
      <description>arXiv:2509.25994v3 Announce Type: replace-cross 
Abstract: Following a recent paper of Anselmo et al., we consider $m \times n$ rectangular matrices formed from the Fibonacci word, and we show that their balance properties can be solved with a finite automaton. We also generalize the result to every Sturmian characteristic word corresponding to a quadratic irrational. Finally, we also examine the analogous question for the Tribonacci word and the Thue-Morse word.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.25994v3</guid>
      <category>math.NT</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <category>math.CO</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeffrey Shallit, Ingrid Vukusic</dc:creator>
    </item>
    <item>
      <title>Psi-Turing Machines: Bounded Introspection for Complexity Barriers and Oracle Separations</title>
      <link>https://arxiv.org/abs/2510.08577</link>
      <description>arXiv:2510.08577v2 Announce Type: replace-cross 
Abstract: We introduce Psi-Turing Machines (Psi-TM): classical Turing machines equipped with a constant-depth introspection interface $ \iota $ and an explicit per-step information budget $ B(d,n)=c\,d\log_2 n $. With the interface frozen, we develop an information-theoretic lower-bound toolkit: Budget counting, $ \Psi $-Fooling, and $ \Psi $-Fano, with worked examples $ L_k $ and $ L_k^{\mathrm{phase}} $. We prove an oracle-relative separation $ P^{\Psi} \neq NP^{\Psi} $ and a strict depth hierarchy, reinforced by an Anti-Simulation Hook that rules out polynomial emulation of $ \iota_k $ using many calls to $ \iota_{k-1} $ under the budget regime. We also present two independent platforms (Psi-decision trees and interface-constrained circuits IC-AC$^{0}$/IC-NC$^{1}$) and bridges that transfer bounds among machine, tree, and circuit with explicit poly/log losses. The model preserves classical computational power outside $ \iota $ yet enables precise oracle-aware statements about barriers (relativization; partial/conditional progress on natural proofs and proof complexity). The aim is a standardized minimal introspection interface with clearly accounted information budgets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.08577v2</guid>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 21 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Rafig Huseynzade</dc:creator>
    </item>
  </channel>
</rss>
