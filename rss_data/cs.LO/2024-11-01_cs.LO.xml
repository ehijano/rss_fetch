<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Nov 2024 04:01:13 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Converting BPMN Diagrams to Privacy Calculus</title>
      <link>https://arxiv.org/abs/2410.23759</link>
      <description>arXiv:2410.23759v1 Announce Type: new 
Abstract: The ecosystem of Privacy Calculus is a formal framework for privacy comprising (a) the Privacy Calculus, a Turing-complete language of message-exchanging processes based on the pi-calculus, (b) a privacy policy language, and (c) a type checker that checks adherence of Privacy Calculus terms to privacy policies. BPMN is a standard for the graphical description of business processes which aims to be understandable by all business users, from those with no technical background to those implementing software. This paper presents how (a subset of) BPMN diagrams can be converted to Privacy Calculus terms, in the hope that it will serve as a small piece of larger workflows for building privacy-preserving software. The conversion is described mathematically in the paper, but has also been implemented as a software tool.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23759v1</guid>
      <category>cs.LO</category>
      <category>cs.CY</category>
      <category>cs.SE</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.410.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 410, 2024, pp. 53-68</arxiv:journal_reference>
      <dc:creator>Georgios V. Pitsiladis, Petros S. Stefaneas</dc:creator>
    </item>
    <item>
      <title>Unification in Matching Logic -- Revisited</title>
      <link>https://arxiv.org/abs/2410.23760</link>
      <description>arXiv:2410.23760v1 Announce Type: new 
Abstract: Matching logic is a logical framework for specifying and reasoning about programs using pattern matching semantics. A pattern is made up of a number of structural components and constraints. Structural components are syntactically matched, while constraints need to be satisfied. Having multiple structural patterns poses a practical problem as it requires multiple matching operations. This is easily remedied by unification, for which an algorithm has already been defined and proven correct in a sorted, polyadic variant of matching logic. This paper revisits the subject in the applicative variant of the language while generalising the unification problem and mechanizing a proven-sound solution in Coq.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23760v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.410.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 410, 2024, pp. 1-17</arxiv:journal_reference>
      <dc:creator>\'Ad\'am Kurucz (ELTE E\"otv\"os Lor\'and University), P\'eter Bereczky (ELTE E\"otv\"os Lor\'and University), D\'aniel Horp\'acsi (ELTE E\"otv\"os Lor\'and University)</dc:creator>
    </item>
    <item>
      <title>Intuitionistic Propositional Logic in Lean</title>
      <link>https://arxiv.org/abs/2410.23765</link>
      <description>arXiv:2410.23765v1 Announce Type: new 
Abstract: In this paper we present a formalization of Intuitionistic Propositional Logic in the Lean proof assistant. Our approach focuses on verifying two completeness proofs for the studied logical system, as well as exploring the relation between the two analyzed semantical paradigms - Kripke and algebraic. In addition, we prove a large number of theorems and derived deduction rules.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23765v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.410.9</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 410, 2024, pp. 133-149</arxiv:journal_reference>
      <dc:creator>Dafina Trufa\c{s}</dc:creator>
    </item>
    <item>
      <title>Leveraging Slither and Interval Analysis to build a Static Analysis Tool</title>
      <link>https://arxiv.org/abs/2410.23766</link>
      <description>arXiv:2410.23766v1 Announce Type: new 
Abstract: Even though much progress has been made in identifying and mitigating smart contract vulnerabilities, we often hear about coding or design issues leading to great financial losses. This paper presents our progress toward finding defects that are sometimes not detected or completely detected by state-of-the-art analysis tools. Although it is still in its incipient phase, we developed a working solution built on top of Slither that uses interval analysis to evaluate the contract state during the execution of each instruction. To improve the accuracy of our results, we extend interval analysis by also considering the constraints imposed by specific instructions. We present the current solution architecture in detail and show how it could be extended to other static analysis techniques, including how it can be integrated with other third-party tools. Our current benchmarks contain examples of smart contracts that highlight the potential of this approach to detect certain code defects. </description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23766v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.410.10</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 410, 2024, pp. 150-166</arxiv:journal_reference>
      <dc:creator>Stefan-Claudiu Susan (Alexandru Ioan Cuza University of Iasi, Department of Computer Science, Iasi, Romania)</dc:creator>
    </item>
    <item>
      <title>Neural Model Checking</title>
      <link>https://arxiv.org/abs/2410.23790</link>
      <description>arXiv:2410.23790v1 Announce Type: new 
Abstract: We introduce a machine learning approach to model checking temporal logic, with application to formal hardware verification. Model checking answers the question of whether every execution of a given system satisfies a desired temporal logic specification. Unlike testing, model checking provides formal guarantees. Its application is expected standard in silicon design and the EDA industry has invested decades into the development of performant symbolic model checking algorithms. Our new approach combines machine learning and symbolic reasoning by using neural networks as formal proof certificates for linear temporal logic. We train our neural certificates from randomly generated executions of the system and we then symbolically check their validity using satisfiability solving which, upon the affirmative answer, establishes that the system provably satisfies the specification. We leverage the expressive power of neural networks to represent proof certificates as well as the fact that checking a certificate is much simpler than finding one. As a result, our machine learning procedure for model checking is entirely unsupervised, formally sound, and practically effective. We experimentally demonstrate that our method outperforms the state-of-the-art academic and commercial model checkers on a set of standard hardware designs written in SystemVerilog.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23790v1</guid>
      <category>cs.LO</category>
      <category>cs.LG</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mirco Giacobbe, Daniel Kroening, Abhinandan Pal, Michael Tautschnig</dc:creator>
    </item>
    <item>
      <title>Efficient Inference and Computation of Optimal Alternatives for Preference Languages Based On Lexicographic Models</title>
      <link>https://arxiv.org/abs/2410.23913</link>
      <description>arXiv:2410.23913v1 Announce Type: new 
Abstract: We analyse preference inference, through consistency, for general preference languages based on lexicographic models. We identify a property, which we call strong compositionality, that applies for many natural kinds of preference statement, and that allows a greedy algorithm for determining consistency of a set of preference statements. We also consider different natural definitions of optimality, and their relations to each other, for general preference languages based on lexicographic models. Based on our framework, we show that testing consistency, and thus inference, is polynomial for a specific preference language LpqT, which allows strict and non-strict statements, comparisons between outcomes and between partial tuples, both ceteris paribus and strong statements, and their combination. Computing different kinds of optimal sets is also shown to be polynomial; this is backed up by our experimental results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23913v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.CC</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nic Wilson, Anne-Marie George</dc:creator>
    </item>
    <item>
      <title>Towards Fast Algorithms for the Preference Consistency Problem Based on Hierarchical Models</title>
      <link>https://arxiv.org/abs/2410.23934</link>
      <description>arXiv:2410.23934v1 Announce Type: new 
Abstract: In this paper, we construct and compare algorithmic approaches to solve the Preference Consistency Problem for preference statements based on hierarchical models. Instances of this problem contain a set of preference statements that are direct comparisons (strict and non-strict) between some alternatives, and a set of evaluation functions by which all alternatives can be rated. An instance is consistent based on hierarchical preference models, if there exists an hierarchical model on the evaluation functions that induces an order relation on the alternatives by which all relations given by the preference statements are satisfied. Deciding if an instance is consistent is known to be NP-complete for hierarchical models. We develop three approaches to solve this decision problem. The first involves a Mixed Integer Linear Programming (MILP) formulation, the other two are recursive algorithms that are based on properties of the problem by which the search space can be pruned. Our experiments on synthetic data show that the recursive algorithms are faster than solving the MILP formulation and that the ratio between the running times increases extremely quickly.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23934v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anne-Marie George, Nic Wilson, Barry O'Sullivan</dc:creator>
    </item>
    <item>
      <title>A Type System for Data Flow and Alias Analysis in ReScript</title>
      <link>https://arxiv.org/abs/2410.23984</link>
      <description>arXiv:2410.23984v1 Announce Type: new 
Abstract: ReScript is a strongly typed language that targets JavaScript, as an alternative to gradually typed languages, such as TypeScript. In this paper, we present a sound type system for data-flow analysis for a subset of the ReScript language, more specifically for a lambda-calculus with mutability and pattern matching. The type system is a local analysis that collects information about variables that are used at each program point as well as alias information. </description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23984v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.410.8</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 410, 2024, pp. 116-132</arxiv:journal_reference>
      <dc:creator>Nicky Ask Lund (Department of Computer Science, Aalborg University), Hans H\"uttel (Department of Computer Science, University of Copenhagen)</dc:creator>
    </item>
    <item>
      <title>Unifying Sequent Systems for G\"odel-L\"ob Provability Logic via Syntactic Transformations</title>
      <link>https://arxiv.org/abs/2410.24053</link>
      <description>arXiv:2410.24053v1 Announce Type: new 
Abstract: We demonstrate the inter-translatability of proofs between the most prominent sequent-based formalisms for G\"odel-L\"ob provability logic. In particular, we consider Sambin and Valentini's sequent system GLseq, Shamkanov's non-wellfounded and cyclic sequent systems GL$\infty$ and GLcirc, Poggiolesi's tree-hypersequent system CSGL, and Negri's labeled sequent system G3GL. Shamkanov showed how to transform proofs between GLseq, GL$\infty$, and GLcirc, and Gor\'e and Ramanayake showed how to transform proofs between CSGL and G3GL, however, the exact nature of proof transformations between the former three systems and the latter two systems has remained an open problem. We solve this open problem by showing how to restructure tree-hypersequent proofs into an end-active form and introduce a novel linearization technique that transforms such proofs into linear nested sequent proofs. As a result, we obtain a new proof-theoretic tool for extracting linear nested sequent systems from tree-hypersequent systems, which yields the first cut-free linear nested sequent calculus LNGL for G\"odel-L\"ob provability logic. We show how to transform proofs in LNGL into a certain normal form, where proofs repeat in stages of modal and local rule applications, and which are translatable into GLseq and G3GL proofs. These new syntactic transformations, together with those mentioned above, establish full proof-theoretic correspondences between GLseq, GL$\infty$, GLcirc, CSGL, G3GL, and LNGL while also giving (to the best of the author's knowledge) the first constructive proof mappings between structural (viz. labeled, tree-hypersequent, and linear nested sequent) systems and a cyclic sequent system.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.24053v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tim S. Lyon</dc:creator>
    </item>
    <item>
      <title>Progressive Safeguards for Safe and Model-Agnostic Reinforcement Learning</title>
      <link>https://arxiv.org/abs/2410.24096</link>
      <description>arXiv:2410.24096v1 Announce Type: cross 
Abstract: In this paper we propose a formal, model-agnostic meta-learning framework for safe reinforcement learning. Our framework is inspired by how parents safeguard their children across a progression of increasingly riskier tasks, imparting a sense of safety that is carried over from task to task. We model this as a meta-learning process where each task is synchronized with a safeguard that monitors safety and provides a reward signal to the agent. The safeguard is implemented as a finite-state machine based on a safety specification; the reward signal is formally shaped around this specification. The safety specification and its corresponding safeguard can be arbitrarily complex and non-Markovian, which adds flexibility to the training process and explainability to the learned policy. The design of the safeguard is manual but it is high-level and model-agnostic, which gives rise to an end-to-end safe learning approach with wide applicability, from pixel-level game control to language model fine-tuning. Starting from a given set of safety specifications (tasks), we train a model such that it can adapt to new specifications using only a small number of training samples. This is made possible by our method for efficiently transferring safety bias between tasks, which effectively minimizes the number of safety violations. We evaluate our framework in a Minecraft-inspired Gridworld, a VizDoom game environment, and an LLM fine-tuning application. Agents trained with our approach achieve near-minimal safety violations, while baselines are shown to underperform.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.24096v1</guid>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nabil Omi, Hosein Hasanbeig, Hiteshi Sharma, Sriram K. Rajamani, Siddhartha Sen</dc:creator>
    </item>
    <item>
      <title>Multi-Structural Games and Beyond</title>
      <link>https://arxiv.org/abs/2301.13329</link>
      <description>arXiv:2301.13329v3 Announce Type: replace 
Abstract: Multi-structural (MS) games are combinatorial games that capture the number of quantifiers of first-order sentences. On the face of their definition, MS games differ from Ehrenfeucht-Fraisse (EF) games in two ways: first, MS games are played on two sets of structures, while EF games are played on a pair of structures; second, in MS games, Duplicator can make any number of copies of structures. In the first part of this paper, we perform a finer analysis of MS games and develop a closer comparison of MS games with EF games. In particular, we point out that the use of sets of structures is of the essence and that when MS games are played on pairs of structures, they capture Boolean combinations of first-order sentences with a fixed number of quantifiers. After this, we focus on another important difference between MS games and EF games, namely, the necessity for Spoiler to play on top of a previous move in order to win some MS games. Via an analysis of the types realized during MS games, we delineate the expressive power of the variant of MS games in which Spoiler never plays on top of a previous move. In the second part we focus on simultaneously capturing number of quantifiers and number of variables in first-order logic. We show that natural variants of the MS game do *not* achieve this. We then introduce a new game, the quantifier-variable tree game, and show that it simultaneously captures the number of quantifiers and number of variables. We conclude by generalizing this game to a family of games, the *syntactic games*, that simultaneously capture reasonable syntactic measures and the number of variables.</description>
      <guid isPermaLink="false">oai:arXiv.org:2301.13329v3</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marco Carmosino, Ronald Fagin, Neil Immerman, Phokion Kolaitis, Jonathan Lenchner, Rik Sengupta</dc:creator>
    </item>
    <item>
      <title>Compositional Shape Analysis with Shared Abduction and Biabductive Loop Acceleration</title>
      <link>https://arxiv.org/abs/2307.06346</link>
      <description>arXiv:2307.06346v3 Announce Type: replace 
Abstract: Biabduction-based shape analysis is a compositional verification and analysis technique that can prove memory safety in the presence of complex, linked data structures. Despite its usefulness, several open problems persist for this kind of analysis; two of which we address in this paper. On the one hand, the original analysis is path-sensitive but cannot combine safety requirements for related branches. This causes the analysis to require additional soundness checks and increases the space for the analysis to become incomplete. We extend the underlying symbolic execution and propose a framework for shared abduction where a common pre-condition is maintained for related computation branches. On the other hand, prior proposals lift loop acceleration methods from forward analysis to biabduction analysis by applying them separately on the pre- and post-condition, which can lead to imprecise or even unsound acceleration results that do not form a loop invariant. In contrast, we propose biabductive loop acceleration, which explicitly constructs and checks candidate loop invariants. For this, we also introduce a novel heuristic called shape extrapolation. This heuristic takes advantage of locality in the handling of list-like data structures (which are the most common data structures found in low-level code) and jointly accelerates pre- and post-conditions by extrapolating the related shapes. In addition to making the analysis more precise, our techniques also make biabductive analysis more efficient since they are sound in just one analysis phase. In contrast, prior techniques always require two phases (as the first phase can produce contracts that are unsound and must hence be verified). We experimentally confirm that our techniques improve on prior techniques; both in terms of precision and runtime of the analysis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.06346v3</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Florian Sextl (TU Wien, Institute of Logic and Computation, Research Unit for Formal Methods in Systems Engineering), Adam Rogalewicz (Brno University of Technology, FIT), Tom\'a\v{s} Vojnar (Masaryk University, Faculty of Informatics, Brno University of Technology, FIT), Florian Zuleger (TU Wien, Institute of Logic and Computation, Research Unit for Formal Methods in Systems Engineering)</dc:creator>
    </item>
    <item>
      <title>A Characterization of Basic Feasible Functionals Through Higher-Order Rewriting and Tuple Interpretations</title>
      <link>https://arxiv.org/abs/2401.12385</link>
      <description>arXiv:2401.12385v3 Announce Type: replace 
Abstract: The class of type-two basic feasible functionals ($\mathtt{BFF}_2$) is the analogue of $\mathtt{FP}$ (polynomial time functions) for type-2 functionals, that is, functionals that can take (first-order) functions as arguments. $\mathtt{BFF}_2$ can be defined through Oracle Turing machines with running time bounded by second-order polynomials. On the other hand, higher-order term rewriting provides an elegant formalism for expressing higher-order computation. We address the problem of characterizing $\mathtt{BFF}_2$ by higher-order term rewriting. Various kinds of interpretations for first-order term rewriting have been introduced in the literature for proving termination and characterizing first-order complexity classes. In this paper, we consider a recently introduced notion of cost-size interpretations for higher-order term rewriting and see second order rewriting as ways of computing type-2 functionals. We then prove that the class of functionals represented by higher-order terms admitting polynomially bounded cost-size interpretations exactly corresponds to $\mathtt{BFF}_2$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.12385v3</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Patrick Baillot, Ugo Dal Lago, Cynthia Kop, Deivid Vale</dc:creator>
    </item>
    <item>
      <title>Epimorphisms and Acyclic Types in Univalent Foundations</title>
      <link>https://arxiv.org/abs/2401.14106</link>
      <description>arXiv:2401.14106v3 Announce Type: replace 
Abstract: We characterize the epimorphisms in homotopy type theory (HoTT) as the fiberwise acyclic maps and develop a type-theoretic treatment of acyclic maps and types in the context of synthetic homotopy theory as developed in univalent foundations. We present examples and applications in group theory, such as the acyclicity of the Higman group, through the identification of groups with 0-connected, pointed 1-types. Many of our results are formalized as part of the agda-unimath library.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.14106v3</guid>
      <category>cs.LO</category>
      <category>math.AT</category>
      <category>math.CT</category>
      <pubDate>Fri, 01 Nov 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ulrik Buchholtz, Tom de Jong, Egbert Rijke</dc:creator>
    </item>
  </channel>
</rss>
