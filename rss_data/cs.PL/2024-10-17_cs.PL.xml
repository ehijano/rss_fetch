<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Oct 2024 04:00:18 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Membership Testing for Semantic Regular Expressions</title>
      <link>https://arxiv.org/abs/2410.13262</link>
      <description>arXiv:2410.13262v1 Announce Type: new 
Abstract: SMORE (Chen et al., 2023) recently proposed the concept of semantic regular expressions that extend the classical formalism with a primitive to query external oracles such as databases and large language models (LLMs). Such patterns can be used to identify lines of text containing references to semantic concepts such as cities, celebrities, political entities, etc. The focus in their paper was on automatically synthesizing semantic regular expressions from positive and negative examples. In this paper, we study the membership testing problem:
  First, We present a two-pass NFA-based algorithm to determine whether a string $w$ matches a semantic regular expression (SemRE) $r$ in $O(|r|^2 |w|^2 + |r| |w|^3)$ time, assuming the oracle responds to each query in unit time. In common situations, where oracle queries are not nested, we show that this procedure runs in $O(|r|^2 |w|^2)$ time. Experiments with a prototype implementation of this algorithm validate our theoretical analysis, and show that the procedure massively outperforms a dynamic programming-based baseline, and incurs a $\approx 2 \times$ overhead over the time needed for interaction with the oracle.
  Next, We establish connections between SemRE membership testing and the triangle finding problem from graph theory, which suggest that developing algorithms which are simultaneously practical and asymptotically faster might be challenging. Furthermore, algorithms for classical regular expressions primarily aim to optimize their time and memory consumption. In contrast, an important consideration in our setting is to minimize the cost of invoking the oracle. We demonstrate an $\Omega(|w|^2)$ lower bound on the number of oracle queries necessary to make this determination.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.13262v1</guid>
      <category>cs.PL</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yifei Huang, Matin Amini, Alexis Le Glaunec, Konstantinos Mamouras, Mukund Raghothaman</dc:creator>
    </item>
    <item>
      <title>On Quantum Programming Languages</title>
      <link>https://arxiv.org/abs/2410.13337</link>
      <description>arXiv:2410.13337v1 Announce Type: cross 
Abstract: This thesis (Habilitation \`a diriger des recherches) presents some of my research contributions since my Ph.D defense in 2008. I have had the chance to participate in the development of quantum programming languages since their early developments: the presentation aims to present my point of view on the evolution of the subject, my contributions, and the current research trends in the community. The target audience is a graduate student interested in pointers to the field of quantum programming languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.13337v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Beno\^it Valiron</dc:creator>
    </item>
    <item>
      <title>EOSpython Version 0.0.11: A Framework for Scenario Generation and a Solution System for the Agile Earth Observation Satellite Scheduling Problem</title>
      <link>https://arxiv.org/abs/2410.13462</link>
      <description>arXiv:2410.13462v1 Announce Type: cross 
Abstract: EOSpython is a PyPI published Python package that encompass everything within a centralized earth observation satellite scheduling system in terms of customer database setup, scenario generation, pre-processing, problem setup, scheduling solution approach, decision maker preference integration, and visualization. The package is tailored to easily configure internal parameters and contribute with other solution approaches.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.13462v1</guid>
      <category>math.OC</category>
      <category>astro-ph.IM</category>
      <category>cs.ET</category>
      <category>cs.NA</category>
      <category>cs.PL</category>
      <category>math.NA</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alex Elkj{\ae}r Vasegaard, Andreas K\"uhne Larsen</dc:creator>
    </item>
    <item>
      <title>Integrating Large Language Models and Reinforcement Learning for Non-Linear Reasoning</title>
      <link>https://arxiv.org/abs/2410.13501</link>
      <description>arXiv:2410.13501v1 Announce Type: cross 
Abstract: Large Language Models (LLMs) were shown to struggle with long-term planning, which may be caused by the limited way in which they explore the space of possible solutions. We propose an architecture where a Reinforcement Learning (RL) Agent guides an LLM's space exploration: (1) the Agent has access to domain-specific information, and can therefore make decisions about the quality of candidate solutions based on specific and relevant metrics, which were not explicitly considered by the LLM's training objective; (2) the LLM can focus on generating immediate next steps, without the need for long-term planning. We allow non-linear reasoning by exploring alternative paths and backtracking. We evaluate this architecture on the program equivalence task, and compare it against Chain of Thought (CoT) and Tree of Thoughts (ToT). We assess both the downstream task, denoting the binary classification, and the intermediate reasoning steps. Our approach compares positively against CoT and ToT.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.13501v1</guid>
      <category>cs.LG</category>
      <category>cs.PL</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Yoav Alon, Cristina David</dc:creator>
    </item>
    <item>
      <title>Axiomatization of Compact Initial Value Problems: Open Properties</title>
      <link>https://arxiv.org/abs/2410.13836</link>
      <description>arXiv:2410.13836v1 Announce Type: cross 
Abstract: This article proves the completeness of an axiomatization for initial value problems (IVPs) with compact initial conditions and compact time horizons for bounded open safety, open liveness and existence properties. Completeness systematically reduces the proofs of these properties to a complete axiomatization for differential equation invariants. This result unifies symbolic logic and numerical analysis by a computable procedure that generates symbolic proofs with differential invariants for rigorous error bounds of numerical solutions to polynomial initial value problems. The procedure is modular and works for all polynomial IVPs with rational coefficients and initial conditions and symbolic parameters constrained to compact sets. Furthermore, this paper discusses generalizations to IVPs with initial conditions/symbolic parameters that are not necessarily constrained to compact sets, achieved through the derivation of fully symbolic axioms/proof-rules based on the axiomatization.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.13836v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.LO</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Andr\'e Platzer, Long Qian</dc:creator>
    </item>
    <item>
      <title>Scenario-Based Proofs for Concurrent Objects [Extended Version]</title>
      <link>https://arxiv.org/abs/2301.05740</link>
      <description>arXiv:2301.05740v2 Announce Type: replace 
Abstract: Concurrent objects form the foundation of many applications that exploit multicore architectures and their importance has lead to informal correctness arguments, as well as formal proof systems. Correctness arguments (as found in the distributed computing literature) give intuitive descriptions of a few canonical executions or "scenarios" often each with only a few threads, yet it remains unknown as to whether these intuitive arguments have a formal grounding and extend to arbitrary interleavings over unboundedly many threads.
  We present a novel proof technique for concurrent objects, based around identifying a small set of scenarios (representative, canonical interleavings), formalized as the commutativity quotient of a concurrent object. We next give an expression language for defining abstractions of the quotient in the form of regular or context-free languages that enable simple proofs of linearizability. These quotient expressions organize unbounded interleavings into a form more amenable to reasoning and make explicit the relationship between implementation-level contention/interference and ADT-level transitions.
  We evaluate our work on numerous non-trivial concurrent objects from the literature (including the Michael-Scott queue, Elimination stack, SLS reservation queue, RDCSS and Herlihy-Wing queue). We show that quotients capture the diverse features/complexities of these algorithms, can be used even when linearization points are not straight-forward, correspond to original authors' correctness arguments, and provide some new scenario-based arguments. Finally, we show that discovery of some object's quotients reduces to two-thread reasoning and give an implementation that can derive candidate quotients expressions from source code.</description>
      <guid isPermaLink="false">oai:arXiv.org:2301.05740v2</guid>
      <category>cs.PL</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Constantin Enea, Eric Koskinen</dc:creator>
    </item>
    <item>
      <title>Gradual Sensitivity Typing</title>
      <link>https://arxiv.org/abs/2308.02018</link>
      <description>arXiv:2308.02018v3 Announce Type: replace 
Abstract: Reasoning about the sensitivity of functions with respect to their inputs has interesting applications in various areas, such as differential privacy. In order to check and enforce sensitivity, several approaches have been developed, notably sensitivity type systems. In these systems, sensitivity can be seen as an effect in the sense of type-and-effects systems as originally proposed by Gifford and Lucassen. Because type-and-effect systems can make certain useful programming patterns tedious or overly conservative, there is value in bringing the benefits of gradual typing to these disciplines in order to ease their adoption. In this work, we motivate, formalize, and prototype gradual sensitivity typing. The language GSoul supports both the unrestricted unknown sensitivity and bounded imprecision in the form of intervals. Gradual sensitivity typing allows programmers to smoothly evolve typed programs without any static sensitivity information towards hardened programs with a mix of static and dynamic sensitivity checking. In particular, we show that gradual sensitivity supports recursive functions for which fully static checking would be overly conservative, seamlessly enabling exact runtime sensitivity checks. GSoul satisfies both the gradual guarantees and sensitivity type soundness, known as metric preservation. We establish that, in general, gradual metric preservation is termination insensitive, and that one can achieve termination-sensitive gradual metric preservation by hardening specifications to bounded imprecision. We implement a prototype that provides an interactive test bed for gradual sensitivity typing. This work opens the door to gradualizing other typing disciplines that rely on function sensitivity such as differential privacy, as well as other quantitative type-based reasoning techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.02018v3</guid>
      <category>cs.PL</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Damian Arquez, Mat\'ias Toro, \'Eric Tanter</dc:creator>
    </item>
    <item>
      <title>ConstraintFlow: A DSL for Specification and Verification of Neural Network Analyses</title>
      <link>https://arxiv.org/abs/2403.18729</link>
      <description>arXiv:2403.18729v2 Announce Type: replace 
Abstract: We develop a declarative DSL - \cf - that can be used to specify Abstract Interpretation-based DNN certifiers. In \cf, programmers can easily define various existing and new abstract domains and transformers, all within just a few 10s of Lines of Code as opposed to 1000s of LOCs of existing libraries. We provide lightweight automatic verification, which can be used to ensure the over-approximation-based soundness of the certifier code written in \cf for arbitrary (but bounded) DNN architectures. Using this automated verification procedure, for the first time, we can verify the soundness of state-of-the-art DNN certifiers for arbitrary DNN architectures, all within a few minutes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.18729v2</guid>
      <category>cs.PL</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Avaljot Singh, Yasmin Sarita, Charith Mendis, Gagandeep Singh</dc:creator>
    </item>
    <item>
      <title>Programming of Cellular Automata in C and C++</title>
      <link>https://arxiv.org/abs/2410.10022</link>
      <description>arXiv:2410.10022v2 Announce Type: replace 
Abstract: This study explores running times of different ways to program cellular automata in C and C++, i.e. looping through arrays by different means, the effect of structures and objects, and the choice of data structure (array versus vector in C++) and compiler (GNU gcc versus Apple clang). The choice of data structure influenced the running time the most. The array version is more than 20-times faster than the vector version in C++. The choice of compiler also had an effect, with the GNU gcc compiler delivering 1.7-times faster programs as compared to the Apple clang compiler. Using pointers instead of array indices, using C instead of C++, and using structures and objects instead of primitive data types has little to neglectable effects on the running time. The study shows that using arrays and looping over them by index in C++ and compiled with GNU gcc reveals the best performance with respect to running time. If one is interested in multi-state cellular automata, objects can be used without loss of that performance. Future studies might investigate Apple's Metal shader or compiler optimisation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.10022v2</guid>
      <category>cs.PL</category>
      <pubDate>Fri, 18 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Patrik Christen</dc:creator>
    </item>
  </channel>
</rss>
