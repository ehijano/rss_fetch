<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Jul 2025 01:27:23 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>An Adequate While-Language for Stochastic Hybrid Computation</title>
      <link>https://arxiv.org/abs/2507.15913</link>
      <description>arXiv:2507.15913v1 Announce Type: new 
Abstract: We introduce a language for formally reasoning about programs that combine differential constructs with probabilistic ones. The language harbours, for example, such systems as adaptive cruise controllers, continuous-time random walks, and physical processes involving multiple collisions, like in Einstein's Brownian motion.
  We furnish the language with an operational semantics and use it to implement a corresponding interpreter. We also present a complementary, denotational semantics and establish an adequacy theorem between both cases.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15913v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Renato Neves, Jos\'e Proen\c{c}a, Juliana Souza</dc:creator>
    </item>
    <item>
      <title>On Expansions of Monadic Second-Order Logic with Dynamical Predicates</title>
      <link>https://arxiv.org/abs/2507.16581</link>
      <description>arXiv:2507.16581v1 Announce Type: new 
Abstract: Expansions of the monadic second-order (MSO) theory of the structure $\langle \mathbb{N} ; &lt; \rangle$ have been a fertile and active area of research ever since the publication of the seminal papers of B\"uchi and Elgot &amp; Rabin on the subject in the 1960s. In the present paper, we establish decidability of the MSO theory of $\langle \mathbb{N} ; &lt;,P \rangle$, where $P$ ranges over a large class of unary ''dynamical'' predicates, i.e., sets of non-negative values assumed by certain integer linear recurrence sequences. One of our key technical tools is the novel concept of (effective) prodisjunctivity, which we expect may also find independent applications further afield.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.16581v1</guid>
      <category>cs.LO</category>
      <category>math.NT</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Joris Nieuwveld, Jo\"el Ouaknine</dc:creator>
    </item>
    <item>
      <title>Transordinal Fixed-Point Operators and Self-Referential Games: A Categorical Framework for Reflective Semantic Convergence</title>
      <link>https://arxiv.org/abs/2507.16620</link>
      <description>arXiv:2507.16620v1 Announce Type: new 
Abstract: We present a new theoretical framework that unifies category-theoretic fixed-point constructions, transfinite recursion, and game-based semantics to model how interpretations of language can stabilize through unlimited self-reference. By iterating a meaning-refinement operator across all ordinal stages, we isolate a unique "transordinal" fixed point and show, via a hierarchy of reflective games, that this same object is the sole equilibrium of an infinite dialogue between a text and its interpreter. The result delivers a mathematically rigorous account of semantic convergence without resorting to statistical training or empirical benchmarks, yet remains simple to explain: start with a rough meaning, let speaker and listener correct each other forever, and the process provably settles on a single, self-consistent interpretation. Because the construction is entirely symbolic, it offers both precise guarantees for formal linguistics and a blueprint for designing language-aware systems that can reason about their own outputs. The paper details the requisite transordinal machinery, proves existence and uniqueness theorems, and connects them to long-standing questions about reflection, truth, and equilibrium in formal systems and semantics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.16620v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Faruk Alpay, Hamdi Al Alakkad</dc:creator>
    </item>
    <item>
      <title>A Unifying Framework for Semiring-Based Constraint Logic Programming With Negation (full version)</title>
      <link>https://arxiv.org/abs/2507.16067</link>
      <description>arXiv:2507.16067v1 Announce Type: cross 
Abstract: Constraint Logic Programming (CLP) is a logic programming formalism used to solve problems requiring the consideration of constraints, like resource allocation and automated planning and scheduling. It has previously been extended in various directions, for example to support fuzzy constraint satisfaction, uncertainty, or negation, with different notions of semiring being used as a unifying abstraction for these generalizations. None of these extensions have studied clauses with negation allowed in the body. We investigate an extension of CLP which unifies many of these extensions and allows negation in the body. We provide semantics for such programs, using the framework of approximation fixpoint theory, and give a detailed overview of the impacts of properties of the semirings on the resulting semantics. As such, we provide a unifying framework that captures existing approaches and allows extending them with a more expressive language.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.16067v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jeroen Spaans, Jesse Heyninck</dc:creator>
    </item>
    <item>
      <title>Improving ASP-based ORS Schedules through Machine Learning Predictions</title>
      <link>https://arxiv.org/abs/2507.16454</link>
      <description>arXiv:2507.16454v1 Announce Type: cross 
Abstract: The Operating Room Scheduling (ORS) problem deals with the optimization of daily operating room surgery schedules. It is a challenging problem subject to many constraints, like to determine the starting time of different surgeries and allocating the required resources, including the availability of beds in different department units. Recently, solutions to this problem based on Answer Set Programming (ASP) have been delivered. Such solutions are overall satisfying but, when applied to real data, they can currently only verify whether the encoding aligns with the actual data and, at most, suggest alternative schedules that could have been computed. As a consequence, it is not currently possible to generate provisional schedules. Furthermore, the resulting schedules are not always robust.
  In this paper, we integrate inductive and deductive techniques for solving these issues. We first employ machine learning algorithms to predict the surgery duration, from historical data, to compute provisional schedules. Then, we consider the confidence of such predictions as an additional input to our problem and update the encoding correspondingly in order to compute more robust schedules. Results on historical data from the ASL1 Liguria in Italy confirm the viability of our integration.
  Under consideration in Theory and Practice of Logic Programming (TPLP).</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.16454v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pierangela Bruno, Carmine Dodaro, Giuseppe Galat\`a, Marco Maratea, Marco Mochi</dc:creator>
    </item>
    <item>
      <title>Applications of Quantified Constraint Solving over the Reals -- Bibliography</title>
      <link>https://arxiv.org/abs/1205.5571</link>
      <description>arXiv:1205.5571v2 Announce Type: replace 
Abstract: Quantified constraints over the reals appear in numerous contexts. Usually existential quantification occurs when some parameter can be chosen by the user of a system, and univeral quantification when the exact value of a parameter is either unknown, or when it occurs in infinitely many, similar versions. The following is a list of application areas and publications that contain applications for solving quantified constraints over the reals. The list is certainly not complete, but grows as the author encounters new items. Contributions are very welcome!</description>
      <guid isPermaLink="false">oai:arXiv.org:1205.5571v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Stefan Ratschan</dc:creator>
    </item>
    <item>
      <title>Timeout Asynchronous Session Types: Safe Asynchronous Mixed-Choice For Timed Interactions</title>
      <link>https://arxiv.org/abs/2401.11197</link>
      <description>arXiv:2401.11197v5 Announce Type: replace 
Abstract: Mixed-choice has long been barred from models of asynchronous communication since it compromises the decidability of key properties of communicating finite-state machines. Session types inherit this restriction, which precludes them from fully modelling timeouts -- a core property of web and cloud services. To address this deficiency, we present (binary) Timeout Asynchronous Session Types (TOAST) as an extension to (binary) asynchronous timed session types, that permits mixed-choice. TOAST deploys timing constraints to regulate the use of mixed-choice so as to preserve communication safety. We provide a new behavioural semantics for TOAST which guarantees progress in the presence of mixed-choice. Building upon TOAST, we provide a calculus featuring process timers which is capable of modelling timeouts using a receive-after pattern, much like Erlang, and capture the correspondence with TOAST specifications via a type system for which we prove subject reduction.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.11197v5</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jonah Pears, Laura Bocchi, Maurizio Murgia, Andy King</dc:creator>
    </item>
    <item>
      <title>Interpretation of Inaccessible Sets in Martin-L\"{o}f Type Theory with One Mahlo Universe</title>
      <link>https://arxiv.org/abs/2402.15074</link>
      <description>arXiv:2402.15074v3 Announce Type: replace 
Abstract: Rathjen proved that Aczel's constructive set theory $\mathbf{CZF}$ extended with inaccessible sets of all transfinite orders can be interpreted in Martin-L\"{o}f type theory $\mathbf{MLTT}$ extended with Setzer's Mahlo universe and another universe above it. In this paper we show that this interpretation can be carried out bottom-up without the universe above the Mahlo universe, provided we add an accessibility predicate instead. If we work in Martin-L\"{o}f type theory with extensional identity types the accessibility predicate can be defined in terms of $\mathrm{W}$-types. The main part of our interpretation has been formalised in the proof assistant Agda.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.15074v3</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yuta Takahashi</dc:creator>
    </item>
    <item>
      <title>The Church Synthesis Problem over Continuous Time</title>
      <link>https://arxiv.org/abs/2404.04782</link>
      <description>arXiv:2404.04782v4 Announce Type: replace 
Abstract: The Church Problem asks for the construction of a procedure which, given a logical specification A(I,O) between input omega-strings I and output omega-strings O, determines whether there exists an operator F that implements the specification in the sense that A(I, F(I)) holds for all inputs I. Buchi and Landweber provided a procedure to solve the Church problem for MSO specifications and operators computable by finite-state automata. We investigate a generalization of the Church synthesis problem to the continuous time domain of the non-negative reals.
  We show that in the continuous time domain there are phenomena which are very different from the canonical discrete time domain of the natural numbers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04782v4</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander Rabinovich, Daniel Fattal</dc:creator>
    </item>
    <item>
      <title>Recursive windows for grammar logics of bounded density</title>
      <link>https://arxiv.org/abs/2507.14956</link>
      <description>arXiv:2507.14956v2 Announce Type: replace 
Abstract: We introduce the family of multi-modal logics of bounded density and with a tableau-like approach using finite \emph{windows} which were introduced in \cite{BalGasq25} and that we generalize to recursive windows. We prove that their satisfiability problem is {\bfseries PSPACE}-complete. As a side effect, the monomodal logic of density is shown to be in para-{\bfseries PSPACE}.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.14956v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Olivier Gasquet</dc:creator>
    </item>
    <item>
      <title>A SHACL-based Data Consistency Solution for Contract Compliance Verification</title>
      <link>https://arxiv.org/abs/2507.15420</link>
      <description>arXiv:2507.15420v2 Announce Type: replace 
Abstract: In recent years, there have been many developments for GDPR-compliant data access and sharing based on consent. For more complex data sharing scenarios, where consent might not be sufficient, many parties rely on contracts. Before a contract is signed, it must undergo the process of contract negotiation within the contract lifecycle, which consists of negotiating the obligations associated with the contract. Contract compliance verification (CCV) provides a means to verify whether a contract is GDPR-compliant, i.e., adheres to legal obligations and there are no violations. The rise of knowledge graph (KG) adoption, enabling semantic interoperability using well-defined semantics, allows CCV to be applied on KGs. In the scenario of different participants negotiating obligations, there is a need for data consistency to ensure that CCV is done correctly. Recent work introduced the automated contracting tool (ACT), a KG-based and ODRL-employing tool for GDPR CCV, which was developed in the Horizon 2020 project smashHit (https://smashhit.eu). Although the tool reports violations with respect to obligations, it had limitations in verifying and ensuring compliance, as it did not use an interoperable semantic formalism, such as SHACL, and did not support users in resolving data inconsistencies. In this work, we propose a novel approach to overcome these limitations of ACT. We semi-automatically resolve CCV inconsistencies by providing repair strategies, which automatically propose (optimal) solutions to the user to re-establish data consistency and thereby support them in managing GDPR-compliant contract lifecycle data. We have implemented the approach, integrated it into ACT and tested its correctness and performance against basic CCV consistency requirements.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15420v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Robert David, Albin Ahmeti, Geni Bushati, Amar Tauqeer, Anna Fensel</dc:creator>
    </item>
    <item>
      <title>What does it take to certify a conversion checker?</title>
      <link>https://arxiv.org/abs/2502.15500</link>
      <description>arXiv:2502.15500v2 Announce Type: replace-cross 
Abstract: We report on a detailed exploration of the properties of conversion (definitional equality) in dependent type theory, with the goal of certifying decision procedures for it. While in that context the property of normalisation has attracted the most light, we instead emphasize the importance of injectivity properties, showing that they alone are both crucial and sufficient to certify most desirable properties of conversion checkers. We also explore the certification of a fully untyped conversion checker, with respect to a typed specification, and show that the story is mostly unchanged, although the exact injectivity properties needed are subtly different.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.15500v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.FSCD.2025.27</arxiv:DOI>
      <dc:creator>Meven Lennon-Bertrand</dc:creator>
    </item>
    <item>
      <title>Bialgebraic Reasoning on Stateful Languages</title>
      <link>https://arxiv.org/abs/2503.10955</link>
      <description>arXiv:2503.10955v2 Announce Type: replace-cross 
Abstract: Reasoning about program equivalence in imperative languages is notoriously challenging, as the presence of states (in the form of variable stores) fundamentally increases the observational power of program terms. The key desideratum for any notion of equivalence is compositionality, guaranteeing that subprograms can be safely replaced by equivalent subprograms regardless of the context. To facilitate compositionality proofs and avoid boilerplate work, one would hope to employ the abstract bialgebraic methods provided by Turi and Plotkin's powerful theory of mathematical operational semantics (a.k.a. abstract GSOS) or its recent extension by Goncharov et al. to higher-order languages. However, multiple attempts to apply abstract GSOS to stateful languages have thus failed. We propose a novel approach to the operational semantics of stateful languages based on the formal distinction between readers (terms that expect an initial input store before being executed), and writers (running terms that have already been provided with a store). In contrast to earlier work, this style of semantics is fully compatible with abstract GSOS, and we can thus leverage the existing theory to obtain coinductive reasoning techniques. We demonstrate that our approach generates non-trivial compositionality results for stateful languages with first-order and higher-order store and that it flexibly applies to program equivalences at different levels of granularity, such as trace, cost, and natural equivalence.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.10955v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 23 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1145/3747513</arxiv:DOI>
      <dc:creator>Sergey Goncharov, Stefan Milius, Lutz Schr\"oder, Stelios Tsampas, Henning Urbat</dc:creator>
    </item>
  </channel>
</rss>
