<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Mar 2025 02:08:47 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 18 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Omega-Regular Robustness</title>
      <link>https://arxiv.org/abs/2503.12631</link>
      <description>arXiv:2503.12631v1 Announce Type: new 
Abstract: Roughly speaking, a system is said to be robust if it can resist disturbances and still function correctly. For instance, if the requirement is that the temperature remains in an allowed range $[l,h]$, then a system that remains in a range $[l',h']\subset[l,h]$ is more robust than one that reaches $l$ and $h$ from time to time. In this example the initial specification is quantitative in nature, this is not the case in $\omega$-regular properties. Still, it seems there is a natural robustness preference relation induced by an $\omega$-regular property. E.g. for a property requiring that every request is eventually granted, one would say that a system where requests are granted two ticks after they are issued is more robust than one in which requests are answered ninety ticks after they are issued. In this work we manage to distill a robustness preference relation that is induced by a given $\omega$-regular language. The relation is a semantic notion (agnostic to the given representation of $L$) that satisfies some natural criteria.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.12631v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 18 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dana Fisman, Elina Sudit</dc:creator>
    </item>
    <item>
      <title>Automata Size Reduction by Procedure Finding</title>
      <link>https://arxiv.org/abs/2410.20227</link>
      <description>arXiv:2410.20227v2 Announce Type: replace 
Abstract: We introduce a novel paradigm for reducing the size of finite automata by compressing repeating sub-graphs. These repeating sub-graphs can be viewed as invocations of a single procedure. Instead of representing each invocation explicitly, they can be replaced by a single procedure that uses a small runtime memory to remember the call context. We elaborate on the technical details of a basic implementation of this idea, where the memory used by the procedures is a simple finite-state register. We propose methods for identifying repetitive sub-graphs, collapsing them into procedures, and measuring the resulting reduction in automata size. Already this basic implementation of reduction by procedure finding yields practically relevant results, particularly in the context of FPGA-accelerated pattern matching, where automata size is a primary bottleneck. We achieve a size reduction of up to 70\% in automata that had already been minimized using existing advanced methods.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.20227v2</guid>
      <category>cs.FL</category>
      <category>cs.NI</category>
      <pubDate>Tue, 18 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Michal \v{S}ed\'y, Luk\'a\v{s} Hol\'ik</dc:creator>
    </item>
    <item>
      <title>Complete Test Suites for Automata in Monoidal Closed Categories</title>
      <link>https://arxiv.org/abs/2411.13412</link>
      <description>arXiv:2411.13412v3 Announce Type: replace 
Abstract: Conformance testing of automata is about checking the equivalence of a known specification and a black-box implementation. An important notion in conformance testing is that of a complete test suite, which guarantees that if an implementation satisfying certain conditions passes all tests, then it is equivalent to the specification.
  We introduce a framework for proving completeness of test suites at the general level of automata in monoidal closed categories. Moreover, we provide a generalization of a classical conformance testing technique, the W-method. We demonstrate the applicability of our results by recovering the W-method for deterministic finite automata, Moore machines, and Mealy machines, and by deriving new instances of complete test suites for weighted automata and deterministic nominal automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.13412v3</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 18 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>B\'alint Kocsis, Jurriaan Rot</dc:creator>
    </item>
    <item>
      <title>iCPS-DL: A Description Language for Autonomic Industrial Cyber-Physical Systems</title>
      <link>https://arxiv.org/abs/2408.17133</link>
      <description>arXiv:2408.17133v2 Announce Type: replace-cross 
Abstract: Modern industrial systems require frequent updates to their cyber and physical infrastructures, often demanding considerable reconfiguration effort. This paper introduces the industrial Cyber-Physical Systems Description Language, iCPS-DL, which enables autonomic reconfigurations for industrial Cyber-Physical Systems. The iCPS-DL maps an industrial process using semantics for physical and cyber-physical components, a state estimation model, and agent interactions. A novel aspect is using communication semantics to ensure live interaction among distributed agents. Reasoning on the semantic description facilitates the configuration of the industrial process control loop. A Water Distribution Networks domain case study demonstrates iCPS-DL's application.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.17133v2</guid>
      <category>eess.SY</category>
      <category>cs.FL</category>
      <category>cs.SY</category>
      <pubDate>Tue, 18 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dimitrios Kouzapas, Christos G. Panayiotou, Demetrios G. Eliades</dc:creator>
    </item>
    <item>
      <title>Unlocking State-Tracking in Linear RNNs Through Negative Eigenvalues</title>
      <link>https://arxiv.org/abs/2411.12537</link>
      <description>arXiv:2411.12537v5 Announce Type: replace-cross 
Abstract: Linear Recurrent Neural Networks (LRNNs) such as Mamba, RWKV, GLA, mLSTM, and DeltaNet have emerged as efficient alternatives to Transformers for long sequences. However, both Transformers and LRNNs struggle to perform state-tracking, which may impair performance in tasks such as code evaluation. In one forward pass, current architectures are unable to solve even parity, the simplest state-tracking task, which non-linear RNNs can handle effectively. Recently, Sarrof et al. (2024) demonstrated that the failure of LRNNs like Mamba to solve parity stems from restricting the value range of their diagonal state-transition matrices to $[0, 1]$ and that incorporating negative values can resolve this issue. We extend this result to non-diagonal LRNNs such as DeltaNet. We prove that finite precision LRNNs with state-transition matrices having only positive eigenvalues cannot solve parity, while non-triangular matrices are needed to count modulo $3$. Notably, we also prove that LRNNs can learn any regular language when their state-transition matrices are products of identity minus vector outer product matrices, each with eigenvalues in the range $[-1, 1]$. Our experiments confirm that extending the eigenvalue range of Mamba and DeltaNet to include negative values not only enables them to solve parity but consistently improves their performance on state-tracking tasks. We also show that state-tracking enabled LRNNs can be pretrained stably and efficiently at scale (1.3B parameters), achieving competitive performance on language modeling and showing promise on code and math tasks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.12537v5</guid>
      <category>cs.LG</category>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <pubDate>Tue, 18 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Riccardo Grazzi, Julien Siems, Arber Zela, J\"org K. H. Franke, Frank Hutter, Massimiliano Pontil</dc:creator>
    </item>
  </channel>
</rss>
