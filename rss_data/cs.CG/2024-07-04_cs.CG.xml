<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CG updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CG</link>
    <description>cs.CG updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CG" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jul 2024 04:01:12 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 04 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Efficient Exact Algorithms for Minimum Covering of Orthogonal Polygons with Squares</title>
      <link>https://arxiv.org/abs/2407.02658</link>
      <description>arXiv:2407.02658v1 Announce Type: new 
Abstract: The Orthogonal Polygon Covering with Squares (OPCS) problem takes as input an orthogonal polygon $P$ without holes with $n$ vertices, where vertices have integral coordinates. The aim is to find a minimum number of axis-parallel, possibly overlapping squares which lie completely inside $P$, such that their union covers the entire region inside $P$. Aupperle et. al~\cite{aupperle1988covering} provide an $\mathcal O(N^{1.5})$-time algorithm to solve OPCS for orthogonal polygons without holes, where $N$ is the number of integral lattice points lying in the interior or on the boundary of $P$. Designing algorithms for OPCS with a running time polynomial in $n$ (the number of vertices of $P$) was discussed as an open question in \cite{aupperle1988covering}, since $N$ can be exponentially larger than $n$. In this paper we design a polynomial-time exact algorithm for OPCS with a running time of $\mathcal O(n^{14})$.
  We also consider the following structural parameterized version of the problem. A knob in an orthogonal polygon is a polygon edge whose both endpoints are convex polygon vertices. Given an input orthogonal polygon with $n$ vertices and $k$ knobs, we design an algorithm for OPCS with running time $\mathcal O(n^2 + k^{14} \cdot n)$.
  In \cite{aupperle1988covering}, the Orthogonal Polygon with Holes Covering with Squares (OPCSH) problem is also studied where orthogonal polygon could have holes, and the objective is to find a minimum square covering of the input polygon. This is shown to be NP-complete. We think there is an error in the existing proof in \cite{aupperle1988covering}, where a reduction from Planar 3-CNF is shown. We fix this error in the proof with an alternate construction of one of the gadgets used in the reduction, hence completing the proof of NP-completeness of OPCSH.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.02658v1</guid>
      <category>cs.CG</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Anubhav Dhar, Subham Ghosh, Sudeshna Kolay</dc:creator>
    </item>
    <item>
      <title>The Fr\'echet Distance Unleashed: Approximating a Dog with a Frog</title>
      <link>https://arxiv.org/abs/2407.03101</link>
      <description>arXiv:2407.03101v1 Announce Type: new 
Abstract: We show that a minor variant of the continuous Fr\'echet distance between polygonal curves can be computed using essentially the same algorithm used to solve the discrete version, thus dramatically simplifying the algorithm for computing it. The new variant is not necessarily monotone, but this shortcoming can be easily handled via refinement.
  Combined with a Dijkstra/Prim type algorithm, this leads to a realization of the Fr\'echet distance (i.e., a morphing) that is locally optimal (aka locally correct), that is both easy to compute, and in practice, takes near linear time on many inputs. The new morphing has the property that the leash is always as short-as-possible.
  We implemented the new algorithm, and developed various strategies to get a fast execution in practice. Among our new contributions is a new simplification strategy that is distance-sensitive, and enables us to compute the exact continuous Fr\'echet distance in near linear time in practice. We preformed extensive experiments on our new algorithm, and released \texttt{Julia} and \texttt{Python} packages with these new implementations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.03101v1</guid>
      <category>cs.CG</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sariel Har-Peled, Benjamin Raichel, Eliot W. Robson</dc:creator>
    </item>
    <item>
      <title>An Improved Algorithm for Shortest Paths in Weighted Unit-Disk Graphs</title>
      <link>https://arxiv.org/abs/2407.03176</link>
      <description>arXiv:2407.03176v1 Announce Type: new 
Abstract: Let $V$ be a set of $n$ points in the plane. The unit-disk graph $G = (V, E)$ has vertex set $V$ and an edge $e_{uv} \in E$ between vertices $u, v \in V$ if the Euclidean distance between $u$ and $v$ is at most 1. The weight of each edge $e_{uv}$ is the Euclidean distance between $u$ and $v$. Given $V$ and a source point $s\in V$, we consider the problem of computing shortest paths in $G$ from $s$ to all other vertices. The previously best algorithm for this problem runs in $O(n \log^2 n)$ time [Wang and Xue, SoCG'19]. The problem has an $\Omega(n\log n)$ lower bound under the algebraic decision tree model. In this paper, we present an improved algorithm of $O(n \log^2 n / \log \log n)$ time (under the standard real RAM model). Furthermore, we show that the problem can be solved using $O(n\log n)$ comparisons under the algebraic decision tree model, matching the $\Omega(n\log n)$ lower bound.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.03176v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Bruce W. Brewer, Haitao Wang</dc:creator>
    </item>
    <item>
      <title>Online Geometric Covering and Piercing</title>
      <link>https://arxiv.org/abs/2305.02445</link>
      <description>arXiv:2305.02445v2 Announce Type: replace 
Abstract: We consider the online version of the piercing set problem, where geometric objects arrive one by one, and the online algorithm must maintain a valid piercing set for the already arrived objects by making irrevocable decisions. It is easy to observe that any deterministic algorithm solving this problem for intervals in $\mathbb{R}$ has a competitive ratio of at least $\Omega(n)$. This paper considers the piercing set problem for similarly sized objects. We propose a deterministic online algorithm for similarly sized fat objects in $\mathbb{R}^d$. For homothetic hypercubes in $\mathbb{R}^d$ with side length in the range $[1,k]$, we propose a deterministic algorithm having a competitive ratio of at most~$3^d\lceil\log_2 k\rceil+2^d$. In the end, we show deterministic lower bounds of the competitive ratio for similarly sized $\alpha$-fat objects in $\mathbb{R}^2$ and homothetic hypercubes in $\mathbb{R}^d$. Note that piercing translated copies of a convex object is equivalent to the unit covering problem, which is well-studied in the online setup. Surprisingly, no upper bound of the competitive ratio was known for the unit covering problem when the corresponding object is anything other than a ball or a hypercube. Our result yields an upper bound of the competitive ratio for the unit covering problem when the corresponding object is any convex object in $\mathbb{R}^d$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.02445v2</guid>
      <category>cs.CG</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/s00453-024-01244-1</arxiv:DOI>
      <dc:creator>Minati De, Saksham Jain, Sarat Varma Kallepalli, Satyam Singh</dc:creator>
    </item>
    <item>
      <title>Online Class Cover Problem</title>
      <link>https://arxiv.org/abs/2308.07020</link>
      <description>arXiv:2308.07020v2 Announce Type: replace 
Abstract: In this paper, we study the online class cover problem where a (finite or infinite) family $\cal F$ of geometric objects and a set ${\cal P}_r$ of red points in $\mathbb{R}^d$ are given a prior, and blue points from $\mathbb{R}^d$ arrives one after another. Upon the arrival of a blue point, the online algorithm must make an irreversible decision to cover it with objects from $\cal F$ that do not cover any points of ${\cal P}_r$. The objective of the problem is to place a minimum number of objects. When $\cal F$ consists of axis-parallel unit squares in $\mathbb{R}^2$, we prove that the competitive ratio of any deterministic online algorithm is $\Omega(\log |{\cal P}_r|)$, and also propose an $O(\log |{\cal P}_r|)$-competitive deterministic algorithm for the problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.07020v2</guid>
      <category>cs.CG</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1016/j.comgeo.2024.102120</arxiv:DOI>
      <dc:creator>Minati De, Anil Maheshwari, Ratnadip Mandal</dc:creator>
    </item>
    <item>
      <title>TriMe++: Multi-threaded triangular meshing in two dimensions</title>
      <link>https://arxiv.org/abs/2309.13824</link>
      <description>arXiv:2309.13824v2 Announce Type: replace 
Abstract: We present TriMe++, a multi-threaded software library designed for generating two-dimensional meshes for intricate geometric shapes using the Delaunay triangulation. Multi-threaded parallel computing is implemented throughout the meshing procedure, making it suitable for fast generation of large-scale meshes. Three iterative meshing algorithms are implemented: the DistMesh algorithm, the centroidal Voronoi diagram meshing, and a hybrid of the two. We compare the performance of the three meshing methods in TriMe++, and show that the hybrid method retains the advantages of the other two. The software library achieves significant parallel speedup when generating a large mesh with $10^6$ points. TriMe++ can handle complicated geometries and generates adaptive meshes of high quality.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.13824v2</guid>
      <category>cs.CG</category>
      <category>cs.DC</category>
      <category>cs.NA</category>
      <category>math.NA</category>
      <category>physics.app-ph</category>
      <category>physics.comp-ph</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jiayin Lu, Chris H. Rycroft</dc:creator>
    </item>
  </channel>
</rss>
