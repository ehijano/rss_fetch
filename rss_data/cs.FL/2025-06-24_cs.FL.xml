<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 24 Jun 2025 04:02:39 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 24 Jun 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Automata on $S$-adic words</title>
      <link>https://arxiv.org/abs/2506.17460</link>
      <description>arXiv:2506.17460v1 Announce Type: new 
Abstract: A fundamental question in logic and verification is the following: for which unary predicates $P_1, \ldots, P_k$ is the monadic second-order theory of $\langle \mathbb{N}; &lt;, P_1, \ldots, P_k \rangle$ decidable? Equivalently, for which infinite words $\alpha$ can we decide whether a given B\"uchi automaton $A$ accepts $\alpha$? Carton and Thomas showed decidability in case $\alpha$ is a fixed point of a letter-to-word substitution $\sigma$, i.e., $\sigma(\alpha) = \alpha$. However, abundantly more words, e.g., Sturmian words, are characterised by a broader notion of self-similarity that uses a set $S$ of substitutions. A word $\alpha$ is said to be directed by a sequence $s = (\sigma_n)_{n \in \mathbb{N}}$ over $S$ if there is a sequence of words $(\alpha_n)_{n \in \mathbb{N}}$ such that $\alpha_0 = \alpha$ and $\alpha_n = \sigma_n(\alpha_{n+1})$ for all $n$; such $\alpha$ is called $S$-adic. We study the automaton acceptance problem for such words and prove, among others, the following. Given finite $S$ and an automaton $A$, we can compute an automaton $B$ that accepts $s \in S^\omega$ if and only if $s$ directs a word $\alpha$ accepted by $A$. Thus we can algorithmically answer questions of the form "Which $S$-adic words are accepted by a given automaton $A$?"</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.17460v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Val\'erie Berth\'e, Toghrul Karimov, Mihir Vahanwala</dc:creator>
    </item>
    <item>
      <title>Tutorial: $\varphi$-Transductions in OpenFst via the Gallic Semiring</title>
      <link>https://arxiv.org/abs/2506.17942</link>
      <description>arXiv:2506.17942v1 Announce Type: new 
Abstract: OpenFst, a popular finite-state transducer library, supports $\varphi$-transitions but, due to an implementation constraint, they cannot be used with transducers in a straightforward way.
  In this short tutorial, we describe how one can use other functionality provided by OpenFst (namely, the Gallic semiring) to correctly implement $\varphi$-transductions and demonstrate it by implementing the MaxMatch (WordPiece) tokenization algorithm (Devlin et al., 2019; Song et al., 2021). Accompanying self-contained code examples are provided. https://www.openfst.org/twiki/pub/Contrib/FstContrib/phi_transduction_tutorial_code.tgz</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.17942v1</guid>
      <category>cs.FL</category>
      <category>cs.CL</category>
      <pubDate>Tue, 24 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marco Cognetta, Cyril Allauzen</dc:creator>
    </item>
    <item>
      <title>Jump Complexity of Deterministic Finite Automata with Translucent Letters</title>
      <link>https://arxiv.org/abs/2506.18393</link>
      <description>arXiv:2506.18393v1 Announce Type: new 
Abstract: We investigate a dynamical complexity measure defined for finite automata with translucent letters (FAwtl). Roughly, this measure counts the minimal number of necessary jumps for such an automaton in order to accept an input. The model considered here is the deterministic finite automaton with translucent letters (DFAwtl). Unlike in the case of the nondeterministic variant, the function describing the jump complexity of any DFAwtl is either bounded by a constant or it is linear. We give a polynomial-time algorithm for deciding whether the jump complexity of a DFAwtl is constant-bounded or linear and we prove that the equivalence problem for DFAwtl of $\bigo(1)$ jump complexity is decidable. We also consider another fundamental problem for extensions of finite automata models, deciding whether the language accepted by a FAwtl is regular. We give a positive partial answer for DFAwtl over the binary alphabet, in contrast with the case of NFAwtl, where the problem is undecidable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.18393v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 24 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-031-77019-7_4</arxiv:DOI>
      <dc:creator>Szil\'ard Zsolt Fazekas, Victor Mitrana, Andrei P\u{a}un, Mihaela P\u{a}un</dc:creator>
    </item>
    <item>
      <title>Regular Model Checking for Systems with Effectively Regular Reachability Relation</title>
      <link>https://arxiv.org/abs/2506.18833</link>
      <description>arXiv:2506.18833v1 Announce Type: new 
Abstract: Regular model checking is a well-established technique for the verification of regular transition systems (RTS): transition systems whose initial configurations and transition relation can be effectively encoded as regular languages. In 2008, To and Libkin studied RTSs in which the reachability relation (the reflexive and transitive closure of the transition relation) is also effectively regular, and showed that the recurrent reachability problem (whether a regular set $L$ of configurations is reached infinitely often) is polynomial in the size of RTS and the transducer for the reachability relation. We extend the work of To and Libkin by studying the decidability and complexity of verifying almost-sure reachability and recurrent reachability -- that is, whether $L$ is reachable or recurrently reachable w.p. 1. We then apply our results to the more common case in which only a regular overapproximation of the reachability relation is available. In particular, we extend recent complexity results on verifying safety using regular abstraction frameworks -- a technique recently introduced by Czerner, the authors, and Welzel-Mohr -- to liveness and almost-sure properties.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.18833v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Tue, 24 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Javier Esparza, Valentin Krasotin</dc:creator>
    </item>
    <item>
      <title>$L^*LM$: Learning Automata from Examples using Natural Language Oracles</title>
      <link>https://arxiv.org/abs/2402.07051</link>
      <description>arXiv:2402.07051v2 Announce Type: replace-cross 
Abstract: Expert demonstrations have proven an easy way to indirectly specify complex tasks. Recent algorithms even support extracting unambiguous formal specifications, e.g. deterministic finite automata (DFA), from demonstrations. Unfortunately, these techniques are generally not sample efficient. In this work, we introduce $L^*LM$, an algorithm for learning DFAs from both demonstrations and natural language. Due to the expressivity of natural language, we observe a significant improvement in the data efficiency of learning DFAs from expert demonstrations. Technically, $L^*LM$ leverages large language models to answer membership queries about the underlying task. This is then combined with recent techniques for transforming learning from demonstrations into a sequence of labeled example learning problems. In our experiments, we observe the two modalities complement each other, yielding a powerful few-shot learner.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.07051v2</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <pubDate>Tue, 24 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Marcell Vazquez-Chanlatte, Karim Elmaaroufi, Stefan J. Witwicki, Matei Zaharia, Sanjit A. Seshia</dc:creator>
    </item>
  </channel>
</rss>
