<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 Jan 2025 02:33:14 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 09 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Transparent Decompilation for Timing Side-Channel Analyses</title>
      <link>https://arxiv.org/abs/2501.04183</link>
      <description>arXiv:2501.04183v1 Announce Type: new 
Abstract: This paper considers the problem of analyzing the timing side-channel security of binary programs through decompilation and source-level analysis. We focus on two popular policies, namely constant-time and speculative constant-time, (S)CT for short, used to protect cryptographic libraries.
  First, we observe that popular decompilers remove (S)CT violations, i.e., transform non-(S)CT programs into (S)CT programs; it follows that analyzing decompiled programs is not sound. Second, we develop techniques to prove that decompilers are transparent, i.e., neither introduce nor remove (S)CT violations. Third, we apply our techniques to \refleCT{}, a core but non-trivial decompiler. As a contribution of independent interest, we find that constant-time verification tools may not be sound, due to their use of preprocessors (e.g.\, binary lifters or IR converters) that eliminate CT violations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.04183v1</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 09 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Santiago Arranz Olmos, Gilles Barthe, Lionel Blatter, S\"oren van der Wall, Zhiyuan Zhang</dc:creator>
    </item>
    <item>
      <title>Developing a Modular Compiler for a Subset of a C-like Language</title>
      <link>https://arxiv.org/abs/2501.04503</link>
      <description>arXiv:2501.04503v1 Announce Type: new 
Abstract: The paper introduces the development of a modular compiler for a subset of a C-like language, which addresses the challenges in constructing a compiler for high-level languages. This modular approach will allow developers to modify a language by adding or removing subsets as required, resulting in a minimal and memory-efficient compiler. The development process is divided into small, incremental steps, where each step yields a fully functioning compiler for an expanding subset of the language. The paper outlines the iterative developmental phase of the compiler, emphasizing progressive enhancements in capabilities and functionality. Adherence to industry best practices of modular design, code reusability, and documentation has enabled the resulting compiler's functional efficiency, maintainability, and extensibility. The compiler proved to be effective not only in managing the language structure but also in developing optimized code, which demonstrates its practical usability. This was also further assessed using the compiler on a tiny memory-deficient single-board computer, again showing the compiler's efficiency and suitability for resource-constrained devices.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.04503v1</guid>
      <category>cs.PL</category>
      <category>cs.CL</category>
      <category>cs.DC</category>
      <category>cs.PF</category>
      <pubDate>Thu, 09 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Debasish Dutta, Neeharika Sonowal, Irani Hazarika</dc:creator>
    </item>
    <item>
      <title>Publish on Ping: A Better Way to Publish Reservations in Memory Reclamation for Concurrent Data Structures</title>
      <link>https://arxiv.org/abs/2501.04250</link>
      <description>arXiv:2501.04250v1 Announce Type: cross 
Abstract: Safe memory reclamation techniques that utilize per read reservations, such as hazard pointers, often cause significant overhead in traversals of linked concurrent data structures. This is primarily due to the need to announce a reservation, and fence to enforce appropriate ordering, before each read. In read-intensive workloads, this overhead is amplified because, even if relatively little memory reclamation actually occurs, the full overhead of reserving records is still incurred while traversing data structures.
  In this paper, we propose a novel memory reclamation technique by combining POSIX signals and delayed reclamation, introducing a publish-on-ping approach. This method eliminates the need to make reservations globally visible before use. Instead, threads privately track which records they are accessing, and share this information on demand with threads that intend to reclaim memory. The approach can serve as a drop-in replacement for hazard pointers and hazard eras. Furthermore, the capability to retain reservations during traversals in data structure operations and publish them on demand facilitates the construction of a variant of hazard pointers (EpochPOP). This variant uses epochs to approach the performance of epoch-based reclamation in the common case where threads are not frequently delayed (while retaining the robustness of hazard pointers).
  Our publish-on-ping implementations based on hazard pointers (HP) and hazard eras, when applied to various data structures, exhibit significant performance improvements. The improvements across various workloads and data structures range from 1.2X to 4X over the original HP, up to 20% compared to a heavily optimized HP implementation similar to the one in the Folly open-source library, and up to 3X faster than hazard eras. EpochPOP delivers performance similar to epoch-based reclamation while providing stronger guarantees.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.04250v1</guid>
      <category>cs.DC</category>
      <category>cs.PL</category>
      <pubDate>Thu, 09 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Ajay Singh, Trevor Brown</dc:creator>
    </item>
  </channel>
</rss>
