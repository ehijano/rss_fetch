<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Sep 2025 04:01:01 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Structural Separation and Semantic Incompatibility in the P vs. NP Problem: Computational Complexity Analysis with Construction Defining Functionality</title>
      <link>https://arxiv.org/abs/2509.22995</link>
      <description>arXiv:2509.22995v1 Announce Type: new 
Abstract: The Boolean satisfiability problem (SAT) holds a central place in computational complexity theory as the first shown NP-complete problem. Due to this role, SAT is often used as the benchmark for polynomial-time reductions: if a problem can be reduced to SAT, it is at least as hard as SAT, and hence considered NP-complete. However, the CDF framework offers a structural inversion of this traditional view. Rather than treating SAT as merely a representative of NP-completeness, we investigate whether the syntactic structure of SAT itself -- especially in its 3SAT form -- is the source of semantic explosion and computational intractability observed in NP problems. In other words, SAT is not just the yardstick of NP-completeness, but may be the structural archetype that induces NP-type complexity. This reframing suggests that the P vs NP question is deeply rooted not only in computational resource limits, but in the generative principles of problem syntax, with 3SAT capturing the recursive and non-local constructions that define the boundary between tractable and intractable problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.22995v1</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yumiko Nishiyama</dc:creator>
    </item>
    <item>
      <title>Proceedings Twentieth International Symposium on Logical and Semantic Frameworks with Applications</title>
      <link>https://arxiv.org/abs/2509.23739</link>
      <description>arXiv:2509.23739v1 Announce Type: new 
Abstract: This volume contains the proceedings of the 20th Workshop on Logical and Semantic Frameworks with Applications (LSFA 2025), which was held in Brasilia, the capital of Brazil, from October 7 to October 8, 2025.
  The aim of the LSFA series of workshops is bringing together theoreticians and practitioners to promote new techniques and results, from the theoretical side, and feedback on the implementation and use of such techniques and results, from the practical side. LSFA includes areas such as proof and type theory, equational deduction and rewriting systems, automated reasoning and concurrency theory.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.23739v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.430</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 430, 2025</arxiv:journal_reference>
      <dc:creator>Haniel Barbosa, Christophe Ringeissen</dc:creator>
    </item>
    <item>
      <title>The Complexity of Defining and Separating Fixpoint Formulae in Modal Logic</title>
      <link>https://arxiv.org/abs/2509.24583</link>
      <description>arXiv:2509.24583v1 Announce Type: new 
Abstract: Modal separability for modal fixpoint formulae is the problem to decide for two given modal fixpoint formulae $\varphi,\varphi'$ whether there is a modal formula $\psi$ that separates them, in the sense that $\varphi\models\psi$ and $\psi\models\neg\varphi'$. We study modal separability and its special case modal definability over various classes of models, such as arbitrary models, finite models, trees, and models of bounded outdegree. Our main results are that modal separability is PSpace-complete over words, that is, models of outdegree $\leq 1$, ExpTime-complete over unrestricted and over binary models, and TwoExpTime-complete over models of outdegree bounded by some $d\geq 3$. Interestingly, this latter case behaves fundamentally different from the other cases also in that modal logic does not enjoy the Craig interpolation property over this class. Motivated by this we study also the induced interpolant existence problem as a special case of modal separability, and show that it is coNExpTime-complete and thus harder than validity in the logic. Besides deciding separability, we also provide algorithms for the effective construction of separators. Finally, we consider in a case study the extension of modal fixpoint formulae by graded modalities and investigate separability by modal formulae and graded modal formulae.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.24583v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jean Christoph Jung, J\k{e}drzej Ko{\l}odziejski</dc:creator>
    </item>
    <item>
      <title>Generalization of Variadic Structures with Binders: A Tool for Structural Code Comparison</title>
      <link>https://arxiv.org/abs/2509.25023</link>
      <description>arXiv:2509.25023v1 Announce Type: new 
Abstract: This paper introduces a novel anti-unification algorithm for the generalization of variadic structures with binders, designed as a flexible tool for structural code comparison. By combining nominal techniques for handling variable binding with support for variadic expressions (common in abstract syntax trees and programming languages), the approach addresses key challenges such as overemphasis on bound variable names and difficulty handling insertions or deletions in code fragments. The algorithm distinguishes between atoms and two kinds of variables (term and hedge variables) to compute best generalizations that maximally preserve structural similarities while abstracting systematic differences. It also provides detailed information to reconstruct original expressions and quantify structural differences. This information can be useful in tasks like code clone detection, refactoring, and program analysis. By introducing a parametrizable rigidity function, the technique offers fine-grained control over similarity criteria and reduces nondeterminism, enabling flexible adaptation to practical scenarios where trivial similarities should be discounted. Although demonstrated primarily in the context of code similarity detection, this framework is broadly applicable wherever precise comparison of variadic and binder-rich representations is required.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.25023v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander Baumgartner, Temur Kutsia</dc:creator>
    </item>
    <item>
      <title>Guard Analysis and Safe Erasure Gradual Typing: a Type System for Elixir</title>
      <link>https://arxiv.org/abs/2408.14345</link>
      <description>arXiv:2408.14345v3 Announce Type: cross 
Abstract: We formalize a new type system for Elixir, a dynamically typed functional programming language of growing popularity that runs on the Erlang virtual machine. Our system combines gradual typing with semantic subtyping to enable precise, sound, and practical static type analysis, without requiring any changes to Elixir's compilation pipeline or runtime. Type soundness is ensured by leveraging runtime checks -- both implicit, from the Erlang VM, and explicit, via developer-written guards.
  Central to our approach are two key innovations: the notion of "strong functions", which can be assigned precise types even when applied to inputs that may fall outside their intended domain; and a fine-grained analysis of guards that enables accurate type refinement for case expressions and guarded function definitions. While type information is erased before execution and not used by the compiler, our "safe erasure" gradual typing strategy maintains soundness and expressiveness without compromising compatibility or performance. This work lays the theoretical foundation for Elixir's new type system, outlines its integration into recent versions of the language, and demonstrates its effectiveness on large-scale industrial codebases.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.14345v3</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Giuseppe Castagna, Guillaume Duboc</dc:creator>
    </item>
    <item>
      <title>The Role of Logic and Automata in Understanding Transformers</title>
      <link>https://arxiv.org/abs/2509.24024</link>
      <description>arXiv:2509.24024v1 Announce Type: cross 
Abstract: The advent of transformers has in recent years led to powerful and revolutionary Large Language Models (LLMs). Despite this, our understanding on the capability of transformers is still meager. In this invited contribution, we recount the rapid progress in the last few years to the question of what transformers can do. In particular, we will see the integral role of logic and automata (also with some help from circuit complexity) in answering this question. We also mention several open problems at the intersection of logic, automata, verification and transformers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.24024v1</guid>
      <category>cs.FL</category>
      <category>cs.CL</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anthony W. Lin, Pablo Barcelo</dc:creator>
    </item>
    <item>
      <title>Overcoming Over-Fitting in Constraint Acquisition via Query-Driven Interactive Refinement</title>
      <link>https://arxiv.org/abs/2509.24489</link>
      <description>arXiv:2509.24489v1 Announce Type: cross 
Abstract: Manual modeling in Constraint Programming is a substantial bottleneck, which Constraint Acquisition (CA) aims to automate. However, passive CA methods are prone to over-fitting, often learning models that include spurious global constraints when trained on limited data, while purely active methods can be query-intensive. We introduce a hybrid CA framework specifically designed to address the challenge of over-fitting in CA. Our approach integrates passive learning for initial candidate generation, a query-driven interactive refinement phase that utilizes probabilistic confidence scores (initialized by machine learning priors) to systematically identify over-fitted constraints, and a specialized subset exploration mechanism to recover valid substructures from rejected candidates. A final active learning phase ensures model completeness. Extensive experiments on diverse benchmarks demonstrate that our interactive refinement phase is crucial for achieving high target model coverage and overall model accuracy from limited examples, doing so with manageable query complexity. This framework represents a substantial advancement towards robust and practical constraint acquisition in data-limited scenarios.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.24489v1</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vasileios Balafas, Dimos Tsouros, Nikolaos Ploskas, Kostas Stergiou</dc:creator>
    </item>
    <item>
      <title>LTL$_f$ Learning Meets Boolean Set Cover</title>
      <link>https://arxiv.org/abs/2509.24616</link>
      <description>arXiv:2509.24616v1 Announce Type: cross 
Abstract: Learning formulas in Linear Temporal Logic (LTLf) from finite traces is a fundamental research problem which has found applications in artificial intelligence, software engineering, programming languages, formal methods, control of cyber-physical systems, and robotics. We implement a new CPU tool called Bolt improving over the state of the art by learning formulas more than 100x faster over 70% of the benchmarks, with smaller or equal formulas in 98% of the cases. Our key insight is to leverage a problem called Boolean Set Cover as a subroutine to combine existing formulas using Boolean connectives. Thanks to the Boolean Set Cover component, our approach offers a novel trade-off between efficiency and formula size.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.24616v1</guid>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Gabriel Bathie, Nathana\"el Fijalkow, Th\'eo Matricon, Baptiste Mouillon, Pierre Vandenhove</dc:creator>
    </item>
    <item>
      <title>Canonical for Automated Theorem Proving in Lean</title>
      <link>https://arxiv.org/abs/2504.06239</link>
      <description>arXiv:2504.06239v2 Announce Type: replace 
Abstract: Canonical is a solver for type inhabitation in dependent type theory, that is, the problem of producing a term of a given type. We present a Lean tactic which invokes Canonical to generate proof terms and synthesize programs. The tactic supports higher-order and dependently-typed goals, structural recursion over indexed inductive types, and definitional equality. Canonical finds proofs for 84% of Natural Number Game problems in 51 seconds total.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.06239v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.ITP.2025.14</arxiv:DOI>
      <arxiv:journal_reference>LIPIcs 352 (2025) 14:1-14:20</arxiv:journal_reference>
      <dc:creator>Chase Norman, Jeremy Avigad</dc:creator>
    </item>
    <item>
      <title>A Formal Proof of Complexity Bounds on Diophantine Equations</title>
      <link>https://arxiv.org/abs/2505.16963</link>
      <description>arXiv:2505.16963v2 Announce Type: replace 
Abstract: We present a universal construction of Diophantine equations with bounded complexity in Isabelle/HOL. This is a formalization of our own work in number theory.
  Hilbert's Tenth Problem was answered negatively by Yuri Matiyasevich, who showed that there is no general algorithm to decide whether an arbitrary Diophantine equation has a solution. However, the problem remains open when generalized to the field of rational numbers, or contrarily, when restricted to Diophantine equations with bounded complexity, characterized by the number of variables $\nu$ and the degree $\delta$. If every Diophantine set can be represented within the bounds $(\nu, \delta)$, we say that this pair is universal, and it follows that the corresponding class of equations is undecidable. In a separate mathematics article, we have determined the first non-trivial universal pair for the case of integer unknowns.
  In this paper, we contribute a formal verification of the main construction required to establish said universal pair. In doing so, we markedly extend the Isabelle AFP entry on multivariate polynomials, formalize parts of a number theory textbook, and develop classical theory on Diophantine equations in Isabelle. Additionally, our work includes metaprogramming infrastructure designed to efficiently handle complex definitions of multivariate polynomials. Our mathematical draft has been formalized while the mathematical research was ongoing, and benefitted largely from the help of the theorem prover. We reflect how the close collaboration between mathematician and computer is an uncommon but promising modus operandi.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16963v2</guid>
      <category>cs.LO</category>
      <category>math.NT</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.ITP.2025.3</arxiv:DOI>
      <arxiv:journal_reference>In: 16th International Conference on Interactive Theorem Proving (ITP 2025). Leibniz International Proceedings in Informatics (LIPIcs), Vol. 352, pp. 3:1-3:18</arxiv:journal_reference>
      <dc:creator>Jonas Bayer, Marco David</dc:creator>
    </item>
    <item>
      <title>Modal Verification Patterns for Systems Software</title>
      <link>https://arxiv.org/abs/2506.01719</link>
      <description>arXiv:2506.01719v3 Announce Type: replace 
Abstract: Although they differ in the functionality they offer, low-level systems exhibit certain patterns of design and utilization of computing resources. In this paper, we argue the position that modalities, in the sense of modal logic, should be a go-to approach when specifying and verifying low-level systems code. We explain how the concept of a resource context helps guide the design of new modalities for verification of systems code, and we justify our perspective by discussing prior systems that have used modalities for systems verification successfully, arguing that they fit into the verification design pattern we articulate, and explaining how this approach might apply to other systems verification challenges.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.01719v3</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Ismail Kuru, Colin S. Gordon</dc:creator>
    </item>
    <item>
      <title>Ranking Functions for Linear-Constraint Loops</title>
      <link>https://arxiv.org/abs/1208.4041</link>
      <description>arXiv:1208.4041v4 Announce Type: replace-cross 
Abstract: In this paper we study the complexity of the problems: given a loop, described by linear constraints over a finite set of variables, is there a linear or lexicographical-linear ranking function for this loop? While existence of such functions implies termination, these problems are not equivalent to termination. When the variables range over the rationals (or reals), it is known that both problems are PTIME decidable. However, when they range over the integers, whether for single-path or multipath loops, the complexity has not yet been determined. We show that both problems are coNP-complete. However, we point out some special cases of importance of PTIME complexity. We also present complete algorithms for synthesizing linear and lexicographical-linear ranking functions, both for the general case and the special PTIME cases. Moreover, in the rational setting, our algorithm for synthesizing lexicographical-linear ranking functions extends existing ones, because our class of ranking functions is more general, yet it has polynomial time complexity.</description>
      <guid isPermaLink="false">oai:arXiv.org:1208.4041v4</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1145/2629488</arxiv:DOI>
      <arxiv:journal_reference>Amir M. Ben-Amram, Samir Genaim: Ranking Functions for Linear-Constraint Loops. J. ACM 61(4): 26:1-26:55 (2014)</arxiv:journal_reference>
      <dc:creator>Amir M. Ben-Amram, Samir Genaim</dc:creator>
    </item>
    <item>
      <title>Monitoring Timed Properties (Revisited)</title>
      <link>https://arxiv.org/abs/2206.14590</link>
      <description>arXiv:2206.14590v4 Announce Type: replace-cross 
Abstract: In this paper we study monitoring of real-time systems with respect to properties expressed either in Metric Interval Temporal Logic or as Timed B\"uchi Automata. We offer efficient symbolic online monitoring algorithms in a number of settings, exploiting so-called zones well-known from efficient model checking of Timed Automata. Our contributions include a new, much simplified treatment of time divergence and monitoring under timing uncertainty. The online monitoring procedure that handles time divergence, as well as uncertain timing, is implemented in the tool MoniTAal, and shown to effectively monitor properties over long traces.</description>
      <guid isPermaLink="false">oai:arXiv.org:2206.14590v4</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Thomas M{\o}ller Grosen, Sean Kauffman, Kim Guldstrand Larsen, Martin Zimmermann</dc:creator>
    </item>
    <item>
      <title>Improving NLSAT for Nonlinear Real Arithmetic</title>
      <link>https://arxiv.org/abs/2406.02122</link>
      <description>arXiv:2406.02122v4 Announce Type: replace-cross 
Abstract: The Model-Constructing Satisfiability Calculus (MCSAT) framework has been applied to SMT problems over various arithmetic theories. NLSAT, an implementation using cylindrical algebraic decomposition (CAD) for explanation, is especially competitive for nonlinear real arithmetic (NRA) constraints. However, current Conflict-Driven Clause Learning (CDCL)-style algorithms only consider literal information when making decisions, and thus ignore the influence of clauses on arithmetic variables. This limitation may lead NLSAT to encounter unnecessary conflicts due to suboptimal literal choices. To address this issue, we analyze conflicts caused by literal decisions and incorporate clause-level information that directly affects arithmetic variables. We propose two main algorithmic improvements: a clause-level feasible-set-based look-ahead mechanism and an arithmetic propagation-based branching heuristic. We implement our solver, named clauseSMT, based on a dynamic variable ordering framework. Experiments indicate that clauseSMT is competitive on nonlinear real arithmetic problems compared with existing SMT solvers (CVC5, Z3, YICES2), and it outperforms all of them on satisfiable instances of SMT(QF_NRA) in SMT-LIB. We also evaluate the effectiveness of our proposed methods.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.02122v4</guid>
      <category>cs.SC</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Zhonghan Wang</dc:creator>
    </item>
    <item>
      <title>Mixing Any Cocktail with Limited Ingredients: On the Structure of Payoff Sets in Multi-Objective POMDPs and its Impact on Randomised Strategies</title>
      <link>https://arxiv.org/abs/2502.18296</link>
      <description>arXiv:2502.18296v2 Announce Type: replace-cross 
Abstract: We consider multi-dimensional payoff functions in partially observable Markov decision processes. We study the structure of the set of expected payoff vectors of all strategies (policies) and study what kind are needed to achieve a given expected payoff vector. In general, pure strategies (i.e., not resorting to randomisation) do not suffice for this problem.
  We prove that for any payoff for which the expectation is well-defined under all strategies, it is sufficient to mix (i.e., randomly select a pure strategy at the start of a play and committing to it for the rest of the play) finitely many pure strategies to approximate any expected payoff vector up to any precision. Furthermore, for any payoff for which the expected payoff is finite under all strategies, any expected payoff can be obtained exactly by mixing finitely many strategies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.18296v2</guid>
      <category>cs.GT</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>math.PR</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>James C. A. Main, Mickael Randour</dc:creator>
    </item>
    <item>
      <title>Logic Gate Neural Networks are Good for Verification</title>
      <link>https://arxiv.org/abs/2505.19932</link>
      <description>arXiv:2505.19932v2 Announce Type: replace-cross 
Abstract: Learning-based systems are increasingly deployed across various domains, yet the complexity of traditional neural networks poses significant challenges for formal verification. Unlike conventional neural networks, learned Logic Gate Networks (LGNs) replace multiplications with Boolean logic gates, yielding a sparse, netlist-like architecture that is inherently more amenable to symbolic verification, while still delivering promising performance. In this paper, we introduce a SAT encoding for verifying global robustness and fairness in LGNs. We evaluate our method on five benchmark datasets, including a newly constructed 5-class variant, and find that LGNs are both verification-friendly and maintain strong predictive performance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.19932v2</guid>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <arxiv:journal_reference>Proceedings of the International Conference on Neuro-symbolic Systems, PMLR 288:90-103, 2025</arxiv:journal_reference>
      <dc:creator>Fabian Kresse, Emily Yu, Christoph H. Lampert, Thomas A. Henzinger</dc:creator>
    </item>
    <item>
      <title>Constrained Decoding for Robotics Foundation Models</title>
      <link>https://arxiv.org/abs/2509.01728</link>
      <description>arXiv:2509.01728v3 Announce Type: replace-cross 
Abstract: Recent advances in the development of robotic foundation models have led to promising end-to-end and general-purpose capabilities in robotic systems. Trained on vast datasets of simulated and real-world trajectories, these models map multimodal observations directly to action sequences for physical execution. Despite promising real-world capabilities, these models are still data-driven and, therefore, lack explicit notions of behavioral correctness. We address this gap by introducing SafeDec, a constrained decoding framework for autoregressive, robot foundation models that enforces invariant safety specifications on candidate action trajectories. Task-specific safety rules are expressed as Signal Temporal Logic (STL) formulas and are enforced at inference time with minimal overhead. Our method ensures that generated actions provably satisfy STL specifications under assumed dynamics at runtime without retraining , while remaining agnostic of the underlying policy. We evaluate SafeDec on tasks from the CHORES benchmark for state-of-the-art generalist policies (e.g., SPOC, Flare, PoliFormer) across hundreds of procedurally generated environments and show that our decoding-time interventions are useful not only for filtering unsafe actions but also for conditional action generation. Videos are available at constrained-robot-fms.github.io.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.01728v3</guid>
      <category>cs.RO</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Tue, 30 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Parv Kapoor, Akila Ganlath, Michael Clifford, Changliu Liu, Sebastian Scherer, Eunsuk Kang</dc:creator>
    </item>
  </channel>
</rss>
