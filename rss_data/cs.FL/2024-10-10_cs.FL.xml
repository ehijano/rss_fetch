<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 11 Oct 2024 02:24:20 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Maximal Length Cellular Automata : A Survey</title>
      <link>https://arxiv.org/abs/2410.05947</link>
      <description>arXiv:2410.05947v1 Announce Type: new 
Abstract: This article surveys some theoretical aspects of Cellular Automata (CAs) research. In particular, we discuss on maximal length CA. An n-cell CA is a maximal length CA, if all the configurations except one form a single cycle. There is a bonding between maximal length CA and primitive polynomial. So, primitive polynomials occupy a good amount of space in this survey. The main goal of this survey is to provide a tutorial on maximal length CA theory to researchers with classical and new results on maximality. We also give a compact collection of known results with references to their proofs, and to suggest some open problems. Additionally, some new theorems and corollaries are added to bridge the gaps among several known results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.05947v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sumit Adak, Sukanta Das</dc:creator>
    </item>
    <item>
      <title>LR Parsing of Permutation Phrases</title>
      <link>https://arxiv.org/abs/2410.06769</link>
      <description>arXiv:2410.06769v1 Announce Type: new 
Abstract: This paper presents an efficient method for LR parsing of permutation phrases. In practical cases, the proposed algorithm constructs an LR(0) automaton that requires significantly fewer states to process a permutation phrase compared to the standard construction. For most real-world grammars, the number of states is typically reduced from $\Omega(n!)$ to $O(2^{n})$, resulting in a much more compact parsing table. The state reduction increases with longer permutation phrases and a higher number of permutation phrases within the right-hand side of a rule. We demonstrate the effectiveness of this method through its application to parsing a JSON document.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.06769v1</guid>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jana Kosti\v{c}ov\'a</dc:creator>
    </item>
    <item>
      <title>TuringQ: Benchmarking AI Comprehension in Theory of Computation</title>
      <link>https://arxiv.org/abs/2410.06547</link>
      <description>arXiv:2410.06547v1 Announce Type: cross 
Abstract: We present TuringQ, the first benchmark designed to evaluate the reasoning capabilities of large language models (LLMs) in the theory of computation. TuringQ consists of 4,006 undergraduate and graduate-level question-answer pairs, categorized into four difficulty levels and covering seven core theoretical areas. We evaluate several open-source LLMs, as well as GPT-4, using Chain of Thought prompting and expert human assessment. Additionally, we propose an automated LLM-based evaluation system that demonstrates competitive accuracy when compared to human evaluation. Fine-tuning a Llama3-8B model on TuringQ shows measurable improvements in reasoning ability and out-of-domain tasks such as algebra. TuringQ serves as both a benchmark and a resource for enhancing LLM performance in complex computational reasoning tasks. Our analysis offers insights into LLM capabilities and advances in AI comprehension of theoretical computer science.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.06547v1</guid>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pardis Sadat Zahraei, Ehsaneddin Asgari</dc:creator>
    </item>
    <item>
      <title>Stochastic Process Turing Machines</title>
      <link>https://arxiv.org/abs/2410.07131</link>
      <description>arXiv:2410.07131v1 Announce Type: cross 
Abstract: Computer science theory provides many different measures of complexity of a system including Kolmogorov complexity, logical depth, computational depth, and Levin complexity. However, these measures are all defined only for deterministic Turing machines, i.e., deterministic dynamics of the underlying generative process whose output we are interested in. Therefore, by construction they cannot capture complexity of the output of stochastic processes - like those in the real world. Motivated by this observation, we combine probabilistic Turing machines with a prior over the inputs to the Turing machine to define a complete stochastic process of Turing machines. We call this a stochastic process Turing machine. Stochastic process Turing machines allow us to formalize a stochastic generalization of logical depth called stochastic depth, and also to apply stochastic thermodynamics to the analysis of Turing machines. Stochastic process Turing machines and stochastic depth allow us to study the complex, stochastic systems like the human brain, societies, and evolution all from within the framework of formal computation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.07131v1</guid>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>David Wolpert, Jordan Scharnhorst</dc:creator>
    </item>
    <item>
      <title>Planning with Probabilistic Opacity and Transparency: A Computational Model of Opaque/Transparent Observations</title>
      <link>https://arxiv.org/abs/2405.05408</link>
      <description>arXiv:2405.05408v2 Announce Type: replace 
Abstract: Qualitative opacity of a secret is a security property, which means that a system trajectory satisfying the secret is observation-equivalent to a trajectory violating the secret. In this paper, we study how to synthesize a control policy that maximizes the probability of a secret being made opaque against an eavesdropping attacker/observer, while subject to other task performance constraints. In contrast to existing belief-based approach for opacity-enforcement, we develop an approach that uses the observation function, the secret, and the model of the dynamical systems to construct a so-called opaque-observations automaton which accepts the exact set of observations that enforce opacity. Leveraging this opaque-observations automaton, we can reduce the optimal planning in Markov decision processes(MDPs) for maximizing probabilistic opacity or its dual notion, transparency, subject to task constraints into a constrained planning problem over an augmented-state MDP. Finally, we illustrate the effectiveness of the developed methods in robot motion planning problems with opacity or transparency requirements.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.05408v2</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sumukha Udupa, Jie Fu</dc:creator>
    </item>
    <item>
      <title>Constant-delay enumeration for SLP-compressed documents</title>
      <link>https://arxiv.org/abs/2209.12301</link>
      <description>arXiv:2209.12301v3 Announce Type: replace-cross 
Abstract: We study the problem of enumerating results from a query over a compressed document. The model we use for compression are straight-line programs (SLPs), which are defined by a context-free grammar that produces a single string. For our queries, we use a model called Annotated Automata, an extension of regular automata that allows annotations on letters. This model extends the notion of Regular Spanners as it allows arbitrarily long outputs. Our main result is an algorithm that evaluates such a query by enumerating all results with output-linear delay after a preprocessing phase which takes linear time on the size of the SLP, and cubic time over the size of the automaton. This is an improvement over Schmid and Schweikardt's result, which, with the same preprocessing time, enumerates with a delay that is logarithmic on the size of the uncompressed document. We achieve this through a persistent data structure named Enumerable Compact Sets with Shifts which guarantees output-linear delay under certain restrictions. These results imply constant-delay enumeration algorithms in the context of regular spanners. Further, we use an extension of annotated automata which utilizes succinctly encoded annotations to save an exponential factor from previous results that dealt with constant-delay enumeration over vset automata. Lastly, we extend our results in the same fashion Schmid and Schweikardt did to allow complex document editing while maintaining the constant delay guarantee.</description>
      <guid isPermaLink="false">oai:arXiv.org:2209.12301v3</guid>
      <category>cs.DS</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Mart\'in Mu\~noz, Cristian Riveros</dc:creator>
    </item>
    <item>
      <title>Semantic Tree-Width and Path-Width of Conjunctive Regular Path Queries</title>
      <link>https://arxiv.org/abs/2212.01679</link>
      <description>arXiv:2212.01679v4 Announce Type: replace-cross 
Abstract: We show that the problem of whether a query is equivalent to a query of tree-width $k$ is decidable, for the class of Unions of Conjunctive Regular Path Queries with two-way navigation (UC2RPQs). A previous result by Barcel\'o, Romero, and Vardi [SIAM Journal on Computing, 2016] has shown decidability for the case $k=1$, and here we extend this result showing that decidability in fact holds for any arbitrary $k\geq 1$. The algorithm is in 2ExpSpace, but for the restricted but practically relevant case where all regular expressions of the query are of the form $a^*$ or $(a_1 + \dotsb + a_n)$ we show that the complexity of the problem drops to $\Pi^P_2$.
  We also investigate the related problem of approximating a UC2RPQ by queries of small tree-width. We exhibit an algorithm which, for any fixed number $k$, builds the maximal under-approximation of tree-width $k$ of a UC2RPQ. The maximal under-approximation of tree-width $k$ of a query $q$ is a query $q'$ of tree-width $k$ which is contained in $q$ in a maximal and unique way, that is, such that for every query $q"$ of tree-width $k$, if $q"$ is contained in $q$ then $q"$ is also contained in $q'$.
  Our approach is shown to be robust, in the sense that it allows also to test equivalence with queries of a given path-width, it also covers the previously known result for $k=1$, and it allows to test for equivalence of whether a (one-way) UCRPQ is equivalent to a UCRPQ of a given tree-width (or path-width).</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.01679v4</guid>
      <category>cs.LO</category>
      <category>cs.DB</category>
      <category>cs.FL</category>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Diego Figueira, R\'emi Morvan</dc:creator>
    </item>
  </channel>
</rss>
