<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Feb 2026 02:32:20 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Computer Science as Infrastructure: the Spine of the Lean Computer Science Library (CSLib)</title>
      <link>https://arxiv.org/abs/2602.15078</link>
      <description>arXiv:2602.15078v1 Announce Type: new 
Abstract: Following in the footsteps of the success of Mathlib - the centralised library of formalised mathematics in Lean - CSLib is a rapidly-growing centralised library of formalised computer science and software. In this paper, we present its founding technical principles, operation, abstractions, and semantic framework. We contribute reusable semantic interfaces (reduction and labelled transition systems), proof automation, CI/testing support for maintaining automation and compatibility with Mathlib, and the first substantial developments of languages and models.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.15078v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christopher Henson, Fabrizio Montesi</dc:creator>
    </item>
    <item>
      <title>Hennessy-Milner Logic in CSLib, the Lean Computer Science Library</title>
      <link>https://arxiv.org/abs/2602.15409</link>
      <description>arXiv:2602.15409v1 Announce Type: new 
Abstract: We present a library-level formalisation of Hennessy-Milner Logic (HML) - a foundational logic for labelled transition systems (LTSs) - for the Lean Computer Science Library (CSLib). Our development includes the syntax, satisfaction relation, and denotational semantics of HML, as well as a complete metatheory including the Hennessy-Milner theorem - bisimilarity coincides with theory equivalence for image-finite LTSs. Our development emphasises generality and reusability: it is parametric over arbitrary LTSs, definitions integrate with CSLib's infrastructure (such as the formalisation of bisimilarity), and proofs leverage Lean's automation (notably the grind tactic). All code is publicly available in CSLib and can be readily applied to systems that use its LTS API.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.15409v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Fabrizio Montesi, Marco Peressotti, Alexandre Rademaker</dc:creator>
    </item>
    <item>
      <title>Generating Theorems by Generating Proof Structures</title>
      <link>https://arxiv.org/abs/2602.15511</link>
      <description>arXiv:2602.15511v1 Announce Type: new 
Abstract: We address generating theorems from a given set of axioms, without proof goal, aiming at value from a mathematical point of view or as lemmas for automated proving. As benchmark, we convert a fragment of the Metamath database set.mm. Our techniques are centered on proof terms and condensed detachment, which ties in with approaches to automated first-order proving by proof structure enumeration, and links to Metamath as well as to formulas-as-types. Our methods for generating theorems are based on partitioning the set of proof terms into inductively characterized levels. We study two ideas for improvement: Lemma synthesis by DAG compression of proof term sets and incorporating combinators into proof term construction.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.15511v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christoph Wernhard</dc:creator>
    </item>
    <item>
      <title>Computation and Size of Interpolants for Hybrid Modal Logics</title>
      <link>https://arxiv.org/abs/2602.15821</link>
      <description>arXiv:2602.15821v1 Announce Type: new 
Abstract: Recent research has established complexity results for the problem of deciding the existence of interpolants in logics lacking the Craig Interpolation Property (CIP). The proof techniques developed so far are non-constructive, and no meaningful bounds on the size of interpolants are known. Hybrid modal logics (or modal logics with nominals) are a particularly interesting class of logics without CIP: in their case, CIP cannot be restored without sacrificing decidability and, in applications, interpolants in these logics can serve as definite descriptions and separators between positive and negative data examples in description logic knowledge bases. In this contribution we show, using a new hypermosaic elimination technique, that in many standard hybrid modal logics Craig interpolants can be computed in fourfold exponential time, if they exist. On the other hand, we show that the existence of uniform interpolants is undecidable, which is in stark contrast to modal or intuitionistic logic where uniform interpolants always exist.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.15821v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jean Christoph Jung, J\k{e}drzej Ko{\l}odziejski, Frank Wolter</dc:creator>
    </item>
    <item>
      <title>A Resolution-Based Interactive Proof System for UNSAT</title>
      <link>https://arxiv.org/abs/2401.14996</link>
      <description>arXiv:2401.14996v4 Announce Type: replace 
Abstract: Modern SAT or QBF solvers are expected to produce correctness certificates. However, certificates have worst-case exponential size (unless NP=coNP), and at recent SAT competitions the largest certificates of unsatisfiability are starting to reach terabyte size. This puts limits to the development of SAT-solving services in which a client with limited computational power sends a formula to a solver running on a powerful server, which returns a certificate to be checked by the client.
  Recently, Couillard et al. have suggested to replace certificates with interactive proof systems based on the IP=PSPACE theorem. They have presented an interactive protocol between a prover and a verifier for an extension of QBF. The overall running time of the protocol is linear in the time needed by a standard BDD-based algorithm, and the time invested by the verifier is polynomial in the size of the formula. (So, in particular, the verifier never has to read or process exponentially long certificates). We call such an interactive protocol competitive with the BDD algorithm for solving QBF.
  While BDD algorithms are state-of-the-art for certain classes of QBF instances, no modern (UN)SAT solver is based on BDDs. For this reason, we initiate the study of interactive certification for more practical SAT algorithms. In particular, we address the question whether interactive protocols can be competitive with some variant of resolution. We present two contributions. First, we prove a theorem that reduces the problem of finding competitive interactive protocols to finding an arithmetisation of formulas satisfying certain commutativity properties. (Arithmetisation is the fundamental technique underlying the IP=PSPACE theorem.) Then, we apply the theorem to give the first interactive protocol for the Davis-Putnam resolution procedure. We also report on an implementation and give some experimental results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.14996v4</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Philipp Czerner, Javier Esparza, Valentin Krasotin, Adrian Krauss</dc:creator>
    </item>
    <item>
      <title>Craig Interpolation for the Logic of Here and There with a Variation of Mints' Sequent System</title>
      <link>https://arxiv.org/abs/2601.04080</link>
      <description>arXiv:2601.04080v2 Announce Type: replace 
Abstract: We present a Maehara-style construction of Craig interpolants for the three-valued propositional logic of here and there (HT), also known as G\"odel's $G_3$. The method adapts a recent interpolation technique that operates on classically encoded logic programs to a variation of a sequent calculus for HT by Mints. The approach is characterized by two stages: First, a preliminary interpolant is constructed, a formula that is an interpolant in some sense, but not yet the desired HT formula. In the second stage, an actual HT interpolant is obtained from this preliminary interpolant. With the classical encoding, the preliminary interpolant is a classical Craig interpolant for classical encodings of the two input HT formulas. In the presented adaptation, the sequent system operates directly on HT formulas, and the preliminary interpolant is in a nonclassical logic that generalizes HT by an additional logic operator.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.04080v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christoph Wernhard</dc:creator>
    </item>
    <item>
      <title>Formalising the Bruhat-Tits Tree</title>
      <link>https://arxiv.org/abs/2505.12933</link>
      <description>arXiv:2505.12933v3 Announce Type: replace-cross 
Abstract: In this article we describe the formalisation of the Bruhat-Tits tree - an important tool in modern number theory - in the Lean Theorem Prover. Motivated by the goal of connecting to ongoing research, we apply our formalisation to verify a result about harmonic cochains on the tree.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.12933v3</guid>
      <category>math.NT</category>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Judith Ludwig, Christian Merten</dc:creator>
    </item>
    <item>
      <title>On the $\Sigma^0_1$-Completeness of Cubic Diophantine Systems and their Consequences for Equations</title>
      <link>https://arxiv.org/abs/2510.00759</link>
      <description>arXiv:2510.00759v5 Announce Type: replace-cross 
Abstract: We prove that $\mathrm{H}\mathbb{N}(3,n)=\mathrm{U}$ for some fixed $n$. The core result is a uniform primitive recursive compiler from sentence codes to finite cubic Diophantine systems over $\mathbb{N}$, such that arithmetic theoremhood is equivalent to cubic solvability on the compiler image. The translation is explicit: finite proof traces are arithmetized, local syntactic and inference checks are compiled to quadratic constraints, and one guard gadget $u = 1+v^2, u\cdot E = 0$ provides the unique degree escalation from $2$ to $3$ while preserving solvability. The construction is mechanized in $\textsf{Rocq}$ and certified in the Calculus of Inductive Constructions, including uniform computability, checker--constraint equivalence, and a global degree-$3$ bound for emitted systems. From this certified core, undecidability is obtained by a classical fixed-point Diagonal Argument: any total correct decider for cubic satisfiability computes a mirror cubic instance on which it fails. Consequently cubic satisfiability is $\Sigma^0_1$-complete, and in particular there is no total correct procedure deciding all degree-$3$ Diophantine instances.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.00759v5</guid>
      <category>math.LO</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Milan Rosko</dc:creator>
    </item>
    <item>
      <title>Comparative Expressivity for Structured Argumentation Frameworks with Uncertain Rules and Premises</title>
      <link>https://arxiv.org/abs/2510.18631</link>
      <description>arXiv:2510.18631v2 Announce Type: replace-cross 
Abstract: Modelling qualitative uncertainty in formal argumentation is essential both for practical applications and theoretical understanding. Yet, most of the existing works focus on \textit{abstract} models for arguing with uncertainty. Following a recent trend in the literature, we tackle the open question of studying plausible instantiations of these abstract models. To do so, we ground the uncertainty of arguments in their components, structured within rules and premises. Our main technical contributions are: i) the introduction of a notion of expressivity that can handle abstract and structured formalisms, and ii) the presentation of both negative and positive expressivity results, comparing the expressivity of abstract and structured models of argumentation with uncertainty. These results affect incomplete abstract argumentation frameworks, and their extension with dependencies, on the abstract side, and ASPIC+, on the structured side.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.18631v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Carlo Proietti, Antonio Yuste-Ginel</dc:creator>
    </item>
    <item>
      <title>A Formal Framework for the Explanation of Finite Automata Decisions</title>
      <link>https://arxiv.org/abs/2602.13351</link>
      <description>arXiv:2602.13351v2 Announce Type: replace-cross 
Abstract: Finite automata (FA) are a fundamental computational abstraction that is widely used in practice for various tasks in computer science, linguistics, biology, electrical engineering, and artificial intelligence. Given an input word, an FA maps the word to a result, in the simple case "accept" or "reject", but in general to one of a finite set of results. A question that then arises is: why? Another question is: how can we modify the input word so that it is no longer accepted? One may think that the automaton itself is an adequate explanation of its behaviour, but automata can be very complex and difficult to make sense of directly. In this work, we investigate how to explain the behaviour of an FA on an input word in terms of the word's characters. In particular, we are interested in minimal explanations: what is the minimal set of input characters that explains the result, and what are the minimal changes needed to alter the result? In this paper, we propose an efficient method to determine all minimal explanations for the behaviour of an FA on a particular word. This allows us to give unbiased explanations about which input features are responsible for the result. Experiments show that our approach scales well, even when the underlying problem is challenging.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.13351v2</guid>
      <category>cs.FL</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jaime Cuartas Granada, Alexey Ignatiev, Peter J. Stuckey</dc:creator>
    </item>
  </channel>
</rss>
