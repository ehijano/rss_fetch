<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Feb 2026 05:00:17 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Time-Optimal Construction of String Synchronizing Sets</title>
      <link>https://arxiv.org/abs/2602.11324</link>
      <description>arXiv:2602.11324v1 Announce Type: new 
Abstract: A key principle in string processing is local consistency: using short contexts to handle matching fragments of a string consistently. String synchronizing sets [Kempa, Kociumaka; STOC 2019] are an influential instantiation of this principle. A $\tau$-synchronizing set of a length-$n$ string is a set of $O(n/\tau)$ positions, chosen via their length-$2\tau$ contexts, such that (outside highly periodic regions) at least one position in every length-$\tau$ window is selected. Among their applications are faster algorithms for data compression, text indexing, and string similarity in the word RAM model.
  We show how to preprocess any string $T \in [0..\sigma)^n$ in $O(n\log\sigma/\log n)$ time so that, for any $\tau\in[1..n]$, a $\tau$-synchronizing set of $T$ can be constructed in $O((n\log\tau)/(\tau\log n))$ time. Both bounds are optimal in the word RAM model with word size $w=\Theta(\log n)$. Previously, the construction time was $O(n/\tau)$, either after an $O(n)$-time preprocessing [Kociumaka, Radoszewski, Rytter, Wale\'n; SICOMP 2024], or without preprocessing if $\tau&lt;0.2\log_\sigma n$ [Kempa, Kociumaka; STOC 2019].
  A simple version of our method outputs the set as a sorted list in $O(n/\tau)$ time, or as a bitmask in $O(n/\log n)$ time. Our optimal construction produces a compact fully indexable dictionary, supporting select queries in $O(1)$ time and rank queries in $O(\log(\tfrac{\log\tau}{\log\log n}))$ time, matching unconditional cell-probe lower bounds for $\tau\le n^{1-\Omega(1)}$.
  We achieve this via a new framework for processing sparse integer sequences in a custom variable-length encoding. For rank and select queries, we augment the optimal variant of van Emde Boas trees [P\u{a}tra\c{s}cu, Thorup; STOC 2006] with a deterministic linear-time construction. The above query-time guarantees hold after preprocessing time proportional to the encoding size (in words).</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11324v1</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jonas Ellert, Tomasz Kociumaka</dc:creator>
    </item>
    <item>
      <title>Preprocessed 3SUM for Unknown Universes with Subquadratic Space</title>
      <link>https://arxiv.org/abs/2602.11363</link>
      <description>arXiv:2602.11363v1 Announce Type: new 
Abstract: We consider the classic 3SUM problem: given sets of integers $A, B, C $, determine whether there is a tuple $(a, b, c) \in A \times B \times C$ satisfying $a + b + c = 0$. The 3SUM Hypothesis, central in fine-grained complexity, states that there does not exist a truly subquadratic time 3SUM algorithm. Given this long-standing barrier, recent work over the past decade has explored 3SUM from a data structural perspective. Specifically, in the 3SUM in preprocessed universes regime, we are tasked with preprocessing sets $A, B$ of size $n$, to create a space-efficient data structure that can quickly answer queries, each of which is a 3SUM problem of the form $A', B', C'$, where $A' \subseteq A$ and $B' \subseteq B$. A series of results have achieved $\tilde{O}(n^2)$ preprocessing time, $\tilde{O}(n^2)$ space, and query time improving progressively from $\tilde{O}(n^{1.9})$ [CL15] to $\tilde{O}(n^{11/6})$ [CVX23] to $\tilde{O}(n^{1.5})$ [KPS25]. Given these series of works improving query time, a natural open question has emerged: can one achieve both truly subquadratic space and truly subquadratic query time for 3SUM in preprocessed universes?
  We resolve this question affirmatively, presenting a tradeoff curve between query and space complexity. Specifically, we present a simple randomized algorithm achieving $\tilde{O}(n^{1.5 + \varepsilon})$ query time and $\tilde{O}(n^{2 - 2\varepsilon/3})$ space complexity. Furthermore, our algorithm has $\tilde{O}(n^2)$ preprocessing time, matching past work. Notably, quadratic preprocessing is likely necessary for our tradeoff as either the preprocessing or the query time must be at least $n^{2-o(1)}$ under the 3SUM Hypothesis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11363v1</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yael Kirkpatrick, John Kuszmaul, Surya Mathialagan, Virginia Vassilevska Williams</dc:creator>
    </item>
    <item>
      <title>Adaptive Power Iteration Method for Differentially Private PCA</title>
      <link>https://arxiv.org/abs/2602.11454</link>
      <description>arXiv:2602.11454v1 Announce Type: new 
Abstract: We study $(\epsilon,\delta)$-differentially private algorithms for the problem of approximately computing the top singular vector of a matrix $A\in\mathbb{R}^{n\times d}$ where each row of $A$ is a datapoint in $\mathbb{R}^{d}$. In our privacy model, neighboring inputs differ by one single row/datapoint. We study the private variant of the power iteration method, which is widely adopted in practice. Our algorithm is based on a filtering technique which adapts to the coherence parameter of the input matrix. This technique provides a utility that goes beyond the worst-case guarantees for matrices with low coherence parameter. Our work departs from and complements the work by Hardt-Roth (STOC 2013) which designed a private power iteration method for the privacy model where neighboring inputs differ in one single entry by at most 1.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11454v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ta Duy Nguyem, Alina Ene, Huy Le Nguyen</dc:creator>
    </item>
    <item>
      <title>Gray Codes With Constant Delay and Constant Auxiliary Space</title>
      <link>https://arxiv.org/abs/2602.11791</link>
      <description>arXiv:2602.11791v1 Announce Type: new 
Abstract: We give the first two algorithms to enumerate all binary words of $\{0,1\}^\ell$ (like Gray codes) while ensuring that the delay and the auxiliary space is independent from $\ell$, i.e., constant time for each word, and constant memory in addition to the $\ell$ bits storing the current word. Our algorithms are given in two new computational models: tape machines and deque machines. We also study more restricted models, queue machines and stack machines, and show that they cannot enumerate all binary words with constant auxiliary space, even with unrestricted delay.
  A tape machine is a Turing machine that stores the current binary word on a single working tape of length $\ell$. The machine has a single head and must edit its tape to reach all possible words of $\{0,1\}^{\ell}$ , and output them (in unit time, by entering special output states), with no duplicates. We construct a tape machine that achieves this task with constant delay between consecutive outputs, which implies that the machine implements a so-called skew-tolerant quasi-Gray code. We then construct a more involved tape machine that implements a Gray code.
  A deque machine stores the current binary word on a double-ended queue of length $\ell$, and stores a constant-size internal state. It works as a tape machine, except that it modifies the content of the deque by performing push and pop operations on the endpoints. We construct deque machines that enumerate all words of $\{0,1\}^\ell$ with constant-delay. The main technical challenge in this model is to correctly detect when enumeration has finished.
  Our work on deque machine is also motivated by other contexts in which endpoint modifications occur naturally. In particular, our result is a first step towards enumerating walks in directed graphs with constant delay and constant auxiliary space, addressing a core task in modern graph database query processing.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11791v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antoine Amarilli, Claire David, Nadime Francis, Victor Marsault, Mika\"el Monet, Yann Strozecki</dc:creator>
    </item>
    <item>
      <title>Combinatorial Perpetual Scheduling</title>
      <link>https://arxiv.org/abs/2602.11826</link>
      <description>arXiv:2602.11826v1 Announce Type: new 
Abstract: This paper introduces a framework for combinatorial variants of perpetual-scheduling problems. Given a set system $(E,\mathcal{I})$, a schedule consists of an independent set $I_t \in \mathcal{I}$ for every time step $t \in \mathbb{N}$, with the objective of fulfilling frequency requirements on the occurrence of elements in $E$. We focus specifically on combinatorial bamboo garden trimming, where elements accumulate height at growth rates $g(e)$ for $e \in E$ given as a convex combination of incidence vectors of $\mathcal{I}$ and are reset to zero when scheduled, with the goal of minimizing the maximum height attained by any element.
  Using the integrality of the matroid-intersection polytope, we prove that, when $(E,\mathcal{I})$ is a matroid, it is possible to guarantee a maximum height of at most 2, which is optimal. We complement this existential result with efficient algorithms for specific matroid classes, achieving a maximum height of 2 for uniform and partition matroids, and 4 for graphic and laminar matroids. In contrast, we show that for general set systems, the optimal guaranteed height is $\Theta(\log |E|)$ and can be achieved by an efficient algorithm. For combinatorial pinwheel scheduling, where each element $e\in E$ needs to occur in the schedule at least every $a_e \in \mathbb{N}$ time steps, our results imply bounds on the density sufficient for schedulability.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11826v1</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mirabel Mendoza-Cadena, Arturo Merino, Mads Anker Nielsen, Kevin Schewior</dc:creator>
    </item>
    <item>
      <title>History-Independent Load Balancing</title>
      <link>https://arxiv.org/abs/2602.11953</link>
      <description>arXiv:2602.11953v1 Announce Type: new 
Abstract: We give a (strongly) history-independent two-choice balls-and-bins algorithm on $n$ bins that supports both insertions and deletions on a set of up to $m$ balls, while guaranteeing a maximum load of $m / n + O(1)$ with high probability, and achieving an expected recourse of $O(\log \log (m/n))$ per operation. To the best of our knowledge, this is the first history-independent solution to achieve nontrivial guarantees of any sort for $m/n \ge \omega(1)$ and is the first fully dynamic solution (history independent or not) to achieve $O(1)$ overload with $o(m/n)$ expected recourse.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11953v1</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Michael A. Bender, William Kuszmaul, Elaine Shi, Rose Silver</dc:creator>
    </item>
    <item>
      <title>Optimizing Distances for Multi-Broadcast in Temporal Graphs</title>
      <link>https://arxiv.org/abs/2602.12126</link>
      <description>arXiv:2602.12126v1 Announce Type: new 
Abstract: Temporal graphs represent networks in which connections change over time, with edges available only at specific moments. Motivated by applications in logistics, multi-agent information spreading, and wireless networks, we introduce the D-Temporal Multi-Broadcast (D-TMB) problem, which asks for scheduling the availability of edges so that a predetermined subset of sources reach all other vertices while optimizing the worst-case temporal distance D from any source. We show that D-TMB generalizes ReachFast (arXiv:2112.08797). We then characterize the computational complexity and approximability of D-TMB under six definitions of temporal distance D, namely Earliest-Arrival (EA), Latest-Departure (LD), Fastest-Time (FT), Shortest-Traveling (ST), Minimum-Hop (MH), and Minimum-Waiting (MW). For a single source, we show that D-TMB can be solved in polynomial time for EA and LD, while for the other temporal distances it is NP-hard and hard to approximate within a factor that depends on the adopted distance function. We give approximation algorithms for FT and MW. For multiple sources, if feasibility is not assumed a priori, the problem is inapproximable within any factor unless P = NP, even with just two sources. We complement this negative result by identifying structural conditions that guarantee tractability for EA and LD for any number of sources.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.12126v1</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniele Carnevale, Gianlorenzo D'Angelo</dc:creator>
    </item>
    <item>
      <title>Improved Online Algorithms for Inventory Management Problems with Holding and Delay Costs: Riding the Wave Makes Things Simpler, Stronger, &amp; More General</title>
      <link>https://arxiv.org/abs/2602.12175</link>
      <description>arXiv:2602.12175v1 Announce Type: new 
Abstract: The Joint Replenishment Problem (JRP) is a classical inventory management problem, that aims to model the trade-off between coordinating orders for multiple commodities (and their cost) with holding costs incurred by meeting demand in advance. Moseley, Niaparast and Ravi introduced a natural online generalization of the JRP in which inventory corresponding to demands may be replenished late, for a delay cost, or early, for a holding cost. They established that when the holding and delay costs are monotone and uniform across demands, there is a 30-competitive algorithm that employs a greedy strategy and a dual-fitting based analysis.
  We develop a 5-competitive algorithm that handles arbitrary monotone demand-specific holding and delay cost functions, thus simultaneously improving upon the competitive ratio and relaxing the uniformity assumption. Our primal-dual algorithm is in the spirit of the work Buchbinder, Kimbrel, Levi, Makarychev, and Sviridenko, which maintains a wavefront dual solution to decide when to place an order and which items to order. The main twist is in deciding which requests to serve early. In contrast to the work of Moseley et al., which ranks early requests in ascending order of desired service time and serves them until their total holding cost matches the ordering cost incurred for that item, we extend to the non-uniform case by instead ranking in ascending order of when the delay cost of a demand would reach its current holding cost. An important special case of the JRP is the single-item lot-sizing problem. Here, Moseley et al. gave a 3-competitive algorithm when the holding and delay costs are uniform across demands. We provide a new algorithm for which the competitive ratio is $\phi +1 \approx 2.681$, where $\phi$ is the golden ratio, which again holds for arbitrary monotone holding-delay costs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.12175v1</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>David Shmoys, Varun Suriyanarayana, Seeun William Umboh</dc:creator>
    </item>
    <item>
      <title>Self-referential instances of the dominating set problem are irreducible</title>
      <link>https://arxiv.org/abs/2602.10559</link>
      <description>arXiv:2602.10559v1 Announce Type: cross 
Abstract: We study the algorithmic decidability of the domination number in the Erdos-Renyi random graph model $G(n,p)$. We show that for a carefully chosen edge probability $p=p(n)$, the domination problem exhibits a strong irreducible property. Specifically, for any constant $0&lt;c&lt;1$, no algorithm that inspects only an induced subgraph of order at most $n^c$ can determine whether $G(n,p)$ contains a dominating set of size $k=\ln n$. We demonstrate that the existence of such a dominating set can be flipped by a local symmetry mapping that alters only a constant number of edges, thereby producing indistinguishable random graph instances which require exhaustive search. These results demonstrate that the extreme hardness of the dominating set problem in random graphs cannot be attributed to local structure, but instead arises from the self-referential nature and near-independence structure of the entire solution space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.10559v1</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guangyan Zhou</dc:creator>
    </item>
    <item>
      <title>An Improved Upper Bound for the Euclidean TSP Constant Using Band Crossovers</title>
      <link>https://arxiv.org/abs/2602.11250</link>
      <description>arXiv:2602.11250v1 Announce Type: cross 
Abstract: Consider $n$ points generated uniformly at random in the unit square, and let $L_n$ be the length of their optimal traveling salesman tour. Beardwood, Halton, and Hammersley (1959) showed $L_n / \sqrt n \to \beta$ almost surely as $n\to \infty$ for some constant $\beta$. The exact value of $\beta$ is unknown but estimated to be approximately $0.71$ (Applegate, Bixby, Chv\'atal, Cook 2011). Beardwood et al. further showed that $0.625 \leq \beta \leq 0.92116.$ Currently, the best known bounds are $0.6277 \leq \beta \leq 0.90380$, due to Gaudio and Jaillet (2019) and Carlsson and Yu (2023), respectively. The upper bound was derived using a computer-aided approach that is amenable to lower bounds with improved computation speed. In this paper, we show via simulation and concentration analysis that future improvement of the $0.90380$ is limited to $\sim0.88$. Moreover, we provide an alternative tour-constructing heuristic that, via simulation, could potentially improve the upper bound to $\sim0.85$. Our approach builds on a prior \emph{band-traversal} strategy, initially proposed by Beardwood et al. (1959) and subsequently refined by Carlsson and Yu (2023): divide the unit square into bands of height $\Theta(1/\sqrt{n})$, construct paths within each band, and then connect the paths to create a TSP tour. Our approach allows paths to cross bands, and takes advantage of pairs of points in adjacent bands which are close to each other. A rigorous numerical analysis improves the upper bound to $0.90367$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11250v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <category>math.PR</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Julia Gaudio, Charlie K. Guan</dc:creator>
    </item>
    <item>
      <title>When agents choose bundles autonomously: guarantees beyond discrepancy</title>
      <link>https://arxiv.org/abs/2602.11330</link>
      <description>arXiv:2602.11330v1 Announce Type: cross 
Abstract: We consider the fair division of indivisible items among $n$ agents with additive non-negative normalized valuations, with the goal of obtaining high value guarantees, that is, close to the proportional share for each agent.
  We prove that partitions where \emph{every} part yields high value for each agent are asymptotically limited by a discrepancy barrier of $\Theta(\sqrt{n})$. Guided by this, our main objective is to overcome this barrier and achieve stronger individual guarantees for each agent in polynomial time.
  Towards this, we are able to exhibit an exponential improvement over the discrepancy barrier. In particular, we can create partitions on-the-go such that when agents arrive sequentially (representing a previously-agreed priority order) and pick a part autonomously and rationally (i.e., one of highest value), then each is guaranteed a part of value at least $\mathsf{PROP} - \mathcal{O}{(\log n)}$. Moreover, we show even better guarantees for three restricted valuation classes such as those defined by: a common ordering on items, a bound on the multiplicity of values, and a hypergraph with a bound on the \emph{influence} of any agent. Specifically, we study instances where: (1) the agents are ``close'' to unanimity in their relative valuation of the items -- a generalization of the ordered additive setting; (2) the valuation functions do not assign the same positive value to more than $t$ items; and (3) the valuation functions respect a hypergraph, a setting introduced by Christodoulou et al. [EC'23], where agents are vertices and items are hyperedges. While the sizes of the hyperedges and neighborhoods can be arbitrary, the influence of any agent $a$, defined as the number of its neighbors who value at least one item positively that $a$ also values positively, is bounded.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11330v1</guid>
      <category>cs.GT</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sushmita Gupta, Pallavi Jain, Sanjay Seetharaman, Meirav Zehavi</dc:creator>
    </item>
    <item>
      <title>Markovian protocols and an upper bound on the extension complexity of the matching polytope</title>
      <link>https://arxiv.org/abs/2602.11382</link>
      <description>arXiv:2602.11382v1 Announce Type: cross 
Abstract: This paper investigates the extension complexity of polytopes by exploiting the correspondence between non-negative factorizations of slack matrices and randomized communication protocols. We introduce a geometric characterization of extension complexity based on the width of Markovian protocols, as a variant of the framework introduced by Faenza et al. This enables us to derive a new upper bound of $\tilde{O}(n^3\cdot 1.5^n)$ for the extension complexity of the matching polytope $P_{\text{match}}(n)$, improving upon the standard $2^n$-bound given by Edmonds' description. Additionally, we recover Goemans' compact formulation for the permutahedron using a one-round protocol based on sorting networks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11382v1</guid>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>M. Szusterman</dc:creator>
    </item>
    <item>
      <title>The Distortion of Prior-Independent b-Matching Mechanisms</title>
      <link>https://arxiv.org/abs/2602.11404</link>
      <description>arXiv:2602.11404v1 Announce Type: cross 
Abstract: In a setting where $m$ items need to be partitioned among $n$ agents, we evaluate the performance of mechanisms that take as input each agent's \emph{ordinal preferences}, i.e., their ranking of the items from most- to least-preferred. The standard measure for evaluating ordinal mechanisms is the \emph{distortion}, and the vast majority of the literature on distortion has focused on worst-case analysis, leading to some overly pessimistic results. We instead evaluate the distortion of mechanisms with respect to their expected performance when the agents' preferences are generated stochastically. We first show that no ordinal mechanism can achieve a distortion better than $e/(e-1)\approx 1.582$, even if each agent needs to receive exactly one item (i.e., $m=n$) and every agent's values for different items are drawn i.i.d.\ from the same known distribution. We then complement this negative result by proposing an ordinal mechanism that achieves the optimal distortion of $e/(e-1)$ even if each agent's values are drawn from an agent-specific distribution that is unknown to the mechanism. To further refine our analysis, we also optimize the \emph{distortion gap}, i.e., the extent to which an ordinal mechanism approximates the optimal distortion possible for the instance at hand, and we propose a mechanism with a near-optimal distortion gap of $1.076$. Finally, we also evaluate the distortion and distortion gap of simple mechanisms that have a one-pass structure.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11404v1</guid>
      <category>cs.GT</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ioannis Caragiannis, Vasilis Gkatzelis, Sebastian Homrighausen</dc:creator>
    </item>
    <item>
      <title>Bounded Local Generator Classes for Deterministic State Evolution</title>
      <link>https://arxiv.org/abs/2602.11476</link>
      <description>arXiv:2602.11476v1 Announce Type: cross 
Abstract: We formalize a constructive subclass of locality-preserving deterministic operators acting on graph-indexed state systems. We define the class of Bounded Local Generator Classes (BLGC), consisting of finite-range generators operating on bounded state spaces under deterministic composition. Within this class, incremental update cost is independent of total system dimension. We prove that, under the BLGC assumptions, per-step operator work satisfies W_t = O(1) as the number of nodes M \to \infty, establishing a structural decoupling between global state size and incremental computational effort. The framework admits a Hilbert-space embedding in \ell^2(V; \mathbb{R}^d) and yields bounded operator norms on admissible subspaces. The result applies specifically to the defined subclass and does not claim universality beyond the stated locality and boundedness constraints.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.11476v1</guid>
      <category>cs.OS</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>R. Jay Martin II</dc:creator>
    </item>
    <item>
      <title>An Improved FPT Algorithm for Computing the Interleaving Distance between Merge Trees via Path-Preserving Maps</title>
      <link>https://arxiv.org/abs/2602.12028</link>
      <description>arXiv:2602.12028v1 Announce Type: cross 
Abstract: A merge tree is a fundamental topological structure used to capture the sub-level set (and similarly, super-level set) topology in scalar data analysis. The interleaving distance is a theoretically sound, stable metric for comparing merge trees. However, computing this distance exactly is NP-hard. First fixed-parameter tractable (FPT) algorithm for it's exact computation introduces the concept of an $\varepsilon$-good map between two merge trees, where $\varepsilon$ is a candidate value for the interleaving distance. The complexity of their algorithm is $O(2^{2\tau}(2\tau)^{2\tau+2}\cdot n^2\log^3n)$ where $\tau$ is the degree-bound parameter and $n$ is the total number of nodes in both the merge trees. Their algorithm exhibits exponential complexity in $\tau$, which increases with the increasing value of $\varepsilon$. In the current paper, we propose an improved FPT algorithm for computing the $\varepsilon$-good map between two merge trees. Our algorithm introduces two new parameters, $\eta_f$ and $\eta_g$, corresponding to the numbers of leaf nodes in the merge trees $M_f$ and $M_g$, respectively. This parametrization is motivated by the observation that a merge tree can be decomposed into a collection of unique leaf-to-root paths. The proposed algorithm achieves a complexity of $O\!\left(n^2\log n+\eta_g^{\eta_f}(\eta_f+\eta_g)\, n \log n \right)$. To obtain this reduced complexity, we assume that number of possible $\varepsilon$-good maps from $M_f$ to $M_g$ does not exceed that from $M_g$ to $M_f$. Notably, the parameters $\eta_f$ and $\eta_g$ are independent of the choice of $\varepsilon$. Compared to their algorithm, our approach substantially reduces the search space for computing an optimal $\varepsilon$-good map. We also provide a formal proof of correctness for the proposed algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.12028v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Althaf P V, Amit Chattopadhyay, Osamu Saeki</dc:creator>
    </item>
    <item>
      <title>Keeping a Secret Requires a Good Memory: Space Lower-Bounds for Private Algorithms</title>
      <link>https://arxiv.org/abs/2602.12209</link>
      <description>arXiv:2602.12209v1 Announce Type: cross 
Abstract: We study the computational cost of differential privacy in terms of memory efficiency. While the trade-off between accuracy and differential privacy is well-understood, the inherent cost of privacy regarding memory use remains largely unexplored. This paper establishes for the first time an unconditional space lower bound for user-level differential privacy by introducing a novel proof technique based on a multi-player communication game.
  Central to our approach, this game formally links the hardness of low-memory private algorithms to the necessity of ``contribution capping'' -- tracking and limiting the users who disproportionately impact the dataset. We demonstrate that winning this communication game requires transmitting information proportional to the number of over-active users, which translates directly to memory lower bounds.
  We apply this framework, as an example, to the fundamental problem of estimating the number of distinct elements in a stream and we prove that any private algorithm requires almost $\widetilde{\Omega}(T^{1/3})$ space to achieve certain error rates in a promise variant of the problem. This resolves an open problem in the literature (by Jain et al. NeurIPS 2023 and Cummings et al. ICML 2025) and establishes the first exponential separation between the space complexity of private algorithms and their non-private $\widetilde{O}(1)$ counterparts for a natural statistical estimation task. Furthermore, we show that this communication-theoretic technique generalizes to broad classes of problems, yielding lower bounds for private medians, quantiles, and max-select.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.12209v1</guid>
      <category>cs.CR</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alessandro Epasto, Xin Lyu, Pasin Manurangsi</dc:creator>
    </item>
    <item>
      <title>How to Compute a Moving Sum</title>
      <link>https://arxiv.org/abs/2509.00537</link>
      <description>arXiv:2509.00537v2 Announce Type: replace 
Abstract: Windowed recurrences are sliding window calculations where a function is applied iteratively across the window of data, and are ubiquitous throughout the natural, social, and computational sciences. In this monograph we explore the computational aspects of these calculations, including sequential and parallel computation, and develop the theory underlying the algorithms and their applicability. We introduce an efficient new sequential algorithm with low latency, and develop new techniques to derive and analyze the complexity and domain of validity of existing sequential algorithms. For parallel computation we derive new parallel and vector algorithms by relating windowed recurrences to the algebraic construction of semidirect products, and to algorithms for exponentiation in semigroups. In the middle chapters of the monograph we further develop the theory of semi-associativity and the algebraic conditions for representing function composition and function application by data. This systematizes the techniques used by practitioners to parallelize recurrence calculations. We end the monograph with an extensive gallery of examples of interest to specialists in many fields. Throughout the monograph new algorithms are described with pseudo-code transcribed from functioning source code.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.00537v2</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>David K. Maslen, Daniel N. Rockmore</dc:creator>
    </item>
    <item>
      <title>Refining the Complexity Landscape of Speed Scaling: Hardness and Algorithms</title>
      <link>https://arxiv.org/abs/2512.17663</link>
      <description>arXiv:2512.17663v3 Announce Type: replace 
Abstract: We study the computational complexity of scheduling jobs on a single speed-scalable processor with the objective of capturing the trade-off between the (weighted) flow time and the energy consumption. This trade-off has been extensively explored in the literature through a number of problem formulations that differ in the specific job characteristics and the precise objective function. Nevertheless, the computational complexity of four important problem variants has remained unresolved and was explicitly identified as an open question in prior work. In this paper, we settle the complexity of these variants.
  More specifically, we prove that the problem of minimizing the objective of total (weighted) flow time plus energy is NP-hard for the cases of (i) unit-weight jobs with arbitrary sizes, and (ii)~arbitrary-weight jobs with unit sizes. These results extend to the objective of minimizing the total (weighted) flow time subject to an energy budget and hold even when the schedule is required to adhere to a given priority ordering.
  In contrast, we show that when a completion-time ordering is provided, the same problem variants become polynomial-time solvable. The latter result highlights the subtle differences between priority and completion orderings for the problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.17663v3</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antonios Antoniadis, Denise Graafsma, Ruben Hoeksma, Maria Vlasiou</dc:creator>
    </item>
    <item>
      <title>Mind the Gap. Doubling Constant Parametrization of Weighted Problems: TSP, Max-Cut, and More</title>
      <link>https://arxiv.org/abs/2601.00768</link>
      <description>arXiv:2601.00768v2 Announce Type: replace 
Abstract: Despite much research, hard weighted problems still resist super-polynomial improvements over their textbook solution. On the other hand, the unweighted versions of these problems have recently witnessed the sought-after speedups. Currently, the only way to repurpose the algorithm of the unweighted version for the weighted version is to employ a polynomial embedding of the input weights. This, however, introduces a pseudo-polynomial factor into the running time, which becomes impractical for arbitrarily weighted instances.
  In this paper, we introduce a new way to repurpose the algorithm of the unweighted problem. Specifically, we show that the time complexity of several well-known NP-hard problems operating over the $(\min, +)$ and $(\max, +)$ semirings, such as TSP, Weighted Max-Cut, and Edge-Weighted $k$-Clique, is proportional to that of their unweighted versions when the set of input weights has small doubling. We achieve this by a meta-algorithm that converts the input weights into polynomially bounded integers using the recent constructive Freiman's theorem by Randolph and W\k{e}grzycki [ESA 2024] before applying the polynomial embedding.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.00768v2</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.STACS.2026.29</arxiv:DOI>
      <dc:creator>Mihail Stoian</dc:creator>
    </item>
    <item>
      <title>Online Decision Making with Fairness over Time</title>
      <link>https://arxiv.org/abs/2211.03997</link>
      <description>arXiv:2211.03997v3 Announce Type: replace-cross 
Abstract: Online platforms increasingly rely on sequential decision-making algorithms to allocate resources, match users, or control exposure, while facing growing pressure to ensure fairness over time. We study a general online decision-making framework in which a platform repeatedly makes decisions from possibly non-convex and discrete feasible sets, such as indivisible assignments or assortment choices, to maximize accumulated reward. Importantly, these decisions must jointly satisfy a set of general, $m$-dimensional, potentially unbounded but convex global constraints, which model diverse long-term fairness goals beyond simple budget caps. We develop a primal-dual algorithm that interprets fairness constraints as dynamic prices and updates them online based on observed outcomes. The algorithm is simple to implement, requiring only the solution of perturbed local optimization problems at each decision step. Under the standard random permutation model, we show that our method achieves $\tilde{O}(\sqrt{mT})$ regret in expected reward while guaranteeing $O(\sqrt{mT})$ violation of long-term fairness constraints deterministically over a horizon of $T$ steps. To capture realistic demand patterns such as periodicity or perturbation, we further extend our guarantees to a grouped random permutation model.</description>
      <guid isPermaLink="false">oai:arXiv.org:2211.03997v3</guid>
      <category>math.OC</category>
      <category>cs.DS</category>
      <pubDate>Fri, 13 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Rui Chen, Oktay Gunluk, Andrea Lodi, Guanyi Wang</dc:creator>
    </item>
  </channel>
</rss>
