<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Feb 2026 02:55:40 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Definability and Interpolation in Philosophy</title>
      <link>https://arxiv.org/abs/2602.07907</link>
      <description>arXiv:2602.07907v1 Announce Type: new 
Abstract: This paper is a historical tour of occurrences of the Craig interpolation theorem and the Beth definability theorem in philosophy since the 1950s. We identify the notion of dependence as one major red thread behind these, and include some new technical results, in particular, on logical system translations and generalized definability</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.07907v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Johan van Benthem</dc:creator>
    </item>
    <item>
      <title>SAT Encodings for Bandwidth Coloring: A Systematic Design Study</title>
      <link>https://arxiv.org/abs/2602.08423</link>
      <description>arXiv:2602.08423v1 Announce Type: new 
Abstract: The Bandwidth Coloring Problem (BCP) generalizes graph coloring by enforcing minimum separation constraints between adjacent vertices and arises in frequency assignment applications. While SAT-based approaches have shown promise for exact BCP solving, the encoding design space remains largely unexplored. This paper presents a systematic study of SAT encodings for the BCP, proposing a unified framework with six encoding methods across three categories: one-variable, two-variable, and block encodings. We evaluate the impact of key features including incremental solving and symmetry breaking. While symmetry breaking has been studied for graph coloring, it has not been systematically evaluated for SAT-based BCP solvers. Our analysis reveals significant interaction effects between encoding choices and solver configurations. The proposed framework achieves state-of-the-art performance on GEOM and MS-CAP benchmarks. Block encodings solve GEOM120b, the hardest instance, to proven optimality in approximately 1000 seconds, whereas previous methods could not solve it within a one-hour time limit.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08423v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Duc Trung Kim Nguyen, Tuyen Van Kieu, Khanh Van To</dc:creator>
    </item>
    <item>
      <title>Craig Interpolation in Program Verification</title>
      <link>https://arxiv.org/abs/2602.08532</link>
      <description>arXiv:2602.08532v1 Announce Type: new 
Abstract: Craig interpolation is used in program verification for automating key tasks such as the inference of loop invariants and the computation of program abstractions. This chapter covers some of the most important techniques that have been developed in this context over the last years, focusing on two aspects: the derivation of Craig interpolants modulo the theories and data types used in verification and the basic design of verification algorithms applying interpolation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08532v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Philipp R\"ummer</dc:creator>
    </item>
    <item>
      <title>PBLean: Pseudo-Boolean Proof Certificates for Lean 4</title>
      <link>https://arxiv.org/abs/2602.08692</link>
      <description>arXiv:2602.08692v1 Announce Type: new 
Abstract: We present PBLean, a method for importing VeriPB pseudo-Boolean (PB) proof certificates into Lean 4. Key to our approach is reflection: a Boolean checker function whose soundness is fully proved in Lean and executed as compiled native code. Our method scales to proofs with tens of thousands of steps that would exhaust memory under explicit proof-term construction. Our checker supports all VeriPB kernel rules, including cutting-plane derivations and proof-by-contradiction subproofs. In contrast to external verified checkers that produce verdicts, our integration yields Lean theorems that can serve as composable lemmas in larger formal developments. To derive theorems about the original combinatorial problems rather than about PB constraints alone, we support verified encodings. This closes the trust gap between solver output and problem semantics since the constraint translation and its correctness proof are both formalized in Lean. We demonstrate the approach on various combinatorial problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08692v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Stefan Szeider</dc:creator>
    </item>
    <item>
      <title>Verifying DNN-based Semantic Communication Against Generative Adversarial Noise</title>
      <link>https://arxiv.org/abs/2602.08801</link>
      <description>arXiv:2602.08801v1 Announce Type: new 
Abstract: Safety-critical applications like autonomous vehicles and industrial IoT are adopting semantic communication (SemCom) systems using deep neural networks to reduce bandwidth and increase transmission speed by transmitting only task-relevant semantic features.
  However, adversarial attacks against these DNN-based SemCom systems can cause catastrophic failures by manipulating transmitted semantic features.
  Existing defense mechanisms rely on empirical approaches provide no formal guarantees against the full spectrum of adversarial perturbations.
  We present VSCAN, a neural network verification framework that provides mathematical robustness guarantees by formulating adversarial noise generation as mixed integer programming and verifying end-to-end properties across multiple interconnected networks (encoder, decoder, and task model).
  Our key insight is that realistic adversarial constraints (power limitations and statistical undetectability) can be encoded as logical formulae to enable efficient verification using state-of-the-art DNN verifiers.
  Our evaluation on 600 verification properties characterizing various attacker's capabilities shows VSCAN matches attack methods in finding vulnerabilities while providing formal robustness guarantees for 44% of properties -- a significant achievement given the complexity of multi-network verification.
  Moreover, we reveal a fundamental security-efficiency tradeoff: compact 16-dimensional latent spaces achieve 50% verified robustness compared to 64-dimensional spaces.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08801v1</guid>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Thanh Le, Hai Duong, ThanhVu Nguyen, Takeshi Matsumura</dc:creator>
    </item>
    <item>
      <title>Impredicativity in Linear Dependent Type Theory</title>
      <link>https://arxiv.org/abs/2602.08846</link>
      <description>arXiv:2602.08846v1 Announce Type: new 
Abstract: We construct a realizability model of linear dependent type theory from a linear combinatory algebra. Our model motivates a number of additions to the type theory. In particular, we add a universe with two decoding operations: one takes codes to cartesian types and the other takes codes to linear types. The universe is impredicative in the sense that it is closed under both large cartesian dependent products and large linear dependent products. We also add a rule for injectivity of the modality turning linear terms into cartesian terms. With all of the additions, we are able to encode (linear) inductive types. As a case study, we consider the type of lists over a linear type, and demonstrate that our encoding has the relevant uniqueness principle. The construction of the realizability model is fully formalized in the proof assistant Rocq.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08846v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.CT</category>
      <category>math.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sam Speight, Niels van der Weide</dc:creator>
    </item>
    <item>
      <title>Carryless Pairing: Additive Pairing in the Fibonacci Basis</title>
      <link>https://arxiv.org/abs/2509.10382</link>
      <description>arXiv:2509.10382v4 Announce Type: cross 
Abstract: We define a pairing map $\pi : \mathbb{N}^2\to\mathbb{N}$ that encodes $x$ and $y$ into disjoint index bands inside the Zeckendorf support of a single integer. Evaluation and inversion use only addition, comparison, and bounded scans of supports; no multiplication, factorization, or digit interleaving is used. The device is carryless by construction: supports remain non-adjacent, so the output is already in Zeckendorf-normal form. The map is injective but not surjective; membership in its image is decidable by the same support machinery used for decoding. The core claims are mechanized in Rocq.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.10382v4</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Milan Rosko</dc:creator>
    </item>
    <item>
      <title>Automatic Generation of Polynomial Symmetry Breaking Constraints</title>
      <link>https://arxiv.org/abs/2602.08297</link>
      <description>arXiv:2602.08297v1 Announce Type: cross 
Abstract: Symmetry in integer programming causes redundant search and is often handled with symmetry breaking constraints that remove as many equivalent solutions as possible. We propose an algebraic method which allows to generate a random family of polynomial inequalities which can be used as symmetry breakers. The method requires as input an arbitrary base polynomial and a group of permutations which is specific to the integer program. The computations can be easily carried out in any major symbolic computation software. In order to test our approach, we describe a case study on near half-capacity 0-1 bin packing instances which exhibit substantial symmetries. We statically generate random quadratic breakers and add them to a baseline integer programming problem which we then solve with Gurobi. It turns out that simple symmetry breakers, especially combining few variables and permutations, most consistently reduce work time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08297v1</guid>
      <category>cs.SC</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Madalina Erascu, Johannes Middeke</dc:creator>
    </item>
    <item>
      <title>Circuit Representations of Random Forests with Applications to XAI</title>
      <link>https://arxiv.org/abs/2602.08362</link>
      <description>arXiv:2602.08362v1 Announce Type: cross 
Abstract: We make three contributions in this paper. First, we present an approach for compiling a random forest classifier into a set of circuits, where each circuit directly encodes the instances in some class of the classifier. We show empirically that our proposed approach is significantly more efficient than existing similar approaches. Next, we utilize this approach to further obtain circuits that are tractable for computing the complete and general reasons of a decision, which are instance abstractions that play a fundamental role in computing explanations. Finally, we propose algorithms for computing the robustness of a decision and all shortest ways to flip it. We illustrate the utility of our contributions by using them to enumerate all sufficient reasons, necessary reasons and contrastive explanations of decisions; to compute the robustness of decisions; and to identify all shortest ways to flip the decisions made by random forest classifiers learned from a wide range of datasets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08362v1</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Chunxi Ji, Adnan Darwiche</dc:creator>
    </item>
    <item>
      <title>Profinite trees, through Lawvere theories and the lambda-calculus</title>
      <link>https://arxiv.org/abs/2402.13086</link>
      <description>arXiv:2402.13086v2 Announce Type: replace 
Abstract: The starting point of algebraic language theory is that regular languages of finite words are exactly those recognized by finite monoids. This finiteness condition gives rise to a topological space whose points, called profinite words, encode the limiting behavior of words with respect to finite monoids.
  In this work, we move from words and monoids to trees and clones, the algebraic structures underlying deterministic bottom-up tree automata. Using the categorical notion of codensity monad, we introduce a profinite completion for clones. We prove that this construction on clones simultaneously generalizes the ultrafilter monad on sets and the profinite completion of monoids. When applied to free clones on a ranked alphabet, the profinite completion of clones yields a notion of profinite tree, providing a topological approach to regular languages of finite trees. We prove that these profinite trees coincide with a well-identified fragment of the profinite lambda-calculus.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.13086v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>math.CT</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vincent Moreau</dc:creator>
    </item>
    <item>
      <title>On Polynomial-Time Decidability of k-Negations Fragments of First-Order Theories</title>
      <link>https://arxiv.org/abs/2407.18420</link>
      <description>arXiv:2407.18420v4 Announce Type: replace 
Abstract: This paper introduces a generic framework that provides sufficient conditions for guaranteeing polynomial-time decidability of fixed-negation fragments of first-order theories that adhere to certain fixed-parameter tractability requirements. It enables deciding sentences of such theories with arbitrary existential quantification, conjunction and a fixed number of negation symbols in polynomial time. It was recently shown by Nguyen and Pak [SIAM J. Comput. 51(2): 1--31 (2022)] that an even more restricted such fragment of Presburger arithmetic (the first-order theory of the integers with addition and order) is NP-hard. In contrast, by application of our framework, we show that the fixed negation fragment of weak Presburger arithmetic, which drops the order relation from Presburger arithmetic in favour of equality, is decidable in polynomial time. We give two further examples of instantiations of our framework, showing polynomial-time decidability of the fixed negation fragments of weak linear real arithmetic and of the restriction of Presburger arithmetic in which each inequality contains at most one variable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.18420v4</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christoph Haase, Alessio Mansutti, Amaury Pouly</dc:creator>
    </item>
    <item>
      <title>Computation and Concurrency</title>
      <link>https://arxiv.org/abs/2409.02595</link>
      <description>arXiv:2409.02595v5 Announce Type: replace 
Abstract: We try to clarify the relationship between computation and concurrency. Base on the so-called pomsetc automata, we introduce communication and more operators, and establish the algebras modulo language equivalence and truly concurrent bisimilarities.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.02595v5</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yong Wang</dc:creator>
    </item>
    <item>
      <title>Well-Founded Coalgebras Meet K\"onig's Lemma</title>
      <link>https://arxiv.org/abs/2507.18539</link>
      <description>arXiv:2507.18539v2 Announce Type: replace 
Abstract: K\"onig's lemma is a fundamental result about trees with countless applications in mathematics and computer science. In contrapositive form, it states that if a tree is finitely branching and well-founded (i.e. has no infinite paths), then it is finite. We present a coalgebraic version of K\"onig's lemma featuring two dimensions of generalization: from finitely branching trees to coalgebras for a finitary endofunctor H, and from the base category of sets to a locally finitely presentable category C, such as the category of posets, nominal sets, or convex sets. Our coalgebraic K\"onig's lemma states that, under mild assumptions on C and H, every well-founded coalgebra for H is the directed join of its well-founded subcoalgebras with finitely generated state space -- in particular, the category of well-founded coalgebras is locally presentable. As applications, we derive versions of K\"onig's lemma for graphs in a topos as well as for nominal and convex transition systems. Additionally, we show that the key construction underlying the proof gives rise to two simple constructions of the initial algebra (equivalently, the final recursive coalgebra) for the functor H: The initial algebra is both the colimit of all well-founded and of all recursive coalgebras with finitely presentable state space. Remarkably, this result holds even in settings where well-founded coalgebras form a proper subclass of recursive ones. The first construction of the initial algebra is entirely new, while for the second one our approach yields a short and transparent new correctness proof.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.18539v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Henning Urbat, Thorsten Wi{\ss}mann</dc:creator>
    </item>
    <item>
      <title>The Ideal Membership Problem and Abelian Groups</title>
      <link>https://arxiv.org/abs/2201.05218</link>
      <description>arXiv:2201.05218v2 Announce Type: replace-cross 
Abstract: Given polynomials $f_0,\dots, f_k$ the Ideal Membership Problem, IMP for short, asks if $f_0$ belongs to the ideal generated by $f_1,\dots, f_k$. In the search version of this problem the task is to find a proof of this fact. The IMP is a well-known fundamental problem with numerous applications. For instance, it underlies many proof systems based on polynomials such as Nullstellensatz, Polynomial Calculus, and Sum-of-Squares. Although the IMP is in general intractable, in many important cases it can be efficiently solved.
  Mastrolilli [SODA'19] initiated a systematic study of IMPs for ideals arising from Constraint Satisfaction Problems (CSPs), parameterized by constraint languages, denoted IMP($\Gamma$). The ultimate goal of this line of research is to classify all such IMPs accordingly to their complexity. Mastrolilli achieved this goal for IMPs arising from CSP($\Gamma$) where $\Gamma$ is a Boolean constraint language, while Bulatov and Rafiey [STOC'22] advanced these results to several cases of CSPs over finite domains. In this paper we consider IMPs arising from CSPs over `affine' constraint languages, in which constraints are subgroups (or their cosets) of direct products of Abelian groups. This kind of CSPs include systems of linear equations and are considered one of the most important types of tractable CSPs. Some special cases of the problem have been considered before by Bharathi and Mastrolilli [MFCS'21] for linear equation modulo 2, and by Bulatov and Rafiey [STOC'22] to systems of linear equations over $GF(p)$, $p$ prime. Here we prove that if $\Gamma$ is an affine constraint language then IMP($\Gamma$) is solvable in polynomial time assuming the input polynomial has bounded degree.</description>
      <guid isPermaLink="false">oai:arXiv.org:2201.05218v2</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <category>cs.LO</category>
      <category>math.AC</category>
      <category>math.AG</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Andrei A. Bulatov, Akbar Rafiey</dc:creator>
    </item>
    <item>
      <title>GLP: A Grassroots, Multiagent, Concurrent, Logic Programming Language</title>
      <link>https://arxiv.org/abs/2510.15747</link>
      <description>arXiv:2510.15747v2 Announce Type: replace-cross 
Abstract: Grassroots platforms are distributed systems with multiple instances that can (1) operate independently of each other and of any global resource other than the network, and (2) coalesce into ever larger instances, possibly resulting in a single global instance.
  Here, we present Grassroots Logic Programs (GLP), a multiagent concurrent logic programming language designed for the implementation of grassroots platforms. We introduce the language incrementally: We recall the standard operational semantics of logic programs; introduce the operational semantics of Concurrent (single-agent) GLP as a restriction of that of LP; recall the notion of multiagent transition systems and atomic transactions; introduce the operational semantics of multiagent GLP via a multiagent transition system specified via atomic transactions; and prove multiagent GLP to be grassroots. The accompanying programming example is the grassroots social graph -- the infrastructure grassroots platform on which all others are based.
  With the mathematical foundations presented here: a workstation-based implementation of Concurrent GLP was developed by AI, based on the operational semantics of Concurrent GLP; a distributed peer-to-peer smartphone-based implementation of multiagent GLP is being developed by AI, based on the operational semantics of multiagent GLP; a moded type system for GLP was implemented by AI, to facilitate the specification of GLP programs by human and AI designers, for their programming by AI; all reported in detail in companion papers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.15747v2</guid>
      <category>cs.PL</category>
      <category>cs.CR</category>
      <category>cs.DC</category>
      <category>cs.LO</category>
      <category>cs.MA</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Ehud Shapiro</dc:creator>
    </item>
    <item>
      <title>Formal Foundations for Controlled Stochastic Activity Networks</title>
      <link>https://arxiv.org/abs/2511.12974</link>
      <description>arXiv:2511.12974v2 Announce Type: replace-cross 
Abstract: We introduce Controlled Stochastic Activity Networks (Controlled SANs), a formal extension of classical Stochastic Activity Networks that integrates explicit control actions into a unified semantic framework for modeling distributed real-time systems. Controlled SANs systematically capture dynamic behavior involving nondeterminism, probabilistic branching, and stochastic timing, while enabling policy-driven decision-making within a rigorous mathematical framework.
  We develop a hierarchical, automata-theoretic semantics for Controlled SANs that encompasses nondeterministic, probabilistic, and stochastic models in a uniform manner. A structured taxonomy of control policies, ranging from memoryless and finite-memory strategies to computationally augmented policies, is formalized, and their expressive power is characterized through associated language classes. To support model abstraction and compositional reasoning, we introduce behavioral equivalences, including bisimulation and stochastic isomorphism.
  Controlled SANs generalize classical frameworks such as continuous-time Markov decision processes (CTMDPs), providing a rigorous foundation for the specification, verification, and synthesis of dependable systems operating under uncertainty. This framework enables both quantitative and qualitative analysis, advancing the design of safety-critical systems where control, timing, and stochasticity are tightly coupled.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.12974v2</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ali Movaghar</dc:creator>
    </item>
    <item>
      <title>Combinatory Completeness in Structured Multicategories</title>
      <link>https://arxiv.org/abs/2511.17152</link>
      <description>arXiv:2511.17152v2 Announce Type: replace-cross 
Abstract: We give a general notion of combinatory completeness with respect to a faithful cartesian club and use it systematically to obtain characterisations of a number of different kinds of applicative system. Each faithful cartesian club determines a notion of structured multicategory, with the different notions of structured multicategory obtained in this way giving different notions of polynomial over an applicative system, which in turn give different notions of combinatory completeness. We obtain the classical characterisation of combinatory algebras as combinatory complete applicative systems as a specific instance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.17152v2</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ivan Kuzmin, Chad Nester, \"Ulo Reimaa, Sam Speight</dc:creator>
    </item>
    <item>
      <title>Imandra CodeLogician: Neuro-Symbolic Reasoning for Precise Analysis of Software Logic</title>
      <link>https://arxiv.org/abs/2601.11840</link>
      <description>arXiv:2601.11840v2 Announce Type: replace-cross 
Abstract: Large Language Models (LLMs) have shown strong performance on code understanding tasks, yet they fundamentally lack the ability to perform precise, exhaustive mathematical reasoning about program behavior. Existing benchmarks either focus on mathematical proof automation, largely disconnected from real-world software, or on engineering tasks that do not require semantic rigor.
  We present CodeLogician, a neurosymbolic agent for precise analysis of software logic, integrated with ImandraX, an industrial automated reasoning engine deployed in financial markets and safety-critical systems. Unlike prior approaches that use formal methods primarily to validate LLM outputs, CodeLogician uses LLMs to construct explicit formal models of software systems, enabling automated reasoning to answer rich semantic questions beyond binary verification outcomes.
  To rigorously evaluate mathematical reasoning about software logic, we introduce code-logic-bench, a benchmark targeting the middle ground between theorem proving and software engineering benchmarks. It measures reasoning correctness about program state spaces, control flow, coverage constraints, and edge cases, with ground truth defined via formal modeling and region decomposition.
  Comparing LLM-only reasoning against LLMs augmented with CodeLogician, formal augmentation yields substantial improvements, closing a 41-47 percentage point gap in reasoning accuracy. These results demonstrate that neurosymbolic integration is essential for scaling program analysis toward rigorous, autonomous software understanding.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.11840v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hongyu Lin, Samer Abdallah, Makar Valentinov, Paul Brennan, Elijah Kagan, Christoph M. Wintersteiger, Denis Ignatovich, Grant Passmore</dc:creator>
    </item>
  </channel>
</rss>
