<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CG updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CG</link>
    <description>cs.CG updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CG" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Aug 2025 04:00:17 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Distributed Diamond Formation of Sliding Squares</title>
      <link>https://arxiv.org/abs/2508.09638</link>
      <description>arXiv:2508.09638v1 Announce Type: new 
Abstract: The sliding square model is a widely used abstraction for studying self-reconfigurable robotic systems, where modules are square-shaped robots that move by sliding or rotating over one another. In this paper, we propose a novel distributed algorithm that allows a group of modules to reconfigure into a diamond shape, starting from an arbitrary side-connected configuration. It is connectivity-preserving and operates under minimal assumptions: one leader module, common chirality, constant memory per module, and visibility and communication restricted to immediate neighbors. Unlike prior work, which relaxes the original sliding square move-set, our approach uses the unmodified move-set, addressing the additional challenge of handling locked configurations. Our algorithm is sequential in nature and operates with a worst-case time complexity of $\mathcal{O}(n^2)$ rounds, which is optimal for sequential algorithms. To improve runtime, we introduce two parallel variants of the algorithm. Both rely on a spanning tree data structure, allowing modules to make decisions based on local connectivity. Our experimental results show a significant speedup for the first variant, and linear average runtime for the second variant, which is worst-case optimal for parallel algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.09638v1</guid>
      <category>cs.CG</category>
      <category>cs.DC</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Irina Kostitsyna, David Liedtke, Christian Scheideler</dc:creator>
    </item>
    <item>
      <title>Simpler and Faster Contiguous Art Gallery</title>
      <link>https://arxiv.org/abs/2508.09734</link>
      <description>arXiv:2508.09734v1 Announce Type: new 
Abstract: The contiguous art gallery problem was introduced at SoCG'25 in a merged paper that combined three simultaneous results, each achieving a polynomial-time algorithm for the problem. This problem is a variant of the classical art gallery problem, first introduced by Klee in 1973. In the contiguous art gallery problem, we are given a polygon P and asked to determine the minimum number of guards needed, where each guard is assigned a contiguous portion of the boundary of P that it can see, such that all assigned portions together cover the boundary of P. The classical art gallery problem is NP-hard and ER-complete, and the three independent works investigated whether this variant admits a polynomial-time solution. Each of these works indeed presented such a solution, with the fastest running in O(k n^5 log n) time, where n denotes the number of vertices of P and k is the size of a minimum guard set covering the boundary of P. We present a solution that is both considerably simpler and significantly faster, yielding a concise and almost entirely self-contained O(k n^2 log^2 n)-time algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.09734v1</guid>
      <category>cs.CG</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sarita de Berg, Jacobus Conradi, Ivor van der Hoog, Frank Staals</dc:creator>
    </item>
    <item>
      <title>SHREC'25 Track on Multiple Relief Patterns: Report and Analysis</title>
      <link>https://arxiv.org/abs/2508.09909</link>
      <description>arXiv:2508.09909v1 Announce Type: new 
Abstract: This SHREC 2025 track focuses on the recognition and segmentation of relief patterns embedded on the surface of a set of synthetically generated triangle meshes. We report the methods proposed by the participants, whose performance highlights the inherent complexity of solving the problem, which is still open. Then, we discuss the critical aspects of the proposed tasks, highlight the limitations of current techniques, and outline possible directions for future research. All resources and track details are available at the official track webpage: https://sites.google.com/unifi.it/shrec25-relief-pattern.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.09909v1</guid>
      <category>cs.CG</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gabriele Paolini, Claudio Tortorici, Stefano Berretti, Ahmed Hazem Youssef, Halim Benhabiles, Adnane Cabani, Ruiwen He, Karim Hammoudi, Iyyakutti Iyappan Ganapathi, Syed Sadaf Ali, Divya Velayudhan, Maregu Assefa, Naoufel Werghi</dc:creator>
    </item>
    <item>
      <title>TFZ: Topology-Preserving Compression of 2D Symmetric and Asymmetric Second-Order Tensor Fields</title>
      <link>https://arxiv.org/abs/2508.09235</link>
      <description>arXiv:2508.09235v1 Announce Type: cross 
Abstract: In this paper, we present a novel compression framework, TFZ, that preserves the topology of 2D symmetric and asymmetric second-order tensor fields defined on flat triangular meshes. A tensor field assigns a tensor - a multi-dimensional array of numbers - to each point in space. Tensor fields, such as the stress and strain tensors, and the Riemann curvature tensor, are essential to both science and engineering. The topology of tensor fields captures the core structure of data, and is useful in various disciplines, such as graphics (for manipulating shapes and textures) and neuroscience (for analyzing brain structures from diffusion MRI). Lossy data compression may distort the topology of tensor fields, thus hindering downstream analysis and visualization tasks. TFZ ensures that certain topological features are preserved during lossy compression. Specifically, TFZ preserves degenerate points essential to the topology of symmetric tensor fields and retains eigenvector and eigenvalue graphs that represent the topology of asymmetric tensor fields. TFZ scans through each cell, preserving the local topology of each cell, and thereby ensuring certain global topological guarantees. We showcase the effectiveness of our framework in enhancing the lossy scientific data compressors SZ3 and SPERR.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.09235v1</guid>
      <category>cs.GR</category>
      <category>cs.CG</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nathaniel Gorski, Xin Liang, Hanqi Guo, Bei Wang</dc:creator>
    </item>
    <item>
      <title>CWFBind: Geometry-Awareness for Fast and Accurate Protein-Ligand Docking</title>
      <link>https://arxiv.org/abs/2508.09499</link>
      <description>arXiv:2508.09499v1 Announce Type: cross 
Abstract: Accurately predicting the binding conformation of small-molecule ligands to protein targets is a critical step in rational drug design. Although recent deep learning-based docking surpasses traditional methods in speed and accuracy, many approaches rely on graph representations and language model-inspired encoders while neglecting critical geometric information, resulting in inaccurate pocket localization and unrealistic binding conformations. In this study, we introduce CWFBind, a weighted, fast, and accurate docking method based on local curvature features. Specifically, we integrate local curvature descriptors during the feature extraction phase to enrich the geometric representation of both proteins and ligands, complementing existing chemical, sequence, and structural features. Furthermore, we embed degree-aware weighting mechanisms into the message passing process, enhancing the model's ability to capture spatial structural distinctions and interaction strengths. To address the class imbalance challenge in pocket prediction, CWFBind employs a ligand-aware dynamic radius strategy alongside an enhanced loss function, facilitating more precise identification of binding regions and key residues. Comprehensive experimental evaluations demonstrate that CWFBind achieves competitive performance across multiple docking benchmarks, offering a balanced trade-off between accuracy and efficiency.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.09499v1</guid>
      <category>cs.CV</category>
      <category>cs.CG</category>
      <category>cs.LG</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Liyan Jia, Chuan-Xian Ren, Hong Yan</dc:creator>
    </item>
    <item>
      <title>Retroactive Monotonic Priority Queues via Range Searching</title>
      <link>https://arxiv.org/abs/2508.09892</link>
      <description>arXiv:2508.09892v1 Announce Type: cross 
Abstract: The best known fully retroactive priority queue costs $O(\log^2 m \log \log m)$ time per operation, where $m$ is the number of operations performed on the data structure. In contrast, standard (non-retroactive) and partially retroactive priority queues cost $O(\log m)$ time per operation. So far, it is unknown whether this $O(\log m)$ bound can be achieved for fully retroactive priority queues.
  In this work, we study a restricted variant of priority queues known as monotonic priority queues. We show that finding the minimum in a retroactive monotonic priority queue is a special case of the range-searching problem. We design a fully retroactive monotonic priority queue with a cost of $O(\log m + T(m))$ time per operation, where $T(m)$ is the maximum between the query and the update time of a specific range-searching data structure with $m$ elements. Finally, we design a fully retroactive monotonic priority queue that costs $O(\log m \log \log m)$ time per operation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.09892v1</guid>
      <category>cs.DS</category>
      <category>cs.CG</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Lucas Castro, Rosiane de Freitas</dc:creator>
    </item>
    <item>
      <title>Parameterized Approaches to Orthogonal Compaction</title>
      <link>https://arxiv.org/abs/2210.05019</link>
      <description>arXiv:2210.05019v2 Announce Type: replace 
Abstract: Orthogonal graph drawings are used in applications such as UML diagrams, VLSI layout, cable plans, and metro maps. We focus on drawing planar graphs and assume that we are given an \emph{orthogonal representation} that describes the desired shape, but not the exact coordinates of a drawing. Our aim is to compute an orthogonal drawing on the grid that has minimum area among all grid drawings that adhere to the given orthogonal representation.
  This problem is called orthogonal compaction (OC) and is known to be NP-hard, even for orthogonal representations of cycles [Evans et al., 2022]. We investigate the complexity of OC with respect to several parameters. Among others, we show that OC is fixed-parameter tractable with respect to the most natural of these parameters, namely, the number of \emph{kitty corners} of the orthogonal representation: the presence of pairs of kitty corners in an orthogonal representation makes the OC problem hard. Informally speaking, a pair of kitty corners is a pair of reflex corners of a face that point at each other. Accordingly, the number of kitty corners is the number of corners that are involved in some pair of kitty corners.</description>
      <guid isPermaLink="false">oai:arXiv.org:2210.05019v2</guid>
      <category>cs.CG</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1016/j.jcss.2025.103692</arxiv:DOI>
      <arxiv:journal_reference>Journal of Computer and System Sciences, volume 155, article number 103692, 1-22, 2026</arxiv:journal_reference>
      <dc:creator>Walter Didimo, Siddharth Gupta, Philipp Kindermann, Giuseppe Liotta, Alexander Wolff, Meirav Zehavi</dc:creator>
    </item>
    <item>
      <title>Decoupling Geometry from Optimization in 2D Irregular Cutting and Packing Problems: an Open-Source Collision Detection Engine</title>
      <link>https://arxiv.org/abs/2508.08341</link>
      <description>arXiv:2508.08341v2 Announce Type: replace 
Abstract: Addressing irregular cutting and packing (C&amp;P) optimization problems poses two distinct challenges: the geometric challenge of determining whether or not an item can be placed feasibly at a certain position, and the optimization challenge of finding a good solution according to some objective function. Until now, those tackling such problems have had to address both challenges simultaneously, requiring two distinct sets of expertise and a lot of research &amp; development effort. One way to lower this barrier is to decouple the two challenges. In this paper we introduce a powerful collision detection engine (CDE) for 2D irregular C&amp;P problems which assumes full responsibility for the geometric challenge. The CDE (i) allows users to focus with full confidence on their optimization challenge by abstracting geometry away and (ii) enables independent advances to propagate to all optimization algorithms built atop it. We present a set of core principles and design philosophies to model a general and adaptable CDE focused on maximizing performance, accuracy and robustness. These principles are accompanied by a concrete open-source implementation called $\texttt{jagua-rs}$. This paper together with its implementation serves as a catalyst for future advances in irregular C&amp;P problems by providing a solid foundation which can either be used as it currently exists or be further improved upon.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.08341v2</guid>
      <category>cs.CG</category>
      <category>cs.RO</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeroen Gardeyn, Greet Vanden Berghe, Tony Wauters</dc:creator>
    </item>
    <item>
      <title>Accelerated Reeds-Shepp and Under-Specified Reeds-Shepp Algorithms for Mobile Robot Path Planning</title>
      <link>https://arxiv.org/abs/2504.05921</link>
      <description>arXiv:2504.05921v2 Announce Type: replace-cross 
Abstract: In this study, we present a simple and intuitive method for accelerating optimal Reeds-Shepp path computation. Our approach uses geometrical reasoning to analyze the behavior of optimal paths, resulting in a new partitioning of the state space and a further reduction in the minimal set of viable paths. We revisit and reimplement classic methodologies from the literature, which lack contemporary open-source implementations, to serve as benchmarks for evaluating our method. Additionally, we address the under-specified Reeds-Shepp planning problem where the final orientation is unspecified. We perform exhaustive experiments to validate our solutions. Compared to the modern C++ implementation of the original Reeds-Shepp solution in the Open Motion Planning Library, our method demonstrates a 15x speedup, while classic methods achieve a 5.79x speedup. Both approaches exhibit machine-precision differences in path lengths compared to the original solution. We release our proposed C++ implementations for both the accelerated and under-specified Reeds-Shepp problems as open-source code.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.05921v2</guid>
      <category>cs.RO</category>
      <category>cs.CG</category>
      <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1109/TRO.2025.3554406</arxiv:DOI>
      <arxiv:journal_reference>IEEE Transactions on Robotics vol. 41 pp. 2691-2708 (2025)</arxiv:journal_reference>
      <dc:creator>Ibrahim Ibrahim, Wilm Decr\'e, Jan Swevers</dc:creator>
    </item>
  </channel>
</rss>
