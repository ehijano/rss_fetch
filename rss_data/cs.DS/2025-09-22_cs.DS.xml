<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Sep 2025 04:00:16 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Graph-Based Approximate Nearest Neighbor Search Revisited: Theoretical Analysis and Optimization</title>
      <link>https://arxiv.org/abs/2509.15531</link>
      <description>arXiv:2509.15531v1 Announce Type: new 
Abstract: Graph-based approaches to approximate nearest neighbor search (ANNS) have achieved remarkable success in enabling fast, high-recall retrieval on billion-scale vector datasets. Among them, the Sparse Neighborhood Graph (SNG) has emerged as a widely adopted graph structure due to its superior search performance. However, the theoretical understanding of SNG remains limited, leading to reliance on heuristic-based and often suboptimal truncation strategies. In this work, we aim to bridge the gap between theory and practice by providing formal guarantees for graph-based ANNS methods and proposing principled optimization strategies for the truncation parameter. By characterizing the index construction process through martingale-based analysis, we show that the degree of the index graph is $O(n^{2/3+\epsilon})$, where $\epsilon$ is an arbitrarily small constant. Furthermore, we prove that the expected search path length during query processing is $O(\log n)$. Based on these theoretical insights, we introduce a novel and principled method for selecting the truncation parameter $R$ in SNG. Experimental results demonstrate that our method achieves comparable or superior performance in terms of query latency and Recall@10 compared to commonly used binary search heuristics, while yielding 2x to 9x speedups in overall index construction.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.15531v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Xinran Ma, Zhaoqi Zhou, Chuan Zhou, Qi Meng, Zaijiu Shang, Guoliang Li, Zhiming Ma</dc:creator>
    </item>
    <item>
      <title>Constant time enumeration of perfect bipartite matchings</title>
      <link>https://arxiv.org/abs/2509.16135</link>
      <description>arXiv:2509.16135v1 Announce Type: new 
Abstract: We present an algorithm that enumerates all the perfect matchings in a given bipartite graph G = (V,E). Our algorithm requires a constant amortized time to visit one perfect matching of G, in contrast to the current fastest algorithm, published 25 years ago by Uno, which requires O(log |V|) time.
  To facilitate the listing of all edges in a visited perfect matching, we develop a variant of arithmetic circuits, which may have broader applications in future enumeration algorithms. Consequently, a visited perfect matching is represented within a binary tree. Although it is more common to provide visited objects in an array, we present a class of graphs for which achieving constant amortized time is not feasible in this case.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.16135v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Ji\v{r}\'i Fink</dc:creator>
    </item>
    <item>
      <title>On the Structural Parameterizations of 2-Club with Triangle Constraints</title>
      <link>https://arxiv.org/abs/2509.16143</link>
      <description>arXiv:2509.16143v1 Announce Type: new 
Abstract: Given an undirected graph G = (V, E) and an integer k, the s-Club asks if Gcontains a vertex subset S of at least k vertices such that G[S] has diameter at most s. Recently, Vertex r-Triangle s-Club, and Edge r-Triangle s-Club that generalize the notion of s-Club have been studied by Garvardt et al. [TOCS-2023, IWOCA-2022] from the perspective of parameterized complexity. Given a graph G and an integer k, the Vertex r-Triangle s-Club asks if there is an s-Club S with at least k vertices such that every vertex u \in S is part of at least r triangles in G[S]. In this paper, we initiate a systematic study of Vertex r-Triangle s-Club for every integer r &gt;= 1 from the perspective of structural parameters of the input graph. In particular, we provide FPT algorithms for Vertex r-Triangle 2-Club when parameterized by the treewidth (tw) of the input graph, and an XP algorithm when parameterized by the h-index of the input graph. Additionally, when parameterized by the feedback edge number (fes) of the input graph. We provide a kernel of O(fes) edges for Vertex r-Triangle s-Club.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.16143v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ashwin Jacob, Diptapriyo Majumdar, Raghav Sakhuja</dc:creator>
    </item>
    <item>
      <title>Analyzing and improving a classical Betti number estimation algorithm</title>
      <link>https://arxiv.org/abs/2509.16171</link>
      <description>arXiv:2509.16171v1 Announce Type: new 
Abstract: Recently, a classical algorithm for estimating the normalized Betti number of an arbitrary simplicial complex was proposed. Motivated by a quantum algorithm with a similar Monte Carlo structure and improved sample complexity, we give a more in-depth analysis of the sample complexity of this classical algorithm. To this end, we present bounds for the variance of the estimators used in the classical algorithm and show that the variance depends on certain combinatorial properties of the underlying simplicial complex. This new analysis leads us to propose an improvement to the classical algorithm which makes the "easy cases easier'', in that it reduces the sample complexity for simplicial complexes where the variance is sufficiently small. We show the effectiveness and limitations of these classical algorithms by considering Erd\H{o}s-Renyi random graph models to demonstrate the existence of "easy" and "hard" cases. Namely, we show that for certain models our improvement almost always leads to a reduced sample complexity, and also produce separate regimes where the sample complexity for both algorithms is exponential.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.16171v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>quant-ph</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Julien Sorci</dc:creator>
    </item>
    <item>
      <title>Query-Efficient Locally Private Hypothesis Selection via the Scheffe Graph</title>
      <link>https://arxiv.org/abs/2509.16180</link>
      <description>arXiv:2509.16180v1 Announce Type: new 
Abstract: We propose an algorithm with improved query-complexity for the problem of hypothesis selection under local differential privacy constraints. Given a set of $k$ probability distributions $Q$, we describe an algorithm that satisfies local differential privacy, performs $\tilde{O}(k^{3/2})$ non-adaptive queries to individuals who each have samples from a probability distribution $p$, and outputs a probability distribution from the set $Q$ which is nearly the closest to $p$. Previous algorithms required either $\Omega(k^2)$ queries or many rounds of interactive queries.
  Technically, we introduce a new object we dub the Scheff\'e graph, which captures structure of the differences between distributions in $Q$, and may be of more broad interest for hypothesis selection tasks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.16180v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <category>stat.ML</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gautam Kamath, Alireza F. Pour, Matthew Regehr, David P. Woodruff</dc:creator>
    </item>
    <item>
      <title>Clustering with Set Outliers and Applications in Relational Clustering</title>
      <link>https://arxiv.org/abs/2509.16194</link>
      <description>arXiv:2509.16194v1 Announce Type: new 
Abstract: We introduce and study the $k$-center clustering problem with set outliers, a natural and practical generalization of the classical $k$-center clustering with outliers. Instead of removing individual data points, our model allows discarding up to $z$ subsets from a given family of candidate outlier sets $\mathcal{H}$. Given a metric space $(P,\mathsf{dist})$, where $P$ is a set of elements and $\mathsf{dist}$ a distance metric, a family of sets $\mathcal{H}\subseteq 2^P$, and parameters $k, z$, the goal is to compute a set of $k$ centers $S\subseteq P$ and a family of $z$ sets $H\subseteq \mathcal{H}$ to minimize $\max_{p\in P\setminus(\bigcup_{h\in H} h)} \min_{s\in S}\mathsf{dist}(p,s)$. This abstraction captures structured noise common in database applications, such as faulty data sources or corrupted records in data integration and sensor systems.
  We present the first approximation algorithms for this problem in both general and geometric settings. Our methods provide tri-criteria approximations: selecting up to $2k$ centers and $2f z$ outlier sets (where $f$ is the maximum number of sets that a point belongs to), while achieving $O(1)$-approximation in clustering cost. In geometric settings, we leverage range and BBD trees to achieve near-linear time algorithms. In many real applications $f=1$. In this case we further improve the running time of our algorithms by constructing small \emph{coresets}. We also provide a hardness result for the general problem showing that it is unlikely to get any sublinear approximation on the clustering cost selecting less than $f\cdot z$ outlier sets.
  We demonstrate that this model naturally captures relational clustering with outliers: outliers are input tuples whose removal affects the join output. We provide approximation algorithms for both, establishing a tight connection between robust clustering and relational query evaluation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.16194v1</guid>
      <category>cs.DS</category>
      <category>cs.DB</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vaishali Surianarayanan, Neeraj Kumar, Stavros Sintos</dc:creator>
    </item>
    <item>
      <title>Classical and Quantum Heuristics for the Binary Paint Shop Problem</title>
      <link>https://arxiv.org/abs/2509.15294</link>
      <description>arXiv:2509.15294v1 Announce Type: cross 
Abstract: The Binary Paint Shop Problem (BPSP) is an $\mathsf{APX}$-hard optimisation problem in automotive manufacturing: given a sequence of $2n$ cars, comprising $n$ distinct models each appearing twice, the task is to decide which of two colours to paint each car so that the two occurrences of each model are painted differently, while minimising consecutive colour swaps. The key performance metric is the paint swap ratio, the average number of colour changes per car, which directly impacts production efficiency and cost. Prior work showed that the Quantum Approximate Optimisation Algorithm (QAOA) at depth $p=7$ achieves a paint swap ratio of $0.393$, outperforming the classical Recursive Greedy (RG) heuristic with an expected ratio of $0.4$ [Phys. Rev. A 104, 012403 (2021)]. More recently, the classical Recursive Star Greedy (RSG) heuristic was conjectured to achieve an expected ratio of $0.361$. In this study, we develop the theoretical foundations for applying QAOA to BPSP through a reduction of BPSP to weighted MaxCut, and use this framework to benchmark two state-of-the-art low-depth QAOA variants, eXpressive QAOA (XQAOA) and Recursive QAOA (RQAOA), at $p=1$ (denoted XQAOA$_1$ and RQAOA$_1$), against the strongest classical heuristics known to date. Across instances ranging from $2^7$ to $2^{12}$ cars, XQAOA$_1$ achieves an average ratio of $0.357$, surpassing RQAOA$_1$ and all classical heuristics, including the conjectured performance of RSG. Surprisingly, RQAOA$_1$ shows diminishing performance as size increases: despite using provably optimal QAOA$_1$ parameters at each recursion, it is outperformed by RSG on most $2^{11}$-car instances and all $2^{12}$-car instances. To our knowledge, this is the first study to report RQAOA$_1$'s performance degradation at scale. In contrast, XQAOA$_1$ remains robust, indicating strong potential to asymptotically surpass all known heuristics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.15294v1</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <category>cs.ET</category>
      <category>math.OC</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>V Vijendran, Dax Enshan Koh, Ping Koy Lam, Syed M Assad</dc:creator>
    </item>
    <item>
      <title>Tree-independence number VI. Thetas and pyramids</title>
      <link>https://arxiv.org/abs/2509.15458</link>
      <description>arXiv:2509.15458v1 Announce Type: cross 
Abstract: Given a family $\mathcal{H}$ of graphs, we say that a graph $G$ is $\mathcal{H}$-free if no induced subgraph of $G$ is isomorphic to a member of $\mathcal{H}$. Let $W_{t\times t}$ be the $t$-by-$t$ hexagonal grid and let $\mathcal{L}_t$ be the family of all graphs $G$ such that $G$ is the line graph of some subdivision of $W_{t \times t}$. We denote by $\omega(G)$ the size of the largest clique in $G$. We prove that for every integer $t$ there exist integers $c_1(t)$, $c_2(t)$ and $d(t)$ such that every (pyramid, theta, $\mathcal{L}_t$)-free graph $G$ satisfies: i) $G$ has a tree decomposition where every bag has size at most $\omega(G)^{c_1(t)} \log (|V(G)|)$. ii) If $G$ has at least two vertices, then $G$ has a tree decomposition where every bag has independence number at most $\log^{c_2(t)} (|V(G)|)$. iii) For any weight function, $G$ has a balanced separator that is contained in the union of the neighborhoods of at most $d(t)$ vertices. These results qualitatively generalize the main theorems of Abrishami et al. (2022) and Chudnovsky et al. (2024). Additionally, we show that there exist integers $c_3(t), c_4(t)$ such that for every (theta, pyramid)-free graph $G$ and for every non-adjacent pair of vertices $a,b \in V(G)$, i) $a$ can be separated from $b$ by removing at most $w(G)^{c_3(t)}\log(|V(G)|)$ vertices. ii) $a$ can be separated from $b$ by removing a set of vertices with independence number at most $\log^{c_4(t)}(|V(G)|)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.15458v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Maria Chudnovsky, Julien Codsi</dc:creator>
    </item>
    <item>
      <title>A Bouquet of Results on Maximum Range Sum: General Techniques and Hardness Reductions</title>
      <link>https://arxiv.org/abs/2509.16008</link>
      <description>arXiv:2509.16008v1 Announce Type: cross 
Abstract: We revisit the maximum range sum (MaxRS) problem: given a set $P$ of $n$ weighted points in $\mathbb{R}^d$ and a range $Q$ (typically axis-aligned $d$-box or $d$-ball), the goal is to place $Q$ to maximize the total weight of points in $P\cap Q$. We study three natural variations:
  (1) Dynamic MaxRS: The goal is to update the placement of a $d$-ball under point insertions and deletions. We give a randomized $(\frac{1}{2}-\epsilon)$-approximation with update time $O_\epsilon(\log n)$. The approximation factor holds with high probability. To the best of our knowledge, this is the first result on dynamic MaxRS.
  (2) Batched MaxRS: In $\mathbb{R}^1$, along with $P$ we are given $m$ intervals of varying lengths. We prove a conditional lower bound of $\Omega(mn)$ time (via conjectured $(\min,+)$-convolution hardness), showing the trivial $O(mn\log n)$ upper bound in $\mathbb{R}^2$ is essentially tight. We also establish a similar bound for a related problem of batched smallest $k$-enclosing interval.
  (3) Colored MaxRS: Each point has a color from $[m]$, and the goal is to place $Q$ to maximize the number of uniquely colored points in $P\cap Q$. Prior work only considered axis-aligned rectangles in $\mathbb{R}^2$. For $d$-balls, we give: (a) a randomized $(\frac{1}{2}-\epsilon)$-approximation in $O_\epsilon(n\log n)$ time (avoiding exponential dependence on $d$), and (b) in $\mathbb{R}^2$, a $(1-\epsilon)$-approximation in expected $O_\epsilon(n\log n)$ time. Both approximations hold with high probability.
  Our algorithms rely on two techniques of broader interest. The first yields $(\frac{1}{2}-\epsilon)$-approximations via a volume argument on $d$-balls and a randomized game. The second achieves $(1-\epsilon)$-approximations through an exact output-sensitive algorithm, which we speed up by random sampling on colors.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.16008v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Rachana Gusain, Saladi Rahul, Aditya Subramanian</dc:creator>
    </item>
    <item>
      <title>Parameterised algorithms for temporally satisfying reconfiguration problems</title>
      <link>https://arxiv.org/abs/2502.11961</link>
      <description>arXiv:2502.11961v3 Announce Type: replace 
Abstract: Given a static vertex-selection problem (e.g. independent set, dominating set) on a graph, we can define a corresponding temporally satisfying reconfiguration problem on a temporal graph which asks for a sequence of solutions to the vertex-selection problem at each time such that we can reconfigure from one solution to the next. We can think of each solution in the sequence as a set of vertices with tokens placed on them; our reconfiguration model allows us to slide tokens along active edges of a temporal graph at each time-step.
  We show that it is possible to efficiently check whether one solution can be reconfigured to another, and show that approximation results on the static vertex-selection problem can be adapted with a lifetime factor to the reconfiguration version. Our main contributions are fixed-parameter tractable algorithms with respect to: enumeration time of the related static problem; the combination of temporal neighbourhood diversity and lifetime of the input temporal graph; and the combination of lifetime and treewidth of the footprint graph.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.11961v3</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tom Davot, Jessica Enright, Laura Larios-Jones</dc:creator>
    </item>
    <item>
      <title>On the Complexity of Finding Approximate LCS of Multiple Strings</title>
      <link>https://arxiv.org/abs/2505.15992</link>
      <description>arXiv:2505.15992v3 Announce Type: replace 
Abstract: Finding an Approximate Longest Common Substring (ALCS) within a given set $S=\{s_1,s_2,\ldots,s_m\}$ of $m \ge 2$ strings is a key problem in computational biology, such as identifying related mutations across multiple genetic sequences. We study several variants of ALCS problems that, given integers $k$ and $t \le m$, seek the longest string $u$ -- or the longest substring $u$ of any string in $S$ -- that lies within distance $k$ of at least one substring in $t$ distinct strings from $S$. While the general problems are NP-hard, we present efficient algorithms for restricted cases under Hamming and edit distances using the $LCP_k$ and $k$-errata tree data structures. Our methods achieve run times of $\mathcal{O}(N^2)$, $\mathcal{O}(k\ell N^2)$, and $\mathcal{O}(mN\log^k \ell)$, where $\ell$ is the length of the longest string and $N$ is the sum of the lengths of all the strings in $S$. We also establish conditional lower bounds under the Strong Exponential Time Hypothesis and extend our study to indeterminate strings.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15992v3</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Hamed Hasibi, Neerja Mhaskar, W. F. Smyth</dc:creator>
    </item>
    <item>
      <title>A PTAS for multiprocessor scheduling with rejection under a machine cost constraint</title>
      <link>https://arxiv.org/abs/2507.12635</link>
      <description>arXiv:2507.12635v2 Announce Type: replace 
Abstract: We study the multiprocessor scheduling with rejection problem under a machine cost constraint. In this problem, each job is either rejected with a rejection penalty or; accepted and scheduled on one of the machines for processing. The machine cost is proportional to the total processing time of the jobs scheduled on it. The problem aims to minimize the makespan of the accepted jobs plus the total rejection penalty of the rejected jobs while the total machine cost does not exceed a given upper bound. We present a simple $2$-approximation algorithm for the problem and we achieve a PTAS even when the number $m$ of machines is part of the input.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.12635v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Mingyang Gong, Brendan Mumey</dc:creator>
    </item>
    <item>
      <title>Robustifying Learning-Augmented Caching Efficiently without Compromising 1-Consistency</title>
      <link>https://arxiv.org/abs/2507.16242</link>
      <description>arXiv:2507.16242v3 Announce Type: replace 
Abstract: The online caching problem aims to minimize cache misses when serving a sequence of requests under a limited cache size. While naive learning-augmented caching algorithms achieve ideal $1$-consistency, they lack robustness guarantees. Existing robustification methods either sacrifice $1$-consistency or introduce significant computational overhead. In this paper, we introduce Guard, a lightweight robustification framework that enhances the robustness of a broad class of learning-augmented caching algorithms to $2H_k + 2$, while preserving their $1$-consistency. Guard achieves the current best-known trade-off between consistency and robustness, with only $O(1)$ additional per-request overhead, thereby maintaining the original time complexity of the base algorithm. Extensive experiments across multiple real-world datasets and prediction models validate the effectiveness of Guard in practice.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.16242v3</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Peng Chen, Hailiang Zhao, Jiaji Zhang, Xueyan Tang, Yixuan Wang, Shuiguang Deng</dc:creator>
    </item>
    <item>
      <title>Streaming periodicity with mismatches, wildcards, and edits</title>
      <link>https://arxiv.org/abs/2509.14898</link>
      <description>arXiv:2509.14898v2 Announce Type: replace 
Abstract: In this work, we study the problem of detecting periodic trends in strings. While detecting exact periodicity has been studied extensively, real-world data is often noisy, where small deviations or mismatches occur between repetitions. This work focuses on a generalized approach to period detection that efficiently handles noise. Given a string $S$ of length $n$, the task is to identify integers $p$ such that the prefix and the suffix of $S$, each of length $n-p+1$, are similar under a given distance measure. Erg\"un et al. [APPROX-RANDOM 2017] were the first to study this problem in the streaming model under the Hamming distance. In this work, we combine, in a non-trivial way, the Hamming distance sketch of Clifford et al. [SODA 2019] and the structural description of the $k$-mismatch occurrences of a pattern in a text by Charalampopoulos et al. [FOCS 2020] to present a more efficient streaming algorithm for period detection under the Hamming distance. As a corollary, we derive a streaming algorithm for detecting periods of strings which may contain wildcards, a special symbol that match any character of the alphabet. Our algorithm is not only more efficient than that of Erg\"un et al. [TCS 2020], but it also operates without their assumption that the string must be free of wildcards in its final characters. Additionally, we introduce the first two-pass streaming algorithm for computing periods under the edit distance by leveraging and extending the Bhattacharya-Kouck\'y's grammar decomposition technique [STOC 2023].</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14898v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Taha El Ghazi, Tatiana Starikovskaya</dc:creator>
    </item>
    <item>
      <title>Block Encoding of Sparse Matrices via Coherent Permutation</title>
      <link>https://arxiv.org/abs/2508.21667</link>
      <description>arXiv:2508.21667v2 Announce Type: replace-cross 
Abstract: Block encoding of sparse matrices underpins powerful quantum algorithms such as quantum singular value transformation, Hamiltonian simulation, and quantum linear solvers, but its efficient gate-level implementation for arbitrary sparse matrices remains a major challenge. We introduce a unified framework that overcomes the key obstacles of multi-controlled X gates overhead, amplitude reordering, and hardware connectivity, enabling efficient block encoding for arbitrary sparse matrices with explicit gate-level constructions. Central to our approach are a novel connection with combinatorial optimization, which enables systematic assignment of control qubits to achieve nearest-neighbor connectivity, and coherent permutation operators that preserve superposition while enabling amplitude reordering. We demonstrate our methods on structured sparse matrices, showing significant reductions in circuit depth and control overhead, thereby bridging the gap between theoretical formulations and practical circuit implementations for quantum algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.21667v2</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <category>cs.NA</category>
      <category>math.NA</category>
      <pubDate>Mon, 22 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Abhishek Setty</dc:creator>
    </item>
  </channel>
</rss>
