<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.SC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.SC</link>
    <description>cs.SC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.SC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Feb 2026 02:56:44 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>LCM decomposition of linear differential operators in positive characteristic</title>
      <link>https://arxiv.org/abs/2602.07237</link>
      <description>arXiv:2602.07237v1 Announce Type: new 
Abstract: We present an algorithm to compute $\mathrm{LCLM}$-decompositions for linear differentials operators with coefficients in the rational function field of characteristic $p$, $\mathbb{F}_{p^n}(t)$. We show that for an operator $L$ of order $r$ with coefficients of degree $d$, it finishes in polynomial time in $r$, $d$ and $p$. This algorithm proceeds in three steps. We begin by showing that the ''shape'' of the factorisation of $L$ can be easily obtained from the Frobenius normal form of its $p$-curvature, which can be efficiently computed an algorithm from Bostan, Caruso and Schost. Using results from the thesis of the author, we are then able to construct an operator $L^*$ in the same equivalence class as $L$ for which an $\mathrm{LCLM}$-decomposition is known. Finally, by computing an isomorphism between the quotient modules $\mathbb{F}_q(t)\langle\partial\rangle/\mathbb{F}_q(t)\langle\partial\rangle L^*$ and $\mathbb{F}_q(t)\langle\partial\rangle/\mathbb{F}_q(t)\langle\partial\rangle L$, we find a corresponding $\mathrm{LCLM}$-decomposition of $L$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.07237v1</guid>
      <category>cs.SC</category>
      <category>math.RA</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Rapha\"el Pag\`es</dc:creator>
    </item>
    <item>
      <title>Dynamical sequences: closure properties and automatic identity proving</title>
      <link>https://arxiv.org/abs/2602.07576</link>
      <description>arXiv:2602.07576v1 Announce Type: new 
Abstract: Given an algebraically closed field $K$, a dynamical sequence over $K$ is a $K$-valued sequence of the form $a(n):= f(\phi^n(x_0))$, where $\phi\colon X\to X$ and $f\colon X\to\mathbb{A}^1$ are rational maps defined over $K$, and $x_0\in X$ is a point whose forward orbit avoids the indeterminacy loci of $\varphi$ and $f$. Many classical sequences from number theory and algebraic combinatorics fall under this dynamical framework, and we show that the class of dynamical sequences enjoys numerous closure properties and encompasses all elliptic divisibility sequences, all Somos sequences, and all $C^n$- and $D^n$-finite sequences for all $n\ge 1$, as defined by Jim\'enez-Pastor, Nuspl, and Pillwein. We also give an algorithm for proving that two dynamical sequences are identical and illustrate how to use this algorithm by showing how to prove several classical combinatorial identities via this method.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.07576v1</guid>
      <category>cs.SC</category>
      <category>math.CO</category>
      <category>math.NT</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jason P. Bell, Yuxuan Sun</dc:creator>
    </item>
    <item>
      <title>Computing submatrices of the Hermite normal form of a structured polynomial matrix</title>
      <link>https://arxiv.org/abs/2602.08027</link>
      <description>arXiv:2602.08027v1 Announce Type: new 
Abstract: Following several decades of successive algorithmic improvements, works from the 2010s have showed how to compute the Hermite normal form (HNF) of a univariate polynomial matrix within a complexity bound which is essentially that of polynomial matrix multiplication. Recently, several results on bivariate polynomials and Gr\"obner bases have highlighted the interest of computing determinants or HNFs of polynomial matrices that happen to be structured, with a small displacement rank. In such contexts, a small leading principal submatrix of the HNF often contains all the sought information. In this article, we show how the displacement structure can be exploited in order to accelerate the computation of such submatrices. To achieve this, we rely on structured linear algebra over the field thanks to evaluation-interpolation. This allows us to recover some rows of the inverse of the input matrix, from which we deduce the sought HNF submatrix via bases of relations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08027v1</guid>
      <category>cs.SC</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>J\'er\'emy Berthomieu, Vincent Neiger, Hugo Passe</dc:creator>
    </item>
    <item>
      <title>Automatic Generation of Polynomial Symmetry Breaking Constraints</title>
      <link>https://arxiv.org/abs/2602.08297</link>
      <description>arXiv:2602.08297v1 Announce Type: new 
Abstract: Symmetry in integer programming causes redundant search and is often handled with symmetry breaking constraints that remove as many equivalent solutions as possible. We propose an algebraic method which allows to generate a random family of polynomial inequalities which can be used as symmetry breakers. The method requires as input an arbitrary base polynomial and a group of permutations which is specific to the integer program. The computations can be easily carried out in any major symbolic computation software. In order to test our approach, we describe a case study on near half-capacity 0-1 bin packing instances which exhibit substantial symmetries. We statically generate random quadratic breakers and add them to a baseline integer programming problem which we then solve with Gurobi. It turns out that simple symmetry breakers, especially combining few variables and permutations, most consistently reduce work time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08297v1</guid>
      <category>cs.SC</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Madalina Erascu, Johannes Middeke</dc:creator>
    </item>
    <item>
      <title>AMS-HD: Hyperdimensional Computing for Real-Time and Energy-Efficient Acute Mountain Sickness Detection</title>
      <link>https://arxiv.org/abs/2602.08916</link>
      <description>arXiv:2602.08916v1 Announce Type: new 
Abstract: Altitude sickness is a potentially life-threatening condition that impacts many individuals traveling to elevated altitudes. Timely detection is critical as symptoms can escalate rapidly. Early recognition enables simple interventions such as descent, oxygen, or medication, and prompt treatment can save lives by significantly lowering the risk of severe complications. Although conventional machine learning (ML) techniques have been applied to identify altitude sickness using physiological signals, such as heart rate, oxygen saturation, respiration rate, blood pressure, and body temperature, they often struggle to balance predictive performance with low hardware demands. In contrast, hyperdimensional computing (HDC) remains under-explored for this task with limited biomedical features, where it may offer a compelling alternative to existing classification models. Its vector symbolic framework is inherently suited to hardware-efficient design, making it a strong candidate for low-power systems like wearables. Leveraging lightweight computation and efficient streamlined memory usage, HDC enables real-time detection of altitude sickness from physiological parameters collected by wearable devices, achieving accuracy comparable to that of traditional ML models. We present AMS-HD, a novel system that integrates tailored feature extraction and Hadamard HV encoding to enhance both the precision and efficiency of HDC-based detection. This framework is well-positioned for deployment in wearable health monitoring platforms, enabling continuous, on-the-go tracking of acute altitude sickness.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08916v1</guid>
      <category>cs.SC</category>
      <category>cs.ET</category>
      <category>cs.LG</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Abu Masum, Mehran Moghadam, M. Hassan Najafi, Bige Unluturk, Ulkuhan Guler, Sercan Aygun</dc:creator>
    </item>
    <item>
      <title>Debugging code world models</title>
      <link>https://arxiv.org/abs/2602.07672</link>
      <description>arXiv:2602.07672v1 Announce Type: cross 
Abstract: Code World Models (CWMs) are language models trained to simulate program execution by predicting explicit runtime state after every executed command. This execution-based world modeling enables internal verification within the model, offering an alternative to natural language chain-of-thought reasoning. However, the sources of errors and the nature of CWMs' limitations remain poorly understood. We study CWMs from two complementary perspectives: local semantic execution and long-horizon state tracking. On real-code benchmarks, we identify two dominant failure regimes. First, dense runtime state reveals produce token-intensive execution traces, leading to token-budget exhaustion on programs with long execution histories. Second, failures disproportionately concentrate in string-valued state, which we attribute to limitations of subword tokenization rather than program structure. To study long-horizon behavior, we use a controlled permutation-tracking benchmark that isolates state propagation under action execution. We show that long-horizon degradation is driven primarily by incorrect action generation: when actions are replaced with ground-truth commands, a Transformer-based CWM propagates state accurately over long horizons, despite known limitations of Transformers in long-horizon state tracking. These findings suggest directions for more efficient supervision and state representations in CWMs that are better aligned with program execution and data types.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.07672v1</guid>
      <category>cs.SE</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.PL</category>
      <category>cs.SC</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Babak Rahmani</dc:creator>
    </item>
    <item>
      <title>Certified surface approximations using the interval Krawczyk test</title>
      <link>https://arxiv.org/abs/2602.07718</link>
      <description>arXiv:2602.07718v1 Announce Type: cross 
Abstract: We propose an algorithm to construct a certified approximation of a surface by generalizing the Krawczyk test. The Krawczyk test is based on interval arithmetic, and confirms the existence and uniqueness of a solution to a square system of analytic equations in a region. By generalizing this test, we extend the reach of this technique to non-square systems and higher-dimensional varieties. We provide a prototype implementation and illustrate its use on several examples.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.07718v1</guid>
      <category>math.NA</category>
      <category>cs.NA</category>
      <category>cs.SC</category>
      <category>math.AG</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Michael Burr, Jonathan D. Hauenstein, Kisun Lee</dc:creator>
    </item>
    <item>
      <title>Breaking the Simplification Bottleneck in Amortized Neural Symbolic Regression</title>
      <link>https://arxiv.org/abs/2602.08885</link>
      <description>arXiv:2602.08885v2 Announce Type: cross 
Abstract: Symbolic regression (SR) aims to discover interpretable analytical expressions that accurately describe observed data. Amortized SR promises to be much more efficient than the predominant genetic programming SR methods, but currently struggles to scale to realistic scientific complexity. We find that a key obstacle is the lack of a fast reduction of equivalent expressions to a concise normalized form. Amortized SR has addressed this by general-purpose Computer Algebra Systems (CAS) like SymPy, but the high computational cost severely limits training and inference speed. We propose SimpliPy, a rule-based simplification engine achieving a 100-fold speed-up over SymPy at comparable quality. This enables substantial improvements in amortized SR, including scalability to much larger training sets, more efficient use of the per-expression token budget, and systematic training set decontamination with respect to equivalent test expressions. We demonstrate these advantages in our Flash-ANSR framework, which achieves much better accuracy than amortized baselines (NeSymReS, E2E) on the FastSRB benchmark. Moreover, it performs on par with state-of-the-art direct optimization (PySR) while recovering more concise instead of more complex expressions with increasing inference budget.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.08885v2</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.SC</category>
      <pubDate>Tue, 10 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Paul Saegert, Ullrich K\"othe</dc:creator>
    </item>
  </channel>
</rss>
