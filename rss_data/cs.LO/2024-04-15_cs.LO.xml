<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Apr 2024 04:01:32 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 16 Apr 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Computable domains of a Halting Function</title>
      <link>https://arxiv.org/abs/2404.09484</link>
      <description>arXiv:2404.09484v1 Announce Type: new 
Abstract: We discuss the possibility of constructing a function that validates the definition or not definition of the partial recursive functions of one variable. This is a topic in computability theory, which was first approached by Alan M. Turing in 1936 in his foundational work "On Computable Numbers". Here we face it using the Model of computability of the recursive functions instead of the Turing's machines, but the results are transferable from one to another paradigm with ease. Recursive functions that are not defined at a given point, correspond to the Turing machines that "do not end" for a given input. What we propose Is a slight slip from the orthodox point of view: the issue of the self-reference and of the self-validation is not an impediment in imperative languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.09484v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Abel Luis Peralta</dc:creator>
    </item>
    <item>
      <title>Monitoring Second-Order Hyperproperties</title>
      <link>https://arxiv.org/abs/2404.09652</link>
      <description>arXiv:2404.09652v1 Announce Type: new 
Abstract: Hyperproperties express the relationship between multiple executions of a system. This is needed in many AI-related fields, such as knowledge representation and planning, to capture system properties related to knowledge, information flow, and privacy. In this paper, we study the monitoring of complex hyperproperties at runtime. Previous work in this area has either focused on the simpler problem of monitoring trace properties (which are sets of traces, while hyperproperties are sets of sets of traces) or on monitoring first-order hyperproperties, which are expressible in temporal logics with first-order quantification over traces, such as HyperLTL. We present the first monitoring algorithm for the much more expressive class of second-order hyperproperties. Second-order hyperproperties include system properties like common knowledge, which cannot be expressed in first-order logics like HyperLTL.
  We introduce Hyper$^2$LTL$_f$, a temporal logic over finite traces that allows for second-order quantification over sets of traces. We study the monitoring problem in two fundamental execution models: (1) the parallel model, where a fixed number of traces is monitored in parallel, and (2) the sequential model, where an unbounded number of traces is observed sequentially, one trace after the other. For the parallel model, we show that the monitoring of the second-order hyperproperties of Hyper$^2$LTL$_f$ can be reduced to monitoring first-order hyperproperties. For the sequential model, we present a monitoring algorithm that handles second-order quantification efficiently, exploiting optimizations based on the monotonicity of subformulas, graph-based storing of executions, and fixpoint hashing. We present experimental results from a range of benchmarks, including examples from common knowledge and planning.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.09652v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.MA</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Raven Beutner, Bernd Finkbeiner, Hadar Frenkel, Niklas Metzger</dc:creator>
    </item>
    <item>
      <title>Complete Game Logic with Sabotage</title>
      <link>https://arxiv.org/abs/2404.09873</link>
      <description>arXiv:2404.09873v1 Announce Type: new 
Abstract: We introduce Sabotage Game Logic ($\mathsf{GL_s}$), a simple and natural extension of Parikh's Game Logic with a single additional primitive, which allows players to lay traps for the opponent to avoid. $\mathsf{GL_s}$ can be used to model infinite sabotage games, in which players can change the rules during game play. In contrast to Game Logic, which is strictly less expressive, GLs is exactly as expressive as the modal $\mu$-calculus. This reveals a close connection between the entangled nested recursion inherent in modal fixpoint logics and adversarial dynamic rule changes characteristic for sabotage games. Additionally we present a natural Hilbert-style proof calculus for $\mathsf{GL_s}$ and prove completeness. The completeness of an extension of Parikh's calculus for Game Logic follows.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.09873v1</guid>
      <category>cs.LO</category>
      <category>cs.GT</category>
      <category>math.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Noah Abou El Wafa, Andr\'e Platzer</dc:creator>
    </item>
    <item>
      <title>OWLOOP: Interfaces for Mapping OWL Axioms into OOP Hierarchies</title>
      <link>https://arxiv.org/abs/2404.09305</link>
      <description>arXiv:2404.09305v1 Announce Type: cross 
Abstract: The paper tackles the issue of mapping logic axioms formalised in the Ontology Web Language (OWL) within the Object-Oriented Programming (OOP) paradigm. The issues of mapping OWL axioms hierarchies and OOP objects hierarchies are due to OWL-based reasoning algorithms, which might change an OWL hierarchy at runtime; instead, OOP hierarchies are usually defined as static structures. Although programming paradigms based on reflection allow changing the OOP hierarchies at runtime and mapping OWL axioms dynamically, there are no currently available mechanisms that do not limit the reasoning algorithms. Thus, the factory-based paradigm is typically used since it decouples the OWL and OOP hierarchies. However, the factory inhibits OOP polymorphism and introduces a paradigm shift with respect to widely accepted OOP paradigms. We present the OWLOOP API, which exploits the factory to not limit reasoning algorithms, and it provides novel OOP interfaces concerning the axioms in an ontology. OWLOOP is designed to limit the paradigm shift required for using ontologies while improving, through OOP-like polymorphism, the modularity of software architectures that exploit logic reasoning. The paper details our OWL to OOP mapping mechanism, and it shows the benefits and limitations of OWLOOP through examples concerning a robot in a smart environment.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.09305v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.RO</category>
      <category>cs.SE</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Luca Buoncompagni, Fulvio Mastrogiovanni</dc:creator>
    </item>
    <item>
      <title>A Uniform Framework for Language Inclusion Problems</title>
      <link>https://arxiv.org/abs/2404.09862</link>
      <description>arXiv:2404.09862v1 Announce Type: cross 
Abstract: We present a uniform approach for solving language inclusion problems. Our approach relies on a least fixpoint characterization and a quasiorder to compare words of the "smaller" language, reducing the inclusion check to a finite number of membership queries in the "larger" language. We present our approach in detail on the case of inclusion of a context-free language given by a grammar into a regular language. We then explore other inclusion problems and discuss how to apply our approach.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.09862v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-031-56222-8_9</arxiv:DOI>
      <dc:creator>Kyveli Doveri, Pierre Ganty, Chana Weil-Kennedy</dc:creator>
    </item>
    <item>
      <title>Simply typed convertibility is TOWER-complete even for safe lambda-terms</title>
      <link>https://arxiv.org/abs/2305.12601</link>
      <description>arXiv:2305.12601v2 Announce Type: replace 
Abstract: We consider the following decision problem: given two simply typed $\lambda$-terms, are they $\beta$-convertible? Equivalently, do they have the same normal form? It is famously non-elementary, but the precise complexity - namely TOWER-complete - is lesser known. One goal of this short paper is to popularize this fact.
  Our original contribution is to show that the problem stays TOWER-complete when the two input terms belong to Blum and Ong's safe $\lambda$-calculus, a fragment of the simply typed $\lambda$-calculus arising from the study of higher-order recursion schemes. Previously, the best known lower bound for this safe $\beta$-convertibility problem was PSPACE-hardness. Our proof proceeds by reduction from the star-free expression equivalence problem, taking inspiration from the author's work with Pradic on "implicit automata in typed $\lambda$-calculi".
  These results also hold for $\beta\eta$-convertibility.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.12601v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>L\^e Th\`anh D\~ung Nguy\^en</dc:creator>
    </item>
    <item>
      <title>A Fully Abstract Model of PCF Based on Extended Addressing Machines</title>
      <link>https://arxiv.org/abs/2306.13756</link>
      <description>arXiv:2306.13756v2 Announce Type: replace 
Abstract: Extended addressing machines (EAMs) have been introduced to represent higher-order sequential computations. Previously, we have shown that they are capable of simulating -- via an easy encoding -- the operational semantics of PCF, extended with explicit substitutions. In this paper we prove that the simulation is actually an equivalence: a PCF program terminates in a numeral exactly when the corresponding EAM terminates in the same numeral. It follows that the model of PCF obtained by quotienting typable EAMs by a suitable logical relation is adequate. From a definability result stating that every EAM in the model can be transformed into a PCF program with the same observational behavior, we conclude that the model is fully abstract for PCF.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.13756v2</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Benedetto Intrigila, Giulio Manzonetto, Nicolas Munnich</dc:creator>
    </item>
    <item>
      <title>Exploring Non-Regular Extensions of Propositional Dynamic Logic with Description-Logics Features</title>
      <link>https://arxiv.org/abs/2307.09913</link>
      <description>arXiv:2307.09913v4 Announce Type: replace 
Abstract: We investigate the impact of non-regular path expressions on the decidability of satisfiability checking and querying in description logics extending ALC. Our primary objects of interest are ALCreg and ALCvpl, the extensions of with path expressions employing, respectively, regular and visibly-pushdown languages. The first one, ALCreg, is a notational variant of the well-known Propositional Dynamic Logic of Fischer and Ladner. The second one, ALCvpl, was introduced and investigated by Loding and Serre in 2007. The logic ALCvpl generalises many known decidable non-regular extensions of ALCreg.
  We provide a series of undecidability results. First, we show that decidability of the concept satisfiability problem for ALCvpl is lost upon adding the seemingly innocent Self operator. Second, we establish undecidability for the concept satisfiability problem for ALCvpl extended with nominals. Interestingly, our undecidability proof relies only on one single non-regular (visibly-pushdown) language, namely on r#s# := { r^n s^n | n in N } for fixed role names r and s. Finally, in contrast to the classical database setting, we establish undecidability of query entailment for queries involving non-regular atoms from r#s#, already in the case of ALC-TBoxes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.09913v4</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Bartosz Bednarczyk</dc:creator>
    </item>
    <item>
      <title>On the logic of interventionist counterfactuals under indeterministic causal laws</title>
      <link>https://arxiv.org/abs/2312.07223</link>
      <description>arXiv:2312.07223v2 Announce Type: replace 
Abstract: We investigate the generalization of causal models to the case of indeterministic causal laws that was suggested in Halpern (2000). We give an overview of what differences in modeling are enforced by this more general perspective, and propose an implementation of generalized models in the style of the causal team semantics of Barbero &amp; Sandu (2020). In these models, the laws are not represented by functions (as in the deterministic case), but more generally by relations.
  We analyze significant differences in the axiomatization of interventionist counterfactuals in the indeterministic vs. the deterministic case, and provide strongly complete axiomatizations over the full class of indeterministic models and over its recursive subclass.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.07223v2</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <category>math.ST</category>
      <category>stat.TH</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-031-56940-1_11</arxiv:DOI>
      <dc:creator>Fausto Barbero</dc:creator>
    </item>
    <item>
      <title>Accelerated Bounded Model Checking</title>
      <link>https://arxiv.org/abs/2401.09973</link>
      <description>arXiv:2401.09973v2 Announce Type: replace 
Abstract: Bounded Model Checking (BMC) is a powerful technique for proving unsafety. However, finding deep counterexamples that require a large bound is challenging for BMC. On the other hand, acceleration techniques compute "shortcuts" that "compress" many execution steps into a single one. In this paper, we tightly integrate acceleration techniques into SMT-based bounded model checking. By adding suitable "shortcuts" to the SMT-problem on the fly, our approach can quickly detect deep counterexamples, even when only using small bounds. Moreover, using so-called blocking clauses, our approach can prove safety of examples where BMC diverges. An empirical comparison with other state-of-the-art techniques shows that our approach is highly competitive for proving unsafety, and orthogonal to existing techniques for proving safety.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.09973v2</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Florian Frohn, J\"urgen Giesl</dc:creator>
    </item>
  </channel>
</rss>
