<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Apr 2024 04:00:11 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 30 Apr 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Monitoring Real-Time Systems under Parametric Delay</title>
      <link>https://arxiv.org/abs/2404.18282</link>
      <description>arXiv:2404.18282v1 Announce Type: new 
Abstract: Online monitoring of embedded real-time systems can be achieved by reduction of an adequate property language, like Metric Interval Temporal Logic, to timed automata and symbolic execution of the resulting automata on the trace observed from the system. This direct construction however only is faithful if observation of the trace is immediate in the sense that the monitor can assign exact time stamps to the actions it observes, which is rarely true in practice due to the substantial and fluctuating parametric delays introduced by the circuitry connecting the observed system to its monitoring device. We present a purely zone-based online monitoring procedure and its implementation which handle such parametric delays exactly without recurrence to costly verification procedures for parametric timed automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.18282v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Martin Fr\"anzle, Thomas M. Grosen, Kim G. Larsen, Martin Zimmermann</dc:creator>
    </item>
    <item>
      <title>From the Lyndon factorization to the Canonical Inverse Lyndon factorization: back and forth</title>
      <link>https://arxiv.org/abs/2404.17969</link>
      <description>arXiv:2404.17969v1 Announce Type: cross 
Abstract: The notion of inverse Lyndon word is related to the classical notion of Lyndon word. More precisely, inverse Lyndon words are all and only the nonempty prefixes of the powers of the anti-Lyndon words, where an anti-Lyndon word with respect to a lexicographical order is a classical Lyndon word with respect to the inverse lexicographic order. Each word $w$ admits a factorization in inverse Lyndon words, named the canonical inverse Lyndon factorization $\ICFL(w)$, which maintains the main properties of the Lyndon factorization of $w$. Although there is a huge literature on the Lyndon factorization, the relation between the Lyndon factorization $\CFL_{in}$ with respect to the inverse order and the canonical inverse Lyndon factorization $\ICFL$ has not been thoroughly investigated. In this paper, we address this question and we show how to obtain one factorization from the other via the notion of grouping. This result naturally opens new insights in the investigation of the relationship between $\ICFL$ and other notions, e.g., variants of Burrows Wheeler Transform, as already done for the Lyndon factorization.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.17969v1</guid>
      <category>math.CO</category>
      <category>cs.FL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Paola Bonizzoni, Clelia De Felice, Rocco Zaccagnino, Rosalba Zizza</dc:creator>
    </item>
    <item>
      <title>Tracy, Traces, and Transducers: Computable Counterexamples and Explanations for HyperLTL Model-Checking</title>
      <link>https://arxiv.org/abs/2404.18280</link>
      <description>arXiv:2404.18280v1 Announce Type: cross 
Abstract: HyperLTL model-checking enables the automated verification of information-flow properties for security-critical systems. However, it only provides a binary answer. Here, we introduce two paradigms to compute counterexamples and explanations for HyperLTL model-checking, thereby considerably increasing its usefulness. Both paradigms are based on the maxim ``counterexamples/explanations are Skolem functions for the existentially quantified trace variables''.
  Our first paradigm is complete (everything can be explained), but restricted to ultimately periodic system traces. The second paradigm works with (Turing machine) computable Skolem functions and is therefore much more general, but also shown incomplete (not everything can computably be explained). Finally, we prove that it is decidable whether a given finite transition system and a formula have computable Skolem functions witnessing that the system satisfies the formula. Our algorithm also computes transducers implementing computable Skolem functions, if they exist.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.18280v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sarah Winter, Martin Zimmermann</dc:creator>
    </item>
    <item>
      <title>A Regular and Complete Notion of Delay for Streaming String Transducers</title>
      <link>https://arxiv.org/abs/2205.04287</link>
      <description>arXiv:2205.04287v3 Announce Type: replace 
Abstract: The notion of delay between finite transducers is a core element of numerous fundamental results of transducer theory. The goal of this work is to provide a similar notion for more complex abstract machines: we introduce a new notion of delay tailored to measure the similarity between streaming string transducers (SST). We show that our notion is regular: we design a finite automaton that can check whether the delay between any two SSTs executions is smaller than some given bound. As a consequence, our notion enjoys good decidability properties: in particular, while equivalence between non-deterministic SSTs is undecidable, we show that equivalence up to fixed delay is decidable. Moreover, we show that our notion has good completeness properties: we prove that two SSTs are equivalent if and only if they are equivalent up to some (computable) bounded delay. Together with the regularity of our delay notion, it provides an alternative proof that SSTs equivalence is decidable. Finally, the definition of our delay notion is machine-independent, as it only depends on the origin semantics of SSTs. As a corollary, the completeness result also holds for equivalent machine models such as deterministic two-way transducers, or MSO transducers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2205.04287v3</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Emmanuel Filiot, Isma\"el Jecker, Christof L\"oding, Sarah Winter</dc:creator>
    </item>
    <item>
      <title>The Big-O Problem for Max-Plus Automata is Decidable (PSPACE-Complete)</title>
      <link>https://arxiv.org/abs/2304.05229</link>
      <description>arXiv:2304.05229v2 Announce Type: replace 
Abstract: We show that the big-O problem for max-plus automata is decidable and PSPACE-complete. The big-O (or affine domination) problem asks whether, given two max-plus automata computing functions f and g, there exists a constant c such that f &lt; cg+ c. This is a relaxation of the containment problem asking whether f &lt; g, which is undecidable. Our decidability result uses Simon's forest factorisation theorem, and relies on detecting specific elements, that we call witnesses, in a finite semigroup closed under two special operations: stabilisation and flattening.</description>
      <guid isPermaLink="false">oai:arXiv.org:2304.05229v2</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Laure Daviaud, David Purser, Marie Tcheng</dc:creator>
    </item>
    <item>
      <title>Rational cross-sections, bounded generation and orders on groups</title>
      <link>https://arxiv.org/abs/2210.04219</link>
      <description>arXiv:2210.04219v2 Announce Type: replace-cross 
Abstract: We provide new examples of groups without rational cross-sections (also called regular normal forms), using connections with bounded generation and rational orders on groups. Specifically, our examples are extensions of infinite torsion groups, groups of Grigorchuk type, wreath products similar to $C_2\wr(C_2\wr \mathbb Z)$ and $\mathbb Z\wr F_2$, a group of permutations of $\mathbb Z$, and a finitely presented HNN extension of the first Grigorchuk group. This last group is the first example of finitely presented group with solvable word problem and without rational cross-sections. It is also not autostackable, and has no left-regular complete rewriting system.</description>
      <guid isPermaLink="false">oai:arXiv.org:2210.04219v2</guid>
      <category>math.GR</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Corentin Bodart</dc:creator>
    </item>
    <item>
      <title>Robust Probabilistic Temporal Logics</title>
      <link>https://arxiv.org/abs/2306.05806</link>
      <description>arXiv:2306.05806v2 Announce Type: replace-cross 
Abstract: We robustify PCTL and PCTL*, the most important specification languages for probabilistic systems, and show that robustness does not increase the complexity of the model-checking problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.05806v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Martin Zimmermann</dc:creator>
    </item>
    <item>
      <title>The Complexity of Second-order HyperLTL</title>
      <link>https://arxiv.org/abs/2311.15675</link>
      <description>arXiv:2311.15675v2 Announce Type: replace-cross 
Abstract: We determine the complexity of second-order HyperLTL satisfiability, finite-state satisfiability, and model-checking: All three are as hard as truth in third-order arithmetic.
  We also consider two fragments of second-order HyperLTL that have been introduced with the aim to facilitate effective model-checking by restricting the sets one can quantify over. The first one restricts second-order quantification to smallest/largest sets that satisfy a guard while the second one restricts second-order quantification further to least fixed points of (first-order) HyperLTL definable functions.
  The first fragment is still as hard as truth in third-order arithmetic while satisfiability for the second one is $\Sigma_1^1$-complete, i.e., only as hard as (first-order) HyperLTL and therefore much less complex. Finally, finite-state satisfiability and model-checking are in $\Sigma_2^2$ and $\Sigma_1^1$-hard, and thus also less complex than model-checking full second-order HyperLTL.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.15675v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hadar Frenkel, Martin Zimmermann</dc:creator>
    </item>
    <item>
      <title>Computing Minimal Absent Words and Extended Bispecial Factors with CDAWG Space</title>
      <link>https://arxiv.org/abs/2402.18090</link>
      <description>arXiv:2402.18090v2 Announce Type: replace-cross 
Abstract: A string $w$ is said to be a minimal absent word (MAW) for a string $S$ if $w$ does not occur in $S$ and any proper substring of $w$ occurs in $S$. We focus on non-trivial MAWs which are of length at least 2. Finding such non-trivial MAWs for a given string is motivated for applications in bioinformatics and data compression. Fujishige et al. [TCS 2023] proposed a data structure of size $\Theta(n)$ that can output the set $\mathsf{MAW}(S)$ of all MAWs for a given string $S$ of length $n$ in $O(n + |\mathsf{MAW}(S)|)$ time, based on the directed acyclic word graph (DAWG). In this paper, we present a more space efficient data structure based on the compact DAWG (CDAWG), which can output $\mathsf{MAW}(S)$ in $O(|\mathsf{MAW}(S)|)$ time with $O(\mathsf{e}_\min)$ space, where $\mathsf{e}_\min$ denotes the minimum of the sizes of the CDAWGs for $S$ and for its reversal $S^R$. For any strings of length $n$, it holds that $\mathsf{e}_\min &lt; 2n$, and for highly repetitive strings $\mathsf{e}_\min$ can be sublinear (up to logarithmic) in $n$. We also show that MAWs and their generalization minimal rare words have close relationships with extended bispecial factors, via the CDAWG.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.18090v2</guid>
      <category>cs.DS</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Shunsuke Inenaga, Takuya Mieno, Hiroki Arimura, Mitsuru Funakoshi, Yuta Fujishige</dc:creator>
    </item>
    <item>
      <title>SynCode: LLM Generation with Grammar Augmentation</title>
      <link>https://arxiv.org/abs/2403.01632</link>
      <description>arXiv:2403.01632v2 Announce Type: replace-cross 
Abstract: LLMs are widely used in complex AI applications. These applications underscore the need for LLM outputs to adhere to a specific format, for their integration with other components in the systems. Typically the format rules e.g., for data serialization formats such as JSON, YAML, or Code in Programming Language are expressed as context-free grammar (CFG). Due to the hallucinations and unreliability of LLMs, instructing LLMs to adhere to specified syntax becomes an increasingly important challenge.
  We present SynCode, a novel framework for efficient and general syntactical decoding with LLMs, to address this challenge. SynCode leverages the CFG of a formal language, utilizing an offline-constructed efficient lookup table called DFA mask store based on the discrete finite automaton (DFA) of the language grammar terminals. We demonstrate SynCode's soundness and completeness given the CFG of the formal language, presenting its ability to retain syntactically valid tokens while rejecting invalid ones. SynCode seamlessly integrates with any language defined by CFG, as evidenced by experiments focusing on generating JSON, Python, and Go outputs. Our experiments evaluating the effectiveness of SynCode for JSON generation demonstrate that SynCode eliminates all syntax errors and significantly outperforms state-of-the-art baselines. Furthermore, our results underscore how SynCode significantly reduces 96.07% of syntax errors in generated Python and Go code, showcasing its substantial impact on enhancing syntactical precision in LLM generation. Our code is available at https://github.com/uiuc-focal-lab/syncode</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.01632v2</guid>
      <category>cs.LG</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shubham Ugare, Tarun Suresh, Hangoo Kang, Sasa Misailovic, Gagandeep Singh</dc:creator>
    </item>
  </channel>
</rss>
