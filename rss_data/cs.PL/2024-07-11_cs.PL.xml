<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Jul 2024 04:00:13 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 12 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Mover Logic: A Concurrent Program Logic for Reduction and Rely-Guarantee Reasoning (Extended Version)</title>
      <link>https://arxiv.org/abs/2407.08070</link>
      <description>arXiv:2407.08070v1 Announce Type: new 
Abstract: Rely-guarantee (RG) logic uses thread interference specifications (relies and guarantees) to reason about the correctness of multithreaded software. Unfortunately, RG logic requires each function postcondition to be "stabilized" or specialized to the behavior of other threads, making it difficult to write function specifications that are reusable at multiple call sites.
  This paper presents mover logic, which extends RG logic to address this problem via the notion of atomic functions. Atomic functions behave as if they execute serially without interference from concurrent threads, and so they can be assigned more general and reusable specifications that avoid the stabilization requirement of RG logic. Several practical verifiers (Calvin-R, QED, CIVL, Armada, Anchor, etc.) have demonstrated the modularity benefits of atomic function specifications. However, the complexity of these systems and their correctness proofs makes it challenging to understand and extend these systems. Mover logic formalizes the central ideas reduction in a declarative program logic that may provide foundation for future work in this area.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08070v1</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Cormac Flanagan, Stephen N. Freund</dc:creator>
    </item>
    <item>
      <title>Teaching Type Systems Implementation with Stella, an Extensible Statically Typed Programming Language</title>
      <link>https://arxiv.org/abs/2407.08089</link>
      <description>arXiv:2407.08089v1 Announce Type: new 
Abstract: We report on a half-semester course focused around implementation of type systems in programming languages. The course assumes basics of classical compiler construction, in particular, the abstract syntax representation, the Visitor pattern, and parsing. The course is built around a language Stella with a minimalistic core and a set of small extensions, covering algebraic data types, references, exceptions, exhaustive pattern matching, subtyping, recursive types, universal polymorphism, and type reconstruction. Optionally, an implementation of an interpreter and a compiler is offered to the students. To facilitate fast development and variety of implementation languages we rely on the BNF Converter tool and provide templates for the students in multiple languages. Finally, we report some results of teaching based on students' achievements.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08089v1</guid>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.405.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 405, 2024, pp. 1-19</arxiv:journal_reference>
      <dc:creator>Abdelrahman Abounegm (Innopolis University), Nikolai Kudasov (Innopolis University), Alexey Stepanov (Innopolis University)</dc:creator>
    </item>
    <item>
      <title>Functional Programming in Learning Electromagnetic Theory</title>
      <link>https://arxiv.org/abs/2407.08090</link>
      <description>arXiv:2407.08090v1 Announce Type: new 
Abstract: Electromagnetic theory is central to physics. An undergraduate major in physics typically takes a semester or a year of electromagnetic theory as a junior or senior, and a graduate student in physics typically takes an additional semester or year at a more advanced level. In fall 2023, the author taught his undergraduate electricity and magnetism class using numerical methods in Haskell in parallel with traditional analytical methods. This article describes what functional programming has to offer to physics in general, and electromagnetic theory in particular. We give examples from vector calculus, the mathematical language in which electromagnetic theory is expressed, and electromagnetic theory itself.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08090v1</guid>
      <category>cs.PL</category>
      <category>cs.MS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.405.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 405, 2024, pp. 20-35</arxiv:journal_reference>
      <dc:creator>Scott N. Walck (Lebanon Valley College)</dc:creator>
    </item>
    <item>
      <title>Programming Language Case Studies Can Be Deep</title>
      <link>https://arxiv.org/abs/2407.08091</link>
      <description>arXiv:2407.08091v1 Announce Type: new 
Abstract: In the pedagogy of programming languages, one well-known course structure is to tour multiple languages as a means of touring  paradigms. This tour-of-paradigms approach has long received criticism as lacking depth, distracting students from foundational issues in language theory and implementation. This paper argues for disentangling the idea of a tour-of-languages from the tour-of-paradigms. We make this argument by presenting, in depth, a series of case studies included in the Human-Centered Programming Languages curriculum. In this curriculum, case studies become deep, serving to tour the different intellectual foundations through which a scholar can approach programming languages, which one could call the tour-of-humans. In particular, the design aspect of programming languages has much to learn from the social sciences and humanities, yet these intellectual foundations would yield far fewer deep contributions  if we did not permit them to employ case studies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08091v1</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.405.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 405, 2024, pp. 56-79</arxiv:journal_reference>
      <dc:creator>Rose Bohrer (Worcester Polytechnic Institute)</dc:creator>
    </item>
    <item>
      <title>Finite-State Automaton To/From Regular Expression Visualization</title>
      <link>https://arxiv.org/abs/2407.08088</link>
      <description>arXiv:2407.08088v1 Announce Type: cross 
Abstract: Most Formal Languages and Automata Theory courses explore the duality between computation models to recognize words in a language and computation models to generate words in a language. For students unaccustomed to formal statements, these transformations are rarely intuitive. To assist students with such transformations, visualization tools can play a pivotal role. This article presents visualization tools developed for FSM -- a domain-specific language for the Automata Theory classroom -- to transform a finite state automaton to a regular expression and vice versa. Using these tools, the user may provide an arbitrary finite-state machine or an arbitrary regular expression and step forward and step backwards through a transformation. At each step, the visualization describes the step taken. The tools are outlined, their implementation is described, and they are compared with related work. In addition, empirical data collected from a control group is presented. The empirical data suggests that the tools are well-received, effective, and learning how to use them has a low extraneous cognitive load.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08088v1</guid>
      <category>cs.FL</category>
      <category>cs.GR</category>
      <category>cs.HC</category>
      <category>cs.PL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.405.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 405, 2024, pp. 36-55</arxiv:journal_reference>
      <dc:creator>Marco T. Moraz\'an (Seton Hall University), Tijana Mini\'c (Seton Hall University)</dc:creator>
    </item>
    <item>
      <title>Pragmatics of Formally Verified Yet Efficient Static Analysis, in particular for Formally Verified Compilers</title>
      <link>https://arxiv.org/abs/2407.08258</link>
      <description>arXiv:2407.08258v1 Announce Type: cross 
Abstract: Formally verified compilers and formally verified static analyzers are a solution to the problem that certain industries face when they have to demonstrate to authorities that the object code they run truly corresponds to its source code and that it satisfies certain properties.  From a scientific and technological point of view, they are a challenge: not only a number of nontrivial invariants and algorithms must be proved to be correct, but also the implementation must be reasonably effective so that the tools operate within reasonable time. Many optimizations in compilers rely on static analysis, and thus a formally verified compiler entails formally verified static analyses.In this article, we explain some difficulties, possible solutions, design choices and trade-offs pertaining to verified static analysis, in particular when the solution of the analysis is expressed as some form of tree, map or set.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08258v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>David Monniaux (VERIMAG - IMAG)</dc:creator>
    </item>
    <item>
      <title>AbstractBeam: Enhancing Bottom-Up Program Synthesis using Library Learning</title>
      <link>https://arxiv.org/abs/2405.17514</link>
      <description>arXiv:2405.17514v2 Announce Type: replace-cross 
Abstract: LambdaBeam is a state-of-the-art execution-guided algorithm for program synthesis that incorporates higher-order functions, lambda functions, and iterative loops into the Domain-Specific Language (DSL). LambdaBeam generates every program from the start. Yet, many program blocks or subprograms occur frequently in a given domain, e.g., loops to traverse a list. Thus, repeating programs can be used to enhance the synthesis algorithm. However, LambdaBeam fails to leverage this potential. For this purpose, we introduce AbstractBeam: A novel program synthesis framework that employs Library Learning to identify such program repetitions, integrates them into the DSL, and thus utilizes their potential to boost LambdaBeam's synthesis algorithm. Our experimental evaluations demonstrate that AbstractBeam significantly improves LambdaBeam's performance in the LambdaBeam integer list manipulation domain. Additionally, AbstractBeam's program generation is more efficient compared to LambdaBeam's synthesis. Finally, our findings indicate that Library Learning is effective in domains not specifically crafted to highlight its benefits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.17514v2</guid>
      <category>cs.SE</category>
      <category>cs.AI</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Janis Zenkner, Lukas Dierkes, Tobias Sesterhenn, Chrisitan Bartelt</dc:creator>
    </item>
  </channel>
</rss>
