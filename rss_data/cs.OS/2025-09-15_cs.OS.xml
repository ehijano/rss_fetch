<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.OS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.OS</link>
    <description>cs.OS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.OS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Sep 2025 04:01:11 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Exploring Busy Period for Worst-Case Deadline Failure Probability Analysis</title>
      <link>https://arxiv.org/abs/2509.10479</link>
      <description>arXiv:2509.10479v1 Announce Type: cross 
Abstract: Busy period is a fundamental concept in classical deterministic real-time scheduling analysis. In this deterministic context, only one busy period - which starts at the critical instant - needs to be considered, which identifies the worst-case scenario and thus paves the way for the development of efficient and safe analysis techniques. However, a recent work has revealed that, in the context of \textit{probabilistic} real-time scheduling analysis, only considering critical instant is not safe. In this paper, we address this gap by systematically analyzing deadline miss probabilities across varying busy period starting points. We propose a novel method of Worst-Case Deadline Failure Probability (WCDFP) for probabilistic fixed-priority preemptive scheduling. Experimental results demonstrate significant improvements over state-of-the-art methods achieved by our proposed method.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.10479v1</guid>
      <category>cs.NI</category>
      <category>cs.OS</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Junyi Liu, Xu Jiang, Yuanzhen Mu, Wang Yi, Nan Guan</dc:creator>
    </item>
    <item>
      <title>{\mu}Fork: Supporting POSIX fork Within a Single-Address-Space OS</title>
      <link>https://arxiv.org/abs/2509.09439</link>
      <description>arXiv:2509.09439v2 Announce Type: replace 
Abstract: Single-address-space operating systems have well-known lightweightness benefits that result from their central design idea: the kernel and applications share a unique address space. This model makes these operating systems (OSes) incompatible by design with a large class of software: multiprocess POSIX applications. Indeed, the semantics of the primitive used to create POSIX processes, fork, are inextricably tied to the existence of multiple address spaces. Prior approaches addressing this issue trade off lightweightness, compatibility and/or isolation. We propose {\mu}Fork, a single-address-space operating system design supporting POSIX fork on modern hardware without compromising on any of these key objectives. {\mu}Fork emulates POSIX processes ({\mu}processes) and achieves fork by creating for the child a copy of the parent {\mu}process' memory at a different location within a single address space. This approach presents two challenges: relocating the child's absolute memory references (pointers), as well as providing user/kernel and {\mu}processes isolation without impacting lightweightness. We address them using CHERI. We implement {\mu}Fork and evaluate it upon three real-world use-cases: Redis snapshots, Nginx multi-worker deployments, and Zygote FaaS worker warm-up. {\mu}Fork outperforms previous work and traditional monolithic OSes on key lightweightness metrics by an order of magnitude, e.g. it can offer a fork-bound FaaS function throughput 24% higher than that of a monolithic OS, and can fork a {\mu}process in 54{\mu}s, 3.7x faster than a traditional fork.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.09439v2</guid>
      <category>cs.OS</category>
      <pubDate>Tue, 16 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3731569.3764809</arxiv:DOI>
      <dc:creator>John Alistair Kressel, Hugo Lefeuvre, Pierre Olivier</dc:creator>
    </item>
  </channel>
</rss>
