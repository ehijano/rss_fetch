<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Dec 2024 05:00:40 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Non-Ground Congruence Closure</title>
      <link>https://arxiv.org/abs/2412.10066</link>
      <description>arXiv:2412.10066v1 Announce Type: new 
Abstract: Congruence closure on ground equations is a well-established, efficient algorithm for deciding ground equalities. It computes an explicit representation of the ground equivalence classes on the basis of a set of ground input equations. Then equalities are decided by membership. We generalize the ground congruence closure algorithm to non-ground equations. The algorithm also computes an explicit representation of all non-ground equivalence classes. It is terminating due to an a priori bound on the term size. By experiments we compare our new algorithm with ground congruence closure.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.10066v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hendrik Leidinger, Christoph Weidenbach</dc:creator>
    </item>
    <item>
      <title>Direct Encoding of Declare Constraints in ASP</title>
      <link>https://arxiv.org/abs/2412.10152</link>
      <description>arXiv:2412.10152v1 Announce Type: new 
Abstract: Answer Set Programming (ASP), a well-known declarative logic programming paradigm, has recently found practical application in Process Mining. In particular, ASP has been used to model tasks involving declarative specifications of business processes. In this area, Declare stands out as the most widely adopted declarative process modeling language, offering a means to model processes through sets of constraints valid traces must satisfy, that can be expressed in Linear Temporal Logic over Finite Traces (LTLf). Existing ASP-based solutions encode Declare constraints by modeling the corresponding LTLf formula or its equivalent automaton which can be obtained using established techniques. In this paper, we introduce a novel encoding for Declare constraints that directly models their semantics as ASP rules, eliminating the need for intermediate representations. We assess the effectiveness of this novel approach on two Process Mining tasks by comparing it with alternative ASP encodings and a Python library for Declare. Under consideration in Theory and Practice of Logic Programming (TPLP).</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.10152v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Francesco Chiariello, Valeria Fionda, Antonio Ielo, Francesco Ricca</dc:creator>
    </item>
    <item>
      <title>Strong Structural Bounds for MaxSAT: The Fine Details of Using Neuromorphic and Quantum Hardware Accelerators</title>
      <link>https://arxiv.org/abs/2412.10289</link>
      <description>arXiv:2412.10289v1 Announce Type: new 
Abstract: Hardware accelerators like quantum annealers or neuromorphic chips are capable of finding the ground state of a Hamiltonian. A promising route in utilizing these devices is via methods from automated reasoning: The problem at hand is first encoded into MaxSAT; then MaxSAT is reduced to Max2SAT; and finally, Max2SAT is translated into a Hamiltonian. It was observed that different encodings can dramatically affect the efficiency of the hardware accelerators. Yet, previous studies were only concerned with the size of the encodings rather than with syntactic or structural properties.
  We establish structure-aware reductions between MaxSAT, Max2SAT, and the quadratic unconstrained binary optimization problem (QUBO) that underlies such hardware accelerators. All these problems turn out to be equivalent under linear-time, treewidth-preserving reductions. As a consequence, we obtain tight lower bounds under ETH and SETH for Max2SAT and QUBO, as well as a new time-optimal fixed-parameter algorithm for QUBO. While our results are tight up to a constant additive factor for the primal treewidth, we require a constant multiplicative factor for the incidence treewidth. To close the emerging gap, we supplement our results with novel time-optimal algorithms for fragments of MaxSAT based on model counting.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.10289v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Max Bannach, Jai Grover, Markus Hecher</dc:creator>
    </item>
    <item>
      <title>A Note On Square-free Sequences and Anti-unification Type</title>
      <link>https://arxiv.org/abs/2412.10307</link>
      <description>arXiv:2412.10307v1 Announce Type: new 
Abstract: Anti-unification is a fundamental operation used for inductive inference. It is abstractly defined as a process deriving from a set of symbolic expressions a new symbolic expression possessing certain commonalities shared between its members. We consider anti-unification over term algebras where some function symbols are interpreted as associative-idempotent ($f(x,f(y,z)) = f(f(x,y),z)$ and $f(x,x)=x$, respectively) and show that there exists generalization problems for which a minimal complete set of solutions does not exist (Nullary), that is every complete set must contain comparable elements with respect to the generality relation. In contrast to earlier techniques for showing the nullarity of a generalization problem, we exploit combinatorial properties of complete sets of solutions to show that comparable elements are not avoidable. We show that every complete set of solutions contains an infinite chain of comparable generalizations whose structure is isomorphic to a subsequence of an infinite square-free sequence over three symbols.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.10307v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>David M. Cerna</dc:creator>
    </item>
    <item>
      <title>A Practical Quantum Hoare Logic with Classical Variables, I</title>
      <link>https://arxiv.org/abs/2412.09869</link>
      <description>arXiv:2412.09869v1 Announce Type: cross 
Abstract: In this paper, we present a Hoare-style logic for reasoning about quantum programs with classical variables. Our approach offers several improvements over previous work:
  (1) Enhanced expressivity of the programming language: Our logic applies to quantum programs with classical variables that incorporate quantum arrays and parameterised quantum gates, which have not been addressed in previous research on quantum Hoare logic, either with or without classical variables.
  (2) Intuitive correctness specifications: In our logic, preconditions and postconditions for quantum programs with classical variables are specified as a pair consisting of a classical first-order logical formula and a quantum predicate formula (possibly parameterised by classical variables). These specifications offer greater clarity and align more closely with the programmer's intuitive understanding of quantum and classical interactions.
  (3) Simplified proof system: By introducing a novel idea in formulating a proof rule for reasoning about quantum measurements, along with (2), we develop a proof system for quantum programs that requires only minimal modifications to classical Hoare logic. Furthermore, this proof system can be effectively and conveniently combined with classical first-order logic to verify quantum programs with classical variables.
  As a result, the learning curve for quantum program verification techniques is significantly reduced for those already familiar with classical program verification techniques, and existing tools for verifying classical programs can be more easily adapted for quantum program verification.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.09869v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Mingsheng Ying</dc:creator>
    </item>
    <item>
      <title>How to fit large complexity classes into TFNP</title>
      <link>https://arxiv.org/abs/2412.09984</link>
      <description>arXiv:2412.09984v1 Announce Type: cross 
Abstract: Subclasses of TFNP (total functional NP) are usually defined by specifying a complete problem, which is necessarily in TFNP, and including all problems many-one reducible to it. We study two notions of how a TFNP problem can be reducible to an object, such as a complexity class, outside TFNP. This gives rise to subclasses of TFNP which capture some properties of that outside object. We show that well-known subclasses can arise in this way, for example PPA from reducibility to parity P and PLS from reducibility to P^NP.
  We study subclasses arising from PSPACE and the polynomial hierarchy, and show that they are characterized by the propositional proof systems Frege and constant-depth Frege, extending the known pairings between natural TFNP subclasses and proof systems.
  We study approximate counting from this point of view, and look for a subclass of TFNP that gives a natural home to combinatorial principles such as Ramsey which can be proved using approximate counting. We relate this to the recently-studied Long choice and Short choice problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.09984v1</guid>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Neil Thapen</dc:creator>
    </item>
    <item>
      <title>Translating Three-Variable First-Order Predicate Logic to Relation Algebra, Implemented using Z3</title>
      <link>https://arxiv.org/abs/2308.02513</link>
      <description>arXiv:2308.02513v4 Announce Type: replace 
Abstract: This paper presents the development of a software tool that enables the translation of first-order predicate logic with at most three variables into relation algebra. The tool was developed using the Z3 theorem prover, leveraging its capabilities to enhance reliability, generate code, and expedite development. The resulting standalone Python program allows users to translate first-order logic formulas into relation algebra, eliminating the need to work with relation algebra explicitly. This paper outlines the theoretical background of first-order logic, relation algebra, and the translation process. It also describes the implementation details, including validation of the software tool using Z3 for testing correctness. By demonstrating the feasibility of utilizing first-order logic as an alternative language for expressing relation algebra, this tool paves the way for integrating first-order logic into tools traditionally relying on relation algebra as input.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.02513v4</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anthony Brogni, Sebastiaan J. C. Joosten</dc:creator>
    </item>
    <item>
      <title>Bluebell: An Alliance of Relational Lifting and Independence For Probabilistic Reasoning</title>
      <link>https://arxiv.org/abs/2402.18708</link>
      <description>arXiv:2402.18708v2 Announce Type: replace 
Abstract: We present Bluebell, a program logic for reasoning about probabilistic programs where unary and relational styles of reasoning come together to create new reasoning tools. Unary-style reasoning is very expressive and is powered by foundational mechanisms to reason about probabilistic behaviour like independence and conditioning. The relational style of reasoning, on the other hand, naturally shines when the properties of interest compare the behaviour of similar programs (e.g. when proving differential privacy) managing to avoid having to characterize the output distributions of the individual programs. So far, the two styles of reasoning have largely remained separate in the many program logics designed for the deductive verification of probabilistic programs. In Bluebell, we unify these styles of reasoning through the introduction of a new modality called "joint conditioning" that can encode and illuminate the rich interaction between conditional independence and relational liftings; the two powerhouses from the two styles of reasoning.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.18708v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3704894</arxiv:DOI>
      <arxiv:journal_reference>Proc. ACM Program. Lang. 9, POPL, Article 58 (January 2025)</arxiv:journal_reference>
      <dc:creator>Jialu Bao, Emanuele D'Osualdo, Azadeh Farzan</dc:creator>
    </item>
    <item>
      <title>Language Inclusion for Boundedly-Ambiguous Vector Addition Systems is Decidable</title>
      <link>https://arxiv.org/abs/2202.08033</link>
      <description>arXiv:2202.08033v4 Announce Type: replace-cross 
Abstract: We consider the problems of language inclusion and language equivalence for Vector Addition Systems with States (VASSes) with the acceptance condition defined by the set of accepting states (and more generally by some upward-closed conditions). In general the problem of language equivalence is undecidable even for one-dimensional VASSes, thus to get decidability we investigate restricted subclasses. On one hand we show that the problem of language inclusion of a VASS in k-ambiguous VASS (for any natural k) is decidable and even in Ackermann. On the other hand we prove that the language equivalence problem is Ackermann-hard already for deterministic VASSes. These two results imply Ackermann-completeness for language inclusion and equivalence in several possible restrictions. Some of our techniques can be also applied in much broader generality in infinite-state systems, namely for some subclass of well-structured transition systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2202.08033v4</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.CONCUR.2022.16</arxiv:DOI>
      <arxiv:journal_reference>LIPIcs, 2022, 243, 16:1--16:22, Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik</arxiv:journal_reference>
      <dc:creator>Wojciech Czerwi\'nski, Piotr Hofman</dc:creator>
    </item>
    <item>
      <title>Positional $\omega$-regular languages</title>
      <link>https://arxiv.org/abs/2401.15384</link>
      <description>arXiv:2401.15384v3 Announce Type: replace-cross 
Abstract: In the context of two-player games over graphs, a language $L$ is called positional if, in all games using $L$ as winning objective, the protagonist can play optimally using positional strategies, that is, strategies that do not depend on the history of the play. In this work, we describe the class of parity automata recognising positional languages, providing a complete characterisation of positionality for $\omega$-regular languages. As corollaries, we establish decidability of positionality in polynomial time, finite-to-infinite and 1-to-2-players lifts, and show the closure under union of prefix-independent positional objectives, answering a conjecture by Kopczy\'nski in the $\omega$-regular case.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.15384v3</guid>
      <category>cs.FL</category>
      <category>cs.GT</category>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antonio Casares, Pierre Ohlmann</dc:creator>
    </item>
    <item>
      <title>Solving Epistemic Logic Programs using Generate-and-Test with Propagation</title>
      <link>https://arxiv.org/abs/2410.22130</link>
      <description>arXiv:2410.22130v2 Announce Type: replace-cross 
Abstract: This paper introduces a general framework for generate-and-test-based solvers for epistemic logic programs that can be instantiated with different generator and tester programs, and we prove sufficient conditions on those programs for the correctness of the solvers built using this framework. It also introduces a new generator program that incorporates the propagation of epistemic consequences and shows that this can exponentially reduce the number of candidates that need to be tested while only incurring a linear overhead. We implement a new solver based on these theoretical findings and experimentally show that it outperforms existing solvers by achieving a ~3.3x speed-up and solving 91% more instances on well-known benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.22130v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Mon, 16 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jorge Fandinno, Lute Lillo</dc:creator>
    </item>
  </channel>
</rss>
