<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 Oct 2024 04:02:16 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Synthesis of Timeline-Based Planning Strategies Avoiding Determinization</title>
      <link>https://arxiv.org/abs/2410.22757</link>
      <description>arXiv:2410.22757v1 Announce Type: new 
Abstract: Qualitative timeline-based planning models domains as sets of independent, but interacting, components whose behaviors over time, the timelines, are governed by sets of qualitative temporal constraints (ordering relations), called synchronization rules. Its plan-existence problem has been shown to be PSPACE-complete; in particular, PSPACE-membership has been proved via reduction to the nonemptiness problem for nondeterministic finite automata. However, nondeterministic automata cannot be directly used to synthesize planning strategies as a costly determinization step is needed. In this paper, we identify a large fragment of qualitative timeline-based planning whose plan-existence problem can be directly mapped into the nonemptiness problem of deterministic finite automata, which can then be exploited to synthesize strategies. In addition, we identify a  maximal subset of Allen's relations that fits into such a deterministic fragment.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.22757v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.409.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 409, 2024, pp. 5-18</arxiv:journal_reference>
      <dc:creator>Renato Acampora (University of Udine, Italy), Dario Della Monica (University of Udine, Italy), Luca Geatti (University of Udine, Italy), Nicola Gigante (Free University of Bozen-Bolzano, Italy), Angelo Montanari (University of Udine, Italy), Pietro Sala (University of Verona, Italy)</dc:creator>
    </item>
    <item>
      <title>Deterministic Suffix-reading Automata</title>
      <link>https://arxiv.org/abs/2410.22761</link>
      <description>arXiv:2410.22761v1 Announce Type: new 
Abstract: We introduce deterministic suffix-reading automata (DSA), a new automaton model over finite words. Transitions in a DSA are labeled with words. From a state, a DSA triggers an outgoing transition on seeing a word ending with the transition's label. Therefore, rather than moving along an input word letter by letter, a DSA can jump along blocks of letters, with each block ending in a suitable suffix. This feature allows DSAs to recognize regular languages more concisely, compared to DFAs. In this work, we focus on questions around finding a "minimal" DSA for a regular language. The number of states is not a faithful measure of the size of a DSA, since the transition-labels contain strings of arbitrary length. Hence, we consider total-size (number of states + number of edges + total length of transition-labels) as the size measure of DSAs.
  We start by formally defining the model and providing a DSA-to-DFA conversion that allows to compare the expressiveness and succinctness of DSA with related automata models.  Our main technical contribution is a method to derive DSAs from a given DFA: a DFA-to-DSA conversion. We make a surprising observation that the smallest DSA derived from the canonical DFA of a regular language L need not be a minimal DSA for L. This observation leads to a fundamental bottleneck in deriving a minimal DSA for a regular language. In fact, we prove that given a DFA and a number k, the problem of deciding if there exists an equivalent DSA of total-size at most k is NP-complete.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.22761v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.409.9</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 409, 2024, pp. 70-87</arxiv:journal_reference>
      <dc:creator>R Keerthan, B Srivathsan, R Venkatesh, Sagar Verma</dc:creator>
    </item>
    <item>
      <title>Two-Way One-Counter Nets Revisited</title>
      <link>https://arxiv.org/abs/2410.22845</link>
      <description>arXiv:2410.22845v1 Announce Type: new 
Abstract: One Counter Nets (OCNs) are finite-state automata equipped with a counter that cannot become negative, but cannot be explicitly tested for zero. Their close connection to various other models (e.g., PDAs, Vector Addition Systems, and Counter Automata) make them an attractive modeling tool. The two-way variant of OCNs (2-OCNs) was introduced in the 1980's and shown to be more expressive than OCNs, so much so that the emptiness problem is undecidable already in the deterministic model (2-DOCNs). In a first part, we study the emptiness problem of natural restrictions of 2-OCNs, under the light of modern results about Vector Addition System with States (VASS). We show that emptiness is decidable for 2-OCNs over \emph{bounded languages} i.e., languages contained in $a_1^*a_2^*\cdots a_k^*$), and decidable and Ackermann-complete for \emph{sweeping} 2-OCNs, where the head direction only changes at the end-markers. Both decidability results revolve around reducing the problem to VASS reachability, but they rely on strikingly different approaches.
  In a second part, we study the expressive power of 2-OCNs, showing an array of connections between bounded languages, sweeping 2-OCNs, and semilinear languages. Most noteworthy among these connections, is that the bounded languages recognized by sweeping 2-OCNs are precisely those that are semilinear. Finally, we establish an intricate pumping lemma for 2-DOCNs and use it to show that there are OCN languages that are not 2-DOCN recognizable, improving on the known result that there are such 2-OCN languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.22845v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shaull Almagor, Micha\"el Cadilhac, Asaf Yeshurun</dc:creator>
    </item>
    <item>
      <title>Explorable Parity Automata</title>
      <link>https://arxiv.org/abs/2410.23187</link>
      <description>arXiv:2410.23187v1 Announce Type: new 
Abstract: We define the class of explorable automata on finite or infinite words. This is a generalization of History-Deterministic (HD) automata, where this time non-deterministic choices can be resolved by building finitely many simultaneous runs instead of just one. We show that recognizing HD parity automata of fixed index among explorable ones is in PTime, thereby giving a strong link between the two notions. We then show that recognizing explorable automata is ExpTime-complete, in the case of finite words or parity automata up to index [0, 2]. Additionally, we define the notion of {\omega}-explorable automata on infinite words, where countably many runs can be used to resolve the non-deterministic choices. We show ExpTime-completeness for {\omega}-explorability of automata on infinite words for the safety and coB\"uchi acceptance conditions. We finally characterize the expressivity of ({\omega}-)explorable automata with respect to the parity index hierarchy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.23187v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Emile Hazard, Olivier Idir, Denis Kuperberg</dc:creator>
    </item>
    <item>
      <title>Adding Reconfiguration to Zielonka's Asynchronous Automata</title>
      <link>https://arxiv.org/abs/2305.01425</link>
      <description>arXiv:2305.01425v2 Announce Type: replace 
Abstract: We study an extension of Zielonka's (fixed) asynchronous automata called reconfigurable asynchronous automata where processes can dynamically change who they communicate with. We show that reconfigurable asynchronous automata are not more expressive than fixed asynchronous automata by giving translations from one to the other.  However, going from reconfigurable to fixed comes at the cost of disseminating communication (and knowledge) to all processes in the system. We then show that this is unavoidable by describing a language accepted by a reconfigurable automaton such that in every equivalent fixed automaton, every process must either be aware of all communication or be irrelevant.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.01425v2</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.409.10</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 409, 2024, pp. 88-102</arxiv:journal_reference>
      <dc:creator>Mathieu Lehaut (University of Gothenburg), Nir Piterman (University of Gothenburg)</dc:creator>
    </item>
    <item>
      <title>Masked Hard-Attention Transformers Recognize Exactly the Star-Free Languages</title>
      <link>https://arxiv.org/abs/2310.13897</link>
      <description>arXiv:2310.13897v4 Announce Type: replace 
Abstract: The expressive power of transformers over inputs of unbounded size can be studied through their ability to recognize classes of formal languages. In this paper, we establish exact characterizations of transformers with hard attention (in which all attention is focused on exactly one position) and attention masking (in which each position only attends to positions on one side). With strict masking (each position cannot attend to itself) and without position embeddings, these transformers are expressively equivalent to linear temporal logic (LTL), which defines exactly the star-free languages. A key technique is the use of Boolean RASP as a convenient intermediate language between transformers and LTL. We then take numerous results known for LTL and apply them to transformers, showing how position embeddings, strict masking, and depth all increase expressive power.</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.13897v4</guid>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Andy Yang, David Chiang, Dana Angluin</dc:creator>
    </item>
    <item>
      <title>Active Learning of Mealy Machines with Timers</title>
      <link>https://arxiv.org/abs/2403.02019</link>
      <description>arXiv:2403.02019v2 Announce Type: replace 
Abstract: We present the first algorithm for query learning of a class of Mealy machines with timers in a black-box context. Our algorithm is an extension of the L# algorithm of Vaandrager et al. to a timed setting. We rely on symbolic queries which empower us to reason on untimed executions while learning. Similarly to the algorithm for learning timed automata of Waga, these symbolic queries can be implemented using finitely many concrete queries. Experiments with a prototype implementation, written in Rust, show that our algorithm is able to efficiently learn realistic benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.02019v2</guid>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>V\'eronique Bruy\`ere, Bharat Garhewal, Guillermo A. P\'erez, Ga\"etan Staquet, Frits W. Vaandrager</dc:creator>
    </item>
    <item>
      <title>Jumping Automata Must Pay</title>
      <link>https://arxiv.org/abs/2405.11849</link>
      <description>arXiv:2405.11849v2 Announce Type: replace 
Abstract: Jumping automata are finite automata that read their input in a non-sequential manner, by allowing a reading head to "jump" between positions on the input, consuming a permutation of the input word. We argue that allowing the head to jump should incur some cost. To this end, we propose three quantitative semantics for jumping automata, whereby the jumps of the head in an accepting run define the cost of the run. The three semantics correspond to different interpretations of jumps: the absolute distance semantics counts the distance the head jumps, the reversal semantics counts the number of times the head changes direction, and the Hamming distance measures the number of letter-swaps the run makes.
  We study these measures, with the main focus being the boundedness problem: given a jumping automaton, decide whether its (quantitative) languages is bounded by some given number k. We establish the decidability and complexity for this problem under several variants.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.11849v2</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 31 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.409.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 409, 2024, pp. 19-34</arxiv:journal_reference>
      <dc:creator>Shaull Almagor (Technion), Ishai Salgado (Technion)</dc:creator>
    </item>
  </channel>
</rss>
