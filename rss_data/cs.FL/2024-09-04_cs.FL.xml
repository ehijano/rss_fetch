<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Sep 2024 01:46:56 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Attractor Basins in Concurrent Systems</title>
      <link>https://arxiv.org/abs/2409.01079</link>
      <description>arXiv:2409.01079v1 Announce Type: new 
Abstract: A crucial question in analyzing a concurrent system is to determine its long-run behaviour, and in particular, whether there are irreversible choices in its evolution, leading into parts of the reachability space from which there is no return to other parts. Casting this problem in the unifying framework of safe Petri nets, our previous work has provided techniques for identifying attractors, i.e. terminal strongly connected components of the reachability space. What we aim at is to determine the attraction basins associated to those attractors; that is, those states from where all infinite runs are doomed to end in the given attractor, as opposed to those that are free to evolve differently. Here, we provide a solution for the case of safe Petri nets. Our algorithm uses net unfoldings and provides a map of all of those configurations (concurrent executions of the system) that lead onto cliff-edges, i.e. any maximal extension for those configurations lies in some basin that is considered fatal.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.01079v1</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Giann Karlo Aguirre Samboni, Stefan Haar, Loic Paulev\'e, Stefan Schwoon, Nick W\"urdemann</dc:creator>
    </item>
    <item>
      <title>Completing the picture for the Skolem Problem on order-4 linear recurrence sequences</title>
      <link>https://arxiv.org/abs/2409.01221</link>
      <description>arXiv:2409.01221v1 Announce Type: new 
Abstract: For almost a century, the decidability of the Skolem Problem - that is, the problem of finding whether a given linear recurrence sequence (LRS) has a zero term - has remained open. A breakthrough in the 1980s established that the Skolem Problem is indeed decidable for algebraic LRS of order at most 3, and real algebraic LRS of order at most 4. However, for general algebraic LRS of order 4 the question of decidability has remained open. Our main contribution in this paper is to prove decidability for this last case, i.e. we show that the Skolem Problem is decidable for all algebraic LRS of order at most 4.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.01221v1</guid>
      <category>cs.FL</category>
      <category>math.NT</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Piotr Bacik</dc:creator>
    </item>
    <item>
      <title>Constructing Concise Characteristic Samples for Acceptors of Omega Regular Languages</title>
      <link>https://arxiv.org/abs/2209.09336</link>
      <description>arXiv:2209.09336v5 Announce Type: replace 
Abstract: A characteristic sample for a language $L$ and a learning algorithm $\textbf{L}$ is a finite sample of words $T_L$ labeled by their membership in $L$ such that for any sample $T \supseteq T_L$ consistent with $L$, on input $T$ the learning algorithm $\textbf{L}$ returns a hypothesis equivalent to $L$. Which omega automata have characteristic sets of polynomial size, and can these sets be constructed in polynomial time? We address these questions here.
  In brief, non-deterministic omega automata of any of the common types, in particular B\"uchi, do not have characteristic samples of polynomial size. For deterministic omega automata that are isomorphic to their right congruence automata, the fully informative languages, polynomial time algorithms for constructing characteristic samples and learning from them are given.
  The algorithms for constructing characteristic sets in polynomial time for the different omega automata (of types B\"uchi, coB\"uchi, parity, Rabin, Street, or Muller), require deterministic polynomial time algorithms for (1) equivalence of the respective omega automata, and (2) testing membership of the language of the automaton in the informative classes, which we provide.</description>
      <guid isPermaLink="false">oai:arXiv.org:2209.09336v5</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dana Angluin, Dana Fisman</dc:creator>
    </item>
    <item>
      <title>Completeness Theorems for Kleene algebra with tests and top</title>
      <link>https://arxiv.org/abs/2304.07190</link>
      <description>arXiv:2304.07190v4 Announce Type: replace 
Abstract: We prove two completeness results for Kleene algebra with tests and a top element, with respect to guarded string languages and binary relations. While the equational theories of those two classes of models coincide over the signature of Kleene algebra, this is no longer the case when we consider an additional constant ``top'' for the full element. Indeed, the full relation satisfies more laws than the full language, and we show that those additional laws can all be derived from a single additional axiom. We recover that the two equational theories coincide if we slightly generalise the notion of relational model, allowing sub-algebras of relations where top is a greatest element but not necessarily the full relation. We use models of closed languages and reductions in order to prove our completeness results, which are relative to any axiomatisation of the algebra of regular events. For one of our constructions, we extend the concept of finite monoid recognisability to guarded-string languages; this device makes it possible to obtain a PSpace algorithm for the equational theory of binary relations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2304.07190v4</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Damien Pous, Jana Wagemaker</dc:creator>
    </item>
    <item>
      <title>Random Deterministic Automata With One Added Transition</title>
      <link>https://arxiv.org/abs/2402.06591</link>
      <description>arXiv:2402.06591v2 Announce Type: replace 
Abstract: Every language recognized by a non-deterministic finite automaton can be recognized by a deterministic automaton, at the cost of a potential increase of the number of states, which in the worst case can go from $n$ states to $2^n$ states. In this article, we investigate this classical result in a probabilistic setting where we take a deterministic automaton with $n$ states uniformly at random and add just one random transition. These automata are almost deterministic in the sense that only one state has a non-deterministic choice when reading an input letter. In our model, each state has a fixed probability to be final. We prove that for any $d\geq 1$, with non-negligible probability the minimal (deterministic) automaton of the language recognized by such an automaton has more than $n^d$ states; as a byproduct, the expected size of its minimal automaton grows faster than any polynomial. Our result also holds when each state is final with some probability that depends on $n$, as long as it is not too close to $0$ and $1$, at distance at least $\Omega(\frac1{\sqrt{n}})$ to be precise, therefore allowing models with a sublinear number of final states in expectation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.06591v2</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Arnaud Carayol, Philippe Duchon, Florent Koechlin, Cyril Nicaud</dc:creator>
    </item>
    <item>
      <title>MLRegTest: A Benchmark for the Machine Learning of Regular Languages</title>
      <link>https://arxiv.org/abs/2304.07687</link>
      <description>arXiv:2304.07687v4 Announce Type: replace-cross 
Abstract: Synthetic datasets constructed from formal languages allow fine-grained examination of the learning and generalization capabilities of machine learning systems for sequence classification. This article presents a new benchmark for machine learning systems on sequence classification called MLRegTest, which contains training, development, and test sets from 1,800 regular languages. Different kinds of formal languages represent different kinds of long-distance dependencies, and correctly identifying long-distance dependencies in sequences is a known challenge for ML systems to generalize successfully. MLRegTest organizes its languages according to their logical complexity (monadic second order, first order, propositional, or monomial expressions) and the kind of logical literals (string, tier-string, subsequence, or combinations thereof). The logical complexity and choice of literal provides a systematic way to understand different kinds of long-distance dependencies in regular languages, and therefore to understand the capacities of different ML systems to learn such long-distance dependencies. Finally, the performance of different neural networks (simple RNN, LSTM, GRU, transformer) on MLRegTest is examined. The main conclusion is that performance depends significantly on the kind of test set, the class of language, and the neural network architecture.</description>
      <guid isPermaLink="false">oai:arXiv.org:2304.07687v4</guid>
      <category>cs.LG</category>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sam van der Poel, Dakotah Lambert, Kalina Kostyszyn, Tiantian Gao, Rahul Verma, Derek Andersen, Joanne Chau, Emily Peterson, Cody St. Clair, Paul Fodor, Chihiro Shibata, Jeffrey Heinz</dc:creator>
    </item>
    <item>
      <title>A Framework for Universality in Physics, Computer Science, and Beyond</title>
      <link>https://arxiv.org/abs/2307.06851</link>
      <description>arXiv:2307.06851v3 Announce Type: replace-cross 
Abstract: Turing machines and spin models share a notion of universality according to which some simulate all others. Is there a theory of universality that captures this notion? We set up a categorical framework for universality which includes as instances universal Turing machines, universal spin models, NP completeness, top of a preorder, denseness of a subset, and more. By identifying necessary conditions for universality, we show that universal spin models cannot be finite. We also characterize when universality can be distinguished from a trivial one and use it to show that universal Turing machines are non-trivial in this sense. Our framework allows not only to compare universalities within each instance, but also instances themselves. We leverage a Fixed Point Theorem inspired by a result of Lawvere to establish that universality and negation give rise to unreachability (such as uncomputability). As such, this work sets the basis for a unified approach to universality and invites the study of further examples within the framework.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.06851v3</guid>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>math-ph</category>
      <category>math.MP</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <arxiv:DOI>10.46298/compositionality-6-3</arxiv:DOI>
      <arxiv:journal_reference>Compositionality, Volume 6 (2024) (August 29, 2024) compositionality:14134</arxiv:journal_reference>
      <dc:creator>Tom\'a\v{s} Gonda, Tobias Reinhart, Sebastian Stengele, Gemma De les Coves</dc:creator>
    </item>
    <item>
      <title>The Complexity of Second-order HyperLTL</title>
      <link>https://arxiv.org/abs/2311.15675</link>
      <description>arXiv:2311.15675v3 Announce Type: replace-cross 
Abstract: We determine the complexity of second-order HyperLTL satisfiability, finite-state satisfiability, and model-checking: All three are as hard as truth in third-order arithmetic.
  We also consider two fragments of second-order HyperLTL that have been introduced with the aim to facilitate effective model-checking by restricting the sets one can quantify over. The first one restricts second-order quantification to smallest/largest sets that satisfy a guard while the second one restricts second-order quantification further to least fixed points of (first-order) HyperLTL definable functions. The first fragment is still as hard as truth in third-order arithmetic while satisfiability for the second one is $\Sigma_1^1$-complete, i.e., only as hard as (first-order) HyperLTL and therefore much less complex. Finally, finite-state satisfiability and model-checking are in $\Sigma_2^2$ and $\Sigma_1^1$-hard, and thus also less complex than for full second-order HyperLTL.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.15675v3</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Wed, 04 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hadar Frenkel, Martin Zimmermann</dc:creator>
    </item>
  </channel>
</rss>
