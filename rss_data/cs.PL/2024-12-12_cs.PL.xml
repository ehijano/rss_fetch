<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Dec 2024 02:43:52 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 12 Dec 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Scalable, Validated Code Translation of Entire Projects using Large Language Models</title>
      <link>https://arxiv.org/abs/2412.08035</link>
      <description>arXiv:2412.08035v1 Announce Type: new 
Abstract: Large language models (LLMs) show promise in code translation due to their ability to generate idiomatic code. However, a significant limitation when using LLMs for code translation is scalability: existing works have shown a drop in translation success rates for code exceeding around 100 lines. We overcome this limitation by developing a modular approach to translation, where we partition the code into small code fragments which can be translated independently and semantically validated (that is, checking I/O equivalence). When this approach is applied naively, we discover that LLMs are unreliable when translating features of the source language that do not have a direct mapping to the target language, and that the LLM often gets stuck in repair loops when attempting to fix errors. To address these issues, we introduce two key concepts: (1) feature mapping, which integrates predefined translation rules with LLM-based translation to guide the LLM in navigating subtle language differences and producing semantically accurate code; and (2) type-compatibility, which facilitates localized checks at the function signature level to detect errors early, thereby narrowing the scope of potential repairs. We apply our approach to translating real-world Go codebases to Rust, demonstrating that we can consistently generate reliable Rust translations for projects up to 6,600 lines of code and 369 functions, with an average of 73% of functions successfully validated for I/O equivalence, considerably higher than any existing work.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.08035v1</guid>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Thu, 12 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hanliang Zhang, Cristina David, Meng Wang, Brandon Paulsen, Daniel Kroening</dc:creator>
    </item>
    <item>
      <title>A Gentle Overview of Asynchronous Session-based Concurrency: Deadlock Freedom by Typing</title>
      <link>https://arxiv.org/abs/2412.08232</link>
      <description>arXiv:2412.08232v1 Announce Type: new 
Abstract: While formal models of concurrency tend to focus on synchronous communication, asynchronous communication is relevant in practice. In this paper, we will discuss asynchronous communication in the context of session-based concurrency, the model of computation in which session types specify the structure of the two-party protocols implemented by the channels of a communicating process. We overview recent work on addressing the challenge of ensuring the deadlock-freedom property for message-passing processes that communicate asynchronously in cyclic process networks governed by session types. We offer a  gradual presentation of three typed process frameworks and outline how they may be used to guarantee deadlock freedom for a concurrent functional language with sessions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.08232v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 12 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.414.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 414, 2024, pp. 1-20</arxiv:journal_reference>
      <dc:creator>Bas van den Heuvel (Karlsruhe University of Applied Sciences, Karlsruhe,,University of Freiburg, Freiburg, Germany), Jorge A. P\'erez (University of Groningen, The Netherlands)</dc:creator>
    </item>
    <item>
      <title>An Overview of the Decentralized Reconfiguration Language Concerto-D through its Maude Formalization</title>
      <link>https://arxiv.org/abs/2412.08233</link>
      <description>arXiv:2412.08233v1 Announce Type: new 
Abstract: We propose an overview of the decentralized reconfiguration language Concerto-D through its Maude formalization. Concerto-D extends the already published Concerto language. Concerto-D improves on two different parameters compared with related work: the decentralized coordination of numerous local reconfiguration plans which avoid a single point of failure when considering unstable networks such as edge computing, or cyber-physical systems (CPS) for instance; and a mechanized formal semantics of the language with Maude which offers guarantees on the executability of the semantics. Throughout the paper, the Concerto-D language and its semantics are exemplified with a reconfiguration extracted from a real case study on a CPS. We rely on the Maude formal specification language, which is based on rewriting logic, and consequently perfectly suited for describing a concurrent model.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.08233v1</guid>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Thu, 12 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.414.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 414, 2024, pp. 21-38</arxiv:journal_reference>
      <dc:creator>Farid Arfi (IMT Atlantique), H\'el\`ene Coullon (IMT Atlantique), Fr\'ed\'eric Loulergue (University of Orleans), Jolan Philippe (IMT Atlantique), Simon Robillard (University of Montpellier)</dc:creator>
    </item>
    <item>
      <title>The B2Scala Tool: Integrating Bach in Scala with Security in Mind</title>
      <link>https://arxiv.org/abs/2412.08235</link>
      <description>arXiv:2412.08235v1 Announce Type: new 
Abstract: Process algebras have been widely used to verify security protocols in a formal manner. However they mostly focus on synchronous communication based on the exchange of messages. We present an alternative approach relying on asynchronous communication obtained through information available on a shared space. More precisely this paper first proposes an embedding in Scala of a Linda-like language, called Bach.  It consists of a Domain Specific Language, internal to Scala, that allows us to experiment programs developed in Bach while benefiting from the Scala eco-system, in particular from its type system as well as program fragments developed in Scala. Moreover, we introduce a logic that allows to restrict the executions of programs to those meeting logic formulae. Our work is illustrated on the Needham-Schroeder security protocol, for which we manage to automatically rediscover the man-in-the-middle attack first put in evidence by G. Lowe.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.08235v1</guid>
      <category>cs.PL</category>
      <category>cs.MA</category>
      <category>cs.SC</category>
      <pubDate>Thu, 12 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.414.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 414, 2024, pp. 58-76</arxiv:journal_reference>
      <dc:creator>Doha Ouardi (University of Namur), Manel Barkallah (University of Namur), Jean-Marie Jacquet (University of Namur)</dc:creator>
    </item>
    <item>
      <title>Crash-Stop Failures in Asynchronous Multiparty Session Types</title>
      <link>https://arxiv.org/abs/2311.11851</link>
      <description>arXiv:2311.11851v4 Announce Type: replace-cross 
Abstract: Session types provide a typing discipline for message-passing systems. However, their theory often assumes an ideal world: one in which everything is reliable and without failures. Yet this is in stark contrast with distributed systems in the real world. To address this limitation, we introduce a new asynchronous multiparty session types (MPST) theory with crash-stop failures, where processes may crash arbitrarily and cease to interact after crashing. We augment asynchronous MPST and processes with crash handling branches, and integrate crash-stop failure semantics into types and processes. Our approach requires no user-level syntax extensions for global types, and features a formalisation of global semantics, which captures complex behaviours induced by crashed/crash handling processes.
  Our new theory covers the entire spectrum, ranging from the ideal world of total reliability to entirely unreliable scenarios where any process may crash, using optional reliability assumptions. Under these assumptions, we demonstrate the sound and complete correspondence between global and local type semantics, which guarantee deadlock-freedom, protocol conformance, and liveness of well-typed processes by construction, even in the presence of crashes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.11851v4</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 12 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Adam D. Barwell, Ping Hou, Nobuko Yoshida, Fangyi Zhou</dc:creator>
    </item>
    <item>
      <title>How secure is AI-generated Code: A Large-Scale Comparison of Large Language Models</title>
      <link>https://arxiv.org/abs/2404.18353</link>
      <description>arXiv:2404.18353v2 Announce Type: replace-cross 
Abstract: This study compares state-of-the-art Large Language Models (LLMs) on their tendency to generate vulnerabilities when writing C programs using a neutral zero-shot prompt. Tihanyi et al. introduced the FormAI dataset at PROMISE'23, featuring 112,000 C programs generated by GPT-3.5-turbo, with over 51.24% identified as vulnerable. We extended that research with a large-scale study involving 9 state-of-the-art models such as OpenAI's GPT-4o-mini, Google's Gemini Pro 1.0, TII's 180 billion-parameter Falcon, Meta's 13 billion-parameter Code Llama, and several other compact models. Additionally, we introduce the FormAI-v2 dataset, which comprises 331 000 compilable C programs generated by these LLMs. Each program in the dataset is labeled based on the vulnerabilities detected in its source code through formal verification, using the Efficient SMT-based Context-Bounded Model Checker (ESBMC). This technique minimizes false positives by providing a counterexample for the specific vulnerability and reduces false negatives by thoroughly completing the verification process. Our study reveals that at least 62.07% of the generated programs are vulnerable. The differences between the models are minor, as they all show similar coding errors with slight variations. Our research highlights that while LLMs offer promising capabilities for code generation, deploying their output in a production environment requires proper risk assessment and validation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.18353v2</guid>
      <category>cs.CR</category>
      <category>cs.AI</category>
      <category>cs.PL</category>
      <pubDate>Thu, 12 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/s10664-024-10590-1.</arxiv:DOI>
      <dc:creator>Norbert Tihanyi, Tamas Bisztray, Mohamed Amine Ferrag, Ridhi Jain, Lucas C. Cordeiro</dc:creator>
    </item>
  </channel>
</rss>
