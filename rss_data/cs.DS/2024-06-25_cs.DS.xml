<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Jun 2024 01:47:02 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 25 Jun 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Calculation of the Comparative Efficiency of Algorithms Using a Single Metric</title>
      <link>https://arxiv.org/abs/2406.15510</link>
      <description>arXiv:2406.15510v1 Announce Type: new 
Abstract: While time complexity and space complexity of an algorithm helps to determine its efficiency when time or space needs to be optimized respectively, they fail to determine the more efficient algorithm when time and space both need to be optimized simultaneously. This resulted in the development of the A1-Score Factor which solve the problem i.e., helps to find the algorithm which optimizes both time and space simultaneously. The following research paper contains the hypothesis, the proof, the theoretical and the graphical implementation of the A1-Score Factor along with the use cases of the same.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.15510v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.22214/ijraset.2023.50714</arxiv:DOI>
      <arxiv:journal_reference>International Journal for Research in Applied Science and Engineering Technology, Volume 11, Issue IV (2023) 2549-2553</arxiv:journal_reference>
      <dc:creator>Arya Chakraborty</dc:creator>
    </item>
    <item>
      <title>Exponential Time Approximation for Coloring 3-Colorable Graphs</title>
      <link>https://arxiv.org/abs/2406.15563</link>
      <description>arXiv:2406.15563v1 Announce Type: new 
Abstract: The problem of efficiently coloring $3$-colorable graphs with few colors has received much attention on both the algorithmic and inapproximability fronts. We consider exponential time approximations, in which given a parameter $r$, we aim to develop an $r$-approximation algorithm with the best possible runtime, providing a tradeoff between runtime and approximation ratio. In this vein, an algorithm to $O(n^\varepsilon)$-color a 3-colorable graphs in time $2^{\Theta(n^{1-2\varepsilon}\log(n))}$ is given in (Atserias and Dalmau, SODA 2022.)
  We build on tools developed in (Bansal et al., Algorithmic, 2019) to obtain an algorithm to color $3$-colorable graphs with $O(r)$ colors in $\exp\left(\tilde{O}\left(\frac {n\log^{11/2}r} {r^3}\right)\right)$ time, asymptotically improving upon the bound given by Atserias and Dalmau.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.15563v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Venkatesan Guruswami, Rhea Jain</dc:creator>
    </item>
    <item>
      <title>Pairwise-Independent Contention Resolution</title>
      <link>https://arxiv.org/abs/2406.15876</link>
      <description>arXiv:2406.15876v1 Announce Type: new 
Abstract: We study online contention resolution schemes (OCRSs) and prophet inequalities for non-product distributions. Specifically, when the active set is sampled according to a pairwise-independent (PI) distribution, we show a $(1-o_k(1))$-selectable OCRS for uniform matroids of rank $k$, and $\Omega(1)$-selectable OCRSs for laminar, graphic, cographic, transversal, and regular matroids. These imply prophet inequalities with the same ratios when the set of values is drawn according to a PI distribution. Our results complement recent work of Dughmi, Kalayci, and Patel (STOC '24) showing that no $\omega(1/k)$-selectable OCRS exists in the PI setting for general matroids of rank $k$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.15876v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Anupam Gupta, Jinqiao Hu, Gregory Kehne, Roie Levin</dc:creator>
    </item>
    <item>
      <title>Learning-Based Heavy Hitters and Flow Frequency Estimation in Streams</title>
      <link>https://arxiv.org/abs/2406.16270</link>
      <description>arXiv:2406.16270v1 Announce Type: new 
Abstract: Identifying heavy hitters and estimating the frequencies of flows are fundamental tasks in various network domains. Existing approaches to this challenge can broadly be categorized into two groups, hashing-based and competing-counter-based. The Count-Min sketch is a standard example of a hashing-based algorithm, and the Space Saving algorithm is an example of a competing-counter algorithm. Recent works have explored the use of machine learning to enhance algorithms for frequency estimation problems, under the algorithms with prediction framework. However, these works have focused solely on the hashing-based approach, which may not be best for identifying heavy hitters. In this paper, we present the first learned competing-counter-based algorithm, called LSS, for identifying heavy hitters, top k, and flow frequency estimation that utilizes the well-known Space Saving algorithm. We provide theoretical insights into how and to what extent our approach can improve upon Space Saving, backed by experimental results on both synthetic and real-world datasets. Our evaluation demonstrates that LSS can enhance the accuracy and efficiency of Space Saving in identifying heavy hitters, top k, and estimating flow frequencies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16270v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Rana Shahout, Michael Mitzenmacher</dc:creator>
    </item>
    <item>
      <title>On Computing Pairwise Statistics with Local Differential Privacy</title>
      <link>https://arxiv.org/abs/2406.16305</link>
      <description>arXiv:2406.16305v1 Announce Type: new 
Abstract: We study the problem of computing pairwise statistics, i.e., ones of the form $\binom{n}{2}^{-1} \sum_{i \ne j} f(x_i, x_j)$, where $x_i$ denotes the input to the $i$th user, with differential privacy (DP) in the local model. This formulation captures important metrics such as Kendall's $\tau$ coefficient, Area Under Curve, Gini's mean difference, Gini's entropy, etc. We give several novel and generic algorithms for the problem, leveraging techniques from DP algorithms for linear queries.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16305v1</guid>
      <category>cs.DS</category>
      <category>cs.CR</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Badih Ghazi, Pritish Kamath, Ravi Kumar, Pasin Manurangsi, Adam Sealfon</dc:creator>
    </item>
    <item>
      <title>Optimal Generation of Strictly Increasing Binary Trees and Beyond</title>
      <link>https://arxiv.org/abs/2406.16396</link>
      <description>arXiv:2406.16396v1 Announce Type: new 
Abstract: This article presents two novel algorithms for generating random increasing trees. The first algorithm efficiently generates strictly increasing binary trees using an ad hoc method. The second algorithm improves the recursive method for weighted strictly increasing unary-binary increasing trees, optimizing randomness usage.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16396v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.403.15</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 403, 2024, pp. 60-65</arxiv:journal_reference>
      <dc:creator>Olivier Bodini (LIPN), Francis Durand (LIPN), Philippe Marchal (LAGA)</dc:creator>
    </item>
    <item>
      <title>Bijective BWT based compression schemes</title>
      <link>https://arxiv.org/abs/2406.16475</link>
      <description>arXiv:2406.16475v1 Announce Type: new 
Abstract: We show that for any string $w$ of length $n$, $r_B = O(z\log^2 n)$, where $r_B$ and $z$ are respectively the number of character runs in the bijective Burrows-Wheeler transform (BBWT), and the number of Lempel-Ziv 77 factors of $w$. We can further induce a bidirectional macro scheme of size $O(r_B)$ from the BBWT. Finally, there exists a family of strings with $r_B = \Omega(\log n)$ but having only $r=2$ character runs in the standard Burrows--Wheeler transform (BWT). However, a lower bound for $r$ is the minimal run-length of the BBWTs applied to the cyclic shifts of $w$, whose time complexity might be $o(n^2)$ in the light that we show how to compute the Lyndon factorization of all cyclic rotations in $O(n)$ time. Considering also the rotation operation performing cyclic shifts, we conjecture that we can transform two strings having the same Parikh vector to each other by BBWT and rotation operations, and prove this conjecture for the case of binary alphabets and permutations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16475v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Golnaz Badkobeh, Hideo Bannai, Dominik K\"oppl</dc:creator>
    </item>
    <item>
      <title>An FPRAS for #nFBDD</title>
      <link>https://arxiv.org/abs/2406.16515</link>
      <description>arXiv:2406.16515v1 Announce Type: new 
Abstract: #nFBDD is the problem of counting the number of satisfying assignments, or models, of a non-deterministic free binary decision diagram (nFBDD). The problem is #P-hard. We study the approximate variant of this problem where one seeks an estimate of the model count. It is known that there exists a quasi-polynomial-time randomized approximation scheme (QPRAS) for #nFBDD. We provide the first FPRAS for #nFBDD</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16515v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kuldeep S. Meel, Alexis de Colnet</dc:creator>
    </item>
    <item>
      <title>Optimizing Search Strategies: A Study of Two-Pointer Linear Search Implementation</title>
      <link>https://arxiv.org/abs/2406.16729</link>
      <description>arXiv:2406.16729v1 Announce Type: new 
Abstract: This report investigates three fundamental search algorithms: Linear Search, Binary Search, and Two Pointer Search. Linear Search checks each element sequentially, Binary Search divides the search space in half, and Two Pointer Search uses two pointers to scan from both ends of a sorted list. We compare these algorithms in terms of time complexity, space complexity, and practical performance. Our findings demonstrate that while Linear Search is straightforward, it is inefficient for large datasets. Binary Search is efficient for sorted data but requires an initial sorting step. The Two Pointer Search, combining elements of both methods, offers a practical balance of simplicity and efficiency. We propose a novel implementation of the Two Pointer Search algorithm and validate its performance through comprehensive testing on various hardware configurations. The results indicate that our proposed algorithm significantly improves search efficiency, making it suitable for both sorted and unsorted datasets. Future work will extend this algorithm to more complex data structures and real-world applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16729v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nazma Akter Zinnia, Eisuke Hanada</dc:creator>
    </item>
    <item>
      <title>Scheduling with Obligatory Tests</title>
      <link>https://arxiv.org/abs/2406.16734</link>
      <description>arXiv:2406.16734v1 Announce Type: new 
Abstract: Motivated by settings such as medical treatments or aircraft maintenance, we consider a scheduling problem with jobs that consist of two operations, a test and a processing part. The time required to execute the test is known in advance while the time required to execute the processing part becomes known only upon completion of the test. We use competitive analysis to study algorithms for minimizing the sum of completion times for $n$ given jobs on a single machine. As our main result, we prove using a novel analysis technique that the natural $1$-SORT algorithm has competitive ratio at most 1.861. For the special case of uniform test times, we show that a simple threshold-based algorithm has competitive ratio at most 1.585. We also prove a lower bound that shows that no deterministic algorithm can be better than $\sqrt{2}$-competitive even in the case of uniform test times.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16734v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Konstantinos Dogeas, Thomas Erlebach, Ya-Chun Liang</dc:creator>
    </item>
    <item>
      <title>Stochastic Scheduling with Abandonments via Greedy Strategies</title>
      <link>https://arxiv.org/abs/2406.15691</link>
      <description>arXiv:2406.15691v1 Announce Type: cross 
Abstract: Motivated by applications where impatience is pervasive and service times are uncertain, we study a scheduling model where jobs may depart at an unknown point in time and service times are stochastic. Initially, we have access to a single server and $n$ jobs with known non-negative values: these jobs have unknown stochastic service and departure times with known distributional information, which we assume to be independent. When the server is free, we can run an available job which occupies the server for an unknown amount of time, and collect its value. The objective is to maximize the expected total value obtained from jobs run on the server. Natural formulations of this problem suffer from the curse of dimensionality. In fact, this problem is NP-hard even in the deterministic case. Hence, we focus on efficiently computable approximation algorithms that can provide high expected reward compared to the optimal expected value. Towards this end, we first provide a compact linear programming (LP) relaxation that gives an upper bound on the expected value obtained by the optimal policy. Then we design a polynomial-time algorithm that is nearly a $(1/2)\cdot (1-1/e)$-approximation to the optimal LP value (so also to the optimal expected value). We next shift our focus to the case of independent and identically distributed (i.i.d.) service times. In this case, we show that the greedy policy that always runs the highest-valued job whenever the server is free obtains a $1/2$-approximation to the optimal expected value. Our approaches extend effortlessly and we demonstrate their flexibility by providing approximations to natural extensions of our problem. Finally, we evaluate our LP-based policies and the greedy policy empirically on synthetic and real datasets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.15691v1</guid>
      <category>math.OC</category>
      <category>cs.DS</category>
      <category>cs.GT</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yihua Xu, Rohan Ghuge, Sebastian Perez-Salazar</dc:creator>
    </item>
    <item>
      <title>Fair Clustering: Critique, Caveats, and Future Directions</title>
      <link>https://arxiv.org/abs/2406.15960</link>
      <description>arXiv:2406.15960v1 Announce Type: cross 
Abstract: Clustering is a fundamental problem in machine learning and operations research. Therefore, given the fact that fairness considerations have become of paramount importance in algorithm design, fairness in clustering has received significant attention from the research community. The literature on fair clustering has resulted in a collection of interesting fairness notions and elaborate algorithms. In this paper, we take a critical view of fair clustering, identifying a collection of ignored issues such as the lack of a clear utility characterization and the difficulty in accounting for the downstream effects of a fair clustering algorithm in machine learning settings. In some cases, we demonstrate examples where the application of a fair clustering algorithm can have significant negative impacts on social welfare. We end by identifying a collection of steps that would lead towards more impactful research in fair clustering.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.15960v1</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.CY</category>
      <category>cs.DS</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>John Dickerson, Seyed A. Esmaeili, Jamie Morgenstern, Claire Jie Zhang</dc:creator>
    </item>
    <item>
      <title>Comprehensive characterization of three-qubit Grover search algorithm on IBM's 127-qubit superconducting quantum computers</title>
      <link>https://arxiv.org/abs/2406.16018</link>
      <description>arXiv:2406.16018v1 Announce Type: cross 
Abstract: The Grover search algorithm is a pivotal advancement in quantum computing, promising a remarkable speedup over classical algorithms in searching unstructured large databases. Here, we report results for the implementation and characterization of a three-qubit Grover search algorithm using the state-of-the-art scalable quantum computing technology of superconducting quantum architectures. To delve into the algorithm's scalability and performance metrics, our investigation spans the execution of the algorithm across all eight conceivable single-result oracles, alongside nine two-result oracles, employing IBM Quantum's 127-qubit quantum computers. Moreover, we conduct five quantum state tomography experiments to precisely gauge the behavior and efficiency of our implemented algorithm under diverse conditions; ranging from noisy, noise-free environments to the complexities of real-world quantum hardware. By connecting theoretical concepts with real-world experiments, this study not only shed light on the potential of NISQ (Noisy Intermediate-Scale Quantum) computers in facilitating large-scale database searches but also offer valuable insights into the practical application of the Grover search algorithm in real-world quantum computing applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16018v1</guid>
      <category>quant-ph</category>
      <category>cs.AI</category>
      <category>cs.CR</category>
      <category>cs.DS</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>M. AbuGhanem</dc:creator>
    </item>
    <item>
      <title>Quantum Metropolis Sampling via Weak Measurement</title>
      <link>https://arxiv.org/abs/2406.16023</link>
      <description>arXiv:2406.16023v1 Announce Type: cross 
Abstract: Gibbs sampling is a crucial computational technique used in physics, statistics, and many other scientific fields. For classical Hamiltonians, the most commonly used Gibbs sampler is the Metropolis algorithm, known for having the Gibbs state as its unique fixed point. For quantum Hamiltonians, designing provably correct Gibbs samplers has been more challenging. [TOV+11] introduced a novel method that uses quantum phase estimation (QPE) and the Marriot-Watrous rewinding technique to mimic the classical Metropolis algorithm for quantum Hamiltonians. The analysis of their algorithm relies upon the use of a boosted and shift-invariant version of QPE which may not exist [CKBG23]. Recent efforts to design quantum Gibbs samplers take a very different approach and are based on simulating Davies generators [CKBG23,CKG23,RWW23,DLL24]. Currently, these are the only provably correct Gibbs samplers for quantum Hamiltonians.
  We revisit the inspiration for the Metropolis-style algorithm of [TOV+11] and incorporate weak measurement to design a conceptually simple and provably correct quantum Gibbs sampler, with the Gibbs state as its approximate unique fixed point. Our method uses a Boosted QPE which takes the median of multiple runs of QPE, but we do not require the shift-invariant property. In addition, we do not use the Marriott-Watrous rewinding technique which simplifies the algorithm significantly.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16023v1</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jiaqing Jiang, Sandy Irani</dc:creator>
    </item>
    <item>
      <title>Pop Stacks with a Bypass</title>
      <link>https://arxiv.org/abs/2406.16399</link>
      <description>arXiv:2406.16399v1 Announce Type: cross 
Abstract: We consider sorting procedures for permutations making use of pop stacks with a bypass operation, and explore the combinatorial properties of the associated algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16399v1</guid>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.403.17</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 403, 2024, pp. 73-78</arxiv:journal_reference>
      <dc:creator>Lapo Cioni (University of Pisa, Italy), Luca Ferrari (University of Firenze, Italy), Rebecca Smith (SUNY Brockport)</dc:creator>
    </item>
    <item>
      <title>Greedy Gray Codes for some Restricted Classes of Binary Words</title>
      <link>https://arxiv.org/abs/2406.16405</link>
      <description>arXiv:2406.16405v1 Announce Type: cross 
Abstract: We investigate the existence of greedy Gray codes, based on the choice of the first element in the code, for two classes of binary words: generalized Fibonacci words and generalized Dyck words.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16405v1</guid>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.403.23</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 403, 2024, pp. 108-112</arxiv:journal_reference>
      <dc:creator>Nathana\"el Hassler, Vincent Vajnovszki, Dennis Wong</dc:creator>
    </item>
    <item>
      <title>Engineering faster double-array Aho-Corasick automata</title>
      <link>https://arxiv.org/abs/2207.13870</link>
      <description>arXiv:2207.13870v3 Announce Type: replace 
Abstract: Multiple pattern matching in strings is a fundamental problem in text processing applications such as regular expressions or tokenization. This paper studies efficient implementations of double-array Aho-Corasick automata (DAACs), data structures for quickly performing the multiple pattern matching. The practical performance of DAACs is improved by carefully designing the data structure, and many implementation techniques have been proposed thus far. A problem in DAACs is that their ideas are not aggregated. Since comprehensive descriptions and experimental analyses are unavailable, engineers face difficulties in implementing an efficient DAAC.
  In this paper, we review implementation techniques for DAACs and provide a comprehensive description of them. We also propose several new techniques for further improvement. We conduct exhaustive experiments through real-world datasets and reveal the best combination of techniques to achieve a higher performance in DAACs. The best combination is different from those used in the most popular libraries of DAACs, which demonstrates that their performance can be further enhanced. On the basis of our experimental analysis, we developed a new Rust library for fast multiple pattern matching using DAACs, named Daachorse, as open-source software at https://github.com/daac-tools/daachorse. Experiments demonstrate that Daachorse outperforms other AC-automaton implementations, indicating its suitability as a fast alternative for multiple pattern matching in many applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2207.13870v3</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1002/spe.3190</arxiv:DOI>
      <arxiv:journal_reference>Software: Practice and Experience (SPE), 53(6): 1332-1361, 2023</arxiv:journal_reference>
      <dc:creator>Shunsuke Kanda, Koichi Akabe, Yusuke Oda</dc:creator>
    </item>
    <item>
      <title>Polylogarithmic Approximation for Robust s-t Path</title>
      <link>https://arxiv.org/abs/2305.16439</link>
      <description>arXiv:2305.16439v2 Announce Type: replace 
Abstract: The paper revisits the robust $s$-$t$ path problem, one of the most fundamental problems in robust optimization. In the problem, we are given a directed graph with $n$ vertices and $k$ distinct cost functions (scenarios) defined over edges, and aim to choose an $s$-$t$ path such that the total cost of the path is always provable no matter which scenario is realized. With the view of each cost function being associated with an agent, our goal is to find a common $s$-$t$ path minimizing the maximum objective among all agents, and thus create a fair solution for them. The problem is hard to approximate within $o(\log k)$ by any quasi-polynomial time algorithm unless $\mathrm{NP} \subseteq \mathrm{DTIME}(n^{\mathrm{poly}\log n})$, and the best approximation ratio known to date is $\widetilde{O}(\sqrt{n})$ which is based on the natural flow linear program. A longstanding open question is whether we can achieve a polylogarithmic approximation even when a quasi-polynomial running time is allowed.
  We give the first polylogarithmic approximation for robust $s$-$t$ path since the problem was proposed more than two decades ago. In particular, we introduce a $O(\log n \log k)$-approximate algorithm running in quasi-polynomial time. The algorithm is built on a novel linear program formulation for a decision-tree-type structure which enables us to get rid of the $\Omega(\max\{k,\sqrt{n}\})$ integrality gap of the natural flow LP. Further, we also consider some well-known graph classes, e.g., graphs with bounded treewidth, and show that the polylogarithmic approximation can be achieved polynomially on these graphs. We hope the new proposed techniques in the paper can offer new insights into the robust $s$-$t$ path problem and related problems in robust optimization.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.16439v2</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Shi Li, Chenyang Xu, Ruilong Zhang</dc:creator>
    </item>
    <item>
      <title>$t$-sails and sparse hereditary classes of unbounded tree-width</title>
      <link>https://arxiv.org/abs/2302.04783</link>
      <description>arXiv:2302.04783v5 Announce Type: replace-cross 
Abstract: It has long been known that the following basic objects are obstructions to bounded tree-width: for arbitrarily large $t$, $(1)$ the complete graph $K_t$, $(2)$ the complete bipartite graph $K_{t,t}$, $(3)$ a subdivision of the $(t \times t)$-wall and $(4)$ the line graph of a subdivision of the $(t \times t)$-wall. We now add a further \emph{boundary object} to this list, a \emph{$t$-sail}.
  These results have been obtained by studying sparse hereditary \emph{path-star} graph classes, each of which consists of the finite induced subgraphs of a single infinite graph whose edges can be partitioned into a path (or forest of paths) with a forest of stars, characterised by an infinite word over a possibly infinite alphabet. We show that a path-star class whose infinite graph has an unbounded number of stars, each of which connects an unbounded number of times to the path, has unbounded tree-width. In addition, we show that such a class is not a subclass of the hereditary class of circle graphs.
  We identify a collection of \emph{nested} words with a recursive structure that exhibit interesting characteristics when used to define a path-star graph class. These graph classes do not contain any of the four basic obstructions but instead contain graphs that have large tree-width if and only if they contain arbitrarily large $t$-sails. We show that these classes are infinitely defined and, like classes of bounded degree or classes excluding a fixed minor, do not contain a minimal class of unbounded tree-width.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.04783v5</guid>
      <category>math.CO</category>
      <category>cs.DS</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1016/j.ejc.2024.104005</arxiv:DOI>
      <dc:creator>Daniel Cocks</dc:creator>
    </item>
  </channel>
</rss>
