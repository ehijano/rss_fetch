<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Apr 2024 04:00:23 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 19 Apr 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Resource Specifications for Resource-Manipulating Programs</title>
      <link>https://arxiv.org/abs/2304.12530</link>
      <description>arXiv:2304.12530v2 Announce Type: replace 
Abstract: Specifications for modular program verifiers are expressed as constraints on program states (e.g. preconditions) and relations on program states (e.g. postconditions). For programs whose domain is managing resources of any kind (e.g. cryptocurrencies), such state-based specifications must make explicit properties that a human would implicitly understand for free. For example, it's clear that depositing into your bank account will not change other balances, but classically this must be stated as a frame condition. As a result, classical specifications for resource-manipulating programs quickly become verbose and difficult to interpret, write and debug.
  In this paper, we present a novel methodology that extends a modular program verifier to support user-defined first-class resources, allowing resource-related operations and properties to be expressed directly and eliminating the need to reify implicit knowledge in the specifications. We implement our methodology as an extension of the program verifier Prusti, and use it to verify real-world smart contracts and a key part of a blockchain application. Our evaluation demonstrates that specifications written with our methodology are more concise and substantially simpler than specifications written purely in terms of program states.</description>
      <guid isPermaLink="false">oai:arXiv.org:2304.12530v2</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Zachary Grannan, Alexander J. Summers</dc:creator>
    </item>
    <item>
      <title>Escape with Your Self: Expressive Reachability Types with Sound and Decidable Bidirectional Type Checking</title>
      <link>https://arxiv.org/abs/2404.08217</link>
      <description>arXiv:2404.08217v2 Announce Type: replace 
Abstract: Despite Rust's success in systems programming, its "shared XOR mutable" principle significantly restricts how mutable values can be used, precluding many useful functional programming idioms. Reachability types are a recent proposal to address the key limitations of Rust-style "shared XOR mutable" approaches by tracking lifetimes and reachability of shared, escaping, and mutable data, even in the presence of higher-order functions and polymorphic types. The key to enable such expressiveness is the notion of self-references in reachability qualifiers. However, self-references present major challenges in designing expressive subtyping and decidable type checking algorithms, since self-references are neither fully covariant nor fully contravariant, yet still need to vary in certain circumstances. Thus, making reachability types practical and bringing the benefits of programming with lifetimes and sharing to higher-level languages remains an open challenge.
  In this paper, we investigate the issues of subtyping and type checking of self-references for reachability types. We address key gaps in previous work by presenting the $\lambda^{\diamond}_R$-calculus of reachability types with a refined notion of subtyping, which is more expressive compared to prior work, and more smoothly supports features such as Church-encoded datatypes. We also develop a sound and decidable bidirectional type checking algorithm, which is implemented and verified in the Coq proof assistant.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.08217v2</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Songlin Jia, Guannan Wei, Siyuan He, Yueyang Tang, Yuyan Bao, Tiark Rompf</dc:creator>
    </item>
  </channel>
</rss>
