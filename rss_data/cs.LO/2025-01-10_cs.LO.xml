<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 Jan 2025 05:01:25 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Automated Analysis of Logically Constrained Rewrite Systems using crest</title>
      <link>https://arxiv.org/abs/2501.05240</link>
      <description>arXiv:2501.05240v1 Announce Type: new 
Abstract: We present crest, a tool for automatically proving (non-)confluence and termination of logically constrained rewrite systems. We compare crest to other tools for logically constrained rewriting. Extensive experiments demonstrate the promise of crest.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.05240v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jonas Sch\"opf, Aart Middeldorp</dc:creator>
    </item>
    <item>
      <title>A Dichotomy Theorem for Ordinal Ranks in MSO</title>
      <link>https://arxiv.org/abs/2501.05385</link>
      <description>arXiv:2501.05385v1 Announce Type: new 
Abstract: We focus on formulae $\exists X.\, \varphi (\vec{Y}, X) $ of monadic second-order logic over the full binary tree, such that the witness $X$ is a well-founded set. The ordinal rank $\mathrm{rank} (X) &lt; \omega_1$ of such a set $X$ measures its depth and branching structure. We search for the least upper bound for these ranks, and discover the following dichotomy depending on the formula $\varphi$. Let $\eta_{\varphi}$ be the minimal ordinal such that, whenever an instance $\vec{Y}$ satisfies the formula, there is a witness $X$ with $\mathrm{rank} (X) \leq \eta_{\varphi}$. Then $\eta_{\varphi}$ is either strictly smaller than $\omega^2$ or it reaches the maximal possible value $\omega_1$. Moreover, it is decidable which of the cases holds. The result has potential for applications in a variety of ordinal-related problems, in particular it entails a result about the closure ordinal of a fixed-point formula.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.05385v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Damian Niwi\'nski, Pawe{\l} Parys, Micha{\l} Skrzypczak</dc:creator>
    </item>
    <item>
      <title>Baking for Dafny: A CakeML Backend for Dafny</title>
      <link>https://arxiv.org/abs/2501.05111</link>
      <description>arXiv:2501.05111v1 Announce Type: cross 
Abstract: Dafny is a verification-aware programming language that allows developers to formally specify their programs and prove them correct. Currently, a Dafny program is compiled in two steps: First, a backend translates the input program to a high-level target language like C# or Rust. Second, the translated program is compiled using the target language's toolchain. Recently, an intermediate representation (IR) has been added to Dafny that serves as input to new backends. At the time of writing, none of these steps are verified, resulting in both the backend and the target language's toolchain being part of Dafny's trusted computing base (TCB). To reduce Dafny's TCB, we started developing a new backend that translates Dafny to CakeML, a verified, bootstrapped subset of Standard ML, in the interactive theorem prover HOL4. We also started to define functional big-step semantics for the Dafny IR to prove correctness of the backend.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.05111v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Nezamabadi, Magnus Myreen</dc:creator>
    </item>
    <item>
      <title>From Scientific Texts to Verifiable Code: Automating the Process with Transformers</title>
      <link>https://arxiv.org/abs/2501.05252</link>
      <description>arXiv:2501.05252v1 Announce Type: cross 
Abstract: Despite the vast body of research literature proposing algorithms with formal guarantees, the amount of verifiable code in today's systems remains minimal. This discrepancy stems from the inherent difficulty of verifying code, particularly due to the time-consuming nature and strict formalism of proof details that formal verification tools require. However, the emergence of transformers in Large Language Models presents a promising solution to this challenge. In this position paper, we believe that transformers have the potential to read research papers that propose algorithms with formal proofs and translate these proofs into verifiable code. We leverage transformers to first build a formal structure of the proof using the original text from the paper, and then to handle the tedious, low-level aspects of proofs that are often omitted by humans. We argue that this approach can significantly reduce the barrier to formal verification. The above idea of reading papers to write verifiable code opens new avenues for automating the verification of complex systems, enabling a future where formally verified algorithms from academic research can more seamlessly transition into real-world software systems, thereby improving code reliability and security.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.05252v1</guid>
      <category>cs.SE</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Changjie Wang, Mariano Scazzariello, Marco Chiesa</dc:creator>
    </item>
    <item>
      <title>Reversible Computation with Stacks and "Reversible Management of Failures"</title>
      <link>https://arxiv.org/abs/2501.05259</link>
      <description>arXiv:2501.05259v1 Announce Type: cross 
Abstract: This work focuses on making certain computational models reversible. We start with the idea that "reversibilizing" should mean a process that gives a computational model an operational semantics capable of interpreting each term as a bijection. The most commonly used method of reversibilization creates operational semantics that halt computation when it is not possible to uniquely determine the starting state from a produced computational state; thus, terms are interpreted as partial bijective functions. We introduce $\textsf{S-CORE}$, a language of terms that allows manipulation of variables and stacks. For $\textsf{S-CORE}$, we define the operational semantics $\textsf{R-semantics}$. With the help of a proof assistant, we certify that $\textsf{R-semantics}$ makes $\textsf{S-CORE}$ a reversible imperative computational model where all terms are interpreted as total bijections on an appropriate state space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.05259v1</guid>
      <category>cs.PL</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Matteo Palazzo, Luca Roversi</dc:creator>
    </item>
    <item>
      <title>HyperLTL Satisfiability Is Highly Undecidable, HyperCTL$^*$ is Even Harder</title>
      <link>https://arxiv.org/abs/2303.16699</link>
      <description>arXiv:2303.16699v5 Announce Type: replace 
Abstract: Temporal logics for the specification of information-flow properties are able to express relations between multiple executions of a system. The two most important such logics are HyperLTL and HyperCTL*, which generalise LTL and CTL* by trace quantification. It is known that this expressiveness comes at a price, i.e. satisfiability is undecidable for both logics. In this paper we settle the exact complexity of these problems, showing that both are in fact highly undecidable: we prove that HyperLTL satisfiability is $\Sigma_1^1$-complete and HyperCTL* satisfiability is $\Sigma_1^2$-complete. These are significant increases over the previously known lower bounds and the first upper bounds. To prove $\Sigma_1^2$-membership for HyperCTL*, we prove that every satisfiable HyperCTL* sentence has a model that is equinumerous to the continuum, the first upper bound of this kind. We also prove this bound to be tight. Furthermore, we prove that both countable and finitely-branching satisfiability for HyperCTL* are as hard as truth in second-order arithmetic, i.e. still highly undecidable. Finally, we show that the membership problem for every level of the HyperLTL quantifier alternation hierarchy is $\Pi_1^1$-complete.</description>
      <guid isPermaLink="false">oai:arXiv.org:2303.16699v5</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marie Fortin, Louwe B. Kuijer, Patrick Totzke, Martin Zimmermann</dc:creator>
    </item>
    <item>
      <title>How to play the Accordion. Uniformity and the (non-)conservativity of the linear approximation of the {\lambda}-calculus</title>
      <link>https://arxiv.org/abs/2305.02785</link>
      <description>arXiv:2305.02785v4 Announce Type: replace 
Abstract: Twenty years after its introduction by Ehrhard and Regnier, differentiation in $\lambda$-calculus and in linear logic is now a celebrated tool. In particular, it allows to write the Taylor formula in various $\lambda$-calculi, hence providing a theory of linear approximations for these calculi. In the standard $\lambda$-calculus, this linear approximation is expressed by results stating that the (possibly) infinitary $\beta$-reduction of $\lambda$-terms is simulated by the reduction of their Taylor expansion: in terms of rewriting systems, the resource reduction (operating on Taylor approximants) is an extension of the $\beta$-reduction.
  In this paper, we address the converse property, conservativity: are there reductions of the Taylor approximants that do not arise from an actual $\beta$-reduction of the approximated term? We show that if we restrict the setting to finite terms and $\beta$-reduction sequences, then the linear approximation is conservative. However, as soon as one allows infinitary reduction sequences this property is broken. We design a counter-example, the Accordion. Then we show how restricting the reduction of the Taylor approximants allows to build a conservative extension of the $\beta$-reduction preserving good simulation properties. This restriction relies on uniformity, a property that was already at the core of Ehrhard and Regnier's pioneering work.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.02785v4</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>R\'emy Cerda, Lionel Vaux Auclair</dc:creator>
    </item>
    <item>
      <title>Formal Modeling and Verification of Publisher-Subscriber Paradigm in ROS 2</title>
      <link>https://arxiv.org/abs/2412.16186</link>
      <description>arXiv:2412.16186v2 Announce Type: replace 
Abstract: The Robot Operating System (ROS) is one of the most popular middleware for developing robot applications, but it is subject to major shortcomings when applied to real-time robotic systems in safety-critical environments. For this reason, ROS 2 was released in 2017 for implementing real-time capabilities in distributed robotic systems while supporting the most prominent aspects of the original ROS. There is still not much work done to provide formal guarantees and correctness of a ROS program. In this paper, we propose a framework to address this challenging problem of guaranteeing the correct behaviour of robotic systems. We propose a formal modelling of a ROS 2 program, and also describe the program using a network of timed automata. We then prove that the sets of executions of a ROS program in the model and in the network of timed automata are the same. Thus to analyze a publisher-subscriber scenario of ROS 2 program, our algorithm first converts the program into the model, and then into the network of timed automata. The applicability and validity of our approach are verified by conducting several experiments on a simplified system and an actual robotic system, and the results and limitations are discussed.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16186v2</guid>
      <category>cs.LO</category>
      <category>cs.RO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jahid Chowdhury Choton, Lipsy Gupta, Pavithra Prabhakar</dc:creator>
    </item>
    <item>
      <title>Checkpoint-based rollback recovery in session programming</title>
      <link>https://arxiv.org/abs/2312.02851</link>
      <description>arXiv:2312.02851v4 Announce Type: replace-cross 
Abstract: To react to unforeseen circumstances or amend abnormal situations in communication-centric systems, programmers are in charge of "undoing" the interactions which led to an undesired state. To assist this task, session-based languages can be endowed with reversibility mechanisms. In this paper we propose a language enriched with programming facilities to commit session interactions, to roll back the computation to a previous commit point, and to abort the session. Rollbacks in our language always bring the system to previous visited states and a rollback cannot bring the system back to a point prior to the last commit. Programmers are relieved from the burden of ensuring that a rollback never restores a checkpoint imposed by a session participant different from the rollback requester. Such undesired situations are prevented at design-time (statically) by relying on a decidable compliance check at the type level, implemented in MAUDE. We show that the language satisfies error-freedom and progress of a session.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.02851v4</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Claudio Antares Mezzina, Francesco Tiezzi, Nobuko Yoshida</dc:creator>
    </item>
    <item>
      <title>Symmetric Linear Arc Monadic Datalog and Gadget Reductions</title>
      <link>https://arxiv.org/abs/2407.04924</link>
      <description>arXiv:2407.04924v3 Announce Type: replace-cross 
Abstract: A Datalog program solves a constraint satisfaction problem (CSP) if and only if it derives the goal predicate precisely on the unsatisfiable instances of the CSP.
  There are three Datalog fragments that are particularly important for finite-domain constraint satisfaction: arc monadic Datalog, linear Datalog, and symmetric linear Datalog, each having good computational properties. We consider the fragment of Datalog where we impose all of these restrictions simultaneously, i.e., we study \emph{symmetric linear arc monadic (slam) Datalog}. We characterise the CSPs that can be solved by a slam Datalog program as those that have a gadget reduction to a particular Boolean constraint satisfaction problem. We also present exact characterisations in terms of a homomorphism duality (which we call \emph{unfolded caterpillar duality}), and in universal-algebraic terms (using known minor conditions, namely the existence of quasi Maltsev operations and $k$-absorptive operations of arity $nk$}, for all $n,k \geq 1$). Our characterisations also imply that the question whether a given finite-domain CSP can be expressed by a slam Datalog program is decidable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.04924v3</guid>
      <category>math.RA</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Fri, 10 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Manuel Bodirsky, Florian Starke</dc:creator>
    </item>
  </channel>
</rss>
