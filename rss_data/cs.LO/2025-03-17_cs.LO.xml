<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Mar 2025 03:26:37 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Synthesis with Guided Environments</title>
      <link>https://arxiv.org/abs/2503.10819</link>
      <description>arXiv:2503.10819v1 Announce Type: new 
Abstract: In the synthesis problem, we are given a specification, and we automatically generate a system that satisfies the specification in all environments. We introduce and study {\em synthesis with guided environments} (SGE, for short), where the system may harness the knowledge and computational power of the environment during the interaction. The underlying idea in SGE is that in many settings, in particular when the system serves or directs the environment, it is of the environment's interest that the specification is satisfied, and it would follow the guidance of the system. Thus, while the environment is still hostile, in the sense that the system should satisfy the specification no matter how the environment assigns values to the input signals, in SGE the system assigns values to some output signals and guides the environment via {\em programs\/} how to assign values to other output signals. A key issue is that these assignments may depend on input signals that are hidden from the system but are known to the environment, using programs like ``copy the value of the hidden input signal $x$ to the output signal $y$." SGE is thus particularly useful in settings where the system has partial visibility.
  We solve the problem of SGE, show its superiority with respect to traditional synthesis, and study theoretical aspects of SGE, like the complexity (memory and domain) of programs used by the system, as well as the connection of SGE to synthesis of (possibly distributed) systems with partial visibility.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.10819v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Orna Kupferman, Ofer Leshkowitz</dc:creator>
    </item>
    <item>
      <title>Research Vision: Multi-Agent Path Planning for Cops And Robbers Via Reactive Synthesis</title>
      <link>https://arxiv.org/abs/2503.11475</link>
      <description>arXiv:2503.11475v1 Announce Type: new 
Abstract: We propose the problem of multi-agent path planning for a generalization of the classic Cops and Robbers game via reactive synthesis. Specifically, through the application of LTLt and Coordination Synthesis, we aim to check whether various Cops and Robbers games are realizable (a strategy exists for the cops which guarantees they catch the robbers). Additionally, we construct this strategy as an executable program for the multiple system players in our games. In this paper we formalize the problem space, and propose potential directions for solutions. We also show how our formalization of this generalized cops and robbers game can be mapped to a broad range of other problems in the reactive program synthesis space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.11475v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>William Fishell, Andoni Rodriguez, Mark Santolucito</dc:creator>
    </item>
    <item>
      <title>Structural Liveness of Conservative Petri Nets</title>
      <link>https://arxiv.org/abs/2503.11590</link>
      <description>arXiv:2503.11590v1 Announce Type: new 
Abstract: We show that the EXPSPACE-hardness result for structural liveness of Petri nets [Jancar and Purser, 2019] holds even for a simple subclass of conservative nets. As the main result we then show that for structurally live conservative nets the values of the least live markings are at most double exponential in the size of the nets, which entails the EXPSPACE-completeness of structural liveness for conservative Petri nets; the complexity of the general case remains unclear. As a proof ingredient with a potential of wider applicability, we present an extension of the known results bounding the smallest integer solutions of boolean combinations of linear (in)equations and divisibility constraints.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.11590v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Petr Jan\v{c}ar, J\'er\^ome Leroux, Ji\v{r}\'i Val\r{u}\v{s}ek</dc:creator>
    </item>
    <item>
      <title>A Type Theory for Comprehension Categories with Applications to Subtyping</title>
      <link>https://arxiv.org/abs/2503.10868</link>
      <description>arXiv:2503.10868v1 Announce Type: cross 
Abstract: In this paper we develop a type theory that we show is an internal language for comprehension categories. This type theory is closely related to Martin-L\"of type theory (MLTT). Indeed, semantics of MLTT are often given in comprehension categories, albeit usually only in discrete or full ones. As we explain, requiring a comprehension category to be full or discrete can be understood as removing one `dimension' of morphisms. Thus, in our syntax, we recover this extra dimension. We show that this extra dimension can be used to encode subtyping in a natural way. Important instances of non-full comprehension categories include ones used for constructive or univalent intensional models of MLTT and directed type theory, and so our syntax is a more faithful internal language for these than is MLTT.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.10868v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Niyousha Najmaei, Niels van der Weide, Benedikt Ahrens, Paige Randall North</dc:creator>
    </item>
    <item>
      <title>Bialgebraic Reasoning on Stateful Languages</title>
      <link>https://arxiv.org/abs/2503.10955</link>
      <description>arXiv:2503.10955v1 Announce Type: cross 
Abstract: Reasoning about program equivalence in imperative languages is notoriously challenging, as the presence of states (in the form of variable stores) fundamentally increases the observational power of program terms. The key desideratum for any notion of equivalence is compositionality, guaranteeing that subprograms can be safely replaced by equivalent subprograms regardless of the context. To facilitate compositionality proofs and avoid boilerplate work, one would hope to employ the abstract bialgebraic methods provided by Turi and Plotkin's powerful theory of mathematical operational semantics (a.k.a. abstract GSOS) or its recent extension by Goncharov et al. to higher-order languages. However, multiple attempts to apply abstract GSOS to stateful languages have thus failed. We propose a novel approach to the operational semantics of stateful languages based on the formal distinction between readers (terms that expect an initial input store before being executed), and writers (running terms that have already been provided with a store). In contrast to earlier work, this style of semantics is fully compatible with abstract GSOS, and we can thus leverage the existing theory to obtain coinductive reasoning techniques. We demonstrate that our approach generates non-trivial compositionality results for stateful languages with first-order and higher-order store and that it flexibly applies to program equivalences at different levels of granularity, such as trace, cost, and natural equivalence.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.10955v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sergey Goncharov, Stefan Milius, Lutz Schr\"oder, Stelios Tsampas, Henning Urbat</dc:creator>
    </item>
    <item>
      <title>Alternating Quantifiers in Uniform One-Dimensional Fragments with an Excursion into Three-Variable Logic</title>
      <link>https://arxiv.org/abs/2404.03377</link>
      <description>arXiv:2404.03377v4 Announce Type: replace 
Abstract: The uniform one-dimensional fragment of first-order logic was introduced a few years ago as a generalization of the two-variable fragment to contexts involving relations of arity greater than two. Quantifiers in this logic are used in blocks, each block consisting only of existential quantifiers or only of universal quantifiers. In this paper we consider the possibility of mixing both types of quantifiers in blocks. We show the finite (exponential) model property and NExpTime-completeness of the satisfiability problem for two restrictions of the resulting formalism: in the first we require that every block of quantifiers is either purely universal or ends with the existential quantifier, in the second we restrict the number of variables to three; in both equality is not allowed. We also extend the second variation to a rich subfragment of the three-variable fragment (without equality) that still has the finite model property and decidable, NExpTime-complete satisfiability.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.03377v4</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Oskar Fiuk, Emanuel Kieronski</dc:creator>
    </item>
    <item>
      <title>Comparing differentiable logics for learning with logical constraints</title>
      <link>https://arxiv.org/abs/2407.03847</link>
      <description>arXiv:2407.03847v2 Announce Type: replace 
Abstract: Extensive research on formal verification of machine learning systems indicates that learning from data alone often fails to capture underlying background knowledge, such as specifications implicitly available in the data. Various neural network verifiers have been developed to ensure that a machine-learnt model satisfies correctness and safety properties; however, they typically assume a trained network with fixed weights. A promising approach for creating machine learning models that inherently satisfy constraints after training is to encode background knowledge as explicit logical constraints that guide the learning process via so-called differentiable logics. In this paper, we experimentally compare and evaluate various logics from the literature, present our findings, and highlight open problems for future work. We evaluate differentiable logics with respect to their suitability in training, and use a neural network verifier to check their ability to establish formal guarantees. The complete source code for our experiments is available as an easy-to-use framework for training with differentiable logics at https://github.com/tflinkow/comparing-differentiable-logics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.03847v2</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <arxiv:DOI>10.1016/j.scico.2025.103280</arxiv:DOI>
      <arxiv:journal_reference>Science of Computer Programming 244 (2025)</arxiv:journal_reference>
      <dc:creator>Thomas Flinkow, Barak A. Pearlmutter, Rosemary Monahan</dc:creator>
    </item>
    <item>
      <title>Synthesis with Privacy Against an Observer</title>
      <link>https://arxiv.org/abs/2411.08635</link>
      <description>arXiv:2411.08635v2 Announce Type: replace 
Abstract: We study automatic synthesis of systems that interact with their environment and maintain privacy against an observer to the interaction. The system and the environment interact via sets $I$ and $O$ of input and output signals. The input to the synthesis problem contains, in addition to a specification, also a list of secrets, a function $cost: I\cup O\rightarrow\mathbb{N}$, which maps each signal to the cost of hiding it, and a bound $b\in\mathbb{N}$ on the budget that the system may use for hiding of signals. The desired output is an $(I/O)$-transducer $T$ and a set $H\subseteq I\cup O$ of signals that respects the bound on the budget, thus $\sum_{s\in H} cost(s)\leq b$, such that for every possible interaction of $T$, the generated computation satisfies the specification, yet an observer, from whom the signals in $H$ are hidden, cannot evaluate the secrets.
  We first show that the problem's complexity is 2EXPTIME-complete for specifications and secrets in LTL, making it no harder than synthesis without privacy requirements. We then analyze the complexity further, isolating the two aspects that do not exist in traditional synthesis: the need to hide secret values and the need to choose the set $H$. We do this by studying settings in which traditional synthesis is solvable in polynomial time -- when the specification formalism is deterministic automata and when the system is closed -- and show that each of these aspects adds an exponential blow-up in complexity. We continue and study bounded synthesis with privacy, where the input includes a bound on the synthesized transducer size, as well as a variant of the problem in which the observer has knowledge, either about the specification or about the system, which can be helpful in evaluating the secrets. Additionally, we study certified privacy, where the synthesis algorithm provides certification that the secrets remain hidden.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.08635v2</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Orna Kupferman, Ofer Leshkowitz, Namma Shamash Halevy</dc:creator>
    </item>
    <item>
      <title>Graph Homomorphism, Monotone Classes and Bounded Pathwidth</title>
      <link>https://arxiv.org/abs/2403.00497</link>
      <description>arXiv:2403.00497v2 Announce Type: replace-cross 
Abstract: In recent work by Johnson et al. (2022), a framework was described for the study of graph problems over classes specified by omitting each of a finite set of graphs as subgraphs. If a problem falls into the framework then its computational complexity can be described for all such graph classes, giving a dichotomy between those classes for which the problem is hard and those for which it is easy.
  In this article, we consider several variants of the homomorphism problem in relation to this framework. It is known that certain homomorphism problems, e.g. $C_5$-Colouring, do not sit in the framework. By contrast, we show that the more general problem of Graph Homomorphism does sit in the framework, with hard cases NP-complete and easy cases in P.
  We go on to consider several locally constrained variants of the homomorphism problem, namely the locally bijective, surjective and injective variants. Like $C_5$-Colouring, none of these is in the framework. However, where a bounded-degree restrictions are considered, we prove that each of these problems is in our framework, with hard cases NP-complete and easy cases in P
  Next, we give the first example of a problem in the framework such that hardness is in the polynomial hierarchy above NP. This comes from a list colouring game, realised through first-order logic as quantified constraints. We show that with the additional restriction of bounded alternation, the problem is contained in the framework. The hard cases are $\Pi_{2k}^\mathrm{P}$-complete and the easy cases are in P.
  Finally, we go on to consider an aforementioned problem from our framework, complete for the second level of the polynomial hierarchy, under the omission in the input of not just a graph, but rather a graph $H$ annotated with the types for each vertex: existential or universal.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.00497v2</guid>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tala Eagling-Vose, Barnaby Martin, Daniel Paulusma, Siani Smith</dc:creator>
    </item>
    <item>
      <title>Towards Verifying Exact Conditions for Implementations of Density Functional Approximations</title>
      <link>https://arxiv.org/abs/2408.05316</link>
      <description>arXiv:2408.05316v5 Announce Type: replace-cross 
Abstract: Density Functional Theory (DFT) is used extensively in the computation of electronic properties of matter, with various applications. Approximating the exchange-correlation (XC) functional is the key to the Kohn-Sham DFT approach, the basis of most DFT calculations. The choice of this density functional approximation (DFA) depends crucially on the particular system under study, which has resulted in the development of hundreds of DFAs. Though the exact density functional is not known, researchers have discovered analytical properties of this exact functional. Furthermore, these exact conditions are used when designing DFAs. We present XCVerifier, the first approach for verifying whether a DFA implementation satisfies the DFT exact conditions. XCVerifier was evaluated on five DFAs from the popular Libxc library and seven exact conditions from recent work. XCVerifier was able to verify or find violations for a majority of the DFA/condition pairs, demonstrating the feasibility of using formal methods to verify DFA implementations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.05316v5</guid>
      <category>cond-mat.mtrl-sci</category>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Sameerah Helal, Zhe Tao, Cindy Rubio-Gonz\'alez, Francois Gygi, Aditya V. Thakur</dc:creator>
    </item>
    <item>
      <title>Fair Termination of Asynchronous Binary Sessions</title>
      <link>https://arxiv.org/abs/2503.07273</link>
      <description>arXiv:2503.07273v2 Announce Type: replace-cross 
Abstract: We study a theory of asynchronous session types ensuring that well-typed processes terminate under a suitable fairness assumption. Fair termination entails starvation freedom and orphan message freedom namely that all messages, including those that are produced early taking advantage of asynchrony, are eventually consumed. The theory is based on a novel fair asynchronous subtyping relation for session types that is coarser than the existing ones. The type system is also the first of its kind that is firmly rooted in linear logic: fair asynchronous subtyping is incorporated as a natural generalization of the cut and axiom rules of linear logic and asynchronous communication is modeled through a suitable set of commuting conversions and of deep cut reductions in linear logic proofs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.07273v2</guid>
      <category>cs.PL</category>
      <category>cs.DC</category>
      <category>cs.LO</category>
      <pubDate>Mon, 17 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Luca Padovani, Gianluigi Zavattaro</dc:creator>
    </item>
  </channel>
</rss>
