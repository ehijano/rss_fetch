<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Jun 2024 01:39:49 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 27 Jun 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>An Order Theory Framework of Recurrence Equations for Static Cost Analysis $-$ Dynamic Inference of Non-Linear Inequality Invariants</title>
      <link>https://arxiv.org/abs/2406.18260</link>
      <description>arXiv:2406.18260v1 Announce Type: new 
Abstract: Recurrence equations have played a central role in static cost analysis, where they can be viewed as abstractions of programs and used to infer resource usage information without actually running the programs with concrete data. Such information is typically represented as functions of input data sizes. More generally, recurrence equations have been increasingly used to automatically obtain non-linear numerical invariants. However, state-of-the-art recurrence solvers and cost analysers suffer from serious limitations when dealing with the (complex) features of recurrences arising from cost analyses. We address this challenge by developing a novel order-theoretical framework where recurrences are viewed as operators and their solutions as fixpoints, which allows leveraging powerful pre/postfixpoint search techniques. We prove useful properties and provide principles and insights that enable us to develop techniques and combine them to design new solvers. We have also implemented and experimentally evaluated an optimisation-based instantiation of the proposed approach. The results are quite promising: our prototype outperforms state-of-the-art cost analysers and recurrence solvers, and can infer tight non-linear lower/upper bounds, in a reasonable time, for complex recurrences representing diverse program behaviours.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.18260v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Louis Rustenholz, Pedro Lopez-Garcia, Jos\'e F. Morales, Manuel V. Hermenegildo</dc:creator>
    </item>
    <item>
      <title>Example-Based Reasoning about the Realizability of Polymorphic Programs</title>
      <link>https://arxiv.org/abs/2406.18304</link>
      <description>arXiv:2406.18304v1 Announce Type: new 
Abstract: Parametricity states that polymorphic functions behave the same regardless of how they are instantiated. When developing polymorphic programs, Wadler's free theorems can serve as free specifications, which can turn otherwise partial specifications into total ones, and can make otherwise realizable specifications unrealizable. This is of particular interest to the field of program synthesis, where the unrealizability of a specification can be used to prune the search space. In this paper, we focus on the interaction between parametricity, input-output examples, and sketches. Unfortunately, free theorems introduce universally quantified functions that make automated reasoning difficult. Container morphisms provide an alternative representation for polymorphic functions that captures parametricity in a more manageable way. By using a translation to the container setting, we show how reasoning about the realizability of polymorphic programs with input-output examples can be automated.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.18304v1</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3674636</arxiv:DOI>
      <dc:creator>Niek Mulleners, Johan Jeuring, Bastiaan Heeren</dc:creator>
    </item>
    <item>
      <title>Totality for Mixed Inductive and Coinductive Types</title>
      <link>https://arxiv.org/abs/1901.07820</link>
      <description>arXiv:1901.07820v4 Announce Type: replace-cross 
Abstract: This paper introduces an ML / Haskell like programming language with nested inductive and coinductive algebraic datatypes called chariot. Functions are defined by arbitrary recursive definitions and can thus lead to non-termination and other "bad" behavior. chariot comes with a //totality checker// that tags possibly ill-behaved definitions. Such a totality checker is mandatory in the context of proof assistants based on type theory like Agda.Proving correctness of this checker is far from trivial and relies on  - an interpretation of types as parity games,  - an interpretation of correct values as winning strategies for those games,  - the Lee, Jones and Ben Amram's size-change principle, used to check that the strategies induced by recursive definitions are winning.This paper develops the first two points, the last step being the subject of an upcoming paper.A prototype has been implemented and can be used to experiment with the resulting totality checker, giving a practical argument in favor of this principle.</description>
      <guid isPermaLink="false">oai:arXiv.org:1901.07820v4</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Pierre Hyvernat (LAMA)</dc:creator>
    </item>
  </channel>
</rss>
