<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Aug 2024 04:01:07 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 21 Aug 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>G\"odel Incompleteness Theorem for PAC Learnable Theory</title>
      <link>https://arxiv.org/abs/2408.10211</link>
      <description>arXiv:2408.10211v1 Announce Type: new 
Abstract: Different from the view that information is objective reality, we adopts the idea that all information needs to be compiled by the interpreter before it can be observed. Then, the interpreter-based information theory with its complexity is given by formula. Through the relationship between complexity and PAC learnability, the general PAC learnability corresponding to general complexity is derived. Then we generalize the observation process to the formal system with functors, in which we give concrete proof of the generalized G\"odel incompleteness theorem. Finally, the Cantor set, the original G\"odel incompleteness theorem, the Turing halting problem and the EPR paradox are put into the same mathematical framework as the specific applications of the general G\"odel incompleteness theorem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10211v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Zhifeng Ma, Tianyi Wu, Zhangang Han</dc:creator>
    </item>
    <item>
      <title>The Stable Model Semantics for Higher-Order Logic Programming</title>
      <link>https://arxiv.org/abs/2408.10563</link>
      <description>arXiv:2408.10563v1 Announce Type: new 
Abstract: We propose a stable model semantics for higher-order logic programs. Our semantics is developed using Approximation Fixpoint Theory (AFT), a powerful formalism that has successfully been used to give meaning to diverse non-monotonic formalisms. The proposed semantics generalizes the classical two-valued stable model semantics of (Gelfond and Lifschitz 1988) as-well-as the three-valued one of (Przymusinski 1990), retaining their desirable properties. Due to the use of AFT, we also get for free alternative semantics for higher-order logic programs, namely supported model, Kripke-Kleene, and well-founded. Additionally, we define a broad class of stratified higher-order logic programs and demonstrate that they have a unique two-valued higher-order stable model which coincides with the well-founded semantics of such programs. We provide a number of examples in different application domains, which demonstrate that higher-order logic programming under the stable model semantics is a powerful and versatile formalism, which can potentially form the basis of novel ASP systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10563v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Bart Bogaerts, Angelos Charalambidis, Giannos Chatziagapis, Babis Kostopoulos, Samuele Pollaci, Panos Rondogiannis</dc:creator>
    </item>
    <item>
      <title>Variations on distributed belief</title>
      <link>https://arxiv.org/abs/2408.10637</link>
      <description>arXiv:2408.10637v1 Announce Type: new 
Abstract: Motivated by the search for forms of distributed belief that do not collapse in the face of conflicting information, this paper introduces the notions of cautious and bold distributed belief. Both notions rely on maximally consistent subgroups of agents, with cautious quantifying universally and bold quantifying existentially. As a result, while the cautious distributed belief of a group is inconsistent only when all group members are individually inconsistent, the bold distributed belief of a group is never inconsistent. The paper discusses these two notions, presenting their respective modalities and semantic interpretations, discussing some of their basic properties, studying whether they preserve doxastic properties from the members of the group, and comparing them not only with standard distributed belief but also with one another, both at the level of modalities and at the level of language expressivity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10637v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>John Lindqvist, Fernando R. Vel\'azquez-Quesada, Thomas \r{A}gotnes</dc:creator>
    </item>
    <item>
      <title>Proving Cutoff Bounds for Safety Properties in First-Order Logic</title>
      <link>https://arxiv.org/abs/2408.10685</link>
      <description>arXiv:2408.10685v1 Announce Type: new 
Abstract: First-order logic has been established as an important tool for modeling and verifying intricate systems such as distributed protocols and concurrent systems. These systems are parametric in the number of nodes in the network or the number of threads, which is finite in any system instance, but unbounded. One disadvantage of first-order logic is that it cannot distinguish between finite and infinite structures, leading to spurious counterexamples. To mitigate this, we offer a verification approach that captures only finite system instances. Our approach is an adaptation of the cutoff method to systems modeled in first-order logic. The idea is to show that any safety violation in a system instance of size larger than some bound can be simulated by a safety violation in a system of a smaller size. The simulation provides an inductive argument for correctness in finite instances, reducing the problem to showing safety of instances with bounded size. To this end, we develop a framework to (i) encode such simulation relations in first-order logic and to (ii) validate the simulation relation by a set of verification conditions given to an SMT solver. We apply our approach to verify safety of a set of examples, some of which cannot be proven by a first-order inductive invariant.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10685v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Raz Lotan, Eden Frenkel, Sharon Shoham</dc:creator>
    </item>
    <item>
      <title>Relational Graph Convolutional Networks Do Not Learn Sound Rules</title>
      <link>https://arxiv.org/abs/2408.10261</link>
      <description>arXiv:2408.10261v1 Announce Type: cross 
Abstract: Graph neural networks (GNNs) are frequently used to predict missing facts in knowledge graphs (KGs). Motivated by the lack of explainability for the outputs of these models, recent work has aimed to explain their predictions using Datalog, a widely used logic-based formalism. However, such work has been restricted to certain subclasses of GNNs. In this paper, we consider one of the most popular GNN architectures for KGs, R-GCN, and we provide two methods to extract rules that explain its predictions and are sound, in the sense that each fact derived by the rules is also predicted by the GNN, for any input dataset. Furthermore, we provide a method that can verify that certain classes of Datalog rules are not sound for the R-GCN. In our experiments, we train R-GCNs on KG completion benchmarks, and we are able to verify that no Datalog rule is sound for these models, even though the models often obtain high to near-perfect accuracy. This raises some concerns about the ability of R-GCN models to generalise and about the explainability of their predictions. We further provide two variations to the training paradigm of R-GCN that encourage it to learn sound rules and find a trade-off between model accuracy and the number of learned sound rules.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10261v1</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Matthew Morris, David J. Tena Cucala, Bernardo Cuenca Grau, Ian Horrocks</dc:creator>
    </item>
    <item>
      <title>Query languages for neural networks</title>
      <link>https://arxiv.org/abs/2408.10362</link>
      <description>arXiv:2408.10362v1 Announce Type: cross 
Abstract: We lay the foundations for a database-inspired approach to interpreting and understanding neural network models by querying them using declarative languages. Towards this end we study different query languages, based on first-order logic, that mainly differ in their access to the neural network model. First-order logic over the reals naturally yields a language which views the network as a black box; only the input--output function defined by the network can be queried. This is essentially the approach of constraint query languages. On the other hand, a white-box language can be obtained by viewing the network as a weighted graph, and extending first-order logic with summation over weight terms. The latter approach is essentially an abstraction of SQL. In general, the two approaches are incomparable in expressive power, as we will show. Under natural circumstances, however, the white-box approach can subsume the black-box approach; this is our main result. We prove the result concretely for linear constraint queries over real functions definable by feedforward neural networks with a fixed number of hidden layers and piecewise linear activation functions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10362v1</guid>
      <category>cs.AI</category>
      <category>cs.DB</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Martin Grohe, Christoph Standke, Juno Steegmans, Jan Van den Bussche</dc:creator>
    </item>
    <item>
      <title>Boolean Matrix Logic Programming</title>
      <link>https://arxiv.org/abs/2408.10369</link>
      <description>arXiv:2408.10369v1 Announce Type: cross 
Abstract: We describe a datalog query evaluation approach based on efficient and composable boolean matrix manipulation modules. We first define an overarching problem, Boolean Matrix Logic Programming (BMLP), which uses boolean matrices as an alternative computation to evaluate datalog programs. We develop two novel BMLP modules for bottom-up inferences on linear dyadic recursive datalog programs, and show how additional modules can extend this capability to compute both linear and non-linear recursive datalog programs of arity two. Our empirical results demonstrate that these modules outperform general-purpose and specialised systems by factors of 30x and 9x, respectively, when evaluating large programs with millions of facts. This boolean matrix approach significantly enhances the efficiency of datalog querying to support logic programming techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10369v1</guid>
      <category>cs.SC</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Lun Ai, Stephen H. Muggleton</dc:creator>
    </item>
    <item>
      <title>Hologram Reasoning for Solving Algebra Problems with Geometry Diagrams</title>
      <link>https://arxiv.org/abs/2408.10592</link>
      <description>arXiv:2408.10592v1 Announce Type: cross 
Abstract: Solving Algebra Problems with Geometry Diagrams (APGDs) is still a challenging problem because diagram processing is not studied as intensively as language processing. To work against this challenge, this paper proposes a hologram reasoning scheme and develops a high-performance method for solving APGDs by using this scheme. To reach this goal, it first defines a hologram, being a kind of graph, and proposes a hologram generator to convert a given APGD into a hologram, which represents the entire information of APGD and the relations for solving the problem can be acquired from it by a uniform way. Then HGR, a hologram reasoning method employs a pool of prepared graph models to derive algebraic equations, which is consistent with the geometric theorems. This method is able to be updated by adding new graph models into the pool. Lastly, it employs deep reinforcement learning to enhance the efficiency of model selection from the pool. The entire HGR not only ensures high solution accuracy with fewer reasoning steps but also significantly enhances the interpretability of the solution process by providing descriptions of all reasoning steps. Experimental results demonstrate the effectiveness of HGR in improving both accuracy and interpretability in solving APGDs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10592v1</guid>
      <category>cs.AI</category>
      <category>cs.CG</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Litian Huang, Xinguo Yu, Feng Xiong, Bin He, Shengbing Tang, Jiawen Fu</dc:creator>
    </item>
    <item>
      <title>Rejection in Abstract Argumentation: Harder Than Acceptance?</title>
      <link>https://arxiv.org/abs/2408.10683</link>
      <description>arXiv:2408.10683v1 Announce Type: cross 
Abstract: Abstract argumentation is a popular toolkit for modeling, evaluating, and comparing arguments. Relationships between arguments are specified in argumentation frameworks (AFs), and conditions are placed on sets (extensions) of arguments that allow AFs to be evaluated. For more expressiveness, AFs are augmented with \emph{acceptance conditions} on directly interacting arguments or a constraint on the admissible sets of arguments, resulting in dialectic frameworks or constrained argumentation frameworks. In this paper, we consider flexible conditions for \emph{rejecting} an argument from an extension, which we call rejection conditions (RCs). On the technical level, we associate each argument with a specific logic program. We analyze the resulting complexity, including the structural parameter treewidth. Rejection AFs are highly expressive, giving rise to natural problems on higher levels of the polynomial hierarchy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.10683v1</guid>
      <category>cs.AI</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Johannes K. Fichte, Markus Hecher, Yasir Mahmood, Arne Meier</dc:creator>
    </item>
    <item>
      <title>Extending the Quantitative Pattern-Matching Paradigm</title>
      <link>https://arxiv.org/abs/2408.11007</link>
      <description>arXiv:2408.11007v1 Announce Type: cross 
Abstract: We show how (well-established) type systems based on non-idempotent intersection types can be extended to characterize termination properties of functional programming languages with pattern matching features. To model such programming languages, we use a (weak and closed) $\lambda$-calculus integrating a pattern matching mechanism on algebraic data types (ADTs). Remarkably, we also show that this language not only encodes Plotkin's CBV and CBN $\lambda$-calculus as well as other subsuming frameworks, such as the bang-calculus, but can also be used to interpret the semantics of effectful languages with exceptions. After a thorough study of the untyped language, we introduce a type system based on intersection types, and we show through purely logical methods that the set of terminating terms of the language corresponds exactly to that of well-typed terms. Moreover, by considering non-idempotent intersection types, this characterization turns out to be quantitative, i.e. the size of the type derivation of a term t gives an upper bound for the number of evaluation steps from t to its normal form.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.11007v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Sandra Alves, Delia Kesner, Miguel Ramos</dc:creator>
    </item>
    <item>
      <title>On the Number of Quantifiers Needed to Define Boolean Functions</title>
      <link>https://arxiv.org/abs/2407.00688</link>
      <description>arXiv:2407.00688v2 Announce Type: replace 
Abstract: The number of quantifiers needed to express first-order (FO) properties is captured by two-player combinatorial games called multi-structural games. We analyze these games on binary strings with an ordering relation, using a technique we call parallel play, which significantly reduces the number of quantifiers needed in many cases. Ordered structures such as strings have historically been notoriously difficult to analyze in the context of these and similar games. Nevertheless, in this paper, we provide essentially tight upper bounds on the number of quantifiers needed to characterize different-sized subsets of strings. The results immediately give bounds on the number of quantifiers necessary to define several different classes of Boolean functions. One of our results is analogous to Lupanov's upper bounds on circuit size and formula size in propositional logic: we show that every Boolean function on $n$-bit inputs can be defined by a FO sentence having $(1 + \varepsilon)n\log(n) + O(1)$ quantifiers, and that this is essentially tight. We reduce this number to $(1 + \varepsilon)\log(n) + O(1)$ when the Boolean function in question is sparse.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.00688v2</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marco Carmosino, Ronald Fagin, Neil Immerman, Phokion Kolaitis, Jonathan Lenchner, Rik Sengupta</dc:creator>
    </item>
    <item>
      <title>Probabilities of the Third Type: Statistical Relational Learning and Reasoning with Relative Frequencies</title>
      <link>https://arxiv.org/abs/2202.10367</link>
      <description>arXiv:2202.10367v4 Announce Type: replace-cross 
Abstract: Dependencies on the relative frequency of a state in the domain are common when modelling probabilistic dependencies on relational data. For instance, the likelihood of a school closure during an epidemic might depend on the proportion of infected pupils exceeding a threshold. Often, rather than depending on discrete thresholds, dependencies are continuous: for instance, the likelihood of any one mosquito bite transmitting an illness depends on the proportion of carrier mosquitoes. Current approaches usually only consider probabilities over possible worlds rather than over domain elements themselves. An exception are the recently introduced lifted Bayesian networks for conditional probability logic, which express discrete dependencies on probabilistic data. We introduce functional lifted Bayesian networks, a formalism that explicitly incorporates continuous dependencies on relative frequencies into statistical relational artificial intelligence, and compare and contrast them with lifted Bayesian networks for conditional probability logic. Incorporating relative frequencies is not only beneficial to modelling; it also provides a more rigorous approach to learning problems where training and test or application domains have different sizes. To this end, we provide a representation of the asymptotic probability distributions induced by functional lifted Bayesian networks on domains of increasing sizes. Since that representation has well-understood scaling behaviour across domain sizes, it can be used to estimate parameters for a large domain consistently from randomly sampled subpopulations. Furthermore, we show that in parametric families of FLBN, convergence is uniform in the parameters, which ensures a meaningful dependence of the asymptotic probabilities on the parameters of the model.</description>
      <guid isPermaLink="false">oai:arXiv.org:2202.10367v4</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1613/jair.1.15679</arxiv:DOI>
      <arxiv:journal_reference>Journal of Artificial Intelligence Research 80 (2024) 1407-1436</arxiv:journal_reference>
      <dc:creator>Felix Weitk\"amper</dc:creator>
    </item>
    <item>
      <title>Checkpoint-based rollback recovery in session programming</title>
      <link>https://arxiv.org/abs/2312.02851</link>
      <description>arXiv:2312.02851v2 Announce Type: replace-cross 
Abstract: To react to unforeseen circumstances or amend abnormal situations in communication-centric systems, programmers are in charge of "undoing" the interactions which led to an undesired state. To assist this task, session-based languages can be endowed with reversibility mechanisms. In this paper we propose a language enriched with programming facilities to commit session interactions, to roll back the computation to a previous commit point, and to abort the session. Rollbacks in our language always bring the system to previous visited states and a rollback cannot bring the system back to a point prior to the last commit. Programmers are relieved from the burden of ensuring that a rollback never restores a checkpoint imposed by a session participant different from the rollback requester. Such undesired situations are prevented at design-time (statically) by relying on a decidable compliance check at the type level, implemented in MAUDE. We show that the language satisfies error-freedom and progress of a session.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.02851v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Claudio Antares Mezzina, Francesco Tiezzi, Nobuko Yoshida</dc:creator>
    </item>
    <item>
      <title>Cloud Kitchen: Using Planning-based Composite AI to Optimize Food Delivery Processes</title>
      <link>https://arxiv.org/abs/2402.10725</link>
      <description>arXiv:2402.10725v2 Announce Type: replace-cross 
Abstract: The global food delivery market provides many opportunities for AI-based services that can improve the efficiency of feeding the world. This paper presents the Cloud Kitchen platform as a decision-making tool for restaurants with food delivery and a simulator to evaluate the impact of the decisions. The platform contains a Technology-Specific Bridge (TSB) that provides an interface for communicating with restaurants or the simulator. TSB uses a planning domain model to represent decisions embedded in the Unified Planning Framework (UPF). Decision-making, which concerns allocating customers' orders to vehicles and deciding in which order the customers will be served (for each vehicle), is done via a Vehicle Routing Problem with Time Windows (VRPTW), an efficient tool for this problem. We show that decisions made by our platform can improve customer satisfaction by reducing the number of delayed deliveries using a real-world historical dataset.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.10725v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Slavom\'ir \v{S}vanc\'ar, Luk\'a\v{s} Chrpa, Filip Dvo\v{r}\'ak, Tom\'a\v{s} Balyo</dc:creator>
    </item>
  </channel>
</rss>
