<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Apr 2025 01:47:29 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Directed First-Order Logic</title>
      <link>https://arxiv.org/abs/2504.11225</link>
      <description>arXiv:2504.11225v1 Announce Type: new 
Abstract: We present a first-order logic equipped with an "asymmetric" directed notion of equality, which can be thought of as transitions/rewrites between terms, allowing for types to be interpreted as preorders. We then provide a universal property to such "directed equalities" by describing introduction and elimination rules that allows them to be contracted only with certain syntactic restrictions, based on polarity, which do not allow for symmetry to be derived. We give a characterization of such directed equality as a relative left adjoint, generalizing the idea by Lawvere of equality as left adjoint. The logic is equipped with a precise syntactic system of polarities, inspired by dinaturality, that keeps track of the occurrence of variables (positive/negative/both). The semantics of this logic and its system of variances is then captured categorically using the notion of directed doctrine, which we prove sound and complete with respect to the syntax.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.11225v1</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andrea Laretto, Fosco Loregian, Niccol\`o Veltri</dc:creator>
    </item>
    <item>
      <title>Products of Recursive Programs for Hypersafety Verification</title>
      <link>https://arxiv.org/abs/2504.10800</link>
      <description>arXiv:2504.10800v1 Announce Type: cross 
Abstract: We study the problem of automated hypersafety verification of infinite-state recursive programs. We propose an infinite class of product programs, specifically designed with recursion in mind, that reduce the hypersafety verification of a recursive program to standard safety verification. For this, we combine insights from language theory and concurrency theory to propose an algorithmic solution for constructing an infinite class of recursive product programs. One key insight is that, using the simple theory of visibly pushdown languages, one can maintain the recursive structure of syntactic program alignments which is vital to constructing a new product program that can be viewed as a classic recursive program -- that is, one that can be executed on a single stack. Another key insight is that techniques from concurrency theory can be generalized to help define product programs based on the view that the parallel composition of individual recursive programs includes all possible alignments from which a sound set of alignments that faithfully preserve the satisfaction of the hypersafety property can be selected. On the practical side, we formulate a family of parametric canonical product constructions that are intuitive to programmers and can be used as building blocks to specify recursive product programs for the purpose of relational and hypersafety verification, with the idea that the right product program can be verified automatically using existing techniques. We demonstrate the effectiveness of these techniques through an implementation and highly promising experimental results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.10800v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ruotong Cheng, Azadeh Farzan</dc:creator>
    </item>
    <item>
      <title>The Index and Core of a Relation. With Applications to the Axiomatics of Relation Algebra</title>
      <link>https://arxiv.org/abs/2309.02017</link>
      <description>arXiv:2309.02017v3 Announce Type: replace 
Abstract: We introduce the general notions of an index and a core of a relation. We postulate a limited form of the axiom of choice -- specifically that all partial equivalence relations have an index -- and explore the consequences of adding the axiom to standard axiom systems for point-free reasoning. Examples of the theorems we prove are that a core/index of a difunction is a bijection, and that the so-called ``all or nothing'' axiom used to facilitate pointwise reasoning is derivable from our axiom of choice.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.02017v3</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Roland Backhouse (University of Nottingham, UK), Ed Voermans (Independent Researcher)</dc:creator>
    </item>
    <item>
      <title>Codd's Theorem for Databases over Semirings</title>
      <link>https://arxiv.org/abs/2501.16543</link>
      <description>arXiv:2501.16543v2 Announce Type: replace 
Abstract: Codd's Theorem, a fundamental result of database theory, asserts that relational algebra and relational calculus have the same expressive power on relational databases. We explore Codd's Theorem for databases over semirings and establish two different versions of this result for such databases: the first version involves the five basic operations of relational algebra, while in the second version the division operation is added to the five basic operations of relational algebra. In both versions, the difference operation of relations is given semantics using semirings with monus, while on the side of relational calculus a limited form of negation is used. The reason for considering these two different versions of Codd's theorem is that, unlike the case of ordinary relational databases, the division operation need not be expressible in terms of the five basic operations of relational algebra for databases over an arbitrary positive semiring; in fact, we show that this inexpressibility result holds even for bag databases.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.16543v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guillermo Badia, Phokion G. Kolaitis, Carles Noguera</dc:creator>
    </item>
    <item>
      <title>Strong normalization through idempotent intersection types: a new syntactical approach</title>
      <link>https://arxiv.org/abs/2503.09831</link>
      <description>arXiv:2503.09831v2 Announce Type: replace 
Abstract: It is well-known that intersection type assignment systems can be used to characterize strong normalization (SN). Typical proofs that typable lambda-terms are SN in these systems rely on semantical techniques. In this work, we study $\Lambda_\cap^e$, a variant of Coppo and Dezani's (Curry-style) intersection type system, and we propose a syntactical proof of strong normalization for it. We first design $\Lambda_\cap^i$, a Church-style version, in which terms closely correspond to typing derivations. Then we prove that typability in $\Lambda_\cap^i$ implies SN through a measure that, given a term, produces a natural number that decreases along with reduction. Finally, the result is extended to $\Lambda_\cap^e$, since the two systems simulate each other.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.09831v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pablo Barenbaum, Simona Ronchi Della Rocca, Cristian Sottile</dc:creator>
    </item>
    <item>
      <title>Algorithmic correspondence and analytic rules</title>
      <link>https://arxiv.org/abs/2203.14147</link>
      <description>arXiv:2203.14147v2 Announce Type: replace-cross 
Abstract: We introduce the algorithm MASSA which takes classical modal formulas in input, and, when successful, effectively generates: (a) (analytic) geometric rules of the labelled calculus G3K, and (b) cut-free derivations (of a certain `canonical' shape) of each given input formula in the geometric labelled calculus obtained by adding the rule in output to G3K. We show that MASSA successfully terminates whenever its input formula is a (definite) analytic inductive formula, in which case, the geometric axiom corresponding to the output rule is, modulo logical equivalence, the first-order correspondent of the input formula. In proving the correctness of MASSA, we also show that the algorithm for the elimination of second-order quantifiers SCAN is complete with respect to the class of inductive analytic formulas. Finally, we show how our algorithm can be extended to the class of inductive formulas and to modal logic with quantifiers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2203.14147v2</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Andrea De Domenico, Giuseppe Greco, Alessandra Palmigiano</dc:creator>
    </item>
    <item>
      <title>Classical Distributive Restriction Categories</title>
      <link>https://arxiv.org/abs/2305.16524</link>
      <description>arXiv:2305.16524v3 Announce Type: replace-cross 
Abstract: In the category of sets and partial functions, $\mathsf{PAR}$, while the disjoint union $\sqcup$ is the usual categorical coproduct, the Cartesian product $\times$ becomes a restriction categorical analogue of the categorical product: a restriction product. Nevertheless, $\mathsf{PAR}$ does have a usual categorical product as well in the form $A \&amp; B := A \sqcup B \sqcup (A \times B)$. Surprisingly, asking that a distributive restriction category (a restriction category with restriction products $\times$ and coproducts $\oplus$) has $A \&amp; B$ a categorical product is enough to imply that the category is a classical restriction category. This is a restriction category which has joins and relative complements and, thus, supports classical Boolean reasoning. The first and main observation of the paper is that a distributive restriction category is classical if and only if $A \&amp; B := A \oplus B \oplus (A \times B)$ is a categorical product in which case we call $\&amp;$ the ''classical'' product.
  In fact, a distributive restriction category has a categorical product if and only if it is a classified restriction category. This is in the sense that every map $A \to B$ factors uniquely through a total map $A \to B \oplus \mathsf{1}$, where $\mathsf{1}$ is the restriction terminal object. This implies the second significant observation of the paper, namely, that a distributive restriction category has a classical product if and only if it is the Kleisli category of the exception monad $\_ \oplus \mathsf{1}$ for an ordinary distributive category.
  Thus having a classical product has a significant structural effect on a distributive restriction category. In particular, the classical product not only provides an alternative axiomatization for being classical but also for being the Kleisli category of the exception monad on an ordinary distributive category.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.16524v3</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <pubDate>Wed, 16 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Robin Cockett, Jean-Simon Pacaud Lemay</dc:creator>
    </item>
  </channel>
</rss>
