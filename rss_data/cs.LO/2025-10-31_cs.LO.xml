<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 31 Oct 2025 04:00:46 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Finding Regular Herbrand Models for CHCs using Answer Set Programming</title>
      <link>https://arxiv.org/abs/2510.26428</link>
      <description>arXiv:2510.26428v1 Announce Type: new 
Abstract: We are interested in proving satisfiability of Constrained Horn Clauses (CHCs) over Algebraic Data Types (ADTs). We propose to prove satisfiability by building a tree automaton recognizing the Herbrand model of the CHCs. If such an automaton exists then the model is said to be regular, i.e., the Herbrand model is a regular set of atoms. Kostyukov et al. have shown how to derive an automaton when CVC4 finds a finite model of the CHCs. We propose an alternative way to build the automaton using an encoding into a SAT problem using Clingo, an Answer Set Programming (ASP) tool. We implemented a translation of CHCs with ADTs into an ASP problem. Combined with Clingo, we obtain a semi-complete satisfiability checker: it finds a tree automaton if a regular Herbrand model exists or finds a counter-example if the problem is unsatisfiable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.26428v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.434.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 434, 2025, pp. 4-9</arxiv:journal_reference>
      <dc:creator>Gregoire Maire (ENS Rennes, Rennes, France), Thomas Genet (Univ Rennes, IRISA, Inria, Rennes, France)</dc:creator>
    </item>
    <item>
      <title>Semantic Properties of Computations Defined by Elementary Inference Systems</title>
      <link>https://arxiv.org/abs/2510.26429</link>
      <description>arXiv:2510.26429v1 Announce Type: new 
Abstract: We consider sets/relations/computations defined by *Elementary Inference Systems* I, which are obtained from Smullyan's *elementary formal systems* using Gentzen's notation for inference rules, and proof trees for atoms P(t_1,...,t_n), where predicate P represents the considered set/relation/computation. A first-order theory Th(I), actually a set of definite Horn clauses, is given to I. Properties of objects defined by I are expressed as first-order sentences F, which are proved true or false by *satisfaction* M |= F of F in a *canonical* model M of Th(I). For this reason, we call F a *semantic property* of I. Since canonical models are, in general, incomputable, we show how to (dis)prove semantic properties  by satisfiability in an *arbitrary* model A of Th(I). We apply these ideas to the analysis of properties of programming languages and systems whose computations can be described by means of an elementary inference system. In particular, rewriting-based systems. 
</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.26429v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SC</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.434.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 434, 2025, pp. 10-26</arxiv:journal_reference>
      <dc:creator>Salvador Lucas (Universitat Politecnica de Valencia)</dc:creator>
    </item>
    <item>
      <title>Theta as a Horn Solver</title>
      <link>https://arxiv.org/abs/2510.26430</link>
      <description>arXiv:2510.26430v1 Announce Type: new 
Abstract: Theta is a verification framework that has participated in the CHC-COMP competition since 2023. While its core approach -- based on transforming constrained Horn clauses (CHCs) into control-flow automata (CFAs) for analysis -- has remained mostly unchanged, Theta's verification techniques, design trade-offs, and limitations have remained mostly unexplored in the context of CHCs. This paper fills that gap: we provide a detailed description of the algorithms employed by Theta, highlighting the unique features that distinguish it from other CHC solvers. We also analyze the strengths and weaknesses of the tool in the context of CHC-COMP benchmarks. Notably, in the 2025 edition of the competition, Theta's performance was impacted by a configuration issue, leading to suboptimal results. To provide a clearer picture of Theta's actual capabilities, we re-execute the tool on the competition benchmarks under corrected settings and report on the resulting performance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.26430v1</guid>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.434.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 434, 2025, pp. 27-39</arxiv:journal_reference>
      <dc:creator>Levente Bajczi (Department of Artificial Intelligence and Systems Engineering, Faculty of Electrical Engineering and Informatics, Budapest University of Technology and Economics, Budapest, Hungary), Mil\'an Mondok (Department of Artificial Intelligence and Systems Engineering, Faculty of Electrical Engineering and Informatics, Budapest University of Technology and Economics, Budapest, Hungary), Vince Moln\'ar (Department of Artificial Intelligence and Systems Engineering, Faculty of Electrical Engineering and Informatics, Budapest University of Technology and Economics, Budapest, Hungary)</dc:creator>
    </item>
    <item>
      <title>Bridge and Bound: A Logic-Based Framework for Abstracting (Preliminary Report)</title>
      <link>https://arxiv.org/abs/2510.26654</link>
      <description>arXiv:2510.26654v1 Announce Type: new 
Abstract: At its core, abstraction is the process of generalizing from specific instances to broader concepts or models, with the primary objective of reducing complexity while preserving properties essential to the intended purpose. It is a fundamental, often implicit, principle that structures the understanding, communication, and development of both scientific knowledge and everyday beliefs. Studies on abstraction have evolved from its origins in Ancient Greek philosophy through methodological approaches in psychological and philosophical theories to computational frameworks.
  Formally, abstraction can be understood as the transformation of a source representation into an abstract representation that discards certain details while retaining desirable features. In real-world modeling and reasoning, abstraction is crucial, particularly when managing imperfect or incomplete information that calls for approximate representations. This paper introduces a novel logic-based framework for modeling abstraction processes that goes beyond the traditional entailment of necessary conditions to encompass sufficient conditions as well. We define approximate abstractions, study their tightest and exact forms, and extend the approach to layered abstractions, enabling hierarchical simplification of complex systems and models. The computational complexity of the related reasoning tasks is also discussed.
  For clarity, our framework is developed within classical logic, chosen for its simplicity, expressiveness, and computational friendliness.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.26654v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Andrzej Szalas</dc:creator>
    </item>
    <item>
      <title>CHCVerif: A Portfolio-Based Solver for Constrained Horn Clauses</title>
      <link>https://arxiv.org/abs/2510.26431</link>
      <description>arXiv:2510.26431v1 Announce Type: cross 
Abstract: Constrained Horn Clauses (CHCs) are widely adopted as intermediate representations for a variety of verification tasks, including safety checking, invariant synthesis, and interprocedural analysis. This paper introduces CHCVERIF, a portfolio-based CHC solver that adopts a software verification approach for solving CHCs. This approach enables us to reuse mature software verification tools to tackle CHC benchmarks, particularly those involving bitvectors and low-level semantics. Our evaluation shows that while the method enjoys only moderate success with linear integer arithmetic, it achieves modest success on bitvector benchmarks. Moreover, our results demonstrate the viability and potential of using software verification tools as backends for CHC solving, particularly when supported by a carefully constructed portfolio.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.26431v1</guid>
      <category>cs.SE</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.434.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 434, 2025, pp. 40-51</arxiv:journal_reference>
      <dc:creator>Mih\'aly Dobos-Kov\'acs (Department of Artificial Intelligence,Systems Engineering, Budapest University of Technology,Economics, Hungary), Levente Bajczi (Department of Artificial Intelligence,Systems Engineering, Budapest University of Technology,Economics, Hungary), Andr\'as V\"or\"os (Department of Artificial Intelligence,Systems Engineering, Budapest University of Technology,Economics, Hungary)</dc:creator>
    </item>
    <item>
      <title>Central Submonads and Notions of Computation: Soundness, Completeness and Internal Languages</title>
      <link>https://arxiv.org/abs/2207.09190</link>
      <description>arXiv:2207.09190v3 Announce Type: replace 
Abstract: Monads in category theory are algebraic structures that can be used to model computational effects in programming languages. We show how the notion of "centre", and more generally "centrality", i.e. the property for an effect to commute with all other effects, may be formulated for strong monads acting on symmetric monoidal categories. We identify three equivalent conditions which characterise the existence of the centre of a strong monad (some of which relate it to the premonoidal centre of Power and Robinson) and we show that every strong monad on many well-known naturally occurring categories does admit a centre, thereby showing that this new notion is ubiquitous. More generally, we study central submonads, which are necessarily commutative, just like the centre of a strong monad. We provide a computational interpretation by formulating equational theories of lambda calculi equipped with central submonads, we describe categorical models for these theories and prove soundness, completeness and internal language results for our semantics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2207.09190v3</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.CT</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>TItouan Carette, Louis Lemonnier, Vladimir Zamdzhiev</dc:creator>
    </item>
    <item>
      <title>Rewriting Modulo Traced Comonoid Structure</title>
      <link>https://arxiv.org/abs/2302.09631</link>
      <description>arXiv:2302.09631v5 Announce Type: replace 
Abstract: In this paper we adapt previous work on rewriting string diagrams using hypergraphs to the case where the underlying category has a traced comonoid structure, in which wires can be forked and the outputs of a morphism can be connected to its input. Such a structure is particularly interesting because any traced Cartesian (dataflow) category has an underlying traced comonoid structure. We show that certain subclasses of hypergraphs are fully complete for traced comonoid categories: that is to say, every term in such a category has a unique corresponding hypergraph up to isomorphism, and from every hypergraph with the desired properties, a unique term in the category can be retrieved up to the axioms of traced comonoid categories. We also show how the framework of double pushout rewriting (DPO) can be adapted for traced comonoid categories by characterising the valid pushout complements for rewriting in our setting. We conclude by presenting a case study in the form of recent work on an equational theory for sequential circuits: circuits built from primitive logic gates with delay and feedback. The graph rewriting framework allows for the definition of an operational semantics for sequential circuits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.09631v5</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dan R. Ghica, George Kaye</dc:creator>
    </item>
    <item>
      <title>Analysis of logics with arithmetic</title>
      <link>https://arxiv.org/abs/2508.03574</link>
      <description>arXiv:2508.03574v2 Announce Type: replace 
Abstract: We present new results on finite satisfiability of logics with counting and arithmetic. One result is a tight bound on the complexity of satisfiability of logics with so-called local Presburger quantifiers, which sum over neighbors of a node in a graph. A second contribution concerns computing a semilinear representation of the cardinalities associated with a formula in two variable logic extended with counting quantifiers. Such a representation allows you to get bounds not only on satisfiability for these logics, but for satisfiability in the presence of additional ``global cardinality constraints'': restrictions on cardinalities of unary formulas, expressed using arbitrary decidability logics over arithmetic. In the process, we provide simpler proofs of some key prior results on finite satisfiability and semi-linearity of the spectrum for these logics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.03574v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Michael Benedikt, Chia-Hsuan Lu, Tony Tan</dc:creator>
    </item>
    <item>
      <title>Abstract computation over first-order structures. Part IIb: Moschovakis' operator and other non-determinisms</title>
      <link>https://arxiv.org/abs/2507.03827</link>
      <description>arXiv:2507.03827v2 Announce Type: replace-cross 
Abstract: BSS RAMs were introduced to provide a mathematical framework for characterizing algorithms over first-order structures. Non-deterministic BSS RAMs help to model different non-deterministic approaches. Here, we deal with different types of binary non-determinisms and study the consequences of the decidability of the identity relation and the decidability of finite sets consisting of one or two constants. We compare the binary non-determinism resulting from a non-deterministic branching process, the digital non-determinism resulting from the restriction of guesses to two constants, and some other non-determinisms resulting from the use of Moschovakis' operator applied to oracle sets restricted to tuples of constants. Moreover, we show that the performance capability and the efficiency of individual machines are influenced by the following properties. 1. The identity relation belongs to the underlying structure. 2. The identity is semi-decidable over the underlying structure. 3. Two single-element sets of constants are semi-decidable. 4. A set of two constants is semi-decidable. The order of these properties corresponds to the strength of their influence. In all cases mentioned, the semi-decidability of the sets implies their decidability.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.03827v2</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Fri, 31 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christine Ga{\ss}ner</dc:creator>
    </item>
  </channel>
</rss>
