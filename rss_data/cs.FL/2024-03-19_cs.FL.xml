<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Mar 2024 05:04:57 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 19 Mar 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>The word problem and growth of groups</title>
      <link>https://arxiv.org/abs/2403.11148</link>
      <description>arXiv:2403.11148v1 Announce Type: cross 
Abstract: Let $\mathrm{WP}_G$ denote the word problem in a finitely generated group $G$. We consider the complexity of $\mathrm{WP}_G$ with respect to standard deterministic Turing machines. Let $\mathrm{DTIME}_k(t(n))$ be the complexity class of languages solved in time $O(t(n))$ by a Turing machine with $k$ tapes. We prove that $\mathrm{WP}_G\in\mathrm{DTIME}_1(n\log n)$ if and only if $G$ is virtually nilpotent. We relate the complexity of the word problem and the growth of groups by showing that $\mathrm{WP}_G\not\in \mathrm{DTIME}_1(o(n\log\gamma(n)))$, where $\gamma(n)$ is the growth function of $G$. We prove that $\mathrm{WP}_G\in\mathrm{DTIME}_k(n)$ for strongly contracting automaton groups, $\mathrm{WP}_G\in\mathrm{DTIME}_k(n\log n)$ for groups generated by bounded automata, and $\mathrm{WP}_G\in\mathrm{DTIME}_k(n(\log n)^d)$ for groups generated by polynomial automata. In particular, for the Grigorchuk group, $\mathrm{WP}_G\not\in\mathrm{DTIME}_1(n^{1.7674})$ and $\mathrm{WP}_G\in\mathrm{DTIME}_1(n^2)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.11148v1</guid>
      <category>math.GR</category>
      <category>cs.FL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ievgen Bondarenko</dc:creator>
    </item>
    <item>
      <title>Simulations for Event-Clock Automata</title>
      <link>https://arxiv.org/abs/2207.02633</link>
      <description>arXiv:2207.02633v3 Announce Type: replace 
Abstract: Event-clock automata (ECA) are a well-known semantic subclass of timed automata (TA) which enjoy admirable theoretical properties, e.g., determinizability, and are practically useful to capture timed specifications. However, unlike for timed automata, there exist no implementations for checking non-emptiness of event-clock automata. As ECAs contain special prophecy clocks that guess and maintain the time to the next occurrence of specific events, they cannot be seen as a syntactic subclass of TA. Therefore, implementations for TA cannot be directly used for ECAs, and moreover the translation of an ECA to a semantically equivalent TA is expensive. Another reason for the lack of ECA implementations is the difficulty in adapting zone-based algorithms, critical in the timed automata setting, to the event-clock automata setting. This difficulty was studied in [Geeraerts et al. 2011,2014], where the authors proposed a zone enumeration procedure that uses zone extrapolations for finiteness.
  In this article, we propose a different zone-based algorithm to solve the reachability problem for event-clock automata, using simulations for finiteness. A surprising consequence of our result is that for event-predicting automata, the subclass of event-clock automata that only use prophecy clocks, we obtain finiteness even without any simulations. For general event-clock automata, our new algorithm exploits the G-simulation framework, which is the coarsest known simulation relation in timed automata literature, and has been recently used for advances in other extensions of timed automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2207.02633v3</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>S Akshay, Paul Gastin, R Govind, B Srivathsan</dc:creator>
    </item>
    <item>
      <title>A Fast Algorithm for Computing Prefix Probabilities</title>
      <link>https://arxiv.org/abs/2306.02303</link>
      <description>arXiv:2306.02303v4 Announce Type: replace 
Abstract: Multiple algorithms are known for efficiently calculating the prefix probability of a string under a probabilistic context-free grammar (PCFG). Good algorithms for the problem have a runtime cubic in the length of the input string. However, some proposed algorithms are suboptimal with respect to the size of the grammar. This paper proposes a novel speed-up of Jelinek and Lafferty's (1991) algorithm, whose original runtime is $O(n^3 |N|^3 + |N|^4)$, where $n$ is the input length and $|N|$ is the number of non-terminals in the grammar. In contrast, our speed-up runs in $O(n^2 |N|^3+n^3|N|^2)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.02303v4</guid>
      <category>cs.FL</category>
      <category>cs.DS</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.18653/v1/2023.acl-short.6</arxiv:DOI>
      <arxiv:journal_reference>Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics, Volume 2: Short Papers, pages 57-67, 2003</arxiv:journal_reference>
      <dc:creator>Franz Nowak, Ryan Cotterell</dc:creator>
    </item>
  </channel>
</rss>
