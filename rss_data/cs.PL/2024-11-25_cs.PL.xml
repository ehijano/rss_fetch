<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Nov 2024 05:00:17 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Functional Array Programming in an Extended Pi-Calculus</title>
      <link>https://arxiv.org/abs/2411.14579</link>
      <description>arXiv:2411.14579v1 Announce Type: new 
Abstract:  We study the data-parallel language BUTF, inspired by the Futhark language for array programming. We give a translation of BUTF into a version of the pi-calculus with broadcasting and labeled names. The translation is both complete and sound. Moreover, we propose a cost model by annotating translated BUTF processes.  This is used for a complexity analysis of the translation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14579v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.412.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 412, 2024, pp. 2-18</arxiv:journal_reference>
      <dc:creator>Hans H\"uttel (Department of Computer Science, University of Copenhagen), Lars Jensen (Department of Computer Science, Aalborg University), Chris Oliver Paulsen (Department of Computer Science, Aalborg University), Julian Teule (Department of Computer Science, Aalborg University)</dc:creator>
    </item>
    <item>
      <title>Automatic Inference of Relational Object Invariants</title>
      <link>https://arxiv.org/abs/2411.14735</link>
      <description>arXiv:2411.14735v1 Announce Type: new 
Abstract: Relational object invariants (or representation invariants) are relational properties held by the fields of a (memory) object throughout its lifetime. For example, the length of a buffer never exceeds its capacity. Automatic inference of these invariants is particularly challenging because they are often broken temporarily during field updates. In this paper, we present an Abstract Interpretation-based solution to infer object invariants. Our key insight is a new object abstraction for memory objects, where memory is divided into multiple memory banks, each containing several objects. Within each bank, the objects are further abstracted by separating the most recently used (MRU) object, represented precisely with strong updates, while the rest are summarized. For an effective implementation of this approach, we introduce a new composite abstract domain, which forms a reduced product of numerical and equality sub-domains. This design efficiently expresses relationships between a small number of variables (e.g., fields of the same abstract object). We implement the new domain in the CRAB abstract interpreter and evaluate it on several benchmarks for memory safety. We show that our approach is significantly more scalable for relational properties than the existing implementation of CRAB. For evaluating precision, we have integrated our analysis as a pre-processing step to SEABMC bounded model checker, and show that it is effective at both discharging assertions during pre-processing, and significantly improving the run-time of SEABMC.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14735v1</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yusen Su, Jorge A. Navas, Arie Gurfinkel, Isabel Garcia-Contreras</dc:creator>
    </item>
    <item>
      <title>Enhancing a Hierarchical Graph Rewriting Language based on MELL Cut Elimination</title>
      <link>https://arxiv.org/abs/2411.14802</link>
      <description>arXiv:2411.14802v1 Announce Type: new 
Abstract: Hierarchical graph rewriting is a highly expressive computational formalism that manipulates graphs enhanced with box structures for representing hierarchies. It has provided the foundations of various graph-based modeling tools, but the design of high-level declarative languages based on hierarchical graph rewriting is still a challenge. For a solid design choice, well-established formalisms with backgrounds other than graph rewriting would provide useful guidelines. Proof nets of Multiplicative Exponential Linear Logic (MELL) is such a framework because its original formulation of cut elimination is essentially graph rewriting involving box structures, where so-called Promotion Boxes with an indefinite number of non-local edges may be cloned, migrated and deleted. This work builds on LMNtal as a declarative language based on hierarchical (port) graph rewriting, and discusses how it can be extended to support the above operations on Promotion Boxes of MELL proof nets. LMNtal thus extended turns out to be a practical graph rewriting language that has strong affinity with MELL proof nets. The language features provided are general enough to encode other well-established models of concurrency. Using the toolchain of LMNtal that provides state-space search and model checking, we implemented cut elimination rules of MELL proof nets in extended LMNtal and demonstrated that the platform could serve as a useful workbench for proof nets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14802v1</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Kento Takyu, Kazunori Ueda</dc:creator>
    </item>
    <item>
      <title>Constructing Trustworthy Smart Contracts</title>
      <link>https://arxiv.org/abs/2411.14563</link>
      <description>arXiv:2411.14563v1 Announce Type: cross 
Abstract: Smart contracts form the core of Web3 applications. Contracts mediate the transfer of cryptocurrency, making them irresistible targets for hackers. We introduce ASP, a system aimed at easing the construction of provably secure contracts. The Asp system consists of three closely-linked components: a programming language, a defensive compiler, and a proof checker. The language semantics guarantee that Asp contracts are free of commonly exploited vulnerabilities such as arithmetic overflow and reentrancy. The defensive compiler enforces the semantics and translates Asp to Solidity, the most popular contract language. Deductive proofs establish functional correctness and freedom from critical vulnerabilities such as unauthorized access.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14563v1</guid>
      <category>cs.CR</category>
      <category>cs.PL</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Devora Chait-Roth, Kedar S. Namjoshi</dc:creator>
    </item>
    <item>
      <title>Synchronisability in Mailbox Communication</title>
      <link>https://arxiv.org/abs/2411.14580</link>
      <description>arXiv:2411.14580v1 Announce Type: cross 
Abstract: We revisit the problem of synchronisability for communicating automata, i.e., whether the language of send messages for an asynchronous system is the same as the language of send messages with a synchronous communication. The un/decidability of the problem depends on the specific asynchronous semantics considered as well as the topology (the communication flow) of the system. Synchronisability is known to be undecidable under the peer-to-peer semantics, while it is still an open problem for mailbox communication. The problem was shown to be decidable for ring topologies. In this paper, we show that when generalising to automata with accepting states, synchronisability is undecidable under the mailbox semantics, this result is obtained by resorting to the Post Correspondence problem. In an attempt to solve the specific problem where all states are accepting, we also show that synchronisability is decidable for tree topologies (where, as well as for rings, peer-to-peer coincides with mailbox semantics). We also discuss synchronisability for multitrees in the mailbox setting.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14580v1</guid>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.412.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 412, 2024, pp. 19-34</arxiv:journal_reference>
      <dc:creator>Cinzia Di Giusto (Universit\'e C\^ote d'Azur, CNRS, I3S, France), Laetitia Laversa (Universit\'e Sorbonne Paris Nord, Paris, France), Kirstin Peters (Universit\"at Augsburg, Augsburg, Germany)</dc:creator>
    </item>
    <item>
      <title>OMP4Py: a pure Python implementation of OpenMP</title>
      <link>https://arxiv.org/abs/2411.14887</link>
      <description>arXiv:2411.14887v1 Announce Type: cross 
Abstract: Python demonstrates lower performance in comparison to traditional high performance computing (HPC) languages such as C, C++, and Fortran. This performance gap is largely due to Python's interpreted nature and the Global Interpreter Lock (GIL), which hampers multithreading efficiency. However, the latest version of Python includes the necessary changes to make the interpreter thread-safe, allowing Python code to run without the GIL. This important update will enable users to fully exploit multithreading parallelism in Python. In order to facilitate that task, this paper introduces OMP4Py, the first pure Python implementation of OpenMP. We demonstrate that it is possible to bring OpenMP's familiar directive-based parallelization paradigm to Python, allowing developers to write parallel code with the same level of control and flexibility as in C, C++, or Fortran. The experimental evaluation shows that OMP4Py significantly impacts the performance of various types of applications, although the current threading limitation of Python's interpreter (v3.13) reduce its effectiveness for numerical applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14887v1</guid>
      <category>cs.DC</category>
      <category>cs.PL</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>C\'esar Pi\~neiro, Juan C. Pichel</dc:creator>
    </item>
    <item>
      <title>XGrammar: Flexible and Efficient Structured Generation Engine for Large Language Models</title>
      <link>https://arxiv.org/abs/2411.15100</link>
      <description>arXiv:2411.15100v1 Announce Type: cross 
Abstract: The applications of LLM Agents are becoming increasingly complex and diverse, leading to a high demand for structured outputs that can be parsed into code, structured function calls, and embodied agent commands. These developments bring significant demands for structured generation in LLM inference. Context-free grammar is a flexible approach to enable structured generation via constrained decoding. However, executing context-free grammar requires going through several stack states over all tokens in vocabulary during runtime, bringing non-negligible overhead for structured generation. In this paper, we propose XGrammar, a flexible and efficient structure generation engine for large language models. XGrammar accelerates context-free grammar execution by dividing the vocabulary into context-independent tokens that can be prechecked and context-dependent tokens that need to be interpreted during runtime. We further build transformations to expand the grammar context and reduce the number of context-independent tokens. Additionally, we build an efficient persistent stack to accelerate the context-dependent token checks. Finally, we co-design the grammar engine with LLM inference engine to overlap grammar computation with GPU executions. Evaluation results show that XGrammar can achieve up to 100x speedup over existing solutions. Combined with an LLM inference engine, it can generate near-zero overhead structure generation in end-to-end low-LLM serving.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.15100v1</guid>
      <category>cs.CL</category>
      <category>cs.AI</category>
      <category>cs.PL</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Yixin Dong, Charlie F. Ruan, Yaxing Cai, Ruihang Lai, Ziyi Xu, Yilong Zhao, Tianqi Chen</dc:creator>
    </item>
    <item>
      <title>Proof Repair across Quotient Type Equivalences</title>
      <link>https://arxiv.org/abs/2310.06959</link>
      <description>arXiv:2310.06959v5 Announce Type: replace 
Abstract: Proofs in proof assistants like Coq can be brittle, breaking easily in response to changes. To address this, recent work introduced an algorithm and tool in Coq to automatically repair broken proofs in response to changes that correspond to type equivalences. However, many changes remained out of the scope of this algorithm and tool -- especially changes in underlying behavior. We extend this proof repair algorithm so that it can express certain changes in behavior that were previously out of scope. We focus in particular on equivalences between quotient types -- types equipped with a relation that describes what it means for any two elements of that type to be equal. Quotient type equivalences can be used to express interesting changes in representations of mathematical structures, as well as changes in the underlying implementations of data structures.
  We extend this algorithm and tool to support quotient type equivalences in Coq. Notably, since Coq lacks quotient types entirely, our extensions use Coq's setoid machinery to represent quotients externally. Specifically, (1) our extension to the algorithm supports new changes corresponding to setoids, and (2) our extension to the tool supports this new class of changes and further automates away some of the new proof obligations. We ground our setoid extensions by way of a discussion of a corresponding manual proof repair approach in Cubical Agda, which supports quotient types and allows for some internalization of the correctness criteria for proof repair. We demonstrate our extensions on proof repair case studies for previously unsupported changes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.06959v5</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Cosmo Viola, Max Fan, Talia Ringer</dc:creator>
    </item>
  </channel>
</rss>
