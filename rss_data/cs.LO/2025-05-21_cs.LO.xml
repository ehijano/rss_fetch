<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 May 2025 04:00:51 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Modelling Real-time Systems with Bigraphs</title>
      <link>https://arxiv.org/abs/2505.13449</link>
      <description>arXiv:2505.13449v1 Announce Type: new 
Abstract: Bigraphical Reactive Systems (BRSs) are a graph-rewriting formalism describing systems evolving in two dimensions: spatially, e.g. a person in a room, and non-spatially, e.g. mobile phones communicating regardless of location. Despite use in domains including communication protocols, agent programming, biology, and security, there is no support for real-time systems. We extend BRSs to support real-time systems with a modelling approach that uses multiple perspectives to represent digital clocks. We use Action BRSs, a recent extension of BRSs, where the resulting transition system is a Markov Decision Process (MDP). This allows a natural representation of the choices in each system state: to either allow time to pass or perform a specific action. We implement our proposed approach using the BigraphER toolkit, and demonstrate the effectiveness through multiple examples including modelling cloud system requests.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13449v1</guid>
      <category>cs.LO</category>
      <category>cs.MA</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.417.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 417, 2025, pp. 96-116</arxiv:journal_reference>
      <dc:creator>Maram Albalwe (University of Glasgow, University of Tabuk), Blair Archibald (University of Glasgow), Michele Sevegnani (University of Glasgow)</dc:creator>
    </item>
    <item>
      <title>Fractal Analysis on the Real Interval: A Constructive Approach via Fractal Countability</title>
      <link>https://arxiv.org/abs/2505.13450</link>
      <description>arXiv:2505.13450v1 Announce Type: new 
Abstract: This paper develops a technical and practical reinterpretation of the real interval [a,b] under the paradigm of fractal countability. Instead of assuming the continuum as a completed uncountable totality, we model [a,b] as a layered structure of constructively definable points, indexed by a hierarchy of formal systems. We reformulate classical notions from real analysis -- continuity, measure, differentiation, and integration -- in terms of stratified definability levels S_n, thereby grounding the analytic apparatus in syntactic accessibility rather than ontological postulation. The result is a framework for fractal analysis, in which mathematical operations are relativized to layers of expressibility, enabling new insights into approximation, computability, and formal verification.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13450v1</guid>
      <category>cs.LO</category>
      <category>math.FA</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Stanislav Semenov</dc:creator>
    </item>
    <item>
      <title>Antichains for Concurrent Parameterized Games</title>
      <link>https://arxiv.org/abs/2505.13460</link>
      <description>arXiv:2505.13460v1 Announce Type: new 
Abstract: Concurrent parameterized games involve a fixed yet arbitrary number of players. They are described by finite arenas in which the edges are labeled with languages that describe the possible move combinations leading from one vertex to another (n players yield a word of length n).
  Previous work showed that, when edge labels are regular languages, one can decide whether a distinguished player, called Eve, has a uniform strategy to ensure a reachability objective, against any strategy profile of her arbitrarily many opponents. This decision problem is known to be PSPACE-complete. A basic ingredient in the PSPACE algorithm is the reduction to the exponential-size knowledge game, a 2-player game that reflects the knowledge Eve has on the number of opponents.
  In this paper, we provide a symbolic approach, based on antichains, to compute Eve's winning region in the knowledge game. In words, it gives the minimal knowledge Eve needs at every vertex to win the concurrent parameterized reachability game. More precisely, we propose two fixed-point algorithms that compute, as an antichain, the maximal elements of the winning region for Eve in the knowledge game. We implemented in C++ these two algorithms, as well as the one initially proposed, and report on their relative performances on various benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13460v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Nathalie Bertrand, Patricia Bouyer, Ga\"etan Staquet</dc:creator>
    </item>
    <item>
      <title>Proof Assistants for Teaching: a Survey</title>
      <link>https://arxiv.org/abs/2505.13472</link>
      <description>arXiv:2505.13472v1 Announce Type: new 
Abstract: In parallel to the ever-growing usage of mechanized proofs in diverse areas of mathematics and computer science, proof assistants are used more and more for education. This paper surveys previous work related to the use of proof assistants for (mostly undergraduate) teaching. This includes works where the authors report on their experiments using proof assistants to teach logic, mathematics or computer science, as well as designs or adaptations of proof assistants for teaching. We provide an overview of both tutoring systems that have been designed for teaching proof and proving, or general-purpose proof assistants that have been adapted for education, adding user interfaces and/or dedicated input or output languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13472v1</guid>
      <category>cs.LO</category>
      <category>cs.HC</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.419.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 419, 2025, pp. 1-27</arxiv:journal_reference>
      <dc:creator>Fr\'ed\'eric Tran Minh (Universit\'e Grenoble-Alpes, Grenoble INP, LCIS, France), Laure Gonnord (Universit\'e Grenoble-Alpes, Grenoble INP, LCIS, France), Julien Narboux (IRIF, Universit\'e Paris Cit\'e, CNRS, Paris, France)</dc:creator>
    </item>
    <item>
      <title>A Graphical Interface for Category Theory Proofs in Coq</title>
      <link>https://arxiv.org/abs/2505.13473</link>
      <description>arXiv:2505.13473v1 Announce Type: new 
Abstract: The importance of category theory in recent developments in both mathematics and in computer science cannot be overstated. However, its abstract nature makes it difficult to understand at first. Graphical languages have been developed to help manage this abstraction, but they have not been used in proof assistants, most of which are text-based. We believe that a graphical interface for categorical proofs integrated in a generic proof assistant would allow students to familiarize themselves with diagrammatic reasoning on concrete proofs that they are already familiar with. We present an implementation of a Coq plugin that enables both visualization and interactions with Coq proofs in a graphical manner.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13473v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.419.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 419, 2025, pp. 28-41</arxiv:journal_reference>
      <dc:creator>Luc Chabassier (ENS Paris-Saclay)</dc:creator>
    </item>
    <item>
      <title>ProofBuddy: How it Started, How it's Going</title>
      <link>https://arxiv.org/abs/2505.13474</link>
      <description>arXiv:2505.13474v1 Announce Type: new 
Abstract: We report on our journey to develop ProofBuddy, a web application that is powered by a server-side instance of the proof assistant Isabelle, for the teaching and learning of proofs and proving. The journey started from an attempt to use just Isabelle in an educational context. Along the way, following the educational design research approach with a series of experiments and their evaluations, we observed that a web application like \ProofBuddy has many advantages over a desktop application, for developers and teachers as well as for students. In summary, the advantages cover simplicity, maintainability and customizability. We particularly highlight the latter by exhibiting the potential of interactive tutorials and their implementation within ProofBuddy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13474v1</guid>
      <category>cs.LO</category>
      <category>cs.CY</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.419.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 419, 2025, pp. 90-111</arxiv:journal_reference>
      <dc:creator>Nadine Karsten (TU Berlin), Kim Jana Eiken (TU Berlin), Uwe Nestmann (TU Berlin)</dc:creator>
    </item>
    <item>
      <title>Causality for Cyber-Physical Systems</title>
      <link>https://arxiv.org/abs/2505.13475</link>
      <description>arXiv:2505.13475v1 Announce Type: new 
Abstract: We present a formal theory for analysing causality in cyber-physical systems. To this end, we extend the theory of actual causality by Halpern and Pearl to cope with the continuous nature of cyber-physical systems. Based on our theory, we develop an analysis technique that is used to uncover the causes for examples of failures resulting from verification, which are represented as continuous trajectories. We develop a search-based technique to efficiently produce such causes and provide an implementation for such a technique. Moreover, we apply our solution to case studies (a suspension system and a connected platoon) and benchmark systems to evaluate its effectiveness; in the experiment, we show that we were able to detect causes for inserted faults.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13475v1</guid>
      <category>cs.LO</category>
      <category>cs.CR</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Hugo Araujo, Hana Chockler, Mohammad Reza Mousavi, Gustavo Carvalho, Augusto Sampaio</dc:creator>
    </item>
    <item>
      <title>Master Thesis Impredicative Encodings of Inductive and Coinductive Types</title>
      <link>https://arxiv.org/abs/2505.13495</link>
      <description>arXiv:2505.13495v1 Announce Type: new 
Abstract: In the impredicative type theory of System F ({\lambda}2), it is possible to create inductive data types, such as natural numbers and lists. It is also possible to create coinductive data types such as streams. They work well in the sense that their (co)recursion principles obey the expected computation rules (the \b{eta}-rules). Unfortunately, they do not yield a (co)induction principle, because the necessary uniqueness principles are missing (the {\eta}-rules). Awodey, Frey, and Speight (2018) used an extension of {\lambda}C with sigma-types, equality-types, and functional extensionality to provide System F style inductive types with an induction principle by encoding them as a well-chosen subtype, making them initial algebras. In this thesis, we extend their results. We create a list and quotient type that have the desired induction principles. We show that we can use the technique for general inductive types by defining W-types with an induction principle. We also take the dual notion of their technique and create a coinductive stream type with the desired coinduction principle (also called bisimulation). We finish by showing that this dual approach can be extended to M-types, the generic notion of coinductive types, and the dual of W-types.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13495v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Steven Bronsveld, Herman Geuvers, Niels van der Weide</dc:creator>
    </item>
    <item>
      <title>Relational Hoare Logic for Realistically Modelled Machine Code</title>
      <link>https://arxiv.org/abs/2505.14348</link>
      <description>arXiv:2505.14348v1 Announce Type: new 
Abstract: Many security- and performance-critical domains, such as cryptography, rely on low-level verification to minimize the trusted computing surface and allow code to be written directly in assembly. However, verifying assembly code against a realistic machine model is a challenging task. Furthermore, certain security properties -- such as constant-time behavior -- require relational reasoning that goes beyond traditional correctness by linking multiple execution traces within a single specification. Yet, relational verification has been extensively explored at a higher level of abstraction. In this work, we introduce a Hoare-style logic that provides low-level, expressive relational verification. We demonstrate our approach on the s2n-bignum library, proving both constant-time discipline and equivalence between optimized and verification-friendly routines. Formalized in HOL Light, our results confirm the real-world applicability of relational verification in large assembly codebases.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14348v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Denis Mazzucato (Carnegie Mellon University), Abdalrhman Mohamed (Stanford University), Juneyoung Lee (Amazon Web Services), Clark Barrett (Stanford University), Jim Grundy (Amazon Web Services), John Harrison (Amazon Web Services), Corina S. Pasareanu (Carnegie Mellon University)</dc:creator>
    </item>
    <item>
      <title>Logical relations for call-by-push-value models, via internal fibrations in a 2-category</title>
      <link>https://arxiv.org/abs/2505.14482</link>
      <description>arXiv:2505.14482v1 Announce Type: new 
Abstract: We give a denotational account of logical relations for call-by-push-value (CBPV) in the fibrational style of Hermida, Jacobs, Katsumata and others. Fibrations -- which axiomatise the usual notion of sets-with-relations -- provide a clean framework for constructing new, logical relations-style, models. Such models can then be used to study properties such as effect simulation.
  Extending this picture to CBPV is challenging: the models incorporate both adjunctions and enrichment, making the appropriate notion of fibration unclear. We handle this using 2-category theory. We identify an appropriate 2-category, and define CBPV fibrations to be fibrations internal to this 2-category which strictly preserve the CBPV semantics.
  Next, we develop the theory so it parallels the classical setting. We give versions of the codomain and subobject fibrations, and show that new models can be constructed from old ones by pullback. The resulting framework enables the construction of new, logical relations-style, models for CBPV.
  Finally, we demonstrate the utility of our approach with particular examples. These include a generalisation of Katsumata's $\top\top$-lifting to CBPV models, an effect simulation result, and a relative full completeness result for CBPV without sum types.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14482v1</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pedro H. Azevedo de Amorim, Satoshi Kura, Philip Saville</dc:creator>
    </item>
    <item>
      <title>A Complexity Dichotomy for Semilinear Target Sets in Automata with One Counter</title>
      <link>https://arxiv.org/abs/2505.13749</link>
      <description>arXiv:2505.13749v1 Announce Type: cross 
Abstract: In many kinds of infinite-state systems, the coverability problem has significantly lower complexity than the reachability problem. In order to delineate the border of computational hardness between coverability and reachability, we propose to place these problems in a more general context, which makes it possible to prove complexity dichotomies.
  The more general setting arises as follows. We note that for coverability, we are given a vector $t$ and are asked if there is a reachable vector $x$ satisfying the relation $x\ge t$. For reachability, we want to satisfy the relation $x=t$. In the more general setting, there is a Presburger formula $\varphi(t,x)$, and we are given $t$ and are asked if there is a reachable $x$ with $\varphi(t,x)$.
  We study this setting for systems with one counter and binary updates: (i) integer VASS, (ii) Parikh automata, and (i) standard (non-negative) VASS. In each of these cases, reachability is NP-complete, but coverability is known to be in polynomial time. Our main results are three dichotomy theorems, one for each of the cases (i)--(iii). In each case, we show that for every $\varphi$, the problem is either NP-complete or belongs to $\mathsf{AC}^1$, a circuit complexity class within polynomial time. We also show that it is decidable on which side of the dichotomy a given formula falls.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13749v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yousef Shakiba, Henry Sinclair-Banks, Georg Zetzsche</dc:creator>
    </item>
    <item>
      <title>CLEVER: A Curated Benchmark for Formally Verified Code Generation</title>
      <link>https://arxiv.org/abs/2505.13938</link>
      <description>arXiv:2505.13938v1 Announce Type: cross 
Abstract: We introduce ${\rm C{\small LEVER}}$, a high-quality, curated benchmark of 161 problems for end-to-end verified code generation in Lean. Each problem consists of (1) the task of generating a specification that matches a held-out ground-truth specification, and (2) the task of generating a Lean implementation that provably satisfies this specification. Unlike prior benchmarks, ${\rm C{\small LEVER}}$ avoids test-case supervision, LLM-generated annotations, and specifications that leak implementation logic or allow vacuous solutions. All outputs are verified post-hoc using Lean's type checker to ensure machine-checkable correctness. We use ${\rm C{\small LEVER}}$ to evaluate several few-shot and agentic approaches based on state-of-the-art language models. These methods all struggle to achieve full verification, establishing it as a challenging frontier benchmark for program synthesis and formal reasoning. Our benchmark can be found on GitHub(https://github.com/trishullab/clever) as well as HuggingFace(https://huggingface.co/datasets/amitayusht/clever). All our evaluation code is also available online(https://github.com/trishullab/clever-prover).</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13938v1</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Amitayush Thakur, Jasper Lee, George Tsoukalas, Meghana Sistla, Matthew Zhao, Stefan Zetzche, Greg Durrett, Yisong Yue, Swarat Chaudhuri</dc:creator>
    </item>
    <item>
      <title>Verifying Tree-Manipulating Programs via CHCs</title>
      <link>https://arxiv.org/abs/2505.14092</link>
      <description>arXiv:2505.14092v1 Announce Type: cross 
Abstract: Programs that manipulate tree-shaped data structures often require complex, specialized proofs that are difficult to generalize and automate. This paper introduces a unified, foundational approach to verifying such programs. Central to our approach is the knitted-tree encoding, modeling each program execution as a tree structure capturing input, output, and intermediate states. Leveraging the compositional nature of knitted-trees, we encode these structures as constrained Horn clauses (CHCs), reducing verification to CHC satisfiability task. To illustrate our approach, we focus on memory safety and show how it naturally leads to simple, modular invariants.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14092v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Marco Faella, Gennaro Parlato</dc:creator>
    </item>
    <item>
      <title>Prime Factorization in Models of PV$_1$</title>
      <link>https://arxiv.org/abs/2505.14516</link>
      <description>arXiv:2505.14516v1 Announce Type: cross 
Abstract: Assuming that no family of polynomial-size Boolean circuits can factorize a constant fraction of all products of two $n$-bit primes, we show that the bounded arithmetic theory $\text{PV}_1$, even when augumented by the sharply bounded choice scheme $BB(\Sigma^b_0)$, cannot prove that every number has some prime divisor. By the completeness theorem, it follows that under this assumption there is a model $M$ of $\text{PV}_1$ that contains a nonstandard number $m$ which has no prime factorization.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14516v1</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ond\v{r}ej Je\v{z}il</dc:creator>
    </item>
    <item>
      <title>SATBench: Benchmarking LLMs' Logical Reasoning via Automated Puzzle Generation from SAT Formulas</title>
      <link>https://arxiv.org/abs/2505.14615</link>
      <description>arXiv:2505.14615v1 Announce Type: cross 
Abstract: We introduce SATBench, a benchmark for evaluating the logical reasoning capabilities of large language models (LLMs) through logical puzzles derived from Boolean satisfiability (SAT) problems. Unlike prior work that focuses on inference rule-based reasoning, which often involves deducing conclusions from a set of premises, our approach leverages the search-based nature of SAT problems, where the objective is to find a solution that fulfills a specified set of logical constraints. Each instance in SATBench is generated from a SAT formula, then translated into a story context and conditions using LLMs. The generation process is fully automated and allows for adjustable difficulty by varying the number of clauses. All 2100 puzzles are validated through both LLM-assisted and solver-based consistency checks, with human validation on a subset. Experimental results show that even the strongest model, o4-mini, achieves only 65.0% accuracy on hard UNSAT problems, close to the random baseline of 50%. SATBench exposes fundamental limitations in the search-based logical reasoning abilities of current LLMs and provides a scalable testbed for future research in logical reasoning.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14615v1</guid>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anjiang Wei, Yuheng Wu, Yingjia Wan, Tarun Suresh, Huanmi Tan, Zhanke Zhou, Sanmi Koyejo, Ke Wang, Alex Aiken</dc:creator>
    </item>
    <item>
      <title>If At First You Don't Succeed: Extended Monitorability through Multiple Executions</title>
      <link>https://arxiv.org/abs/2306.05229</link>
      <description>arXiv:2306.05229v3 Announce Type: replace 
Abstract: This paper studies the extent to which branching-time properties can be adequately verified using runtime monitors. We depart from the classical setup where monitoring is limited to a single system execution and investigate the enhanced observational capabilities when monitoring a system over multiple runs. To ensure generality in our results, we focus on branching-time properties expressed in the modal mu-calculus, a well-studied foundational logic that is used by state-of-the-art model checkers. Our results show that the proposed setup can systematically extend previously established monitorability limits for branching-time properties. We then validate our results by instantiating them to verify actor-based systems. We also prove bounds that capture the correspondence between the syntactic structure of a property and the number of required system runs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.05229v3</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antonis Achilleos, Adrian Francalanza, Jasmine Xuereb</dc:creator>
    </item>
    <item>
      <title>Equivalence Hypergraphs: DPO Rewriting for Monoidal E-Graphs</title>
      <link>https://arxiv.org/abs/2406.15882</link>
      <description>arXiv:2406.15882v2 Announce Type: replace 
Abstract: The technique of \emph{equality saturation}, which equips graphs with an equivalence relation, has proven effective for program optimisation. We give a categorical semantics to these structures, called \emph{e-graphs}, in terms of Cartesian categories enriched over the category of semilattices. This approach generalises to monoidal categories, which opens the door to new applications of e-graph techniques, from algebraic to monoidal theories. Finally, we present a sound and complete combinatorial representation of morphisms in such a category, based on a generalisation of hypergraphs which we call \emph{e-hypergraphs}. They have the usual advantage that many of their structural equations are absorbed into a general notion of isomorphism. This new principled approach to e-graphs enables double-pushout (DPO) rewriting for these structures, which constitutes the main contribution of this paper.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.15882v2</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Aleksei Tiurin, Chris Barrett, Dan R. Ghica, Nick Hu</dc:creator>
    </item>
    <item>
      <title>Ordinal Exponentiation in Homotopy Type Theory</title>
      <link>https://arxiv.org/abs/2501.14542</link>
      <description>arXiv:2501.14542v3 Announce Type: replace 
Abstract: We present two seemingly different definitions of constructive ordinal exponentiation, where an ordinal is taken to be a transitive, extensional, and wellfounded order on a set. The first definition is abstract, uses suprema of ordinals, and is solely motivated by the expected equations. The second is more concrete, based on decreasing lists, and can be seen as a constructive version of a classical construction by Sierpi{\'n}ski based on functions with finite support. We show that our two approaches are equivalent (whenever it makes sense to ask the question), and use this equivalence to prove algebraic laws and decidability properties of the exponential. Our work takes place in the framework of homotopy type theory, and all results are formalized in the proof assistant Agda.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14542v3</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tom de Jong, Nicolai Kraus, Fredrik Nordvall Forsberg, Chuangjie Xu</dc:creator>
    </item>
    <item>
      <title>Logic and Computation through the Lens of Semirings</title>
      <link>https://arxiv.org/abs/2502.12939</link>
      <description>arXiv:2502.12939v3 Announce Type: replace 
Abstract: We study the expressivity and computational aspects of first-order logic and its extensions in the semiring semantics developed by Gr\"adel and Tannen. We characterize the complexity of model checking and data complexity of first-order logic both in terms of a generalization of Blum-Shub-Smale machines and arithmetic circuits defined over a semiring. In particular, we give a logical characterization of constant-depth arithmetic circuits by an extension of first-order logic that holds for any semiring that is both commutative and positive.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.12939v3</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Timon Barlag, Nicolas Fr\"ohlich, Teemu Hankala, Miika Hannula, Minna Hirvonen, Vivian Holzapfel, Juha Kontinen, Arne Meier, Laura Strieker</dc:creator>
    </item>
    <item>
      <title>Probabilistic Strategies: Definability and the Tensor Completeness Problem</title>
      <link>https://arxiv.org/abs/2504.09392</link>
      <description>arXiv:2504.09392v3 Announce Type: replace 
Abstract: Programs that combine I/O and countable probabilistic choice, modulo either bisimilarity or trace equivalence, can be seen as describing a probabilistic strategy. For well-founded programs, we might expect to axiomatize bisimilarity via a sum of equational theories and trace equivalence via a tensor of such theories. This is by analogy with similar results for nondeterminism, established previously.
  While bisimilarity is indeed axiomatized via a sum of theories, and the tensor is indeed at least sound for trace equivalence, completeness in general, remains an open problem. Nevertheless, we show completeness in the case that either the probabilistic choice or the I/O operations used are finitary. We also show completeness up to impersonation, i.e. that the tensor theory regards trace equivalent programs as solving the same system of equations. This entails completeness up to the cancellation law of the probabilistic choice operator.
  Furthermore, we show that a probabilistic trace strategy arises as the semantics of a well-founded program iff it is victorious. This means that, when the strategy is played against any partial counterstrategy, the probability of play continuing forever is zero.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.09392v3</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nathan Bowler, Sergey Goncharov, Paul Blain Levy</dc:creator>
    </item>
    <item>
      <title>On the Boolean Network Theory of Datalog$^\neg$</title>
      <link>https://arxiv.org/abs/2504.15417</link>
      <description>arXiv:2504.15417v2 Announce Type: replace 
Abstract: Datalog$^\neg$ is a central formalism used in a variety of domains ranging from deductive databases and abstract argumentation frameworks to answer set programming. Its model theory is the finite counterpart of the logical semantics developed for normal logic programs, mainly based on the notions of Clark's completion and two-valued or three-valued canonical models including supported, stable, regular and well-founded models. In this paper we establish a formal link between Datalog$^\neg$ and Boolean network theory first introduced for gene regulatory networks. We show that in the absence of odd cycles in a Datalog$^\neg$ program, the regular models coincide with the stable models, which entails the existence of stable models, and in the absence of even cycles, we prove the uniqueness of stable partial models and regular models. This connection also gives new upper bounds on the numbers of stable partial, regular, and stable models of a Datalog$^\neg$ program using the cardinality of a feedback vertex set in its atom dependency graph. Interestingly, our connection to Boolean network theory also points us to the notion of trap spaces. In particular we show the equivalence between subset-minimal stable trap spaces and regular models.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.15417v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Van-Giang Trinh, Belaid Benhamou, Sylvain Soliman, Fran\c{c}ois Fages</dc:creator>
    </item>
    <item>
      <title>A Non-Interventionist Approach to Causal Reasoning based on Lewisian Counterfactuals</title>
      <link>https://arxiv.org/abs/2505.12972</link>
      <description>arXiv:2505.12972v2 Announce Type: replace 
Abstract: We present a computationally grounded semantics for counterfactual conditionals in which i) the state in a model is decomposed into two elements: a propositional valuation and a causal base in propositional form that represents the causal information available at the state; and ii) the comparative similarity relation between states is computed from the states' two components. We show that, by means of our semantics, we can elegantly formalize the notion of actual cause without recurring to the primitive notion of intervention. Furthermore, we provide a succinct formulation of the model checking problem for a language of counterfactual conditionals in our semantics. We show that this problem is PSPACE-complete and provide a reduction of it into QBF that can be used for automatic verification of causal properties.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.12972v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Carlos Aguilera-Ventura, Xinghan Liu, Emiliano Lorini, Dmitry Rozplokhas</dc:creator>
    </item>
    <item>
      <title>Most General Explanations of Tree Ensembles (Extended Version)</title>
      <link>https://arxiv.org/abs/2505.10991</link>
      <description>arXiv:2505.10991v3 Announce Type: replace-cross 
Abstract: Explainable Artificial Intelligence (XAI) is critical for attaining trust in the operation of AI systems. A key question of an AI system is ``why was this decision made this way''. Formal approaches to XAI use a formal model of the AI system to identify abductive explanations. While abductive explanations may be applicable to a large number of inputs sharing the same concrete values, more general explanations may be preferred for numeric inputs. So-called inflated abductive explanations give intervals for each feature ensuring that any input whose values fall withing these intervals is still guaranteed to make the same prediction. Inflated explanations cover a larger portion of the input space, and hence are deemed more general explanations. But there can be many (inflated) abductive explanations for an instance. Which is the best? In this paper, we show how to find a most general abductive explanation for an AI decision. This explanation covers as much of the input space as possible, while still being a correct formal explanation of the model's behaviour. Given that we only want to give a human one explanation for a decision, the most general explanation gives us the explanation with the broadest applicability, and hence the one most likely to seem sensible. (The paper has been accepted at IJCAI2025 conference.)</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.10991v3</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Wed, 21 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Yacine Izza, Alexey Ignatiev, Sasha Rubin, Joao Marques-Silva, Peter J. Stuckey</dc:creator>
    </item>
  </channel>
</rss>
