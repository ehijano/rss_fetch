<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Jul 2024 04:01:18 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 16 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>On Lower Bounding Minimal Model Count</title>
      <link>https://arxiv.org/abs/2407.09744</link>
      <description>arXiv:2407.09744v1 Announce Type: new 
Abstract: Minimal models of a Boolean formula play a pivotal role in various reasoning tasks. While previous research has primarily focused on qualitative analysis over minimal models; our study concentrates on the quantitative aspect, specifically counting of minimal models. Exact counting of minimal models is strictly harder than #P, prompting our investigation into establishing a lower bound for their quantity, which is often useful in related applications. In this paper, we introduce two novel techniques for counting minimal models, leveraging the expressive power of answer set programming: the first technique employs methods from knowledge compilation, while the second one draws on recent advancements in hashing-based approximate model counting. Through empirical evaluations, we demonstrate that our methods significantly improve the lower bound estimates of the number of minimal models, surpassing the performance of existing minimal model reasoning systems in terms of runtime.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.09744v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mohimenul Kabir, Kuldeep S Meel</dc:creator>
    </item>
    <item>
      <title>The Significance of Symbolic Logic for Scientific Education</title>
      <link>https://arxiv.org/abs/2407.09959</link>
      <description>arXiv:2407.09959v1 Announce Type: new 
Abstract: This invited paper is a passionate pitch for the significance of logic in scientific education. Logic helps focus on the essential core to identify the foundations of ideas and provides corresponding longevity with the resulting approach to new and old problems. Logic operates symbolically, where each part has a precise meaning and the meaning of the whole is compositional, so a simple function of the meaning of the pieces. This compositionality in the meaning of logical operators is the basis for compositionality in reasoning about logical operators. Both semantic and deductive compositionalities help explain what happens in reasoning. The correctness-critical core of an idea or an algorithm is often expressible eloquently and particularly concisely in logic. The opinions voiced in this paper are influenced by the author's teaching of courses on cyber-physical systems, constructive logic, compiler design, programming language semantics, and imperative programming principles. In each of those courses, different aspects of logic come up for different purposes to elucidate significant ideas particularly clearly. While there is a bias of the thoughts in this paper toward computer science, some courses have been heavily frequented by students from other majors so that some transfer of the thoughts to other science and engineering disciplines is plausible.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.09959v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andr\'e Platzer</dc:creator>
    </item>
    <item>
      <title>A Unifying Approach to Product Constructions for Quantitative Temporal Inference</title>
      <link>https://arxiv.org/abs/2407.10465</link>
      <description>arXiv:2407.10465v1 Announce Type: new 
Abstract: Probabilistic programs are a powerful and convenient approach to formalise distributions over system executions. A classical verification problem for probabilistic programs is temporal inference: to compute the likelihood that the execution traces satisfy a given temporal property. This paper presents a general framework for temporal inference, which applies to a rich variety of quantitative models including those that arise in the operational semantics of probabilistic and weighted programs.
  The key idea underlying our framework is that in a variety of existing approaches, the main construction that enables temporal inference is that of a product between the system of interest and the temporal property. We provide a unifying mathematical definition of product constructions, enabled by the realisation that 1) both systems and temporal properties can be modelled as coalgebras and 2) product constructions are distributive laws in this context. Our categorical framework leads us to our main contribution: a sufficient condition for correctness, which is precisely what enables to use the product construction for temporal inference.
  We show that our framework can be instantiated to naturally recover a number of disparate approaches from the literature including, e.g., partial expected rewards in Markov reward models, resource-sensitive reachability analysis, and weighted optimization problems. Further, we demonstrate a product of weighted programs and weighted temporal properties as a new instance to show the scalability of our approach.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.10465v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Kazuki Watanabe, Sebastian Junges, Jurriaan Rot, Ichiro Hasuo</dc:creator>
    </item>
    <item>
      <title>Strategic Dominance: A New Preorder for Nondeterministic Processes</title>
      <link>https://arxiv.org/abs/2407.10473</link>
      <description>arXiv:2407.10473v1 Announce Type: new 
Abstract: We study the following refinement relation between nondeterministic state-transition models: model B strategically dominates model A iff every deterministic refinement of A is language contained in some deterministic refinement of B. While language containment is trace inclusion, and the (fair) simulation preorder coincides with tree inclusion, strategic dominance falls strictly between the two and can be characterized as "strategy inclusion" between A and B: every strategy that resolves the nondeterminism of A is dominated by a strategy that resolves the nondeterminism of B. Strategic dominance can be checked in 2-ExpTime by a decidable first-order Presburger logic with quantification over words and strategies, called resolver logic. We give several other applications of resolver logic, including checking the co-safety, co-liveness, and history-determinism of boolean and quantitative automata, and checking the inclusion between hyperproperties that are specified by nondeterministic boolean and quantitative automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.10473v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Thomas A. Henzinger, Nicolas Mazzocchi, N. Ege Sara\c{c}</dc:creator>
    </item>
    <item>
      <title>Wadge degrees of $\Delta^0_2$ omega-powers</title>
      <link>https://arxiv.org/abs/2407.10520</link>
      <description>arXiv:2407.10520v1 Announce Type: new 
Abstract: We provide, for each natural number $n$ and each class among $D_n(\Sigma^0_1)$, $\bar D_n(\Sigma^0_1)$ and $D_{2n+1}(\Sigma^0_1)\oplus\bar D_{2n+1}(\Sigma^0_1)$, a regular language whose associated omega-power is complete for this class.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.10520v1</guid>
      <category>cs.LO</category>
      <category>math.GN</category>
      <category>math.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Olivier Finkel (IMJ-PRG), Dominique Lecomte (IMJ-PRG)</dc:creator>
    </item>
    <item>
      <title>A proof-theoretical approach to some extensions of first order quantification</title>
      <link>https://arxiv.org/abs/2407.09865</link>
      <description>arXiv:2407.09865v1 Announce Type: cross 
Abstract: Generalised quantifiers, which include Henkin's branching quantifiers, have been introduced by Mostowski and Lindstr\"om and developed as a substantial topic application of logic, especially model theory, to linguistics with work by Barwise, Cooper, Keenan.
  In this paper, we mainly study the proof theory of some non-standard quantifiers as second order formulae . Our first example is the usual pair of first order quantifiers (for all / there exists) when individuals are viewed as individual concepts handled by second order deductive rules. Our second example is the study of a second order translation of the simplest branching quantifier: ``A member of each team and a member of each board of directors know each other", for which we propose a second order treatment.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.09865v1</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Lo\"ic All\`egre, Oph\'elie Lacroix, Christian Retor\'e</dc:creator>
    </item>
    <item>
      <title>Compositional Symbolic Execution for Correctness and Incorrectness Reasoning (Extended Version)</title>
      <link>https://arxiv.org/abs/2407.10838</link>
      <description>arXiv:2407.10838v1 Announce Type: cross 
Abstract: The introduction of separation logic has led to the development of symbolic-execution techniques and tools that are (functionally) compositional with function specifications that can be used in broader calling contexts. Many of the compositional symbolic-execution tools developed in academia and industry have been grounded on a formal foundation, but either the function specifications are not validated concerning the underlying separation logic of the theory, or there is a large gulf between the theory and the tool implementation.
  We introduce a formal compositional symbolic-execution engine which creates and uses function specifications from an underlying separation logic and provides a sound theoretical foundation partially inspired by the Gillian symbolic-execution platform. This is achieved by providing an axiomatic interface which describes the properties of the consume and produce operations used in the engine to compositionally update the symbolic state, including, when calling function specifications -- a technique used by VeriFast, Viper, and Gillian but not previously characterised independently of the tool. Our result consume and produce operations inspired by the Gillian implementation that satisfy the properties described by our axiomatic interface. A surprising property of our engine semantics is its ability to underpin both correctness and incorrectness reasoning, with the primary distinction being the choice between satisfiability and validity. We use this property to extend the Gillian platform, which previously only supported correctness reasoning, with incorrectness reasoning and automatic true bug-finding using incorrectness bi-abduction. We evaluate our new Gillian platform through instantiation to C. This instantiation is the first tool grounded on a common formal compositional symbolic-execution engine to support both correctness and incorrectness reasoning.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.10838v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.ECOOP.2024.12</arxiv:DOI>
      <arxiv:journal_reference>ECOOP 2024</arxiv:journal_reference>
      <dc:creator>Andreas L\"o\"ow, Daniele Nantes-Sobrinho, Sacha-\'Elie Ayoun, Caroline Cronj\"ager, Petar Maksimovi\'c, Philippa Gardner</dc:creator>
    </item>
    <item>
      <title>Coalgebraic Behavioral Metrics</title>
      <link>https://arxiv.org/abs/1712.07511</link>
      <description>arXiv:1712.07511v5 Announce Type: replace 
Abstract: We study different behavioral metrics, such as those arising from both branching and linear-time semantics, in a coalgebraic setting. Given a coalgebra $\alpha\colon X \to HX$ for a functor $H \colon \mathrm{Set}\to \mathrm{Set}$, we define a framework for deriving pseudometrics on $X$ which measure the behavioral distance of states.
  A crucial step is the lifting of the functor $H$ on $\mathrm{Set}$ to a functor $\overline{H}$ on the category $\mathrm{PMet}$ of pseudometric spaces. We present two different approaches which can be viewed as generalizations of the Kantorovich and Wasserstein pseudometrics for probability measures. We show that the pseudometrics provided by the two approaches coincide on several natural examples, but in general they differ.
  If $H$ has a final coalgebra, every lifting $\overline{H}$ yields in a canonical way a behavioral distance which is usually branching-time, i.e., it generalizes bisimilarity. In order to model linear-time metrics (generalizing trace equivalences), we show sufficient conditions for lifting distributive laws and monads. These results enable us to employ the generalized powerset construction.</description>
      <guid isPermaLink="false">oai:arXiv.org:1712.07511v5</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.23638/LMCS-14(3:20)2018</arxiv:DOI>
      <arxiv:journal_reference>Logical Methods in Computer Science, Volume 14, Issue 3 (September 14, 2018) lmcs:4715</arxiv:journal_reference>
      <dc:creator>Paolo Baldan, Filippo Bonchi, Henning Kerstan, Barbara K\"onig</dc:creator>
    </item>
    <item>
      <title>A Framework for Modelling, Verification and Transformation of Concurrent Imperative Programs</title>
      <link>https://arxiv.org/abs/2007.02261</link>
      <description>arXiv:2007.02261v5 Announce Type: replace 
Abstract: The paper gives a detailed presentation of a framework, embedded into the simply typed higher-order logic and aimed at the support of sound and structured reasoning about various properties of models of imperative programs with interleaved computations. As a case study, a model of the Peterson's mutual exclusion algorithm will be scrutinised in the course of the paper illustrating applicability of the framework.</description>
      <guid isPermaLink="false">oai:arXiv.org:2007.02261v5</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Maksym Bortin</dc:creator>
    </item>
    <item>
      <title>Disentangling Parallelism and Interference in Game Semantics</title>
      <link>https://arxiv.org/abs/2103.15453</link>
      <description>arXiv:2103.15453v2 Announce Type: replace 
Abstract: Game semantics is a denotational semantics presenting compositionally the computational behaviour of various kinds of effectful programs. One of its celebrated achievement is to have obtained full abstraction results for programming languages with a variety of computational effects, in a single framework. This is known as the semantic cube or Abramsky's cube, which for sequential deterministic programs establishes a correspondence between certain conditions on strategies (''innocence'', ''well-bracketing'', ''visibility'') and the absence of matching computational effects. Outside of the sequential deterministic realm, there are still a wealth of game semantics-based full abstraction results; but they no longer fit in a unified canvas. In particular, Ghica and Murawski's fully abstract model for shared state concurrency (IA) does not have a matching notion of pure parallel program-we say that parallelism and interference (i.e. state plus semaphores) are entangled. In this paper we construct a causal version of Ghica and Murawski's model, also fully abstract for IA. We provide compositional conditions parallel innocence and sequentiality, respectively banning interference and parallelism, and leading to four full abstraction results. To our knowledge, this is the first extension of Abramsky's semantic cube programme beyond the sequential deterministic world.</description>
      <guid isPermaLink="false">oai:arXiv.org:2103.15453v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Simon Castellan (EPICURE), Pierre Clairambault (LIS, CNRS, LSC)</dc:creator>
    </item>
    <item>
      <title>A Generalized Hybrid Hoare Logic</title>
      <link>https://arxiv.org/abs/2303.15020</link>
      <description>arXiv:2303.15020v3 Announce Type: replace 
Abstract: Deductive verification of hybrid systems (HSs) increasingly attracts more attention in recent years because of its power and scalability, where a powerful specification logic for HSs is the cornerstone. Often, HSs are naturally modelled by concurrent processes that communicate with each other. However, existing specification logics cannot easily handle such models. In this paper, we present a specification logic and proof system for Hybrid Communicating Sequential Processes (HCSP), that extends CSP with ordinary differential equations (ODE) and interrupts to model interactions between continuous and discrete evolution. Because it includes a rich set of algebraic operators, complicated hybrid systems can be easily modelled in an algebra-like compositional way in HCSP. Our logic can be seen as a generalization and simplification of existing hybrid Hoare logics (HHL) based on duration calculus (DC), as well as a conservative extension of existing Hoare logics for concurrent programs. Its assertion logic is the first-order theory of differential equations (FOD), together with assertions about traces recording communications, readiness, and continuous evolution. We prove continuous relative completeness of the logic w.r.t. FOD, as well as discrete relative completeness in the sense that continuous behaviour can be arbitrarily approximated by discretization. Finally, we implement the above logic in Isabelle/HOL, and apply it to verify two case studies to illustrate the power and scalability of our logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2303.15020v3</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Naijun Zhan, Xiangyu Jin, Bohua Zhan, Shuling Wang, Dimitar Guelev</dc:creator>
    </item>
    <item>
      <title>The Flower Calculus</title>
      <link>https://arxiv.org/abs/2402.15174</link>
      <description>arXiv:2402.15174v3 Announce Type: replace 
Abstract: We introduce the flower calculus, a deep inference proof system for intuitionistic first-order logic inspired by Peirce's existential graphs. It works as a rewriting system over inductive objects called ''flowers'', that enjoy both a graphical interpretation as topological diagrams, and a textual presentation as nested sequents akin to coherent formulas. Importantly, the calculus dispenses completely with the traditional notion of symbolic connective, operating solely on nested flowers containing atomic predicates. We prove both the soundness of the full calculus and the completeness of an analytic fragment with respect to Kripke semantics. This provides to our knowledge the first analyticity result for a proof system based on existential graphs, adapting semantic cut-elimination techniques to a deep inference setting. Furthermore, the kernel of rules targetted by completeness is fully invertible, a desirable property for both automated and interactive proof search.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.15174v3</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:journal_reference>Leibniz International Proceedings in Informatics , 2024, 9th International Conference on Formal Structures for Computation and Deduction (FSCD 2024) (299), pp.5:1-5:24</arxiv:journal_reference>
      <dc:creator>Pablo Donato (PARTOUT)</dc:creator>
    </item>
    <item>
      <title>Structure-Aware Computing By Partial Quantifier Elimination</title>
      <link>https://arxiv.org/abs/2403.05928</link>
      <description>arXiv:2403.05928v3 Announce Type: replace 
Abstract: By structure-aware computing (SAC) we mean computing that is formula-specific i.e., takes into account the structure of the formula at hand. Virtually all efficient algorithms of hardware verification employ some form of SAC. We relate SAC to $\mathit{partial}$ $\mathit{quantifier}$ $\mathit{elimination}$ (PQE). The latter is a generalization of regular quantifier elimination where one can take a $\mathit{part}$ of the formula out of the scope of quantifiers. The objective of this paper is to emphasize the significance of studying PQE for enhancing the $\mathit{existing}$ methods of SAC and creating $\mathit{new}$ ones. First, we show that interpolation (that can be viewed as an instance of SAC) is a special case of PQE. Then we describe application of SAC by PQE to three different problems of hardware verification: property generation, equivalence checking and model checking. Besides, we discuss using SAC by PQE for SAT solving.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.05928v3</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Eugene Goldberg</dc:creator>
    </item>
  </channel>
</rss>
