<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Jan 2025 02:33:25 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Quantifier Elimination and Craig Interpolation: The Quantitative Way (Technical Report)</title>
      <link>https://arxiv.org/abs/2501.15156</link>
      <description>arXiv:2501.15156v1 Announce Type: new 
Abstract: Quantifier elimination (QE) and Craig interpolation (CI) are central to various state-of-the-art automated approaches to hardware- and software verification. They are rooted in the Boolean setting and are successful for, e.g., first-order theories such as linear rational arithmetic. What about their applicability in the quantitative setting where formulae evaluate to numbers and quantitative supremum/infimum quantifiers are the natural pendant to traditional Boolean quantifiers? Applications include establishing quantitative properties of programs such as bounds on expected outcomes of probabilistic programs featuring unbounded non-determinism and analyzing the flow of information through programs.
  In this paper, we present the - to the best of our knowledge - first QE algorithm for possibly unbounded, $\infty$- or $(-\infty)$-valued, or discontinuous piecewise linear quantities. They are the quantitative counterpart to linear rational arithmetic, and are a popular quantitative assertion language for probabilistic program verification. We provide rigorous soundness proofs as well as upper space complexity bounds. Moreover, our algorithm yields a quantitative CI theorem: Given arbitrary piecewise linear quantities $f,g$ with $f \models g$, both the strongest and the weakest Craig interpolant of $f$ and $g$ are quantifier-free and effectively constructible.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15156v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Kevin Batz, Joost-Pieter Katoen, Nora Orhan</dc:creator>
    </item>
    <item>
      <title>Complete Quantum Relational Hoare Logics from Optimal Transport Duality</title>
      <link>https://arxiv.org/abs/2501.15238</link>
      <description>arXiv:2501.15238v1 Announce Type: new 
Abstract: We introduce a quantitative relational Hoare logic for quantum programs. Assertions of the logic range over a new infinitary extension of positive semidefinite operators. We prove that our logic is sound, and complete for bounded postconditions and almost surely terminating programs. Our completeness result is based on a quantum version of the duality theorem from optimal transport. We also define a complete embedding into our logic of a relational Hoare logic with projective assertions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15238v1</guid>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gilles Barthe, Minbo Gao, Theo Wang, Li Zhou</dc:creator>
    </item>
    <item>
      <title>Guarded Negation Transitive Closure Logic is 2-EXPTIME-complete</title>
      <link>https://arxiv.org/abs/2501.15303</link>
      <description>arXiv:2501.15303v1 Announce Type: new 
Abstract: We consider guarded negation transitive closure logic (GNTC). In this paper, we show that the satisfiability problem for GNTC is in 2-EXPTIME (hence, 2-EXPTIME-complete from existing lower bound results), which improves the previously known non-elementary time upper bound. This extends previously known 2-EXPTIME upper bound results, e.g., for the guarded negation fragment of first-order logic, the unary negation fragment of first-order logic with regular path expressions, propositional dynamic logic (PDL) with intersection and converse, and CPDL+ (an extension of PDL with conjunctive queries) of bounded treewidth.
  To this end, we present a sound and complete local model checker on tree decompositions. This system has a closure property of size single exponential, and it induces a reduction from the satisfiability problem for GNTC into the non-emptiness problem for 2-way (weak) alternating parity tree automata in single exponential time.
  Additionally, we investigate the complexity of satisfiability and model checking for fragments of GNTC, such as guarded (quantification) fragments, unary negation fragments, and existential positive fragments.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15303v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yoshiki Nakamura</dc:creator>
    </item>
    <item>
      <title>A General Completeness Theorem for Skip-free Star Algebras</title>
      <link>https://arxiv.org/abs/2501.15325</link>
      <description>arXiv:2501.15325v1 Announce Type: new 
Abstract: We consider process algebras with branching parametrized by an equational theory T, and show that it is possible to axiomatize bisimilarity under certain conditions on T. Our proof abstracts an earlier argument due to Grabmayer and Fokkink (LICS'20), and yields new completeness theorems for skip-free process algebras with probabilistic (guarded) branching, while also covering existing completeness results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15325v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tobias Kapp\'e, Todd Schmid</dc:creator>
    </item>
    <item>
      <title>Variable Elimination as Rewriting in a Linear Lambda Calculus</title>
      <link>https://arxiv.org/abs/2501.15439</link>
      <description>arXiv:2501.15439v1 Announce Type: new 
Abstract: Variable Elimination (VE) is a classical exact inference algorithm for probabilistic graphical models such as Bayesian Networks,
  computing the marginal distribution of a subset of the
  random variables in the model.
  Our goal is to understand Variable Elimination as an algorithm acting on programs, here expressed in an idealized probabilistic functional language -- a linear simply-typed $\lambda$-calculus suffices for our purpose.
  Precisely, we express VE as a term rewriting process,
  which transforms a global definition of a variable into a local
  definition, by swapping and nesting let-in expressions.
  We exploit in an essential way linear types.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15439v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:journal_reference>ESOP 2025</arxiv:journal_reference>
      <dc:creator>Thomas Ehrhard, Claudia Faggian, Michele Pagani</dc:creator>
    </item>
    <item>
      <title>Skolemization In Intermediate Logics</title>
      <link>https://arxiv.org/abs/2501.15507</link>
      <description>arXiv:2501.15507v1 Announce Type: new 
Abstract: Skolemization, with Herbrand's theorem, underpins automated theorem proving and various transformations in computer science and mathematics. Skolemization removes strong quantifiers by introducing new function symbols, enabling efficient proof search algorithms. We characterize intermediate first-order logics that admit standard (and Andrews) Skolemization. These are the logics that allow classical quantifier shift principles. For some logics not in this category, innovative forms of Skolem functions are developed that allow Skolemization. Moreover, we analyze predicate intuitionistic logic with quantifier shift axioms and demonstrate its Kripke frame-incompleteness. These findings may foster resolution-based theorem provers for non-classical logics. This article is part of a larger project investigating Skolemization in non-classical logics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15507v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Matthias Baaz, Mariami Gamsakhurdia, Rosalie Iemhoff, Raheleh Jalali</dc:creator>
    </item>
    <item>
      <title>Tropical Mathematics and the Lambda-Calculus II: Tropical Geometry of Probabilistic Programming Languages</title>
      <link>https://arxiv.org/abs/2501.15637</link>
      <description>arXiv:2501.15637v1 Announce Type: new 
Abstract: In the last few years there has been a growing interest towards methods for statistical inference and learning based on ideas from computational algebraic geometry, and notably from tropical geometry, that is, the study of algebraic varieties over the min-plus semiring. At the same time, recent work has demonstrated the possibility of interpreting a higher-order probabilistic programming language in the framework of tropical mathematics, by exploiting the weighted relational semantics from linear logic. In this paper we try to put these two worlds in contact, by showing that actual methods from tropical geometry can indeed be exploited to perform statistical inference on higher order programs. For example, we show that the problem of describing the most-likely behavior of a probabilistic PCF program reduces to studying a tropical polynomial function associated with the program. We also design an intersection type system that captures such polynomials. As an application of our approach, we finally show that the tropical polynomial associated with a probabilistic protocol expressed in our language can be used to estimate its differential privacy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15637v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Davide Barbarossa, Paolo Pistone</dc:creator>
    </item>
    <item>
      <title>A Tutorial on Stream-based Monitoring</title>
      <link>https://arxiv.org/abs/2501.15913</link>
      <description>arXiv:2501.15913v1 Announce Type: new 
Abstract: Stream-based runtime monitoring frameworks are safety assurance tools that check the runtime behavior of a system against a formal specification. This tutorial provides a hands-on introduction to RTLola, a real-time monitoring toolkit for cyber-physical systems and networks. RTLola processes, evaluates, and aggregates streams of input data, such as sensor readings, and provides a real-time analysis in the form of comprehensive statistics and logical assessments of the system's health. RTLola has been applied successfully in monitoring autonomous systems such as unmanned aircraft. The tutorial guides the reader through the development of a stream-based specification for an autonomous drone observing other flying objects in its flight path. Each tutorial section provides an intuitive introduction, highlighting useful language features and specification patterns, and gives a more in-depth explanation of technical details for the advanced reader. Finally, we discuss how runtime monitors generated from RTLola specifications can be integrated into a variety of systems and discuss different monitoring applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15913v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-031-71177-0</arxiv:DOI>
      <dc:creator>Jan Baumeister, Bernd Finkbeiner, Florian Kohn, Frederik Scheerer</dc:creator>
    </item>
    <item>
      <title>Efficient Evidence Generation for Modal $\mu$-Calculus Model Checking (extended version)</title>
      <link>https://arxiv.org/abs/2501.15938</link>
      <description>arXiv:2501.15938v1 Announce Type: new 
Abstract: Model checking is a technique to automatically assess whether a model of the behaviour of a system meets its requirements. Evidence explaining why the behaviour does (not) meet its requirements is essential for the user to understand the model checking result. Willemse and Wesselink showed that parameterised Boolean equation systems (PBESs), an intermediate format for $\mu$-calculus model checking, can be extended with information to generate such evidence. Solving the resulting PBES is much slower than solving one without additional information, and sometimes even impossible. In this paper we develop a two-step approach to solving a PBES with additional information: we first solve its core and subsequently use the information obtained in this step to solve the PBES with additional information. We prove the correctness of our approach and we have implemented it, demonstrating that it efficiently generates evidence using both explicit and symbolic solving techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15938v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Anna Stramaglia, Jeroen J. A. Keiren, Maurice Laveaux, Tim A. C. Willemse</dc:creator>
    </item>
    <item>
      <title>On the algorithmic structure of Dialectica programs</title>
      <link>https://arxiv.org/abs/2501.16208</link>
      <description>arXiv:2501.16208v1 Announce Type: new 
Abstract: We explore the Dialectica interpretation from the perspective of programming languages, by presenting it as a collection of rules in the style of Hoare logic. This allows us to add a while loop construct for Dialectica realizers, which offers an elegant description of programs extracted from nonconstructive principles. We characterise Dialectica realizers in terms of a generalised backpropagation procedure, whose forward component can be regarded as a `stateful' program in the usual sense. We propose several directions in which the work we present here can be developed in future.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.16208v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Davide Barbarossa, Thomas Powell</dc:creator>
    </item>
    <item>
      <title>Symbolic Knowledge Extraction and Injection with Sub-symbolic Predictors: A Systematic Literature Review</title>
      <link>https://arxiv.org/abs/2501.14836</link>
      <description>arXiv:2501.14836v1 Announce Type: cross 
Abstract: In this paper we focus on the opacity issue of sub-symbolic machine learning predictors by promoting two complementary activities, namely, symbolic knowledge extraction (SKE) and injection (SKI) from and into sub-symbolic predictors. We consider as symbolic any language being intelligible and interpretable for both humans and computers. Accordingly, we propose general meta-models for both SKE and SKI, along with two taxonomies for the classification of SKE and SKI methods. By adopting an explainable artificial intelligence (XAI) perspective, we highlight how such methods can be exploited to mitigate the aforementioned opacity issue. Our taxonomies are attained by surveying and classifying existing methods from the literature, following a systematic approach, and by generalising the results of previous surveys targeting specific sub-topics of either SKE or SKI alone. More precisely, we analyse 132 methods for SKE and 117 methods for SKI, and we categorise them according to their purpose, operation, expected input/output data and predictor types. For each method, we also indicate the presence/lack of runnable software implementations. Our work may be of interest for data scientists aiming at selecting the most adequate SKE/SKI method for their needs, and also work as suggestions for researchers interested in filling the gaps of the current state of the art, as well as for developers willing to implement SKE/SKI-based technologies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14836v1</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3645103</arxiv:DOI>
      <arxiv:journal_reference>ACM Comput. Surv. 56, (2024), 1 - 35</arxiv:journal_reference>
      <dc:creator>Giovanni Ciatto, Federico Sabbatini, Andrea Agiollo, Matteo Magnini, Andrea Omicini</dc:creator>
    </item>
    <item>
      <title>JustLogic: A Comprehensive Benchmark for Evaluating Deductive Reasoning in Large Language Models</title>
      <link>https://arxiv.org/abs/2501.14851</link>
      <description>arXiv:2501.14851v1 Announce Type: cross 
Abstract: Logical reasoning is a critical component of Large Language Models (LLMs), and substantial research efforts in recent years have aimed to enhance their deductive reasoning capabilities. However, existing deductive reasoning benchmarks, which are crucial for evaluating and advancing LLMs, are inadequate due to their lack of task complexity, presence of prior knowledge as a confounder, and superficial error analysis. To address these deficiencies, we introduce JustLogic, a synthetically generated deductive reasoning benchmark designed for rigorous evaluation of LLMs. JustLogic is (i) highly complex, capable of generating a diverse range of linguistic patterns, vocabulary, and argument structures; (ii) prior knowledge independent, eliminating the advantage of models possessing prior knowledge and ensuring that only deductive reasoning is used to answer questions; and (iii) capable of in-depth error analysis on the heterogeneous effects of reasoning depth and argument form on model accuracy. Our experimental results on JustLogic reveal that most state-of-the-art (SOTA) LLMs perform significantly worse than the human average, demonstrating substantial room for model improvement. All code and data are available at https://github.com/michaelchen-lab/JustLogic</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14851v1</guid>
      <category>cs.CL</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Michael K. Chen, Xikun Zhang, Dacheng Tao</dc:creator>
    </item>
    <item>
      <title>The Alternation Hierarchy of First-Order Logic on Words is Decidable</title>
      <link>https://arxiv.org/abs/2501.14899</link>
      <description>arXiv:2501.14899v1 Announce Type: cross 
Abstract: We show that for any $i &gt; 0$, it is decidable, given a regular language, whether it is expressible in the $\Sigma_i[&lt;]$ fragment of first-order logic FO[&lt;]. This settles a question open since 1971.
  Our main technical result relies on the notion of polynomial closure of a class of languages $\mathcal{V}$, that is, finite unions of languages of the form $L_0a_1L_1\cdots a_nL_n$ where each $a_i$ is a letter and each $L_i$ a language of $\mathcal{V}$. We show that if a class $\mathcal{V}$ of regular languages with some closure properties (namely, a positive variety) has a decidable separation problem, then so does its polynomial closure Pol($\mathcal{V}$). The resulting algorithm for Pol($\mathcal{V}$) has time complexity that is exponential in the time complexity for $\mathcal{V}$ and we propose a natural conjecture that would lead to a polynomial time blowup instead.
  Corollaries include the decidability of half levels of the dot-depth hierarchy and the group-based concatenation hierarchy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14899v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Corentin Barloy, Micha\"el Cadilhac, Charles Paperman, Howard Straubing</dc:creator>
    </item>
    <item>
      <title>A Proof-Producing Compiler for Blockchain Applications</title>
      <link>https://arxiv.org/abs/2501.15002</link>
      <description>arXiv:2501.15002v1 Announce Type: cross 
Abstract: CairoZero is a programming language for running decentralized applications (dApps) at scale. Programs written in the CairoZero language are compiled to machine code for the Cairo CPU architecture and cryptographic protocols are used to verify the results of execution efficiently on blockchain. We explain how we have extended the CairoZero compiler with tooling that enables users to prove, in the Lean 3 proof assistant, that compiled code satisfies high-level functional specifications. We demonstrate the success of our approach by verifying primitives for computation with the secp256k1 and secp256r1 curves over a large finite field as well as the validation of cryptographic signatures using the former. We also verify a mechanism for simulating a read-write dictionary data structure in a read-only setting. Finally, we reflect on our methodology and discuss some of the benefits of our approach.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15002v1</guid>
      <category>cs.CR</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeremy Avigad, Lior Goldberg, David Levit, Yoav Seginer, Alon Titelman</dc:creator>
    </item>
    <item>
      <title>Two-sorted algebraic decompositions of Brookes's shared-state denotational semantics</title>
      <link>https://arxiv.org/abs/2501.15104</link>
      <description>arXiv:2501.15104v1 Announce Type: cross 
Abstract: We use a two sorted equational theory of algebraic effects to model concurrent shared state with preemptive interleaving, recovering Brookes's seminal 1996 trace-based model precisely. The decomposition allows us to analyse Brookes's model algebraically in terms of separate but interacting components. The multiple sorts partition terms into layers. We use two sorts: a "hold" sort for layers that disallow interleaving of environment memory accesses, analogous to holding a global lock on the memory; and a "cede" sort for the opposite. The algebraic signature comprises of independent interlocking components: two new operators that switch between these sorts, delimiting the atomic layers, thought of as acquiring and releasing the global lock; non-deterministic choice; and state-accessing operators. The axioms similarly divide cleanly: the delimiters behave as a closure pair; all operators are strict, and distribute over non-empty non-deterministic choice; and non-deterministic global state obeys Plotkin and Power's presentation of global state. Our representation theorem expresses the free algebras over a two-sorted family of variables as sets of traces with suitable closure conditions. When the held sort has no variables, we recover Brookes's trace semantics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15104v1</guid>
      <category>cs.PL</category>
      <category>cs.DC</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yotam Dvir, Ohad Kammar, Ori Lahav, Gordon Plotkin</dc:creator>
    </item>
    <item>
      <title>The continuous functional calculus in Lean</title>
      <link>https://arxiv.org/abs/2501.15639</link>
      <description>arXiv:2501.15639v1 Announce Type: cross 
Abstract: The continuous functional calculus is perhaps the most fundamental construction in the theory of operator algebras, especially $C^{*}$-algebras. Here we document our formalization of the continuous functional calculus in Lean, which constitutes the first such formalization in any proof assistant. Our implementation is already merged into Lean's mathematical library, Mathlib. We provide a brief introduction to the mathematical theory for those unfamiliar with the subject, and then highlight the design decisions in our formalization which proved to be important for usability. Our exposition is aimed at a general mathematical audience and provides a glimpse into the world of formalization by laying bare the discovery process.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.15639v1</guid>
      <category>math.OA</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anatole Dedecker, Jireh Loreaux</dc:creator>
    </item>
    <item>
      <title>Automating the Analysis of Quantitative Automata with QuAK</title>
      <link>https://arxiv.org/abs/2501.16088</link>
      <description>arXiv:2501.16088v1 Announce Type: cross 
Abstract: Quantitative automata model beyond-boolean aspects of systems: every execution is mapped to a real number by incorporating weighted transitions and value functions that generalize acceptance conditions of boolean $\omega$-automata. Despite the theoretical advances in systems analysis through quantitative automata, the first comprehensive software tool for quantitative automata (Quantitative Automata Kit, or QuAK) was developed only recently. QuAK implements algorithms for solving standard decision problems, e.g., emptiness and universality, as well as constructions for safety and liveness of quantitative automata. We present the architecture of QuAK, which reflects that all of these problems reduce to either checking inclusion between two quantitative automata or computing the highest value achievable by an automaton -- its so-called top value. We improve QuAK by extending these two algorithms with an option to return, alongside their results, an ultimately periodic word witnessing the algorithm's output, as well as implementing a new safety-liveness decomposition algorithm that can handle nondeterministic automata, making QuAK more informative and capable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.16088v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marek Chalupa, Thomas A. Henzinger, Nicolas Mazzocchi, N. Ege Sara\c{c}</dc:creator>
    </item>
    <item>
      <title>What is Formal Verification without Specifications? A Survey on mining LTL Specifications</title>
      <link>https://arxiv.org/abs/2501.16274</link>
      <description>arXiv:2501.16274v1 Announce Type: cross 
Abstract: Virtually all verification techniques using formal methods rely on the availability of a formal specification, which describes the design requirements precisely. However, formulating specifications remains a manual task that is notoriously challenging and error-prone. To address this bottleneck in formal verification, recent research has thus focussed on automatically generating specifications for formal verification from examples of (desired and undesired) system behavior. In this survey, we list and compare recent advances in mining specifications in Linear Temporal Logic (LTL), the de facto standard specification language for reactive systems. Several approaches have been designed for learning LTL formulas, which address different aspects and settings of specification design. Moreover, the approaches rely on a diverse range of techniques such as constraint solving, neural network training, enumerative search, etc. We survey the current state-of-the-art techniques and compare them for the convenience of the formal methods practitioners.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.16274v1</guid>
      <category>cs.FL</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Neider, Rajarshi Roy</dc:creator>
    </item>
    <item>
      <title>Privacy-aware Nash Equilibrium Synthesis with Partially Ordered LTL$_f$ Objectives</title>
      <link>https://arxiv.org/abs/2501.16307</link>
      <description>arXiv:2501.16307v1 Announce Type: cross 
Abstract: Nash equilibrium is a fundamental solution concept for modeling the behavior of self-interested agents. We develop an algorithm to synthesize pure Nash equilibria in two-player deterministic games on graphs where players have partial preferences over objectives expressed with linear temporal logic over finite traces. Previous approaches for Nash equilibrium synthesis assume that players' preferences are common knowledge. Instead, we allow players' preferences to remain private but enable communication between players. The algorithm we design synthesizes Nash equilibria for a complete-information game, but synthesizes these equilibria in an incomplete-information setting where players' preferences are private. The algorithm is privacy-aware, as instead of requiring that players share private preferences, the algorithm reduces the information sharing to a query interface. Through this interface, players exchange information about states in the game from which they can enforce a more desirable outcome. We prove the algorithm's completeness by showing that it either returns an equilibrium or certifies that one does not exist. We then demonstrate, via numerical examples, the existence of games where the queries the players exchange are insufficient to reconstruct players' preferences, highlighting the privacy-aware nature of the algorithm we propose.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.16307v1</guid>
      <category>cs.GT</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Caleb Probine, Abhishek Kulkarni, Ufuk Topcu</dc:creator>
    </item>
    <item>
      <title>Quantitative Graded Semantics and Spectra of Behavioural Metrics</title>
      <link>https://arxiv.org/abs/2306.01487</link>
      <description>arXiv:2306.01487v4 Announce Type: replace 
Abstract: Behavioural metrics provide a quantitative refinement of classical two-valued behavioural equivalences on systems with quantitative data, such as metric or probabilistic transition systems. In analogy to the linear-time/branching-time spectrum of two-valued behavioural equivalences on transition systems, behavioural metrics vary in granularity, and are often characterized by fragments of suitable modal logics. In the latter respect, the quantitative case is, however, more involved than the two-valued one; in fact, we show that probabilistic metric trace distance cannot be characterized by any compositionally defined modal logic with unary modalities. We go on to provide a unifying treatment of spectra of behavioural metrics in the emerging framework of graded monads, working in coalgebraic generality, that is, parametrically in the system type. In the ensuing development of quantitative graded semantics, we introduce algebraic presentations of graded monads on the category of metric spaces. Moreover, we provide a general criterion for a given real-valued modal logic to characterize a given behavioural distance. As a case study, we apply this criterion to obtain a new characteristic modal logic for trace distance in fuzzy metric transition systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.01487v4</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.CSL.2025.33</arxiv:DOI>
      <dc:creator>Jonas Forster, Lutz Schr\"oder, Paul Wild, Harsh Beohar, Sebastian Gurke, Barbara K\"onig, Karla Messing</dc:creator>
    </item>
    <item>
      <title>Compositional Shape Analysis with Shared Abduction and Biabductive Loop Acceleration (Extended Abstract)</title>
      <link>https://arxiv.org/abs/2307.06346</link>
      <description>arXiv:2307.06346v4 Announce Type: replace 
Abstract: Biabduction-based shape analysis is a compositional verification and analysis technique that can prove memory safety in the presence of complex, linked data structures. Despite its usefulness, several open problems persist for this kind of analysis; two of which we address in this paper. On the one hand, the original analysis is path-sensitive but cannot combine safety requirements for related branches. This causes the analysis to require additional soundness checks and decreases the analysis' precision. We extend the underlying symbolic execution and propose a framework for shared abduction where a common pre-condition is maintained for related computation branches. On the other hand, prior implementations lift loop acceleration methods from forward analysis to biabduction analysis by applying them separately on the pre- and post-condition, which can lead to imprecise or even unsound acceleration results that do not form a loop invariant. In contrast, we propose biabductive loop acceleration, which explicitly constructs and checks candidate loop invariants. For this, we also introduce a novel heuristic called shape extrapolation. This heuristic takes advantage of locality in the handling of list-like data structures (which are the most common data structures found in low-level code) and jointly accelerates pre- and post-conditions by extrapolating the related shapes. In addition to making the analysis more precise, our techniques also make biabductive analysis more efficient since they are sound in just one analysis phase. In contrast, prior techniques always require two phases (as the first phase can produce contracts that are unsound and must hence be verified). We experimentally confirm that our techniques improve on prior techniques; both in terms of precision and runtime of the analysis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.06346v4</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Florian Sextl (TU Wien, Institute of Logic and Computation, Research Unit for Formal Methods in Systems Engineering), Adam Rogalewicz (Brno University of Technology, FIT), Tom\'a\v{s} Vojnar (Masaryk University, Faculty of Informatics), Florian Zuleger (TU Wien, Institute of Logic and Computation, Research Unit for Formal Methods in Systems Engineering)</dc:creator>
    </item>
    <item>
      <title>Dynamic Separation Logic</title>
      <link>https://arxiv.org/abs/2309.08962</link>
      <description>arXiv:2309.08962v3 Announce Type: replace 
Abstract: This paper introduces a dynamic logic extension of separation logic. The assertion language of separation logic is extended with modalities for the five types of the basic instructions of separation logic: simple assignment, look-up, mutation, allocation, and de-allocation. The main novelty of the resulting dynamic logic is that it allows to combine different approaches to resolving these modalities. One such approach is based on the standard weakest precondition calculus of separation logic. The other approach introduced in this paper provides a novel alternative formalization in the proposed dynamic logic extension of separation logic. The soundness and completeness of this axiomatization has been formalized in the Coq theorem prover.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.08962v3</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.46298/entics.12297</arxiv:DOI>
      <arxiv:journal_reference>Electronic Notes in Theoretical Informatics and Computer Science, Volume 3 - Proceedings of MFPS XXXIX (November 23, 2023) entics:12297</arxiv:journal_reference>
      <dc:creator>Frank S. de Boer, Hans-Dieter A. Hiep, Stijn de Gouw</dc:creator>
    </item>
    <item>
      <title>Non-Cartesian Guarded Recursion with Daggers</title>
      <link>https://arxiv.org/abs/2409.14591</link>
      <description>arXiv:2409.14591v2 Announce Type: replace 
Abstract: Guarded recursion is a framework allowing for a formalisation of streams in classical programming languages. The latter take their semantics in cartesian closed categories. However, some programming paradigms do not take their semantics in a cartesian setting; this is the case for concurrency, reversible and quantum programming for example. In this paper, we focus on reversible programming through its categorical model in dagger categories, which are categories that contain an involutive operator on morphisms. After presenting classical guarded recursion, we show how to introduce this framework into dagger categories with sufficient structure for data types, also called dagger rig categories. First, given an arbitrary category, we build another category shown to be suitable for guarded recursion in multiple ways, via enrichment and fixed point theorems. We then study the interaction between this construction and the structure of dagger rig categories, aiming for reversible programming. Finally, we show that our construction is suitable as a model of higher-order reversible programming languages, such as symmetric pattern-matching.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.14591v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.CT</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Louis Lemonnier</dc:creator>
    </item>
    <item>
      <title>Effectful Mealy Machines: Bisimulation and Trace</title>
      <link>https://arxiv.org/abs/2410.10627</link>
      <description>arXiv:2410.10627v2 Announce Type: replace 
Abstract: We introduce effectful Mealy machines - a general notion of Mealy machine with global effects - and give them semantics in terms of both bisimilarity and traces. Bisimilarity of effectful Mealy machines is characterized syntactically, via free uniform feedback. Traces of effectful Mealy machines are given a novel semantic coinductive universe in terms of effectful streams. We prove that this framework generalizes standard causal processes and captures existing flavours of Mealy machine, bisimilarity, and trace.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.10627v2</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Filippo Bonchi, Elena Di Lavore, Mario Rom\'an</dc:creator>
    </item>
    <item>
      <title>Conformance Games for Graded Semantics</title>
      <link>https://arxiv.org/abs/2411.03069</link>
      <description>arXiv:2411.03069v2 Announce Type: replace 
Abstract: Game-theoretic characterizations of process equivalences traditionally form a central topic in concurrency; for example, most equivalences on the classical linear-time / branching-time spectrum come with such characterizations. Recent work on so-called graded semantics has led to a generic behavioural equivalence game that covers the mentioned games on the linear-time~/ branching-time spectrum and moreover applies in coalgebraic generality, and thus instantiates also to equivalence games on systems with non-relational branching type (probabilistic, weighted, game-based etc.). In the present work, we generalize this approach to cover other types of process comparison beyond equivalence, such as behavioural preorders or pseudometrics. At the most general level, we abstract such notions of behavoiural conformance in terms of topological categories, and later specialize to conformances presented as relational structures to obtain a concrete syntax. We obtain a sound and complete generic game for behavioural conformances in this sense. We present a number of instantiations, obtaining game characterizations of, e.g., trace inclusion, probabilistic trace distance, bisimulation topologies, and simulation distances on metric labelled transition systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.03069v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jonas Forster, Lutz Schr\"oder, Paul Wild</dc:creator>
    </item>
    <item>
      <title>Maintaining $\mathsf{CMSO}_2$ properties on dynamic structures with bounded feedback vertex number</title>
      <link>https://arxiv.org/abs/2107.06232</link>
      <description>arXiv:2107.06232v2 Announce Type: replace-cross 
Abstract: Let $\varphi$ be a sentence of $\mathsf{CMSO}_2$ (monadic second-order logic with quantification over edge subsets and counting modular predicates) over the signature of graphs. We present a dynamic data structure that for a given graph $G$ that is updated by edge insertions and edge deletions, maintains whether $\varphi$ is satisfied in $G$. The data structure is required to correctly report the outcome only when the feedback vertex number of $G$ does not exceed a fixed constant $k$, otherwise it reports that the feedback vertex number is too large. With this assumption, we guarantee amortized update time ${\cal O}_{\varphi,k}(\log n)$. If we additionally assume that the feedback vertex number of $G$ never exceeds $k$, this update time guarantee is worst-case.
  By combining this result with a classic theorem of Erd\H{o}s and P\'osa, we give a fully dynamic data structure that maintains whether a graph contains a packing of $k$ vertex-disjoint cycles with amortized update time ${\cal O}_{k}(\log n)$. Our data structure also works in a larger generality of relational structures over binary signatures.</description>
      <guid isPermaLink="false">oai:arXiv.org:2107.06232v2</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Konrad Majewski, Micha{\l} Pilipczuk, Marek Soko{\l}owski</dc:creator>
    </item>
    <item>
      <title>On the ABK Conjecture, alpha-well Quasi Orders and Dress-Schiffels product</title>
      <link>https://arxiv.org/abs/2303.11451</link>
      <description>arXiv:2303.11451v3 Announce Type: replace-cross 
Abstract: The following is a 2008 conjecture of Abraham, Bonnet and Kubi\'s: [ABK Conjecture] Every well quasi order (wqo) is a countable union of better quasi orders (bqo). We obtain a partial progress on the conjecture, by showing that the class of orders that are a countable union of better quasi orders (sigma-bqo) is closed under various operations. These include diverse products, such as the Dress-Shieffels product. We develop various properties of the latter product. In relation with the main question, we explore the class of alpha-wqo for countable ordinals alpha and obtain several closure properties and a Hausdorff-style classification theorem. Our main contribution is the discovery of various properties of sigma-bqos and ruling out potential counterexamples to the ABK Conjecture.</description>
      <guid isPermaLink="false">oai:arXiv.org:2303.11451v3</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Uri Abraham, Robert Bonnet, Mirna D\v{z}amonja, Maurice Pouzet</dc:creator>
    </item>
    <item>
      <title>Compressing CFI Graphs and Lower Bounds for the Weisfeiler-Leman Refinements</title>
      <link>https://arxiv.org/abs/2308.11970</link>
      <description>arXiv:2308.11970v2 Announce Type: replace-cross 
Abstract: The $k$-dimensional Weisfeiler-Leman ($k$-WL) algorithm is a simple combinatorial algorithm that was originally designed as a graph isomorphism heuristic. It naturally finds applications in Babai's quasipolynomial time isomorphism algorithm, practical isomorphism solvers, and algebraic graph theory. However, it also has surprising connections to other areas such as logic, proof complexity, combinatorial optimization, and machine learning.
  The algorithm iteratively computes a coloring of the $k$-tuples of vertices of a graph. Since F\"urer's linear lower bound [ICALP 2001], it has been an open question whether there is a super-linear lower bound for the iteration number for $k$-WL on graphs. We answer this question affirmatively, establishing an $\Omega(n^{k/2})$-lower bound for all $k$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.11970v2</guid>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Martin Grohe, Moritz Lichter, Daniel Neuen, Pascal Schweitzer</dc:creator>
    </item>
    <item>
      <title>Feasability of Learning Weighted Automata on a Semiring</title>
      <link>https://arxiv.org/abs/2309.07806</link>
      <description>arXiv:2309.07806v4 Announce Type: replace-cross 
Abstract: Since the seminal work by Angluin and the introduction of the L*-algorithm, active learning of automata by membership and equivalence queries has been extensively studied to learn various extensions of automata. For weighted automata, algorithms for restricted cases have been developed in the literature, but so far there was no global approach or understanding how these algorithms could apply (or not) in the general case. In this paper we chart the boundaries of the Angluin approach. We use a class of hypothesis automata which are constructed, in Angluin's style, by using membership and equivalence queries and solving certain finite systems of linear equations over the semiring, and we show the theoretical limitations of this approach. We classify functions with respect to how guessable they are, corresponding to the existence of hypothesis automata computing a given function, and how such an hypothesis automaton can be found. Of course, from an algorithmic standpoint, knowing that a solution (hypothesis automaton) exists need not translate into an effective algorithm to find one. We relate our work to the existing literature with a discussion of some known properties ensuring algorithmic solutions, illustrating the ideas over several familiar semirings (including the natural numbers).</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.07806v4</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Laure Daviaud, Marianne Johnson</dc:creator>
    </item>
    <item>
      <title>A computational method for left-adjointness</title>
      <link>https://arxiv.org/abs/2411.05511</link>
      <description>arXiv:2411.05511v2 Announce Type: replace-cross 
Abstract: In this work, we investigate an effective method for showing that functors between categories are left adjoints. The method applies to a large class of categories, namely locally finitely presentable categories, which are ubiquitous in practice and include standard examples like Set, Grp, etc. Our method relies on a known description of these categories as orthogonal sub-classes of presheaf categories. The functors on which our method applies are the ones that can be presented as particular profunctors, called Kan models in this context. The method for left-adjointness then relies on computing that a particular criterion is satisfied. From this method, we also derive another method for showing that a category is cartesian closed. As proofs of concept and effectivity, we give a concrete implementation of the structures and of the left-adjointness criterion in OCaml and apply it on several examples.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.05511v2</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Simon Forest</dc:creator>
    </item>
    <item>
      <title>A Fourfold Pathogen Reference Ontology Suite</title>
      <link>https://arxiv.org/abs/2501.01454</link>
      <description>arXiv:2501.01454v2 Announce Type: replace-cross 
Abstract: Infectious diseases remain a critical global health challenge, and the integration of standardized ontologies plays a vital role in managing related data. The Infectious Disease Ontology (IDO) and its extensions, such as the Coronavirus Infectious Disease Ontology (CIDO), are essential for organizing and disseminating information related to infectious diseases. The COVID-19 pandemic highlighted the need for updating IDO and its virus-specific extensions. There is an additional need to update IDO extensions specific to bacteria, fungus, and parasite infectious diseases. We adopt the "hub and spoke" methodology to generate pathogen-specific extensions of IDO: Virus Infectious Disease Ontology (VIDO), Bacteria Infectious Disease Ontology (BIDO), Mycosis Infectious Disease Ontology (MIDO), and Parasite Infectious Disease Ontology (PIDO). The creation of pathogen-specific reference ontologies advances modularization and reusability of infectious disease data within the IDO ecosystem. Future work will focus on further refining these ontologies, creating new extensions, and developing application ontologies based on them, in line with ongoing efforts to standardize biological and biomedical terminologies for improved data sharing and analysis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.01454v2</guid>
      <category>q-bio.OT</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Tue, 28 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shane Babcock, Carter Benson, Giacomo De Colle, Sydney Cohen, Alexander D. Diehl, Ram A. N. R. Challa, Ray Mavrovich, Joshua Billig, Anthony Huffman, Yongqun He, John Beverley</dc:creator>
    </item>
  </channel>
</rss>
