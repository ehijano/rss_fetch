<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Oct 2024 04:00:03 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 28 Oct 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>PDL: A Declarative Prompt Programming Language</title>
      <link>https://arxiv.org/abs/2410.19135</link>
      <description>arXiv:2410.19135v1 Announce Type: cross 
Abstract: Large language models (LLMs) have taken the world by storm by making many previously difficult uses of AI feasible. LLMs are controlled via highly expressive textual prompts and return textual answers. Unfortunately, this unstructured text as input and output makes LLM-based applications brittle. This motivates the rise of prompting frameworks, which mediate between LLMs and the external world. However, existing prompting frameworks either have a high learning curve or take away control over the exact prompts from the developer. To overcome this dilemma, this paper introduces the Prompt Declaration Language (PDL). PDL is a simple declarative data-oriented language that puts prompts at the forefront, based on YAML. PDL works well with many LLM platforms and LLMs. It supports writing interactive applications that call LLMs and tools, and makes it easy to implement common use-cases such as chatbots, RAG, or agents. We hope PDL will make prompt programming simpler, less brittle, and more enjoyable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.19135v1</guid>
      <category>cs.AI</category>
      <category>cs.PL</category>
      <pubDate>Mon, 28 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mandana Vaziri, Louis Mandel, Claudio Spiess, Martin Hirzel</dc:creator>
    </item>
    <item>
      <title>Triemaps that match</title>
      <link>https://arxiv.org/abs/2302.08775</link>
      <description>arXiv:2302.08775v2 Announce Type: replace 
Abstract: The trie data structure is a good choice for finite maps whose keys are data structures (trees) rather than atomic values. But what if we want the keys to be patterns, each of which matches many lookup keys? Efficient matching of this kind is well studied in the theorem prover community, but much less so in the context of statically typed functional programming. Doing so yields an interesting new viewpoint -- and a practically useful design pattern, with good runtime performance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.08775v2</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 28 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Simon Peyton Jones, Sebastian Graf</dc:creator>
    </item>
    <item>
      <title>Finite-Choice Logic Programming</title>
      <link>https://arxiv.org/abs/2405.19040</link>
      <description>arXiv:2405.19040v2 Announce Type: replace 
Abstract: Logic programming, as exemplified by datalog, defines the meaning of a program as its unique smallest model: the deductive closure of its inference rules. However, many problems call for an enumeration of models that vary along some set of choices while maintaining structural and logical constraints -- there is no single canonical model. The notion of stable models for logic programs with negation has successfully captured programmer intuition about the set of valid solutions for such problems, giving rise to a family of programming languages and associated solvers known as answer set programming. Unfortunately, the definition of a stable model is frustratingly indirect, especially in the presence of rules containing free variables.
  We propose a new formalism, finite-choice logic programming, that uses choice, not negation, to admit multiple solutions. Finite-choice logic programming contains all the expressive power of the stable model semantics, gives meaning to a new and useful class of programs, and enjoys a least-fixed-point interpretation over a novel domain. We present an algorithm for exploring the solution space and prove it correct with respect to our semantics. Our implementation, the Dusa logic programming language, has performance that compares favorably with state-of-the-art answer set solvers and exhibits more predictable scaling with problem size.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.19040v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Chris Martens, Robert J. Simmons, Michael Arntzenius</dc:creator>
    </item>
    <item>
      <title>Model Checking Recursive Probabilistic Programs with Conditioning</title>
      <link>https://arxiv.org/abs/2404.03515</link>
      <description>arXiv:2404.03515v2 Announce Type: replace-cross 
Abstract: We address the problem of model checking temporal logic specifications for discrete probabilistic programs with recursive procedures, nested queries, and hard conditioning expressed with observe statements. We give them an operational semantics in terms of \emph{probabilistic Operator Precedence Automata} (pOPA), a novel class of probabilistic pushdown automata suitable to model constructs and behaviors of probabilistic programs. We develop a model checking algorithm that can verify requirements expressed in a fragment of Precedence Oriented Temporal Logic (POTLf$\chi$) on a pOPA in single \textsc{exptime}. POTLf$\chi$ is a temporal logic based on Operator Precedence Languages, which features modalities that interact with the context-free structure of program traces, matching procedure calls with returns or observe statements. We provide the \emph{first} probabilistic model checking implementation of context-free language properties for probabilistic pushdown systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.03515v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Mon, 28 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Francesco Pontiggia, Ezio Bartocci, Michele Chiari</dc:creator>
    </item>
  </channel>
</rss>
