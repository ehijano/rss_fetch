<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 12 Nov 2025 02:47:42 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Secret Protection in Labeled Petri Nets</title>
      <link>https://arxiv.org/abs/2511.06135</link>
      <description>arXiv:2511.06135v1 Announce Type: new 
Abstract: We study the secret protection problem (SPP), where the objective is to find a policy of minimal cost ensuring that every execution path from an initial state to a secret state contains a sufficient number of protected events. The problem was originally introduced and studied in the setting of finite automata. In this paper, we extend the framework to labeled Petri nets. We consider two variants of the problem: the Parikh variant, where all occurrences of protected events along an execution path contribute to the security requirement, and the indicator variant, where each protected event is counted only once per execution path. We show that both variants can be solved in exponential space for labeled Petri nets, and that their decision versions are ExpSpace-complete. As a consequence, there is no polynomial-time or polynomial-space algorithm for these problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.06135v1</guid>
      <category>cs.FL</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Stefan Haar, Tom\'a\v{s} Masopust, Jakub Ve\v{c}e\v{r}a</dc:creator>
    </item>
    <item>
      <title>Alloy-Driven Verification of Object-Centric Event Data: From Temporal Logic to Knowledge Graphs</title>
      <link>https://arxiv.org/abs/2511.07263</link>
      <description>arXiv:2511.07263v1 Announce Type: new 
Abstract: Object-centric process mining addresses the limitations of traditional approaches, which often involve the lossy flattening of event data and obscure vital relationships among interacting objects. This paper presents a novel formal framework for Object-centric Event Data (OCED) that ensures the correctness of the meta-model and preserves native object-centric semantics prior to the system implementation. Our approach effectively leverages Alloy for precisely specifying temporal properties and structural relationships between objects and events. This guarantees thorough verification against predefined OCED constraints such as cross-object cardinality bounds and time-aware consistency rules, hence preventing common data integrity issues. We demonstrate the effectiveness of the proposed framework in discovering and validating implicit object dependencies in event logs, particularly when importing data into graph databases like Neo4j. This demonstrates how formal verification can avoid pitfalls that lead to data invisibility and improve knowledge graph creation, enrichment, and querying. To bridge theory and practice, our verified \emph{FOCED} is made accessible through automatically generated Python bindings, empowering industrial users without formal methods expertise. The code is available on GitHub \footnote{https://github.com/sabalati/FOCED}</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.07263v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Saba Latif, Huma Latif, Touseef Ur Rehman, Muhammad Rameez Ur Rahman</dc:creator>
    </item>
    <item>
      <title>Locality Testing for NFAs is PSPACE-complete</title>
      <link>https://arxiv.org/abs/2511.07361</link>
      <description>arXiv:2511.07361v1 Announce Type: new 
Abstract: The class of local languages is a well-known subclass of the regular languages that admits many equivalent characterizations. In this short note we establish the PSPACE-completeness of the problem of determining, given as input a nondeterministic finite automaton (NFA) A, whether the language recognized by A is local or not. This contrasts with the case of deterministic finite automata (DFA), for which the problem is known to be in PTIME.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.07361v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antoine Amarilli, Mika\"el Monet, R\'emi De Pretto</dc:creator>
    </item>
    <item>
      <title>Language Generation: Complexity Barriers and Implications for Learning</title>
      <link>https://arxiv.org/abs/2511.05759</link>
      <description>arXiv:2511.05759v1 Announce Type: cross 
Abstract: Kleinberg and Mullainathan showed that, in principle, language generation is always possible: with sufficiently many positive examples, a learner can eventually produce sentences indistinguishable from those of a target language. However, the existence of such a guarantee does not speak to its practical feasibility. In this work, we show that even for simple and well-studied language families -- such as regular and context-free languages -- the number of examples required for successful generation can be extraordinarily large, and in some cases not bounded by any computable function. These results reveal a substantial gap between theoretical possibility and efficient learnability. They suggest that explaining the empirical success of modern language models requires a refined perspective -- one that takes into account structural properties of natural language that make effective generation possible in practice.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.05759v1</guid>
      <category>cs.CL</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marcelo Arenas, Pablo Barcel\'o, Luis Cofr\'e, Alexander Kozachinskiy</dc:creator>
    </item>
    <item>
      <title>High-Performance Generation of Constrained Input</title>
      <link>https://arxiv.org/abs/2511.05987</link>
      <description>arXiv:2511.05987v1 Announce Type: cross 
Abstract: Language-based testing combines context-free grammar definitions with semantic constraints over grammar elements to generate test inputs. By pairing context-free grammars with constraints, users have the expressiveness of unrestricted grammars while retaining simple structure. However, producing inputs in the presence of such constraints can be challenging. In past approaches, SMT solvers have been found to be very slow at finding string solutions; evolutionary algorithms are faster and more general, but current implementations still struggle with complex constraints that would be required for domains such as compiler testing. In this paper, we present a novel approach for evolutionary language-based testing that improves performance by 3-4 orders of magnitude over the current state of the art, reducing hours of generation and constraint solving time to seconds. We accomplish this by (1) carefully transforming grammar definitions into Rust types and trait implementations, ensuring that the compiler may near-maximally optimize arbitrary operations on arbitrary grammars; and (2) using better evolutionary algorithms that improve the ability of language-based testing to solve complex constraint systems. These performance and algorithmic improvements allow our prototype, FANDANGO-RS, to solve constraints that previous strategies simply cannot handle. We demonstrate this by a case study for a C subset, in which FANDANGO-RS is able to generate 401 diverse, complex, and valid test inputs for a C compiler per minute.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.05987v1</guid>
      <category>cs.SE</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Addison Crump, Alexi Turcotte, Jos\'e Antonio Zamudio Amaya, Andreas Zeller</dc:creator>
    </item>
    <item>
      <title>Duality-based Mode Operations and Pyramid Multilayer Mapping for Rhetorical Modes</title>
      <link>https://arxiv.org/abs/2511.06601</link>
      <description>arXiv:2511.06601v1 Announce Type: cross 
Abstract: Rhetorical modes are useful in both academic and non-academic writing, and can be subjects to be studied within linguistic research and computational modeling. Establishing a conceptual bridge among these domains could enable each to benefit from the others. This paper proposes duality-based mode operations (split-unite, forward-backward, expansion-reduction and orthogonal dualities) to expand the set of rhetorical modes, introducing generated modes like combination and generalization, thereby enhancing epistemic diversity across multiple applications. It further presents a pyramid multilayer mapping framework (e.g., three layers from the rhetorical model layer, to cognitive layer, and to epistemic layers) that reduces the resulting cognitive complexity. The degrees of expressive diversity and complexity reduction are quantified through binomial combinatorics and Shannon entropy analysis. A Marginal Rhetorical Bit (MRB) is identified, permitting the definition of a rhetorical-scalable parameter that measures expressive growth speed in bits per stage. A direct entropy measure shows that hierarchical selection over smaller subsets markedly reduces choice uncertainty compared with flat selection across all modes. These considerations appear to transform static and non-measurable rhetorical taxonomies into more dynamic and more measurable systems for discourse design. From this work, it would be possible to identify a pathway for future AI systems to operate not only on language tokens but on layered rhetorical reasoning structures, bridging linguistic, pedagogical, academic, and computational research</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.06601v1</guid>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Zi-Niu Wu</dc:creator>
    </item>
    <item>
      <title>The No Endmarker Theorem for One-Way Probabilistic Pushdown Automata</title>
      <link>https://arxiv.org/abs/2111.02688</link>
      <description>arXiv:2111.02688v3 Announce Type: replace 
Abstract: In various models of one-way pushdown automata, the explicit use of two designated endmarkers on a read-once input tape has proven to be extremely useful for making a conscious, final decision on the acceptance/rejection of each input word immediately after reading the right endmarker. With no endmarkers, by contrast, a machine must constantly stay in either accepting or rejecting states at any moment since it never notices the end of the input word. This situation, however, helps us analyze the behavior of the machine whose tape head makes the consecutive moves on all prefixes of a given extremely long input word. Since those two machine formulations have their own advantages, it is natural to ask whether the endmarkers are truly necessary to correctly recognize languages. In the deterministic and nondeterministic models, it is well-known that the endmarkers are removable without changing the acceptance criteria of each input word. This paper proves that, for a more general model of one-way probabilistic pushdown automata, the endmarkers are always removable. This is proven by employing probabilistic transformations from an "endmarker" machine to an equivalent "no-endmarker" machine at the cost of double exponential stack-state complexity without compromising its error probability. By setting this error probability appropriately, our proof also provides an alternative proof to both the deterministic and the nondeterministic models as well.</description>
      <guid isPermaLink="false">oai:arXiv.org:2111.02688v3</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tomoyuki Yamakami</dc:creator>
    </item>
    <item>
      <title>Parikh Automata on Finite and Infinite Words</title>
      <link>https://arxiv.org/abs/2307.07238</link>
      <description>arXiv:2307.07238v3 Announce Type: replace 
Abstract: We study Parikh automata on finite and infinite words. First we establish some results for Parikh automata on finite words. Following, we present several definitions of Parikh automata on infinite words. We consider the deterministic as well as the non-deterministic variants and study closure properties, expressiveness, and common decision problems with applications to model checking. Furthermore, we compare our models to other models with counting mechanisms operating on infinite words.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.07238v3</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mario Grobler, Leif Sabellek, Sebastian Siebertz</dc:creator>
    </item>
    <item>
      <title>A note on Automatic Baire property</title>
      <link>https://arxiv.org/abs/2505.18626</link>
      <description>arXiv:2505.18626v2 Announce Type: replace 
Abstract: Automatic Baire property is a variant of the usual Baire property which is fulfilled for subsets of the Cantor space accepted by finite automata. We consider the family $\mathcal{A}$ of subsets of the Cantor space having the Automatic Baire property. In particular we show that not all finite subsets have the Automatic Baire property, and that already a slight increase of the computational power of the accepting device may lead beyond the class $\mathcal{A}$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.18626v2</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ludwig Staiger</dc:creator>
    </item>
    <item>
      <title>Cellular automata can really solve the parity problem</title>
      <link>https://arxiv.org/abs/2501.08684</link>
      <description>arXiv:2501.08684v2 Announce Type: replace-cross 
Abstract: Determining properties of an arbitrary binary sequence is a challenging task if only local processing is allowed. Among these properties, the determination of the parity of 1s by distributed consensus has been a recurring endeavour in the context of automata networks. In its most standard formulation, a one-dimensional cellular automaton rule should process any odd-sized cyclic configuration and lead the lattice to converge to the homogeneous fixed point of 0s if the parity of 1s is even and to the homogeneous fixed point of 1s, otherwise. The only known solution to this problem with a single rule was given by Betel, de Oliveira and Flocchini (coined BFO rule after the authors' initials). However, three years later the authors of the BFO rule realised that the rule would fail for some specific configuration and proposed a computationally sound fix, but a proof could not be worked out. Here we provide another fix to the BFO rule along with a full proof, therefore reassuring that a single-rule solution to the problem really does exist.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.08684v2</guid>
      <category>math.DS</category>
      <category>cs.FL</category>
      <pubDate>Tue, 11 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Barbara Wolnik, Anna Nenca, Pedro Paulo Balbi, Bernard De Baets</dc:creator>
    </item>
  </channel>
</rss>
