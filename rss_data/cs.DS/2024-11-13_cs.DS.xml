<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Nov 2024 05:00:00 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Compressed Game Solving</title>
      <link>https://arxiv.org/abs/2411.07273</link>
      <description>arXiv:2411.07273v1 Announce Type: new 
Abstract: We recast move generators for solving board games as operations on compressed sets of strings. We aim for compressed representations with space sublinear in the number of game positions for interesting sets of positions, move generation in time roughly linear in the compressed size and membership tests in constant time. To the extent that we achieve these tradeoffs empirically, we can strongly solve board games in time sublinear in the state space. We demonstrate this concept with the game Breakthrough where we empirically realize compressed representations taking roughly $n^{0.5}$ to $n^{0.7}$ space to store relevant sets of $n$ positions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07273v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeffrey Considine</dc:creator>
    </item>
    <item>
      <title>An Improved Algorithm for Sparse Instances of SAT</title>
      <link>https://arxiv.org/abs/2411.07389</link>
      <description>arXiv:2411.07389v1 Announce Type: new 
Abstract: We show that the CNF satisfiability problem (SAT) can be solved in time $O^*(1.1199^{(d-2)n})$, where $d$ is either the maximum number of occurrences of any variable or the average number of occurrences of all variables if no variable occurs only once. This improves upon the known upper bound of $O^*(1.1279^{(d-2)n})$ by Wahlstr$\ddot{\text{o}}$m (SAT 2005) and $O^*(1.1238^{(d-2)n})$ by Peng and Xiao (IJCAI 2023). For $d\leq 4$, our algorithm is better than previous results. Our main technical result is an algorithm that runs in $O^*(1.1199^n)$ for 3-occur-SAT, a restricted instance of SAT where all variables have at most 3 occurrences. Through deeper case analysis and a reduction rule that allows us to resolve many variables under a relatively broad criteria, we are able to circumvent the bottlenecks in previous algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07389v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sanjay Jain, Tzeh Yuan Neoh, Frank Stephan</dc:creator>
    </item>
    <item>
      <title>Listing 6-Cycles in Sparse Graphs</title>
      <link>https://arxiv.org/abs/2411.07499</link>
      <description>arXiv:2411.07499v1 Announce Type: new 
Abstract: This work considers the problem of output-sensitive listing of occurrences of $2k$-cycles for fixed constant $k\geq 2$ in an undirected host graph with $m$ edges and $t$ $2k$-cycles. Recent work of Jin and Xu (and independently Abboud, Khoury, Leibowitz, and Safier) [STOC 2023] gives an $O(m^{4/3}+t)$ time algorithm for listing $4$-cycles, and recent work by Jin, Vassilevska Williams and Zhou [SOSA 2024] gives an $\widetilde{O}(n^2+t)$ time algorithm for listing $6$-cycles in $n$ node graphs. We focus on resolving the next natural question: obtaining listing algorithms for $6$-cycles in the sparse setting, i.e., in terms of $m$ rather than $n$. Previously, the best known result here is the better of Jin, Vassilevska Williams and Zhou's $\widetilde{O}(n^2+t)$ algorithm and Alon, Yuster and Zwick's $O(m^{5/3}+t)$ algorithm.
  We give an algorithm for listing $6$-cycles with running time $\widetilde{O}(m^{1.6}+t)$. Our algorithm is a natural extension of Dahlgaard, Knudsen and St\"ockel's [STOC 2017] algorithm for detecting a $2k$-cycle. Our main technical contribution is the analysis of the algorithm which involves a type of ``supersaturation'' lemma relating the number of $2k$-cycles in a bipartite graph to the sizes of the parts in the bipartition and the number of edges. We also give a simplified analysis of Dahlgaard, Knudsen and St\"ockel's $2k$-cycle detection algorithm (with a small polylogarithmic increase in the running time), which is helpful in analyzing our listing algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07499v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Virginia Vassilevska Williams, Alek Westover</dc:creator>
    </item>
    <item>
      <title>Subsetwise and Multi-Level Additive Spanners with Lightness Guarantees</title>
      <link>https://arxiv.org/abs/2411.07505</link>
      <description>arXiv:2411.07505v1 Announce Type: new 
Abstract: An $(\alpha,\beta)$ spanner of an edge weighted graph $G=(V,E)$ is a subgraph $H$ of $G$ such that for every pair of vertices $u$ and $v$, $d_{H}(u,v) \le \alpha \cdot d_G(u,v) + \beta W$, where $d_G(u,v)$ is the shortest path length from $u$ to $v$ in $G$; we consider two settings: in one setting $W = W_G(u,v),$ the maximum edge weight in a shortest path from $u$ to $v$ in $G$, and in the other setting $W=W_{max},$ the maximum edge weight of $G$. If $\alpha&gt;1$ and $\beta=0$, then $H$ is called a multiplicative $\alpha$-spanner. If $\alpha=1$, then $H$ is called an additive +$\beta W$ spanner. While multiplicative spanners are very well studied in the literature, spanners that are both additive and lightweight have been introduced more recently [Ahmed et al., WG 2021]. Here the lightness is the ratio of the spanner weight to the weight of a minimum spanning tree of $G$. In this paper, we examine the widely known subsetwise setting when the distance conditions need to hold only among the pairs of a given subset $S$. We generalize the concept of lightness to subset-lightness using a Steiner tree and provide polynomial-time algorithms to compute subsetwise additive $+\epsilon W(\cdot, \cdot)$ spanner and $+(4+\epsilon) W(\cdot, \cdot)$ spanner with $O_\epsilon(|S|)$ and $O_\epsilon(|V_H|^{1/3} |S|^{1/3})$ subset-lightness, respectively, where $\epsilon$ is an arbitrary positive constant. We next examine a multi-level version of spanners that often arises in network visualization and modeling the quality of service requirements in communication networks. The goal here is to compute a nested sequence of spanners with the minimum total edge weight. We provide an $e$-approximation algorithm to compute multi-level spanners assuming that an oracle is given to compute single-level spanners, improving a previously known 4-approximation [Ahmed et al., IWOCA 2023].</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07505v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Reyan Ahmed, Debajyoti Mondal, Rahnuma Islam Nishat</dc:creator>
    </item>
    <item>
      <title>QR Sort: A Novel Non-Comparative Sorting Algorithm</title>
      <link>https://arxiv.org/abs/2411.07526</link>
      <description>arXiv:2411.07526v1 Announce Type: new 
Abstract: In this paper, we introduce and prove QR Sort, a novel non-comparative integer sorting algorithm. This algorithm uses principles derived from the Quotient-Remainder Theorem and Counting Sort subroutines to sort input sequences stably. QR Sort exhibits the general time and space complexity $\mathcal{O}(n+d+\frac{m}{d})$, where $n$ denotes the input sequence length, $d$ denotes a predetermined positive integer, and $m$ denotes the range of input sequence values plus 1. Setting $d = \sqrt{m}$ minimizes time and space to $\mathcal{O}(n + \sqrt{m})$, resulting in linear time and space $\mathcal{O}(n)$ when $m \leq \mathcal{O}(n^2)$. We provide implementation optimizations for minimizing the time and space complexity, runtime, and number of computations expended by QR Sort, showcasing its adaptability. Our results reveal that QR Sort frequently outperforms established algorithms and serves as a reliable sorting algorithm for input sequences that exhibit large $m$ relative to $n$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07526v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Randolph T. Bushman, Tanya M. Tebcherani, Alhassan S. Yasin</dc:creator>
    </item>
    <item>
      <title>A Simple Algorithm for Dynamic Carpooling with Recourse</title>
      <link>https://arxiv.org/abs/2411.07553</link>
      <description>arXiv:2411.07553v1 Announce Type: new 
Abstract: We give an algorithm for the fully-dynamic carpooling problem with recourse: Edges arrive and depart online from a graph $G$ with $n$ nodes according to an adaptive adversary. Our goal is to maintain an orientation $H$ of $G$ that keeps the discrepancy, defined as $\max_{v \in V} |\text{deg}_H^+(v) - \text{deg}_H^-(v)|$, small at all times. We present a simple algorithm and analysis for this problem with recourse based on cycles that simplifies and improves on a result of Gupta et al. [SODA '22].</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07553v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yuval Efron, Shyamal Patel, Cliff Stein</dc:creator>
    </item>
    <item>
      <title>Elastic-Degenerate String Comparison</title>
      <link>https://arxiv.org/abs/2411.07782</link>
      <description>arXiv:2411.07782v1 Announce Type: new 
Abstract: An elastic-degenerate (ED) string $T$ is a sequence of $n$ sets $T[1],\ldots,T[n]$ containing $m$ strings in total whose cumulative length is $N$. We call $n$, $m$, and $N$ the length, the cardinality and the size of $T$, respectively. The language of $T$ is defined as $L(T)=\{S_1 \cdots S_n\,:\,S_i \in T[i]$ for all $i\in[1,n]\}$. ED strings have been introduced to represent a set of closely-related DNA sequences, also known as a pangenome. The basic question we investigate here is: Given two ED strings, how fast can we check whether the two languages they represent have a nonempty intersection? We call the underlying problem the ED String Intersection (EDSI) problem.For two ED strings $T_1$ and $T_2$ of lengths $n_1$ and $n_2$, cardinalities $m_1$ and $m_2$, and sizes $N_1$ and $N_2$, respectively, we show the following:
  - There is no $O((N_1N_2)^{1-\epsilon})$-time algorithm, for any constant $\epsilon&gt;0$, for EDSI even when $T_1$ and $T_2$ are over a binary alphabet, unless the Strong Exponential-Time Hypothesis is false.
  - There is no combinatorial $O((N_1+N_2)^{1.2-\epsilon}f(n_1,n_2))$-time algorithm, for any constant $\epsilon&gt;0$ and any function $f$, for EDSI even when $T_1$ and $T_2$ are over a binary alphabet, unless the Boolean Matrix Multiplication conjecture is false.
  - An $O(N_1\log N_1\log n_1+N_2\log N_2\log n_2)$-time algorithm for outputting a compact (RLE) representation of the intersection language of two unary ED strings. In the case when $T_1$ and $T_2$ are given in a compact representation, we show that the problem is NP-complete.
  - An $O(N_1m_2+N_2m_1)$-time algorithm for EDSI.
  - An $\tilde{O}(N_1^{\omega-1}n_2+N_2^{\omega-1}n_1)$-time algorithm for EDSI, where $\omega$ is the exponent of matrix multiplication; the $\tilde{O}$ notation suppresses factors that are polylogarithmic in the input size.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07782v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Esteban Gabory, Moses Njagi Mwaniki, Nadia Pisanti, Solon P. Pissis, Jakub Radoszewski, Michelle Sweering, Wiktor Zuba</dc:creator>
    </item>
    <item>
      <title>Model Stealing for Any Low-Rank Language Model</title>
      <link>https://arxiv.org/abs/2411.07536</link>
      <description>arXiv:2411.07536v1 Announce Type: cross 
Abstract: Model stealing, where a learner tries to recover an unknown model via carefully chosen queries, is a critical problem in machine learning, as it threatens the security of proprietary models and the privacy of data they are trained on. In recent years, there has been particular interest in stealing large language models (LLMs). In this paper, we aim to build a theoretical understanding of stealing language models by studying a simple and mathematically tractable setting. We study model stealing for Hidden Markov Models (HMMs), and more generally low-rank language models.
  We assume that the learner works in the conditional query model, introduced by Kakade, Krishnamurthy, Mahajan and Zhang. Our main result is an efficient algorithm in the conditional query model, for learning any low-rank distribution. In other words, our algorithm succeeds at stealing any language model whose output distribution is low-rank. This improves upon the previous result by Kakade, Krishnamurthy, Mahajan and Zhang, which also requires the unknown distribution to have high "fidelity", a property that holds only in restricted cases. There are two key insights behind our algorithm: First, we represent the conditional distributions at each timestep by constructing barycentric spanners among a collection of vectors of exponentially large dimension. Second, for sampling from our representation, we iteratively solve a sequence of convex optimization problems that involve projection in relative entropy to prevent compounding of errors over the length of the sequence. This is an interesting example where, at least theoretically, allowing a machine learning model to solve more complex problems at inference time can lead to drastic improvements in its performance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07536v1</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.DS</category>
      <category>stat.ML</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Allen Liu, Ankur Moitra</dc:creator>
    </item>
    <item>
      <title>Pirogov--Sinai Theory Beyond Lattices</title>
      <link>https://arxiv.org/abs/2411.07809</link>
      <description>arXiv:2411.07809v1 Announce Type: cross 
Abstract: Pirogov--Sinai theory is a well-developed method for understanding the low-temperature phase diagram of statistical mechanics models on lattices. Motivated by physical and algorithmic questions beyond the setting of lattices, we develop a combinatorially flexible version of Pirogov--Sinai theory for the hard-core model of independent sets. Our results illustrate that the main conclusions of Pirogov--Sinai theory can be obtained in significantly greater generality than that of $\mathbb Z^{d}$. The main ingredients in our generalization are combinatorial and involve developing appropriate definitions of contours based on the notion of cycle basis connectivity. This is inspired by works of Tim\'{a}r and Georgakopoulos--Panagiotis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07809v1</guid>
      <category>math.PR</category>
      <category>cs.DS</category>
      <category>math-ph</category>
      <category>math.MP</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sarah Cannon, Tyler Helmuth, Will Perkins</dc:creator>
    </item>
    <item>
      <title>Interval Selection in Sliding Windows</title>
      <link>https://arxiv.org/abs/2405.09338</link>
      <description>arXiv:2405.09338v3 Announce Type: replace 
Abstract: We initiate the study of the Interval Selection problem in the (streaming) sliding window model of computation.
  In this problem, an algorithm receives a potentially infinite stream of intervals on the line, and the objective is to maintain at every moment an approximation to a largest possible subset of disjoint intervals among the $L$ most recent intervals, for some integer $L$.
  We give the following results:
  - In the unit-length intervals case, we give a $2$-approximation sliding window algorithm with space $\tilde{\mathrm{O}}(|OPT|)$, and we show that any sliding window algorithm that computes a $(2-\varepsilon)$-approximation requires space $\Omega(L)$, for any $\varepsilon &gt; 0$.
  - In the arbitrary-length case, we give a $(\frac{11}{3}+\varepsilon)$-approximation sliding window algorithm with space $\tilde{\mathrm{O}}(|OPT|)$, for any constant $\varepsilon &gt; 0$, which constitutes our main result.
  We also show that space $\Omega(L)$ is needed for algorithms that compute a $(2.5-\varepsilon)$-approximation, for any $\varepsilon &gt; 0$.
  Our main technical contribution is an improvement over the smooth histogram technique, which consists of running independent copies of a traditional streaming algorithm with different start times. By employing the one-pass $2$-approximation streaming algorithm by Cabello and P\'{e}rez-Lantero [Theor. Comput. Sci. '17] for Interval Selection on arbitrary-length intervals as the underlying algorithm, the smooth histogram technique immediately yields a $(4+\varepsilon)$-approximation in this setting. Our improvement is obtained by forwarding the structure of the intervals identified in a run to the subsequent run, which constrains the shape of an optimal solution and allows us to target optimal intervals differently.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.09338v3</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Cezar-Mihail Alexandru, Christian Konrad</dc:creator>
    </item>
    <item>
      <title>Average-Distortion Sketching</title>
      <link>https://arxiv.org/abs/2411.05156</link>
      <description>arXiv:2411.05156v2 Announce Type: replace 
Abstract: We introduce average-distortion sketching for metric spaces. As in (worst-case) sketching, these algorithms compress points in a metric space while approximately recovering pairwise distances. The novelty is studying average-distortion: for any fixed (yet, arbitrary) distribution $\mu$ over the metric, the sketch should not over-estimate distances, and it should (approximately) preserve the average distance with respect to draws from $\mu$. The notion generalizes average-distortion embeddings into $\ell_1$ [Rabinovich '03, Kush-Nikolov-Tang '21] as well as data-dependent locality-sensitive hashing [Andoni-Razenshteyn '15, Andoni-Naor-Nikolov-et-al. '18], which have been recently studied in the context of nearest neighbor search.
  $\bullet$ For all $p \in [1, \infty)$ and any $c$ larger than a fixed constant, we give an average-distortion sketch for $([\Delta]^d, \ell_p)$ with approximation $c$ and bit-complexity $\text{poly}(cp \cdot 2^{p/c} \cdot \log(d\Delta))$, which is provably impossible in (worst-case) sketching.
  $\bullet$ As an application, we improve on the approximation of sublinear-time data structures for nearest neighbor search over $\ell_p$ (for large $p &gt; 2$). The prior best approximation was $O(p)$ [Andoni-Naor-Nikolov-et-al. '18, Kush-Nikolov-Tang '21], and we show it can be any $c$ larger than a fixed constant (irrespective of $p$) by using $n^{\text{poly}(cp \cdot 2^{p/c})}$ space.
  We give some evidence that $2^{\Omega(p/c)}$ space may be necessary by giving a lower bound on average-distortion sketches which produce a certain probabilistic certificate of farness (which our sketches crucially rely on).</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.05156v2</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Yiqiao Bao, Anubhav Baweja, Nicolas Menand, Erik Waingarten, Nathan White, Tian Zhang</dc:creator>
    </item>
    <item>
      <title>Polynomial-time tolerant testing stabilizer states</title>
      <link>https://arxiv.org/abs/2408.06289</link>
      <description>arXiv:2408.06289v3 Announce Type: replace-cross 
Abstract: We consider the following task: suppose an algorithm is given copies of an unknown $n$-qubit quantum state $|\psi\rangle$ promised $(i)$ $|\psi\rangle$ is $\varepsilon_1$-close to a stabilizer state in fidelity or $(ii)$ $|\psi\rangle$ is $\varepsilon_2$-far from all stabilizer states, decide which is the case. We show that for every $\varepsilon_1&gt;0$ and $\varepsilon_2\leq \varepsilon_1^C$, there is a $\textsf{poly}(1/\varepsilon_1)$-sample and $n\cdot \textsf{poly}(1/\varepsilon_1)$-time algorithm that decides which is the case (where $C&gt;1$ is a universal constant). Our proof includes a new definition of Gowers norm for quantum states, an inverse theorem for the Gowers-$3$ norm of quantum states and new bounds on stabilizer covering for structured subsets of Paulis using results in additive combinatorics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.06289v3</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 13 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Srinivasan Arunachalam, Arkopal Dutt</dc:creator>
    </item>
  </channel>
</rss>
