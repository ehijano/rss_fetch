<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 07 Mar 2025 05:00:22 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 07 Mar 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Binomial Tabulation: A Short Story</title>
      <link>https://arxiv.org/abs/2503.04001</link>
      <description>arXiv:2503.04001v1 Announce Type: new 
Abstract: We reconstruct some of the development in Richard Bird's [2008] paper Zippy Tabulations of Recursive Functions, using dependent types and string diagrams rather than mere simple types. This paper serves as an intuitive introduction to and demonstration of these concepts for the curious functional programmer, who ideally already has some exposure to dependent types and category theory, is not put off by basic concepts like indexed types and functors, and wants to see a more practical example.
  The paper is presented in the form of a short story, narrated from the perspective of a functional programmer trying to follow the development in Bird's paper. The first section recaps the original simply typed presentation. The second section explores a series of refinements that can be made using dependent types. The third section uses string diagrams to simplify arguments involving functors and naturality. The short story ends there, but the paper concludes with a discussion and reflection in the afterword.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04001v1</guid>
      <category>cs.PL</category>
      <pubDate>Fri, 07 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hsiang-Shang Ko, Shin-Cheng Mu, Jeremy Gibbons</dc:creator>
    </item>
    <item>
      <title>Pydrofoil: accelerating Sail-based instruction set simulators</title>
      <link>https://arxiv.org/abs/2503.04389</link>
      <description>arXiv:2503.04389v1 Announce Type: new 
Abstract: We present Pydrofoil, a multi-stage compiler that generates instruction set simulators (ISSs) from processor instruction set architectures (ISAs) expressed in the high-level, verification-oriented ISA specification language Sail. Pydrofoil shows a &gt; 230x speedup over the C-based ISS generated by Sail on our benchmarks, and is based on the following insights. (i) An ISS is effectively an interpreter loop, and tracing just-in-time (JIT) compilers have proven effective at accelerating those, albeit mostly for dynamically typed languages. (ii) ISS workloads are highly atypical, dominated by intensive bit manipulation operations. Conventional compiler optimisations for general-purpose programming languages have limited impact for speeding up such workloads. We develop suitable domain-specific optimisations. (iii) Neither tracing JIT compilers, nor ahead-of-time (AOT) compilation alone, even with domain-specific optimisations, suffice for the generation of performant ISSs. Pydrofoil therefore implements a hybrid approach, pairing an AOT compiler with a tracing JIT built on the meta-tracing PyPy framework. AOT and JIT use domain-specific optimisations. Our benchmarks demonstrate that combining AOT and JIT compilers provides significantly greater performance gains than using either compiler alone.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04389v1</guid>
      <category>cs.PL</category>
      <pubDate>Fri, 07 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Carl Friedrich Bolz-Tereick, Luke Panayi, Ferdia McKeogh, Tom Spink, Martin Berger</dc:creator>
    </item>
    <item>
      <title>Understanding and Detecting Compatibility Issues in Android Auto Apps</title>
      <link>https://arxiv.org/abs/2503.04003</link>
      <description>arXiv:2503.04003v1 Announce Type: cross 
Abstract: Mobile platforms now power not only smartphones but also in-vehicle systems like Android Auto and CarPlay. Despite an ecosystem of over 3.5 million Android apps and more than 200 million Android Auto-compatible vehicles, only a few hundred apps have been adapted for automotive use. To better understand this gap, we studied 147 reported issues related to Android Auto and identified their root causes. We found that more than 70% of issues result from UI incompatibilities, 24% from media playback errors, and around 5% from failures in voice command handling, showing a lack of effective tools for developers. We introduce CarCompat, a static analysis framework that detects compatibility problems in Android Auto apps. CarCompat constructs a Car-Control Flow Graph (CCFG) to capture interactions among app components, lifecycle methods, and platform-specific callbacks. It applies specialized checkers to detect UI violations, media playback errors, and issues with voice command handling. We evaluated CarCompat on a dataset of 54 Android Auto apps and detected 25 new issues, 4 of which were confirmed by developers, and 2 developers have already released their fixes. The results show that CarCompat helps developers identify and fix compatibility issues, improving the in-vehicle experience.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04003v1</guid>
      <category>cs.SE</category>
      <category>cs.PL</category>
      <pubDate>Fri, 07 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Moshood Fakorede, Umar Farooq</dc:creator>
    </item>
    <item>
      <title>Linearization via Rewriting (Long Version)</title>
      <link>https://arxiv.org/abs/2503.04408</link>
      <description>arXiv:2503.04408v1 Announce Type: cross 
Abstract: We introduce the structural resource lambda-calculus, a new formalism in which strongly normalizing terms of the lambda-calculus can naturally be represented, and at the same time any type derivation can be internally rewritten to its linearization. The calculus is shown to be normalizing and confluent. Noticeably, every strongly normalizable lambda-term can be represented by a type derivation. This is the first example of a system where the linearization process takes place internally, while remaining purely finitary and rewrite-based.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04408v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 07 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ugo Dal Lago, Federico Olimpieri</dc:creator>
    </item>
    <item>
      <title>Modular Reasoning about Error Bounds for Concurrent Probabilistic Programs</title>
      <link>https://arxiv.org/abs/2503.04512</link>
      <description>arXiv:2503.04512v1 Announce Type: cross 
Abstract: We present Coneris, the first higher-order concurrent separation logic for reasoning about error probability bounds of higher-order concurrent probabilistic programs with higher-order state. To support modular reasoning about concurrent (non-probabilistic) program modules, state-of-the-art program logics internalize the classic notion of linearizability within the logic through the concept of logical atomicity.
  Coneris extends this idea to probabilistic concurrent program modules. Thus Coneris supports modular reasoning about probabilistic concurrent modules by capturing a novel notion of randomized logical atomicity within the logic. To do so, Coneris utilizes presampling tapes and a novel probabilistic update modality to describe how state is changed probabilistically at linearization points. We demonstrate this approach by means of smaller synthetic examples and larger case studies.
  All of the presented results, including the meta-theory, have been mechanized in the Rocq proof assistant and the Iris separation logic framework</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04512v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 07 Mar 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Kwing Hei Li, Alejandro Aguirre, Simon Oddershede Gregersen, Philipp G. Haselwarter, Joseph Tassarotti, Lars Birkedal</dc:creator>
    </item>
  </channel>
</rss>
