<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Apr 2024 04:00:15 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 09 Apr 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Counting Like Transformers: Compiling Temporal Counting Logic Into Softmax Transformers</title>
      <link>https://arxiv.org/abs/2404.04393</link>
      <description>arXiv:2404.04393v1 Announce Type: new 
Abstract: Deriving formal bounds on the expressivity of transformers, as well as studying transformers that are constructed to implement known algorithms, are both effective methods for better understanding the computational power of transformers. Towards both ends, we introduce the temporal counting logic $\textbf{K}_\text{t}$[#] alongside the RASP variant $\textbf{C-RASP}$. We show they are equivalent to each other, and that together they are the best-known lower bound on the formal expressivity of future-masked soft attention transformers with unbounded input size. We prove this by showing all $\textbf{K}_\text{t}$[#] formulas can be compiled into these transformers. As a case study, we demonstrate on paper how to use $\textbf{C-RASP}$ to construct simple transformer language models that, using greedy decoding, can only generate sentences that have given properties formally specified in $\textbf{K}_\text{t}$[#].</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04393v1</guid>
      <category>cs.LO</category>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Andy Yang, David Chiang</dc:creator>
    </item>
    <item>
      <title>The Church Synthesis Problem over Continuous Time</title>
      <link>https://arxiv.org/abs/2404.04782</link>
      <description>arXiv:2404.04782v1 Announce Type: new 
Abstract: The Church Problem asks for the construction of a procedure which, given a logical specification A(I,O) between input omega-strings I and output omega-strings O, determines whether there exists an operator F that implements the specification in the sense that A(I, F(I)) holds for all inputs I. Buchi and Landweber provided a procedure to solve the Church problem for MSO specifications and operators computable by finite-state automata. We investigate a generalization of the Church synthesis problem to the continuous time of the non-negative reals.
  We show that in the continuous time there are phenomena which are very different from the canonical discrete time domain of the natural numbers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04782v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander Rabinovich, Daniel Fattal</dc:creator>
    </item>
    <item>
      <title>GATlab: Modeling and Programming with Generalized Algebraic Theories</title>
      <link>https://arxiv.org/abs/2404.04837</link>
      <description>arXiv:2404.04837v1 Announce Type: new 
Abstract: Categories and categorical structures are increasingly recognized as useful abstractions for modeling in science and engineering. To uniformly implement category-theoretic mathematical models in software, we introduce GATlab, a domain-specific language for algebraic specification embedded in a technical programming language. GATlab is based on generalized algebraic theories (GATs), a logical system extending algebraic theories with dependent types so as to encompass category theory. Using GATlab, the programmer can specify generalized algebraic theories and their models, including both free models, based on symbolic expressions, and computational models, defined by arbitrary code in the host language. Moreover, the programmer can define maps between theories and use them to declaratively migrate models of one theory to models of another. In short, GATlab aims to provide a unified environment for both computer algebra and software interface design with generalized algebraic theories. In this paper, we describe the design, implementation, and applications of GATlab.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04837v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Owen Lynch, Kris Brown, James Fairbanks, Evan Patterson</dc:creator>
    </item>
    <item>
      <title>Quantitative Weakest Hyper Pre: Unifying Correctness and Incorrectness Hyperproperties via Predicate Transformers</title>
      <link>https://arxiv.org/abs/2404.05097</link>
      <description>arXiv:2404.05097v1 Announce Type: new 
Abstract: We present a novel \emph{weakest pre calculus} for \emph{reasoning about quantitative hyperproperties} over \emph{nondeterministic and probabilistic} programs. Whereas existing calculi allow reasoning about the expected value that a quantity assumes after program termination from a \emph{single initial state}, we do so for \emph{initial sets of states} or \emph{initial probability distributions}. We thus (i)~obtain a weakest pre calculus for hyper Hoare logic and (ii)~enable reasoning about so-called \emph{hyperquantities} which include expected values but also quantities (e.g. variance) out of scope of previous work. As a byproduct, we obtain a novel strongest post for weighted programs that extends both existing strongest and strongest liberal post calculi. Our framework reveals novel dualities between forward and backward transformers, correctness and incorrectness, as well as nontermination and unreachability.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05097v1</guid>
      <category>cs.LO</category>
      <category>cs.CR</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Linpeng Zhang, Noam Zilberstein, Benjamin Lucien Kaminski, Alexandra Silva</dc:creator>
    </item>
    <item>
      <title>Function spaces for orbit-finite sets</title>
      <link>https://arxiv.org/abs/2404.05265</link>
      <description>arXiv:2404.05265v1 Announce Type: new 
Abstract: Orbit-finite sets are a generalisation of finite sets, and as such support many operations allowed for finite sets, such as pairing, quotienting, or taking subsets. However, they do not support function spaces, i.e. if X and Y are orbit-finite sets, then the space of finitely supported functions from X to Y is not orbit-finite. In this paper we propose two solutions to this problem: one is obtained by generalising the notion of orbit-finite set, and the other one is obtained by restricting it. In both cases, function spaces and the original closure properties are retained. Curiously, both solutions are "linear": the generalisation is based on linear algebra, while the restriction is based on linear logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05265v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>math.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Miko{\l}aj Boja\'nczyk, L\^e Th\`anh D\~ung Nguy\^en, Rafa{\l} Stefa\'nski</dc:creator>
    </item>
    <item>
      <title>On the complexity of normalization for the planar $\lambda$-calculus</title>
      <link>https://arxiv.org/abs/2404.05276</link>
      <description>arXiv:2404.05276v1 Announce Type: new 
Abstract: We sketch a tentative proof of P-completeness for the $\beta$-convertibility problem on untyped planar (a.k.a. ordered or non-commutative) $\lambda$-terms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05276v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anupam Das, Damiano Mazza, L\^e Th\`anh D\~ung Nguy\^en, Noam Zeilberger</dc:creator>
    </item>
    <item>
      <title>Teaching Higher-Order Logic Using Isabelle</title>
      <link>https://arxiv.org/abs/2404.05458</link>
      <description>arXiv:2404.05458v1 Announce Type: new 
Abstract: We present a formalization of higher-order logic in the Isabelle proof assistant, building directly on the foundational framework Isabelle/Pure and developed to be as small and readable as possible. It should therefore serve as a good introduction for someone looking into learning about higher-order logic and proof assistants, without having to study the much more complex Isabelle/HOL with heavier automation. To showcase our development and approach we explain a sample proof, describe the axioms and rules of our higher-order logic, and discuss our experience with teaching the subject in a classroom setting.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05458v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.400.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 400, 2024, pp. 59-78</arxiv:journal_reference>
      <dc:creator>Simon Tobias Lund (Technical University of Denmark), J{\o}rgen Villadsen (Technical University of Denmark)</dc:creator>
    </item>
    <item>
      <title>Linear Contextual Metaprogramming and Session Types</title>
      <link>https://arxiv.org/abs/2404.05475</link>
      <description>arXiv:2404.05475v1 Announce Type: new 
Abstract: We explore the integration of metaprogramming in a call-by-value linear lambda-calculus and sketch its extension to a session type system. We build on a model of contextual modal type theory with multi-level contexts, where contextual values, closing arbitrary terms over a series of variables, may then be boxed and transmitted in messages. Once received, one such value may then be unboxed (with a let-box construct) and locally applied before being run. We present a series of examples where servers prepare and ship code on demand via session typed messages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05475v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.401.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 401, 2024, pp. 1-10</arxiv:journal_reference>
      <dc:creator>Pedro \^Angelo (LIACC,Faculdade de Ci\^encias da Universidade do Porto, Portugal), Atsushi Igarashi (Kyoto University, Kyoto, Japan), Vasco T. Vasconcelos (LASIGE, Faculdade de Ci\^encias da Universidade de Lisboa, Portugal)</dc:creator>
    </item>
    <item>
      <title>Predictable Verification using Intrinsic Definitions</title>
      <link>https://arxiv.org/abs/2404.04515</link>
      <description>arXiv:2404.04515v1 Announce Type: cross 
Abstract: We propose a novel mechanism of defining data structures using intrinsic definitions that avoids recursion and instead utilizes monadic maps satisfying local conditions. We show that intrinsic definitions are a powerful mechanism that can capture a variety of data structures naturally. We show that they also enable a predictable verification methodology that allows engineers to write ghost code to update monadic maps and perform verification using reduction to decidable logics. We evaluate our methodology using Boogie and prove a suite of data structure manipulating programs correct.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04515v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Adithya Murali, Cody Rivera, P. Madhusudan</dc:creator>
    </item>
    <item>
      <title>Iof-maint -- Modular maintenance ontology</title>
      <link>https://arxiv.org/abs/2404.05224</link>
      <description>arXiv:2404.05224v1 Announce Type: cross 
Abstract: In this paper we present a publicly-available maintenance ontology (Iof-maint). Iof-maint is a modular ontology aligned with the Industrial Ontology Foundry Core (IOF Core) and contains 20 classes and 2 relations. It provides a set of maintenance-specific terms used in a wide variety of practical data-driven use cases. Iof-maint supports OWL DL reasoning, is documented, and is actively maintained on GitHub. In this paper, we describe the evolution of the Iof-maint reference ontology based on the extraction of common concepts identified in a number of application ontologies working with industry maintenance work order, procedure and failure mode data.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05224v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.26182/chzp-vs60</arxiv:DOI>
      <dc:creator>Melinda Hodkiewicz, Caitlin Woods, Matt Selway, Markus Stumptner</dc:creator>
    </item>
    <item>
      <title>WebPie: A Tiny Slice of Dependent Typing</title>
      <link>https://arxiv.org/abs/2404.05457</link>
      <description>arXiv:2404.05457v1 Announce Type: cross 
Abstract: Dependently typed programming languages have become increasingly relevant in recent years. They have been adopted in industrial strength programming languages and have been extremely successful as the basis for theorem provers. There are however, very few entry level introductions to the theory of language constructs for dependently typed languages, and even less sources on didactical implementations. In this paper, we present a small dependently typed programming language called WebPie. The main features of the language are inductive types, recursion and case matching. While none of these features are new, we believe this article can provide a step forward towards the understanding and systematic construction of dependently typed languages for researchers new to dependent types.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05457v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.400.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 400, 2024, pp. 2-27</arxiv:journal_reference>
      <dc:creator>Christophe Scholliers (Ghent University)</dc:creator>
    </item>
    <item>
      <title>A Coq Library of Sets for Teaching Denotational Semantics</title>
      <link>https://arxiv.org/abs/2404.05459</link>
      <description>arXiv:2404.05459v1 Announce Type: cross 
Abstract: Sets and relations are very useful concepts for defining denotational semantics. In the Coq proof assistant, curried functions to Prop are used to represent sets and relations, e.g. A -&gt; Prop, A -&gt; B -&gt; Prop, A -&gt; B -&gt; C -&gt; Prop, etc. Further, the membership relation can be encoded by function applications, e.g. X a represents a in X if X: A -&gt; Prop. This is very convenient for developing formal definitions and proofs for professional users, but it makes propositions more difficult to read for non-professional users, e.g. students of a program semantics course. We develop a small Coq library of sets and relations so that standard math notations can be used when teaching denotational semantics of simple imperative languages. This library is developed using Coq's type class system. It brings about zero proof-term overhead comparing with the existing formalization of sets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05459v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.400.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 400, 2024, pp. 79-95</arxiv:journal_reference>
      <dc:creator>Qinxiang Cao, Xiwei Wu, Yalun Liang</dc:creator>
    </item>
    <item>
      <title>Interactive Formal Specification for Mathematical Problems of Engineers</title>
      <link>https://arxiv.org/abs/2404.05462</link>
      <description>arXiv:2404.05462v1 Announce Type: cross 
Abstract: The paper presents the second part of a precise description of the prototype  that has been developed in the course of the ISAC project over the last  two decades. This part describes the "specify-phase", while the first part describing the "solve-phase" is already published.
  In the specify-phase a student interactively constructs a formal specification. The ISAC prototype implements formal specifications as established in theoretical computer science, however, the input language for the construction  avoids requiring users to have knowledge of logic; this makes the system useful for various engineering faculties (and also for high school).
  The paper discusses not only ISAC's design of the specify-phase in detail, but also gives a brief introduction to implementation with the aim of advertising the re-use of formal frameworks (inclusive respective front-ends) with their generic tools for language definition and their rich pool of software  components for formal mathematics.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.05462v1</guid>
      <category>cs.HC</category>
      <category>cs.LO</category>
      <category>cs.MS</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.400.8</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 400, 2024, pp. 120-138</arxiv:journal_reference>
      <dc:creator>Walther Neuper (JKU - Johannes Kepler Universit\"at Linz)</dc:creator>
    </item>
    <item>
      <title>Fully Automated Verification of Linear Time-Invariant Systems against Signal Temporal Logic Specifications via Reachability Analysis</title>
      <link>https://arxiv.org/abs/2306.04089</link>
      <description>arXiv:2306.04089v2 Announce Type: replace 
Abstract: While reachability analysis is one of the most promising approaches for formal verification of dynamic systems, a major disadvantage preventing a more widespread application is the requirement to manually tune algorithm parameters such as the time step size. Manual tuning is especially problematic if one aims to verify that the system satisfies complicated specifications described by signal temporal logic formulas since the effect the tightness of the reachable set has on the satisfaction of the specification is often non-trivial to see for humans. We address this problem with a fully-automated verifier for linear systems, which automatically refines all parameters for reachability analysis until it can either prove or disprove that the system satisfies a signal temporal logic formula for all initial states and all uncertain inputs. Our verifier combines reachset temporal logic with dependency preservation to obtain a model checking approach whose over-approximation error converges to zero for adequately tuned parameters. While we in this work focus on linear systems for simplicity, the general concept we present can equivalently be applied for nonlinear and hybrid systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.04089v2</guid>
      <category>cs.LO</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <category>math.DS</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Niklas Kochdumper, Stanley Bak</dc:creator>
    </item>
    <item>
      <title>Exploring Non-Regular Extensions of Propositional Dynamic Logic with Description-Logics Features</title>
      <link>https://arxiv.org/abs/2307.09913</link>
      <description>arXiv:2307.09913v3 Announce Type: replace 
Abstract: We investigate the impact of non-regular path expressions on the decidability of satisfiability checking and querying in description logics extending ALC. Our primary objects of interest are ALCreg and ALCvpl, the extensions of with path expressions employing, respectively, regular and visibly-pushdown languages. The first one, ALCreg, is a notational variant of the well-known Propositional Dynamic Logic of Fischer and Ladner. The second one, ALCvpl, was introduced and investigated by Loding and Serre in 2007. The logic ALCvpl generalises many known decidable non-regular extensions of ALCreg.
  We provide a series of undecidability results. First, we show that decidability of the concept satisfiability problem for ALCvpl is lost upon adding the seemingly innocent Self operator. Second, we establish undecidability for the concept satisfiability problem for ALCvpl extended with nominals. Interestingly, our undecidability proof relies only on one single non-regular (visibly-pushdown) language, namely on r#s# := { r^n s^n | n in N } for fixed role names r and s. Finally, in contrast to the classical database setting, we establish undecidability of query entailment for queries involving non-regular atoms from r#s#, already in the case of ALC-TBoxes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.09913v3</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Bartosz Bednarczyk</dc:creator>
    </item>
    <item>
      <title>Adding an Implication to Logics of Perfect Paradefinite Algebras</title>
      <link>https://arxiv.org/abs/2309.06764</link>
      <description>arXiv:2309.06764v2 Announce Type: replace 
Abstract: Perfect paradefinite algebras are De Morgan algebras expanded with an operation that allows for the full behavior of classical negation to be restored. They form a variety that is term-equivalent to the variety of involutive Stone algebras. Their associated multiple-conclusion (Set-Set) and single-conclusion (Set-Fmla) order-preserving logics are non-algebraizable self-extensional logics of formal inconsistency and undeterminedness determined by a six-valued matrix, studied in depth by Gomes et al. (2022) from both the algebraic and the proof-theoretical perspectives. In the present paper, we continue that study by investigating directions for conservatively expanding these logics with an implication connective (essentially, one that admits the deduction-detachment theorem). We first consider logics given by very simple and manageable non-deterministic semantics whose implication (in isolation) is classical. These, nevertheless, fail to be self-extensional. We then consider the implication realized by the relative pseudo-complement over the six-valued perfect paradefinite algebra. Our strategy is to expand the language of the latter algebra with this connective and study the (self-extensional) Set-Set and Set-Fmla order-preserving and top-assertional logics of the variety induced by the resulting algebra. We provide axiomatizations for such new variety and for such logics, drawing parallels with the class of symmetric Heyting algebras and with Moisil's 'symmetric modal logic'. For the Set-Set logic, in particular, the axiomatization we obtain is analytic. We close by studying interpolation properties for these logics and concluding that the new variety has the Maehara amalgamation property.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.06764v2</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vitor Greati, S\'ergio Marcelino, Jo\~ao Marcos, Umberto Rivieccio</dc:creator>
    </item>
    <item>
      <title>Towards a Semantic Characterisation of Global Type Well-formedness</title>
      <link>https://arxiv.org/abs/2404.00446</link>
      <description>arXiv:2404.00446v2 Announce Type: replace 
Abstract: We address the question of characterising the well-formedness properties of multiparty session types semantically, i.e., as properties of the semantic model used to interpret types.  Choosing Prime Event Structures (PESs) as our semantic model, we present semantic counterparts for the two properties that underpin global type well-formedness, namely projectability and boundedness, in this model. As a first step towards a characterisation of the class of PESs corresponding to well-formed global types, we identify some simple structural properties satisfied by such PESs.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.00446v2</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.401.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 401, 2024, pp. 11-21</arxiv:journal_reference>
      <dc:creator>Ilaria Castellani (INRIA, Universit\'e C\^ote d'Azur, France), Paola Giannini (DiSSTE, Universit\`a del Piemonte Orientale, Italy)</dc:creator>
    </item>
    <item>
      <title>A faster FPRAS for #NFA</title>
      <link>https://arxiv.org/abs/2312.13320</link>
      <description>arXiv:2312.13320v2 Announce Type: replace-cross 
Abstract: Given a non-deterministic finite automaton (NFA) A with m states, and a natural number n (presented in unary), the #NFA problem asks to determine the size of the set L(A_n) of words of length n accepted by A. While the corresponding decision problem of checking the emptiness of L(A_n) is solvable in polynomial time, the #NFA problem is known to be #P-hard. Recently, the long-standing open question -- whether there is an FPRAS (fully polynomial time randomized approximation scheme) for #NFA -- was resolved in \cite{ACJR19}. The FPRAS due to \cite{ACJR19} relies on the interreducibility of counting and sampling, and computes, for each pair of state q and natural number i &lt;= n, a set of O(\frac{m^7 n^7}{epsilon^7}) many uniformly chosen samples from the set of words of length i that have a run ending at q (\epsilon is the error tolerance parameter of the FPRAS). This informative measure -- the number of samples maintained per state and length -- also affects the overall time complexity with a quadratic dependence.
  Given the prohibitively high time complexity, in terms of each of the input parameters, of the FPRAS due to \cite{ACJR19}, and considering the widespread application of approximate counting (and sampling) in various tasks in Computer Science, a natural question arises: Is there a faster FPRAS for #NFA that can pave the way for the practical implementation of approximate #NFA tools? In this work, we demonstrate that significant improvements in time complexity are achievable. Specifically, we have reduced the number of samples required for each state to be independent of m, with significantly less dependence on $n$ and $\epsilon$, maintaining only \widetilde{O}(\frac{n^4}{epsilon^2}) samples per state.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.13320v2</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kuldeep S. Meel, Sourav Chakraborty, Umang Mathur</dc:creator>
    </item>
    <item>
      <title>Integrating Graceful Degradation and Recovery through Requirement-driven Adaptation</title>
      <link>https://arxiv.org/abs/2401.09678</link>
      <description>arXiv:2401.09678v2 Announce Type: replace-cross 
Abstract: Cyber-physical systems (CPS) are subject to environmental uncertainties such as adverse operating conditions, malicious attacks, and hardware degradation. These uncertainties may lead to failures that put the system in a sub-optimal or unsafe state. Systems that are resilient to such uncertainties rely on two types of operations: (1) graceful degradation, to ensure that the system maintains an acceptable level of safety during unexpected environmental conditions and (2) recovery, to facilitate the resumption of normal system functions. Typically, mechanisms for degradation and recovery are developed independently from each other, and later integrated into a system, requiring the designer to develop an additional, ad-hoc logic for activating and coordinating between the two operations. In this paper, we propose a self-adaptation approach for improving system resiliency through automated triggering and coordination of graceful degradation and recovery. The key idea behind our approach is to treat degradation and recovery as requirement-driven adaptation tasks: Degradation can be thought of as temporarily weakening original (i.e., ideal) system requirements to be achieved by the system, and recovery as strengthening the weakened requirements when the environment returns within an expected operating boundary. Furthermore, by treating weakening and strengthening as dual operations, we argue that a single requirement-based adaptation method is sufficient to enable coordination between degradation and recovery. Given system requirements specified in signal temporal logic (STL), we propose a run-time adaptation framework that performs degradation and recovery in response to environmental changes. We describe a prototype implementation of our framework and demonstrate the feasibility of the proposed approach using a case study in unmanned underwater vehicles.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.09678v2</guid>
      <category>cs.SE</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Simon Chu, Justin Koe, David Garlan, Eunsuk Kang</dc:creator>
    </item>
    <item>
      <title>Techniques for Measuring the Inferential Strength of Forgetting Policies</title>
      <link>https://arxiv.org/abs/2404.02454</link>
      <description>arXiv:2404.02454v2 Announce Type: replace-cross 
Abstract: The technique of forgetting in knowledge representation has been shown to be a powerful and useful knowledge engineering tool with widespread application. Yet, very little research has been done on how different policies of forgetting, or use of different forgetting operators, affects the inferential strength of the original theory. The goal of this paper is to define loss functions for measuring changes in inferential strength based on intuitions from model counting and probability theory. Properties of such loss measures are studied and a pragmatic knowledge engineering tool is proposed for computing loss measures using Problog. The paper includes a working methodology for studying and determining the strength of different forgetting policies, in addition to concrete examples showing how to apply the theoretical results using Problog. Although the focus is on forgetting, the results are much more general and should have wider application to other areas.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.02454v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Patrick Doherty, Andrzej Szalas</dc:creator>
    </item>
  </channel>
</rss>
