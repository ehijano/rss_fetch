<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 23 Jul 2025 01:42:45 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Studying homing and synchronizing sequences for Timed Finite State Machines with output delays</title>
      <link>https://arxiv.org/abs/2507.14526</link>
      <description>arXiv:2507.14526v2 Announce Type: new 
Abstract: The paper introduces final state identification (synchronizing and homing) sequences for Timed Finite State Machines (TFSMs) with output delays and investigates their properties. We formally define the notions of homing sequences (HSs) and synchronizing sequences (SSs) for these TFSMs and demonstrate that several properties that hold for untimed machines do not necessarily apply to timed ones. Furthermore, we explore the applicability of various approaches for deriving SSs and HSs for Timed FSMs with output delays, such as truncated successor tree-based and FSM abstraction-based methods. Correspondingly, we identify the subclasses of TFSMs for which these approaches can be directly applied and those for which other methods are required. Additionally, we evaluate the complexity of existence check and derivation of (shortest) HSs / SSs for TFSMs with output delays.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.14526v2</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Evgenii Vinarskii, Jakub Ruszil, Adam Roman, Natalia Kushik</dc:creator>
    </item>
    <item>
      <title>Input-Driven Pushdown Automata with Translucent Input Letters</title>
      <link>https://arxiv.org/abs/2507.15310</link>
      <description>arXiv:2507.15310v1 Announce Type: new 
Abstract: Input-driven pushdown automata with translucent input letters are investigated. Here, the use of translucent input letters means that the input is processed in several sweeps and that, depending on the current state of the automaton, some input symbols are visible and can be processed, whereas some other symbols are invisible, and may be processed in another sweep. Additionally, the returning mode as well as the non-returning mode are considered, where in the former mode a new sweep must start after processing a visible input symbol. Input-driven pushdown automata differ from traditional pushdown automata by the fact that the actions on the pushdown store (push, pop, nothing) are dictated by the input symbols. We obtain the result that the input-driven nondeterministic model is computationally stronger than the deterministic model both in the returning mode and in the non-returning mode, whereas it is known that the deterministic and the nondeterministic model are equivalent for input-driven pushdown automata without translucency. It also turns out that the non-returning model is computationally stronger than the returning model both in the deterministic and nondeterministic case. Furthermore, we investigate the closure properties of the language families introduced under the Boolean operations. We obtain a complete picture in the deterministic case, whereas in the nondeterministic case the language families are shown to be not closed under complementation. Finally, we look at decidability questions and obtain the non-semidecidability of the questions of universality, inclusion, equivalence, and regularity in the nondeterministic case. </description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15310v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.422.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 422, 2025, pp. 29-43</arxiv:journal_reference>
      <dc:creator>Martin Kutrib, Andreas Malcher, Matthias Wendlandt</dc:creator>
    </item>
    <item>
      <title>Idefix-Closed Languages and Their Application in Contextual Grammars</title>
      <link>https://arxiv.org/abs/2507.15312</link>
      <description>arXiv:2507.15312v1 Announce Type: new 
Abstract: In this paper, we continue the research on the power of contextual grammars with selection languages from  subfamilies of the family of regular languages.  We investigate infix-, prefix-, and suffix-closed languages (referred to as idefix-closed languages) and compare such language families to some other subregular families of languages (finite, monoidal, nilpotent, combinational, (symmetric) definite, ordered, non-counting,  power-separating, commutative, circular, union-free, star, and comet languages). Further, we compare the families of the hierarchies obtained for external and internal contextual grammars with the language families defined by these new types for the selection. In this way, we extend the existing hierarchies by new language families. Moreover, we solve an open problem regarding internal contextual grammars with suffix-closed selection languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15312v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.422.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 422, 2025, pp. 1-14</arxiv:journal_reference>
      <dc:creator>Marvin K\"odding, Bianca Truthe</dc:creator>
    </item>
    <item>
      <title>On a Generalization of the Christoffel Tree: Epichristoffel Trees</title>
      <link>https://arxiv.org/abs/2507.15313</link>
      <description>arXiv:2507.15313v1 Announce Type: new 
Abstract: Sturmian words form a family of one-sided infinite words over a binary alphabet that are obtained as a discretization of a line with an irrational slope starting from the origin. A finite version of this class of words called Christoffel words has been extensively studied for their interesting properties. It is a class of words that has a geometric and an algebraic definition, making it an intriguing topic of study for many mathematicians. Recently, a generalization of Christoffel words for an alphabet with 3 letters or more, called epichristoffel words, using episturmian morphisms has been studied, and many of the properties of Christoffel words have been shown to carry over to epichristoffel words; however, many properties are not shared by them as well. In this paper, we introduce the notion of an epichristoffel tree, which proves to be a useful tool in determining a subclass of epichristoffel words that share an important property of Christoffel words, which is the ability to factorize an epichristoffel word as a product of smaller epichristoffel words. We also use the epichristoffel tree to present some interesting results that help to better understand epichristoffel words.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15313v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.422.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 422, 2025, pp. 15-28</arxiv:journal_reference>
      <dc:creator>Abhishek Krishnamoorthy (Madras Christian College), Robinson Thamburaj (Madras Christian College), Durairaj Gnanaraj Thomas (Madras Christian College)</dc:creator>
    </item>
    <item>
      <title>Orchestration of Music by Grammar Systems</title>
      <link>https://arxiv.org/abs/2507.15314</link>
      <description>arXiv:2507.15314v1 Announce Type: new 
Abstract: This application-oriented study concerns computational musicology, which makes use of grammar systems. We define multi-generative rule-synchronized scattered-context grammar systems (without erasing rules) and demonstrates how to simultaneously make the arrangement of a musical composition for performance by a whole orchestra, consisting of several instruments. Primarily, an orchestration like this is illustrated by examples in terms of classical music. In addition, the orchestration of jazz compositions is sketched as well. The study concludes its discussion by suggesting five open problem areas related to this way of orchestration.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15314v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.422.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 422, 2025, pp. 45-58</arxiv:journal_reference>
      <dc:creator>Jozef Maki\v{s} (Faculty of Information Technology, Brno University of Technology), Alexander Meduna (Faculty of Information Technology, Brno University of Technology), Zbyn\v{e}k K\v{r}ivka (Faculty of Information Technology, Brno University of Technology)</dc:creator>
    </item>
    <item>
      <title>On Repetitive Finite Automata with Translucent Words</title>
      <link>https://arxiv.org/abs/2507.15315</link>
      <description>arXiv:2507.15315v1 Announce Type: new 
Abstract: We introduce and study the repetitive variants of the deterministic and the nondeterministic finite automaton with translucent words (DFAwtw and NFAwtw). On seeing the right sentinel, a repetitive NFAwtw need not halt immediately, accepting or rejecting, but it may change into another state and continue with its computation. We establish that a repetitive DFAwtw already accepts a language that is not even semi-linear, which shows that the property of being repetitive increases the expressive capacity of the DFAwtw and the NFAwtw considerably.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15315v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.422.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 422, 2025, pp. 59-72</arxiv:journal_reference>
      <dc:creator>Franti\v{s}ek Mr\'az (Charles University in Prague), Friedrich Otto (Universit\"atKassel)</dc:creator>
    </item>
    <item>
      <title>A Myhill-Nerode Type Characterization of 2detLIN Languages</title>
      <link>https://arxiv.org/abs/2507.15316</link>
      <description>arXiv:2507.15316v1 Announce Type: new 
Abstract: Linear automata are automata with two reading heads starting from the two extremes of the input, are equivalent to 5' -&gt; 3' Watson-Crick (WK) finite automata. The heads read the input in opposite directions and the computation finishes when the heads meet. These automata accept the class LIN of linear languages. The deterministic counterpart of these models, on the one hand, is less expressive, as only a proper subset of LIN, the class 2detLIN is accepted; and on the other hand, they are also equivalent in the sense of the class of the accepted languages. Now, based on these automata models, we characterize the class of 2detLIN languages with a Myhill-Nerode type of equivalence classes. However, as these automata may do the computation of both the prefix and the suffix of the input, we use prefix-suffix pairs in our classes. Additionally, it is proven that finitely many classes in the characterization match with the 2detLIN languages, but we have some constraints on the used prefix-suffix pairs, i.e., the characterization should have the property to be complete and it must not have any crossing pairs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15316v1</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.422.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 422, 2025, pp. 73-88</arxiv:journal_reference>
      <dc:creator>Benedek Nagy (Eastern Mediterranean University / Eszterh\'azy K\'aroly Catholic University)</dc:creator>
    </item>
    <item>
      <title>On some Classes of Reversible 2-head Automata</title>
      <link>https://arxiv.org/abs/2507.15317</link>
      <description>arXiv:2507.15317v1 Announce Type: new 
Abstract: Deterministic 2-head finite automata which are machines that process an input word from both ends are analyzed for their ability to perform reversible computations. This implies that the automata are backward deterministic, enabling unique forward and backward computation. We explore the computational power of such automata, discovering that, while some regular languages cannot be accepted by these machines, they are capable of accepting some characteristic linear languages, e.g., the language of palindromes. Additionally, we prove that restricted variants, i.e., both 1-limited reversible 2-head finite automata and complete reversible 2-head finite automata are less powerful and they form a proper hierarchy. In the former, in each computation step exactly one input letter is being processed, i.e., only one of the heads can read a letter. These automata are also characterized by putting their states to classes based on the head(s) used to reach and to leave the state. In the complete reversible 2-head finite automata, it is required that any input can be fully read by the automaton. The accepted families are also compared to the classes generated by left deterministic linear grammars.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15317v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.422.7</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 422, 2025, pp. 89-103</arxiv:journal_reference>
      <dc:creator>Benedek Nagy (Eastern Mediterranean University / Eszterh\'azy K\'aroly Catholic University), Walaa Yasin (Eastern Mediterranean University)</dc:creator>
    </item>
    <item>
      <title>The theory of reachability in trace-pushdown systems</title>
      <link>https://arxiv.org/abs/2507.15733</link>
      <description>arXiv:2507.15733v1 Announce Type: new 
Abstract: We consider pushdown systems that store, instead of a single word, a Mazurkiewicz trace on its stack. These systems are special cases of valence automata over graph monoids and subsume multi-stack systems. We identify a class of such systems that allow to decide the first-order theory of their configuration graph with reachability.
  This result complements results by D'Osualdo, Meyer, and Zetzsche (namely the decidability for arbitrary pushdown systems under a severe restriction on the dependence alphabet).</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15733v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dietrich Kuske</dc:creator>
    </item>
    <item>
      <title>On the Effectiveness of Large Language Models in Writing Alloy Formulas</title>
      <link>https://arxiv.org/abs/2502.15441</link>
      <description>arXiv:2502.15441v1 Announce Type: cross 
Abstract: Declarative specifications have a vital role to play in developing safe and dependable software systems. Writing specifications correctly, however, remains particularly challenging. This paper presents a controlled experiment on using large language models (LLMs) to write declarative formulas in the well-known language Alloy. Our use of LLMs is three-fold. One, we employ LLMs to write complete Alloy formulas from given natural language descriptions (in English). Two, we employ LLMs to create alternative but equivalent formulas in Alloy with respect to given Alloy formulas. Three, we employ LLMs to complete sketches of Alloy formulas and populate the holes in the sketches by synthesizing Alloy expressions and operators so that the completed formulas accurately represent the desired properties (that are given in natural language). We conduct the experimental evaluation using 11 well-studied subject specifications and employ two popular LLMs, namely ChatGPT and DeepSeek. The experimental results show that the LLMs generally perform well in synthesizing complete Alloy formulas from input properties given in natural language or in Alloy, and are able to enumerate multiple unique solutions. Moreover, the LLMs are also successful at completing given sketches of Alloy formulas with respect to natural language descriptions of desired properties (without requiring test cases). We believe LLMs offer a very exciting advance in our ability to write specifications, and can help make specifications take a pivotal role in software development and enhance our ability to build robust software.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.15441v1</guid>
      <category>cs.SE</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yang Hong, Shan Jiang, Yulei Fu, Sarfraz Khurshid</dc:creator>
    </item>
    <item>
      <title>STL-GO: Spatio-Temporal Logic with Graph Operators for Distributed Systems with Multiple Network Topologies</title>
      <link>https://arxiv.org/abs/2507.15147</link>
      <description>arXiv:2507.15147v1 Announce Type: cross 
Abstract: Multi-agent systems (MASs) consisting of a number of autonomous agents that communicate, coordinate, and jointly sense the environment to achieve complex missions can be found in a variety of applications such as robotics, smart cities, and internet-of-things applications. Modeling and monitoring MAS requirements to guarantee overall mission objectives, safety, and reliability is an important problem. Such requirements implicitly require reasoning about diverse sensing and communication modalities between agents, analysis of the dependencies between agent tasks, and the spatial or virtual distance between agents. To capture such rich MAS requirements, we model agent interactions via multiple directed graphs, and introduce a new logic -- Spatio-Temporal Logic with Graph Operators (STL-GO). The key innovation in STL-GO are graph operators that enable us to reason about the number of agents along either the incoming or outgoing edges of the underlying interaction graph that satisfy a given property of interest; for example, the requirement that an agent should sense at least two neighboring agents whose task graphs indicate the ability to collaborate. We then propose novel distributed monitoring conditions for individual agents that use only local information to determine whether or not an STL-GO specification is satisfied. We compare the expressivity of STL-GO against existing spatio-temporal logic formalisms, and demonstrate the utility of STL-GO and our distributed monitors in a bike-sharing and a multi-drone case study.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15147v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.MA</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yiqi Zhao, Xinyi Yu, Bardh Hoxha, Georgios Fainekos, Jyotirmoy V. Deshmukh, Lars Lindemann</dc:creator>
    </item>
    <item>
      <title>Fine-Grained Complexity of Ambiguity Problems on Automata and Directed Graphs</title>
      <link>https://arxiv.org/abs/2501.14725</link>
      <description>arXiv:2501.14725v3 Announce Type: replace 
Abstract: In the field of computational logic, two classes of finite automata are considered fundamental: deterministic and nondeterministic automata (DFAs and NFAs). In a more fine-grained approach three natural intermediate classes were introduced, defined by restricting the number of accepting runs of the input NFA. The classes are called: unambiguous, finitely ambiguous, and polynomially ambiguous finite automata. It was observed that central problems, like equivalence, become tractable when the input NFA is restricted to some of these classes. This naturally brought interest into problems determining whether an input NFA belongs to the intermediate classes.
  Our first result is a nearly complete characterization of the fine-grained complexity of these problems. We show that the respective quadratic and cubic running times of Allauzen et al. are optimal under the Orthogonal Vectors hypothesis or the k-Cycle hypothesis, for alphabets with at least two symbols. In contrast, for unary alphabets we show that all aforementioned variants of ambiguity can be decided in almost linear time.
  Finally, we study determinisability of unambiguous weighted automata. We positively resolve a conjecture of Allauzen and Mohri, proving that their quadratic-time algorithm for verifying determinisability of unambiguous weighted automata is optimal, assuming the Orthogonal Vectors hypothesis or the k-Cycle hypothesis. We additionally show that for unary alphabets, this can be decided in linear time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14725v3</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 22 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Karolina Drabik, Anita D\"urr, Fabian Frei, Filip Mazowiecki, Karol W\k{e}grzycki</dc:creator>
    </item>
  </channel>
</rss>
