<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 Oct 2025 04:01:02 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 10 Oct 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Languages of Words of Low Automatic Complexity Are Hard to Compute</title>
      <link>https://arxiv.org/abs/2510.07696</link>
      <description>arXiv:2510.07696v1 Announce Type: new 
Abstract: The automatic complexity of a finite word (string) is an analogue for finite automata of Sipser's distinguishing complexity (1983) and was introduced by Shallit and Wang (2001). For a finite alphabet $\Sigma$ of at least two elements, we consider the non-deterministic automatic complexity given by exactly - yet not necessarily uniquely - accepting automata: a word $x \in \Sigma^*$ has exact non-deterministic automatic complexity $k \in \mathbb{N}$ if there exists a non-deterministic automaton of $k$ states which accepts $x$ while rejecting every other word of the same length as $x$, and no automaton of fewer states has this property. Importantly, and in contrast to the classical notion, the witnessing automaton may have multiple paths of computation accepting $x$. We denote this measure of complexity by $A_{Ne}$, and study a class of languages of low $A_{Ne}$-complexity defined as $L_q = \{ \, x \in \Sigma^* : A_{Ne}(x) &lt; q|x| \, \}$, which is parameterised by rationals $q \in (0,1/2)$ (generalising a class of sets first studied by Kjos-Hanssen). We show that for every $q \in (0,1/2)$, this class is neither context-free nor recognisable by certain Boolean circuits. In the process, we answer an open question of Kjos-Hanssen quantifying the complexity of $L_{1/3}$ in terms of Boolean circuits, and also prove the Shannon effect for $A_{Ne}$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.07696v1</guid>
      <category>cs.FL</category>
      <category>math.LO</category>
      <pubDate>Fri, 10 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Joey Chen, Bj{\o}rn Kjos-Hanssen, Ivan Koswara, Linus Richter, Frank Stephan</dc:creator>
    </item>
    <item>
      <title>On the Complexity of Language Membership for Probabilistic Words</title>
      <link>https://arxiv.org/abs/2510.08127</link>
      <description>arXiv:2510.08127v1 Announce Type: new 
Abstract: We study the membership problem to context-free languages L (CFLs) on probabilistic words, that specify for each position a probability distribution on the letters (assuming independence across positions). Our task is to compute, given a probabilistic word, what is the probability that a word drawn according to the distribution belongs to L. This problem generalizes the problem of counting how many words of length n belong to L, or of counting how many completions of a partial word belong to L.
  We show that this problem is in polynomial time for unambiguous context-free languages (uCFLs), but can be #P-hard already for unions of two linear uCFLs. More generally, we show that the problem is in polynomial time for so-called poly-slicewise-unambiguous languages, where given a length n we can tractably compute an uCFL for the words of length n in the language. This class includes some inherently ambiguous languages, and implies the tractability of bounded CFLs and of languages recognized by unambiguous polynomial-time counter automata; but we show that the problem can be #P-hard for nondeterministic counter automata, even for Parikh automata with a single counter. We then introduce classes of circuits from knowledge compilation which we use for tractable counting, and show that this covers the tractability of poly-slicewise-unambiguous languages and of some CFLs that are not poly-slicewise-unambiguous. Extending these circuits with negation further allows us to show tractability for the language of primitive words, and for the language of concatenations of two palindromes. We finally show the conditional undecidability of the meta-problem that asks, given a CFG, whether the probabilistic membership problem for that CFG is tractable or #P-hard.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.08127v1</guid>
      <category>cs.FL</category>
      <pubDate>Fri, 10 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antoine Amarilli, Mika\"el Monet, Paul Rapha\"el, Sylvain Salvati</dc:creator>
    </item>
    <item>
      <title>Homomorphism Problems in Graph Databases and Automatic Structures</title>
      <link>https://arxiv.org/abs/2510.07422</link>
      <description>arXiv:2510.07422v1 Announce Type: cross 
Abstract: This thesis investigates the central role of homomorphism problems (structure-preserving maps) in two complementary domains: database querying over finite, graph-shaped data, and constraint solving over (potentially infinite) structures. Building on the well-known equivalence between conjunctive query evaluation and homomorphism existence, the first part focuses on conjunctive regular path queries, a standard extension of conjunctive queries that incorporates regular-path predicates. We study the fundamental problem of query minimization under two measures: the number of atoms (constraints) and the tree-width of the query graph. In both cases, we prove the problem to be decidable, and provide efficient algorithms for a large fragment of queries used in practice. The second part of the thesis lifts homomorphism problems to automatic structures, which are infinite structures describable by finite automata. We highlight a dichotomy, between homomorphism problems over automatic structures that are decidable in non-deterministic logarithmic space, and those that are undecidable (proving to be the more common case). In contrast to this prevalence of undecidability, we then focus on the language-theoretic properties of these structures, and show, relying on a novel algebraic language theory, that for any well-behaved logic (a pseudovariety), whether an automatic structure can be described in this logic is decidable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.07422v1</guid>
      <category>cs.LO</category>
      <category>cs.DB</category>
      <category>cs.FL</category>
      <pubDate>Fri, 10 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>R\'emi Morvan</dc:creator>
    </item>
    <item>
      <title>Self-replication and Computational Universality</title>
      <link>https://arxiv.org/abs/2510.08342</link>
      <description>arXiv:2510.08342v1 Announce Type: cross 
Abstract: Self-replication is central to all life, and yet how it dynamically emerges in physical, non-equilibrium systems remains poorly understood. Von Neumann's pioneering work in the 1940s and subsequent developments suggest a natural hypothesis: that any physical system capable of Turing-universal computation can support self-replicating objects. In this work, we challenge this hypothesis by clarifying what computational universality means for physical systems and constructing a cellular automaton that is Turing-universal but cannot sustain non-trivial self-replication. By analogy with biology, such dynamics manifest transcription and translation but cannot instantiate replication. More broadly, our work emphasizes that the computational complexity of translating between physical dynamics and symbolic computation is inseparable from any claim of universality (exemplified by our analysis of Rule 110) and builds mathematical foundations for identifying self-replicating behavior. Our approach enables the formulation of necessary dynamical and computational conditions for a physical system to constitute a living organism.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.08342v1</guid>
      <category>nlin.CG</category>
      <category>cs.FL</category>
      <category>nlin.AO</category>
      <pubDate>Fri, 10 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jordan Cotler, Cl\'ement Hongler, Barbora Hudcov\'a</dc:creator>
    </item>
  </channel>
</rss>
