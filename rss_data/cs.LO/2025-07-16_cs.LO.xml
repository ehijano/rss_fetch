<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Jul 2025 04:00:51 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Comment on Decidability of Quasi-Dense Modal Logics by Lyon and Ostropolski-Nalewaja</title>
      <link>https://arxiv.org/abs/2507.11644</link>
      <description>arXiv:2507.11644v1 Announce Type: new 
Abstract: In \cite{Lyon24} the question of the decidability of quasi-dense modal logics is answered, and an upper bound in EXPSPACE is given. Unfortunately, authors' intricate proof contains a major flaw that cannot be fixed, leaving the question wide open. Once identified, this error roughly amounts to assuming that the union of two consistent sets is consistent, which is of course wrong.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.11644v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Olivier Gasquet</dc:creator>
    </item>
    <item>
      <title>Counting Answer Sets of Disjunctive Answer Set Programs</title>
      <link>https://arxiv.org/abs/2507.11655</link>
      <description>arXiv:2507.11655v1 Announce Type: new 
Abstract: Answer Set Programming (ASP) provides a powerful declarative paradigm for knowledge representation and reasoning. Recently, counting answer sets has emerged as an important computational problem with applications in probabilistic reasoning, network reliability analysis, and other domains. This has motivated significant research into designing efficient ASP counters. While substantial progress has been made for normal logic programs, the development of practical counters for disjunctive logic programs remains challenging.
  We present SharpASP-SR, a novel framework for counting answer sets of disjunctive logic programs based on subtractive reduction to projected propositional model counting. Our approach introduces an alternative characterization of answer sets that enables efficient reduction while ensuring that intermediate representations remain of polynomial size. This allows SharpASP-SR to leverage recent advances in projected model counting technology. Through extensive experimental evaluation on diverse benchmarks, we demonstrate that SharpASP-SR significantly outperforms existing counters on instances with large answer set counts. Building on these results, we develop a hybrid counting approach that combines enumeration techniques with SharpASP-SR to achieve state-of-the-art performance across the full spectrum of disjunctive programs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.11655v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mohimenul Kabir, Supratik Chakraborty, Kuldeep S Meel</dc:creator>
    </item>
    <item>
      <title>Anthem 2.0: Automated Reasoning for Answer Set Programming</title>
      <link>https://arxiv.org/abs/2507.11704</link>
      <description>arXiv:2507.11704v1 Announce Type: new 
Abstract: Anthem 2.0 is a tool to aid in the verification of logic programs written in an expressive fragment of Clingo's input language named mini-gringo, which includes arithmetic operations and simple choice rules but not aggregates. It can translate logic programs into formula representations in the logic of here-and-there, and analyze properties of logic programs such as tightness. Most importantly, Anthem 2.0 can support program verification by invoking first-order theorem provers to confirm that a program adheres to a first-order specification, or to establish strong and external equivalence of programs. This paper serves as an overview of the system's capabilities. We demonstrate how to use Anthem 2.0 effectively and interpret its results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.11704v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jorge Fandinno, Christoph Glinzer, Zachary Hansen, Jan Heuer, Yuliya Lierler, Vladimir Lifschitz, Torsten Schaub, Tobias Stolzmann</dc:creator>
    </item>
    <item>
      <title>Approximation Fixpoint Theory as a Unifying Framework for Fuzzy Logic Programming Semantics (Extended Version)</title>
      <link>https://arxiv.org/abs/2507.11961</link>
      <description>arXiv:2507.11961v1 Announce Type: new 
Abstract: Fuzzy logic programming is an established approach for reasoning under uncertainty. Several semantics from classical, two-valued logic programming have been generalized to the case of fuzzy logic programs. In this paper, we show that two of the most prominent classical semantics, namely the stable model and the well-founded semantics, can be reconstructed within the general framework of approximation fixpoint theory (AFT). This not only widens the scope of AFT from two- to many-valued logics, but allows a wide range of existing AFT results to be applied to fuzzy logic programming. As first examples of such applications, we clarify the formal relationship between existing semantics, generalize the notion of stratification from classical to fuzzy logic programs, and devise "more precise" variants of the semantics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.11961v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Pascal Kettmann, Jesse Heyninck, Hannes Strass</dc:creator>
    </item>
    <item>
      <title>SHACL Validation in the Presence of Ontologies: Semantics and Rewriting Techniques</title>
      <link>https://arxiv.org/abs/2507.12286</link>
      <description>arXiv:2507.12286v1 Announce Type: new 
Abstract: SHACL and OWL are two prominent W3C standards for managing RDF data. These languages share many features, but they have one fundamental difference: OWL, designed for inferring facts from incomplete data, makes the open-world assumption, whereas SHACL is a constraint language that treats the data as complete and must be validated under the closed-world assumption. The combination of both formalisms is very appealing and has been called for, but their semantic gap is a major challenge, semantically and computationally. In this paper, we advocate a semantics for SHACL validation in the presence of ontologies based on core universal models. We provide a technique for constructing these models for ontologies in the rich data-tractable description logic Horn-ALCHIQ. Furthermore, we use a finite representation of this model to develop a rewriting technique that reduces SHACL validation in the presence of ontologies to standard validation. Finally, we study the complexity of SHACL validation in the presence of ontologies, and show that even very simple ontologies make the problem EXPTIME-complete, and PTIME-complete in data complexity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.12286v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Anouk Oudshoorn, Magdalena Ortiz, Mantas Simkus</dc:creator>
    </item>
    <item>
      <title>Quantum circuits are just a phase</title>
      <link>https://arxiv.org/abs/2507.11676</link>
      <description>arXiv:2507.11676v1 Announce Type: cross 
Abstract: Quantum programs today are written at a low level of abstraction - quantum circuits akin to assembly languages - and even advanced quantum programming languages essentially function as circuit description languages. This state of affairs impedes scalability, clarity, and support for higher-level reasoning. More abstract and expressive quantum programming constructs are needed.
  To this end, we introduce a novel yet simple quantum programming language for generating unitaries from "just a phase"; we combine a (global) phase operation that captures phase shifts with a quantum analogue of the "if let" construct that captures subspace selection via pattern matching. This minimal language lifts the focus from quantum gates to eigendecomposition, conjugation, and controlled unitaries; common building blocks in quantum algorithm design.
  We demonstrate several aspects of the expressive power of our language in several ways. Firstly, we establish that our representation is universal by deriving a universal quantum gate set. Secondly, we show that important quantum algorithms can be expressed naturally and concisely, including Grover's search algorithm, Hamiltonian simulation, Quantum Fourier Transform, Quantum Signal Processing, and the Quantum Eigenvalue Transformation. Furthermore, we give clean denotational semantics grounded in categorical quantum mechanics. Finally, we implement a prototype compiler that efficiently translates terms of our language to quantum circuits, and prove that it is sound with respect to these semantics. Collectively, these contributions show that this construct offers a principled and practical step toward more abstract and structured quantum programming.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.11676v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Chris Heunen, Louis Lemonnier, Christopher McNally, Alex Rice</dc:creator>
    </item>
    <item>
      <title>Coinductive Streams in Monoidal Categories</title>
      <link>https://arxiv.org/abs/2212.14494</link>
      <description>arXiv:2212.14494v4 Announce Type: replace 
Abstract: We introduce monoidal streams. Monoidal streams are a generalization of causal stream functions, which can be defined in cartesian monoidal categories, to arbitrary symmetric monoidal categories. In the same way that streams provide semantics to dataflow programming with pure functions, monoidal streams provide semantics to dataflow programming with theories of processes represented by a symmetric monoidal category. Monoidal streams also form a feedback monoidal category. In the same way that we can use a coinductive stream calculus to reason about signal flow graphs, we can use coinductive string diagrams to reason about feedback monoidal categories. As an example, we study syntax for a stochastic dataflow language, with semantics in stochastic monoidal streams.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.14494v4</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Elena Di Lavore, Giovanni de Felice, Mario Rom\'an</dc:creator>
    </item>
    <item>
      <title>Scott's Representation Theorem and the Univalent Karoubi Envelope</title>
      <link>https://arxiv.org/abs/2506.22196</link>
      <description>arXiv:2506.22196v2 Announce Type: replace 
Abstract: Lambek and Scott constructed a correspondence between simply-typed lambda calculi and Cartesian closed categories. Scott's Representation Theorem is a cousin to this result for untyped lambda calculi. It states that every untyped lambda calculus arises from a reflexive object in some category. We present a formalization of Scott's Representation Theorem in univalent foundations, in the (Rocq-)UniMath library. Specifically, we implement two proofs of that theorem, one by Scott and one by Hyland. We also explain the role of the Karoubi envelope -- a categorical construction -- in the proofs and the impact the chosen foundation has on this construction. Finally, we report on some automation we have implemented for the reduction of $\lambda$-terms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.22196v2</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Arnoud van der Leer, Kobe Wullaert, Benedikt Ahrens</dc:creator>
    </item>
    <item>
      <title>Duality theory in linear optimization and its extensions -- formally verified</title>
      <link>https://arxiv.org/abs/2409.08119</link>
      <description>arXiv:2409.08119v2 Announce Type: replace-cross 
Abstract: Farkas established that a system of linear inequalities has a solution if and only if we cannot obtain a contradiction by taking a linear combination of the inequalities. We state and formally prove several Farkas-like theorems over linearly ordered fields in Lean 4. Furthermore, we extend duality theory to the case when some coefficients are allowed to take ``infinite values''.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.08119v2</guid>
      <category>math.OC</category>
      <category>cs.LO</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Martin Dvorak, Vladimir Kolmogorov</dc:creator>
    </item>
    <item>
      <title>A Practical Quantum Hoare Logic with Classical Variables, I</title>
      <link>https://arxiv.org/abs/2412.09869</link>
      <description>arXiv:2412.09869v2 Announce Type: replace-cross 
Abstract: In this paper, we present a Hoare-style logic for reasoning about quantum programs with classical variables. Our approach offers several improvements over previous work:
  (1) Enhanced expressivity of the programming language: Our logic applies to quantum programs with classical variables that incorporate quantum arrays and parameterised quantum gates, which have not been addressed in previous research on quantum Hoare logic, either with or without classical variables.
  (2) Intuitive correctness specifications: In our logic, preconditions and postconditions for quantum programs with classical variables are specified as a pair consisting of a classical first-order logical formula and a quantum predicate formula (possibly parameterised by classical variables). These specifications offer greater clarity and align more closely with the programmer's intuitive understanding of quantum and classical interactions.
  (3) Simplified proof system: By introducing a novel idea in formulating a proof rule for reasoning about quantum measurements, along with (2), we develop a proof system for quantum programs that requires only minimal modifications to classical Hoare logic. Furthermore, this proof system can be effectively and conveniently combined with classical first-order logic to verify quantum programs with classical variables.
  As a result, the learning curve for quantum program verification techniques is significantly reduced for those already familiar with classical program verification techniques, and existing tools for verifying classical programs can be more easily adapted for quantum program verification.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.09869v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Mingsheng Ying</dc:creator>
    </item>
    <item>
      <title>Dependent Multiplicities in Dependent Linear Type Theory</title>
      <link>https://arxiv.org/abs/2507.08759</link>
      <description>arXiv:2507.08759v2 Announce Type: replace-cross 
Abstract: We present a novel dependent linear type theory in which the multiplicity of some variable - i.e., the number of times the variable can be used in a program - can depend on other variables. This allows us to give precise resource annotations to many higher-order functions that cannot be adequately typed in any other system. Inspired by the Dialectica translation, our typing discipline is obtained by embedding linear logic into dependent type theory and specifying how the embedded logic interacts with the host theory. We can then use a standard natural numbers type to obtain a quantitative typing system with dependent multiplicities. We characterise the semantics for our theory as a combination of standard models of dependent type theory and linear logic. Our system can be added to any dependently typed language, which we demonstrate with an implementation in Agda.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.08759v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 17 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Maximilian Dor\'e</dc:creator>
    </item>
  </channel>
</rss>
