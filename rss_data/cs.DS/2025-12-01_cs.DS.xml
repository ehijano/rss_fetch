<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Dec 2025 03:43:36 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>A Combinatorial Characterization of Constant Mixing Time</title>
      <link>https://arxiv.org/abs/2511.21868</link>
      <description>arXiv:2511.21868v2 Announce Type: new 
Abstract: Classical spectral graph theory characterizes graphs with logarithmic mixing time. In this work, we present a combinatorial characterization of graphs with constant mixing time. The combinatorial characterization is based on the small-set bipartite density condition, which is weaker than having near-optimal spectral radius and is stronger than having near-optimal small-set vertex expansion.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.21868v2</guid>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Lap Chi Lau, Raymond Liu</dc:creator>
    </item>
    <item>
      <title>Differential privacy from axioms</title>
      <link>https://arxiv.org/abs/2511.21876</link>
      <description>arXiv:2511.21876v1 Announce Type: new 
Abstract: Differential privacy (DP) is the de facto notion of privacy both in theory and in practice. However, despite its popularity, DP imposes strict requirements which guard against strong worst-case scenarios. For example, it guards against seemingly unrealistic scenarios where an attacker has full information about all but one point in the data set, and still nothing can be learned about the remaining point. While preventing such a strong attack is desirable, many works have explored whether average-case relaxations of DP are easier to satisfy [HWR13,WLF16,BF16,LWX23].
  In this work, we are motivated by the question of whether alternate, weaker notions of privacy are possible: can a weakened privacy notion still guarantee some basic level of privacy, and on the other hand, achieve privacy more efficiently and/or for a substantially broader set of tasks? Our main result shows the answer is no: even in the statistical setting, any reasonable measure of privacy satisfying nontrivial composition is equivalent to DP. To prove this, we identify a core set of four axioms or desiderata: pre-processing invariance, prohibition of blatant non-privacy, strong composition, and linear scalability. Our main theorem shows that any privacy measure satisfying our axioms is equivalent to DP, up to polynomial factors in sample complexity. We complement this result by showing our axioms are minimal: removing any one of our axioms enables ill-behaved measures of privacy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.21876v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guy Blanc, William Pires, Toniann Pitassi</dc:creator>
    </item>
    <item>
      <title>Identifying all snarls and superbubbles in linear-time, via a unified SPQR-tree framework</title>
      <link>https://arxiv.org/abs/2511.21919</link>
      <description>arXiv:2511.21919v1 Announce Type: new 
Abstract: Snarls and superbubbles are fundamental pangenome decompositions capturing variant sites. These bubble-like structures underpin key tasks in computational pangenomics, including structural-variant genotyping, distance indexing, haplotype sampling, and variant annotation. Snarls can be quadratically-many in the size of the graph, and since their introduction in 2018 with the vg toolkit, there has been no work on identifying all snarls in linear time. Moreover, while it is known how to find superbubbles in linear time, this result is a highly specialized solution only achieved after a long series of papers.
  We present the first algorithm identifying all snarls in linear time. This is based on a new representation of all snarls, of size linear in the input graph size, and which can be computed in linear time. Our algorithm is based on a unified framework that also provides a new linear-time algorithm for finding superbubbles. An observation behind our results is that all such structures are separated from the rest of the graph by two vertices (except for cases which are trivially computable), i.e. their endpoints are a 2-separator of the underlying undirected graph. Based on this, we employ the well-known SPQR tree decomposition, which encodes all 2-separators, to guide a traversal that finds the bubble-like structures efficiently.
  We implemented our algorithms in C++ (available at https://github.com/algbio/BubbleFinder) and evaluated them on various pangenomic datasets. Our algorithms outcompete or they are on the same level of existing methods. For snarls, we are up to two times faster than vg, while identifying all snarls. When computing superbubbles, we are up to 50 times faster than BubbleGun. Our SPQR tree framework provides a unifying perspective on bubble-like structures in pangenomics, together with a template for finding other bubble-like structures efficiently.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.21919v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>q-bio.QM</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Francisco Sena, Aleksandr Politov, Corentin Moumard, Manuel C\'aceres, Sebastian Schmidt, Juha Harviainen, Alexandru I. Tomescu</dc:creator>
    </item>
    <item>
      <title>MagnifierSketch: Quantile Estimation Centered at One Point</title>
      <link>https://arxiv.org/abs/2511.22070</link>
      <description>arXiv:2511.22070v1 Announce Type: new 
Abstract: In this paper, we take into consideration quantile estimation in data stream models, where every item in the data stream is a key-value pair. Researchers sometimes aim to estimate per-key quantiles (i.e. quantile estimation for every distinct key), and some popular use cases, such as tail latency measurement, recline on a predefined single quantile (e.g. 0.95- or 0.99- quantile) rather than demanding arbitrary quantile estimation. However, existing algorithms are not specially designed for per-key estimation centered at one point. They cannot achieve high accuracy in our problem setting, and their throughput are not satisfactory to handle high-speed items in data streams. To solve this problem, we propose MagnifierSketch for point-quantile estimation. MagnifierSketch supports both single-key and per-key quantile estimation, and its key techniques are named Value Focus, Distribution Calibration and Double Filtration. We provide strict mathematical derivations to prove the unbiasedness of MagnifierSketch and show its space and time complexity. Our experimental results show that the Average Error (AE) of MagnifierSketch is significantly lower than the state-of-the-art in both single-key and per-key situations. We also implement MagnifierSketch on RocksDB database to reduce quantile query latency in real databases. All related codes of MagnifierSketch are open-sourced and available at GitHub.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22070v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jiarui Guo, Qiushi Lyu, Yuhan Wu, Haoyu Li, Zhaoqian Yao, Yuqi Dong, Xiaolin Wang, Bin Cui, Tong Yang</dc:creator>
    </item>
    <item>
      <title>How fast are algorithms reducing the demands on memory? A survey of progress in space complexity</title>
      <link>https://arxiv.org/abs/2511.22084</link>
      <description>arXiv:2511.22084v1 Announce Type: new 
Abstract: Algorithm research focuses primarily on how many operations processors need to do (time complexity). But for many problems, both the runtime and energy used are dominated by memory accesses. In this paper, we present the first broad survey of how algorithmic progress has improved memory usage (space complexity). We analyze 118 of the most important algorithm problems in computer science, reviewing the 800+ algorithms used to solve them.
  Our results show that space complexity has become much more important in recent years as worries have arisen about memory access bottle-necking performance (the ``memory wall''). In 20% of cases we find that space complexity improvements for large problems (n=1 billion) outpaced improvements in DRAM access speed, suggesting that for these problems algorithmic progress played a larger role than hardware progress in minimizing memory access delays. Increasingly, we also see the emergence of algorithmic Pareto frontiers, where getting better asymptotic time complexity for a problem requires getting worse asymptotic space complexity, and vice-versa. This tension implies that programmers will increasingly need to consider multiple algorithmic options to understand which is best for their particular problem. To help theorists and practitioners alike consider these trade-offs, we have created a reference for them at https://algorithm-wiki.csail.mit.edu.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22084v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hayden Rome, Jayson Lynch, Jeffery Li, Chirag Falor, Neil Thompson</dc:creator>
    </item>
    <item>
      <title>Balancing Two-Dimensional Straight-Line Programs</title>
      <link>https://arxiv.org/abs/2511.22212</link>
      <description>arXiv:2511.22212v1 Announce Type: new 
Abstract: We consider building, given a straight-line program (SLP) consisting of $g$ productions deriving a two-dimensional string $T$ of size $N\times N$, a structure capable of providing random access to any character of $T$. For one-dimensional strings, it is now known how to build a structure of size $\mathcal{O}(g)$ that provides random access in $\mathcal{O}(\log N)$ time. In fact, it is known that this can be obtained by building an equivalent SLP of size $\mathcal{O}(g)$ and depth $\mathcal{O}(\log N)$ [Ganardi, Je\.z, Lohrey, JACM 2021]. We consider the analogous question for two-dimensional strings: can we build an equivalent SLP of roughly the same size and small depth?
  We show that the answer is negative: there exists an infinite family of two-dimensional strings of size $N\times N$ described by a 2D SLP of size $g$ such that any 2D SLP describing the same string of depth $\mathcal{O}(\log N)$ must be of size $\Omega(g\cdot N/\log^{3}N)$. We complement this with an upper bound showing how to construct such a 2D SLP of size $\mathcal{O}(g\cdot N)$. Next, we observe that one can naturally define a generalization of 2D SLP, which we call 2D SLP with holes. We show that a known general balancing theorem by [Ganardi, Je\.z, Lohrey, JACM 2021] immediately implies that, given a 2D SLP of size $g$ deriving a string of size $N\times N$, we can construct a 2D SLP with holes of depth $\mathcal{O}(\log N)$ and size $\mathcal{O}(g)$. This allows us to conclude that there is a structure of size $\mathcal{O}(g)$ providing random access in $\mathcal{O}(\log N)$ time for such a 2D SLP. Further, this can be extended (analogously as for a 1D SLP) to obtain a structure of size $\mathcal{O}(g \log^{\epsilon}N)$ providing random access in $\mathcal{O}(\log N/\log \log N)$ time, for any $\epsilon &gt;0$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22212v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Itai Boneh, Est\'eban Gabory, Pawe{\l} Gawrychowski, Adam G\'orkiewicz</dc:creator>
    </item>
    <item>
      <title>Efficient Trace Frequency Queries in Sparse Graphs</title>
      <link>https://arxiv.org/abs/2511.22289</link>
      <description>arXiv:2511.22289v1 Announce Type: new 
Abstract: Understanding how a vertex relates to a set of vertices is a fundamental task in graph analysis. Given a graph $G$ and a vertex set $X \subseteq V(G)$, consider the collection of subsets of the form $N(u) \cap X$ where $u$ ranges over all vertices outside $X$. These intersections, which we call the traces of $X$, capture all ways vertices in $G$ connect to $X$, and in this paper we consider the problem of listing these traces efficiently, and the related problem of recording the multiplicity (frequency) of each trace. For a given query set $X$, both problems have obvious algorithms with running time $O(|N(X)| \cdot |X|)$ and conditional lower bounds suggest that, on general graphs, one cannot expect better. However, in certain sparse graph classes, more efficient algorithms are possible: Drange \etal (IPEC 2023) used a data structure that answers trace queries in $d$-degenerate graphs with linear initialisation time and query time that only depends on the query set $X$ and $d$. However, the query time is exponential in $|X|$, which makes this approach impractical. By using a stronger parameter than degeneracy, namely the strong $2$-colouring number $s_2$, we construct a data structure in $O(d \cdot \|G\|)$ time, which answers subsequent trace frequency queries in time $O\big((d^2 + s_2^{d+2})|X|\big)$, where $\|G\|$ is the number of edges of $G$, $s_2$ is the strong $2$-colouring number and $d$ the degeneracy of a suitable ordering of $G$. We demonstrate that this data structure is indeed practical and that it beats the simple, obvious alternative in almost all tested settings, using a collection of 217 real-world networks with up to 1.1M edges. As part of this effort, we demonstrate that computing an ordering with a small strong $2$-colouring number is feasible with a simple heuristic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22289v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Christine Awofeso, P\r{a}l Gr{\o}n\r{a}s Drange, Patrick Greaves, Oded Lachish, Felix Reidl</dc:creator>
    </item>
    <item>
      <title>Improved exploration of temporal graphs</title>
      <link>https://arxiv.org/abs/2511.22604</link>
      <description>arXiv:2511.22604v1 Announce Type: new 
Abstract: A temporal graph $G$ is a sequence $(G_t)_{t \in I}$ of graphs on the same vertex set of size $n$. The \emph{temporal exploration problem} asks for the length of the shortest sequence of vertices that starts at a given vertex, visits every vertex, and at each time step $t$ either stays at the current vertex or moves to an adjacent vertex in $G_t$. Bounds on the length of a shortest temporal exploration have been investigated extensively. Perhaps the most fundamental case is when each graph $G_t$ is connected and has bounded maximum degree. In this setting, Erlebach, Kammer, Luo, Sajenko, and Spooner [ICALP 2019] showed that there exists an exploration of $G$ in $\mathcal{O}(n^{7/4})$ time steps. We significantly improve this bound by showing that $\mathcal{O}(n^{3/2} \sqrt{\log n})$ time steps suffice.
  In fact, we deduce this result from a much more general statement. Let the \emph{average temporal maximum degree} $D$ of $G$ be the average of $\max_{t \in I} d_{G_t}(v)$ over all vertices $v \in V(G)$, where $d_{G_t}(v)$ denotes the degree of $v$ in $G_t$. If each graph $G_t$ is connected, we show that there exists an exploration of $G$ in $\mathcal{O}(n^{3/2} \sqrt{D \log n})$ time steps. In particular, this gives the first subquadratic upper bound when the underlying graph has bounded average degree. As a special case, this also improves the previous best bounds when the underlying graph is planar or has bounded treewidth and provides a unified approach for all of these settings. Our bound is subquadratic already when $D=o(n/\log n)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22604v1</guid>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Paul Bastide, Carla Groenland, Lukas Michel, Cl\'ement Rambaud</dc:creator>
    </item>
    <item>
      <title>Sublinear Edge Fault Tolerant Spanners for Hypergraphs</title>
      <link>https://arxiv.org/abs/2511.22803</link>
      <description>arXiv:2511.22803v1 Announce Type: new 
Abstract: We initiate the study on fault-tolerant spanners in hypergraphs and develop fast algorithms for their constructions. A fault-tolerant (FT) spanner preserves approximate distances under network failures, often used in applications like network design and distributed systems. While classic (fault-free) spanners are believed to be easily extended to hypergraphs such as by the method of associated graphs, we reveal that this is not the case in the fault-tolerant setting: simple methods can only get a linear size in the maximum number of faults $f$. In contrast, all known optimal size of FT spanners are sublinear in $f$. Inspired by the FT clustering technique, we propose a clustering based algorithm that achieves an improved sublinear size bound. For an $n$-node $m$-edge hypergraph with rank $r$ and a sketch parameter $k$, our algorithm constructs edge FT (EFT) hyperspanners of stretch $2k-1$ and size $O(k^2f^{1-1/(rk)}n^{1+1/k}\log n)$ with high probability in time $\widetilde{O}(mr^3+fn)$. We also establish a lower bound of $\Omega(f^{1-1/r-1/rk}n^{1+1/k-o(1)})$ edges for EFT hyperspanners, which leaves a gap of poly$(k)f^{1/r}$. Finally, we provide an algorithm for constructing additive EFT hyperspanners by combining multiplicative EFT hyperspanners with additive hyperspanners. We believe that our work will spark interest in developing optimal FT spanners for hypergraphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22803v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jialin He, Nicholas Popescu, Chunjiang Zhu</dc:creator>
    </item>
    <item>
      <title>Spanning Trees with a Small Vertex Cover: the Complexity on Specific Graph Classes</title>
      <link>https://arxiv.org/abs/2511.22912</link>
      <description>arXiv:2511.22912v1 Announce Type: new 
Abstract: In the context of algorithm theory, various studies have been conducted on spanning trees with desirable properties. In this paper, we consider the \textsc{Minimum Cover Spanning Tree} problem (MCST for short). Given a graph $G$ and a positive integer $k$, the problem determines whether $G$ has a spanning tree with a vertex cover of size at most $k$. We reveal the equivalence between \mcst\ and the \textsc{Dominating Set} problem when $G$ is of diameter at most~$2$ or $P_5$-free. This provides the intractability for these graphs and the tractability for several subclasses of $P_5$-free graphs. We also show that \mcst\ is NP-complete for bipartite planar graphs of maximum degree~$4$ and unit disk graphs. These hardness results resolve open questions posed in prior research. Finally, we present an FPT algorithm for {\mcst} parameterized by clique-width and a linear-time algorithm for interval graphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22912v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Toranosuke Kokai, Akira Suzuki, Takahiro Suzuki, Yuma Tamura, Xiao Zhou</dc:creator>
    </item>
    <item>
      <title>Towards an algebraic approach to the reconfiguration CSP</title>
      <link>https://arxiv.org/abs/2511.22914</link>
      <description>arXiv:2511.22914v1 Announce Type: new 
Abstract: This paper investigates the reconfiguration variant of the Constraint Satisfaction Problem (CSP), referred to as the Reconfiguration CSP (RCSP). Given a CSP instance and two of its solutions, RCSP asks whether one solution can be transformed into the other via a sequence of intermediate solutions, each differing by the assignment of a single variable. RCSP has attracted growing interest in theoretical computer science, and when the variable domain is Boolean, the computational complexity of RCSP exhibits a dichotomy depending on the allowed constraint types. A notable special case is the reconfiguration of graph homomorphisms -- also known as graph recoloring -- which has been studied using topological methods. We propose a novel algebraic approach to RCSP, inspired by techniques used in classical CSP complexity analysis. Unlike traditional methods based on total operations, our framework employs partial operations to capture a reduction involving equality constraints. This perspective facilitates the extension of complexity results from Boolean domains to more general settings, demonstrating the versatility of partial operations in identifying tractable RCSP instances.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22914v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Kei Kimura</dc:creator>
    </item>
    <item>
      <title>Solution Discovery for Vertex Cover, Independent Set, Dominating Set, and Feedback Vertex Set</title>
      <link>https://arxiv.org/abs/2511.23012</link>
      <description>arXiv:2511.23012v1 Announce Type: new 
Abstract: In the solution discovery problem for a search problem on graphs, we are given an initial placement of $k$ tokens on the vertices of a graph and asked whether this placement can be transformed into a feasible solution by applying a small number of modifications. In this paper, we study the computational complexity of solution discovery for several fundamental vertex-subset problems on graphs, namely Vertex Cover Discovery, Independent Set Discovery, Dominating Set Discovery, and Feedback Vertex Set Discovery. We first present XP algorithms for all four problems parameterized by clique-width. We then prove that Vertex Cover Discovery, Independent Set Discovery, and Feedback Vertex Set Discovery are NP-complete for chordal graphs and graphs of diameter 2, which have unbounded clique-width. In contrast to these hardness results, we show that all three problems can be solved in polynomial time on split graphs. Furthermore, we design an FPT algorithm for Feedback Vertex Set Discovery parameterized by the number of tokens.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.23012v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Rin Saito, Anouk Sommer, Tatsuhiro Suga, Takahiro Suzuki, Yuma Tamura</dc:creator>
    </item>
    <item>
      <title>Improved and Parameterized Algorithms for Online Multi-level Aggregation: A Memory-based Approach</title>
      <link>https://arxiv.org/abs/2511.23211</link>
      <description>arXiv:2511.23211v1 Announce Type: new 
Abstract: We study the online multi-level aggregation problem with deadlines (MLAP-D) introduced by Bienkowski et al. (ESA 2016, OR 2020). In this problem, requests arrive over time at the vertices of a given vertex-weighted tree, and each request has a deadline that it must be served by. The cost of serving a request equals the cost of a path from the root to the vertex where the request resides. Instead of serving each request individually, requests can be aggregated and served by transmitting a subtree from the root that spans the vertices on which the requests reside, to potentially be more cost-effective. The aggregated cost is the weight of the transmission subtree. The goal of MLAP-D is to find an aggregation solution that minimizes the total cost while serving all requests.
  We present improved and parameterized algorithms for MLAP-D. Our result is twofold. First, we present an $e(D+1)$-competitive algorithm where $D$ is the depth of the tree. Second, we present an $e(4H+2)$-competitive algorithm where $H$ is the caterpillar dimension of the tree. Here, $H \le D$ and $H \le \log_2 |V|$ where $|V|$ is the number of vertices in the given tree. The caterpillar dimension remains constant for rich but simple classes of trees, such as line graphs ($H=1$), caterpillar graphs ($H=2$), and lobster graphs ($H=3$). To the best of our knowledge, this is the first online algorithm parameterized on a measure better than depth. The state-of-the-art online algorithms are $6(D+1)$-competitive by Buchbinder, Feldman, Naor, and Talmon (SODA 2017) and $O(\log |V|)$-competitive by Azar and Touitou (FOCS 2020). Our framework outperforms the state-of-the-art ratios when $H = o(\min\{D,\log_2 |V|\})$. Our simple framework directly applies to trees with any structure and differs from the previous frameworks that reduce the problem to trees with specific structures.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.23211v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander Turoczy, Young-San Lin</dc:creator>
    </item>
    <item>
      <title>Homomorphism Testing with Resilience to Online Manipulations</title>
      <link>https://arxiv.org/abs/2511.23363</link>
      <description>arXiv:2511.23363v1 Announce Type: new 
Abstract: A central challenge in property testing is verifying algebraic structure with minimal access to data. A landmark result addressing this challenge, the linearity test of Blum, Luby, and Rubinfeld (JCSS `93), spurred a rich body of work on testing algebraic properties such as linearity and its generalizations to low-degree polynomials and group homomorphisms. However, classical tests for these properties assume unrestricted, noise-free access to the input function--an assumption that breaks down in adversarial or dynamic settings. To address this, Kalemaj, Raskhodnikova, and Varma (Theory of Computing `23) introduced the online manipulation model, where an adversary may erase or corrupt query responses over time, based on the tester's past queries.
  We initiate the study of {manipulation-resilient} testing for {group homomorphism} in this online model. Our main result is an {optimal} tester that makes $O(1/\varepsilon+\log t)$ queries, where $\varepsilon$ is the distance parameter and $t$ is the number of function values the adversary can erase or corrupt per query. Our result recovers the celebrated $O(1/\varepsilon)$ bound by Ben-Or, Coppersmith, Luby, and Rubinfeld (Random Struct.\ Algorithms `08) for homomorphism testing in the standard property testing model, albeit with a different tester. Our tester, $\mathsf{Random\ Signs\ Test}$, {lifts} known manipulation-resilient linearity testers for $\mathbb{F}_2^n\to \mathbb{F}_2$ to general group domains and codomains by introducing more randomness: instead of verifying the homomorphism condition for a sum of random elements, it uses additions and subtractions of random elements, randomly selecting a sign for each element. We also obtain improved group-specific query bounds for key families of groups.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.23363v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Esty Kelman, Uri Meir, Debanuj Nayak, Sofya Raskhodnikova</dc:creator>
    </item>
    <item>
      <title>Accuracy and resource advantages of quantum eigenvalue estimation with non-Hermitian transcorrelated electronic Hamiltonians</title>
      <link>https://arxiv.org/abs/2511.21867</link>
      <description>arXiv:2511.21867v1 Announce Type: cross 
Abstract: In electronic structure calculations, the transcorrelated method enables a reduction of the basis set size by incorporating the electron-electron correlations directly into the Hamiltonian. However, the transcorrelated Hamiltonian is non-Hermitian, which makes many common quantum algorithms inapplicable. Recently, a quantum eigenvalue estimation algorithm was proposed for non-Hermitian Hamiltonians with real spectra [FOCS 65, 1051 (2024)]. Here we investigate the cost of this algorithm applied to transcorrelated electronic Hamiltonians of second-row atoms and compare it to the cost of applying standard qubitization to non-transcorrelated Hamiltonians. We find that the ground state energy of the transcorrelated Hamiltonian in the STO-6G basis is more accurate than that of a standard Hamiltonian in the cc-pVQZ basis. The T gate counts of the two methods are comparable, while the qubit count of the transcorrelated method is 2.5 times smaller.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.21867v1</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <category>physics.chem-ph</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Alexey Uvarov, Artur F. Izmaylov</dc:creator>
    </item>
    <item>
      <title>Making an oriented graph acyclic using inversions of bounded or prescribed size</title>
      <link>https://arxiv.org/abs/2511.22562</link>
      <description>arXiv:2511.22562v1 Announce Type: cross 
Abstract: Given an oriented graph $D$, the inversion of a subset $X$ of vertices consists in reversing the orientation of all arcs with both endpoints in $X$. When the subset $X$ is of size $p$ (resp. at most $p$), this operation is called an $(=p)$-inversion (resp. $(\leq p)$-inversion). Then, an oriented graph is $(=p)$-invertible if it can be made acyclic by a sequence of $p$-inversions. We observe that, for $n=|V(D)|$, deciding whether $D$ is $(=n-1)$-invertible is equivalent to deciding whether $D$ is acyclically pushable, and thus NP-complete. In all other cases, when $p \neq n-1$, we construct a polynomial-time algorithm to decide $(=p)$-invertibility.
  We then consider the $(= p)$-inversion number, $\text{inv}^{= p}(D)$ (resp. $(\leq p)$-inversion number, $\text{inv}^{\leq p}(D)$), defined as the minimum number of $(=p)$-inversions (resp. $(\leq p)$-inversions) rendering $D$ acyclic. We show that every $(=p)$-invertible digraph $D$ satisfies $\text{inv}^{= p}(D) \leq |A(D)|$ for every integer $p\geq 2$. When $p$ is even, we bound $\text{inv}^{= p}$ by a (linear) function of the feedback arc set number, and rule out the existence of any bounding function for odd $p$.
  Finally, we study the complexity of deciding whether the $(= p)$-inversion number, or the $(\leq p)$-inversion number, of a given oriented graph is at most a given integer $k$. For any fixed positive integer $p \geq 2$, when $k$ is part of the input, we show that both problems are NP-hard even in tournaments. In general oriented graphs, we prove $W[1]$-hardness for both problems when parameterized by $p$, even for $k=1$. In contrast, we exhibit polynomial kernels in $p + k$ for both problems in tournaments.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.22562v1</guid>
      <category>math.CO</category>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>J{\o}rgen Bang-Jensen, Fr\'ed\'eric Havet, Florian H\"orsch, Cl\'ement Rambaud, Amadeus Reinald, Caroline Silva</dc:creator>
    </item>
    <item>
      <title>Efficient Identification of Permutation Symmetries in Many-Body Hamiltonians via Graph Theory</title>
      <link>https://arxiv.org/abs/2511.23160</link>
      <description>arXiv:2511.23160v1 Announce Type: cross 
Abstract: The computational cost of simulating quantum many-body systems can often be reduced by taking advantage of physical symmetries. While methods exist for specific symmetry classes, a general algorithm to find the full permutation symmetry group of an arbitrary Pauli Hamiltonian is notably lacking. This paper introduces a new method that identifies this symmetry group by establishing an isomorphism between the Hamiltonian's permutation symmetry group and the automorphism group of a coloured bipartite graph constructed from the Hamiltonian. We formally prove this isomorphism and show that for physical Hamiltonians with bounded locality and interaction degree, the resulting graph has a bounded degree, reducing the computational problem of finding the automorphism group to polynomial time. The algorithm's validity is empirically confirmed on various physical models with known symmetries. We further show that the problem of deciding whether two Hamiltonians are permutation-equivalent is polynomial-time reducible to the graph isomorphism problem using our graph representation. This work provides a general, structurally exact tool for algorithmic symmetry finding, enabling the scalable application of these symmetries to Hamiltonian simulation problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.23160v1</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Saumya Shah, Patrick Rebentrost</dc:creator>
    </item>
    <item>
      <title>Learning-Augmented Online Bipartite Matching in the Random Arrival Order Model</title>
      <link>https://arxiv.org/abs/2511.23388</link>
      <description>arXiv:2511.23388v1 Announce Type: cross 
Abstract: We study the online unweighted bipartite matching problem in the random arrival order model, with $n$ offline and $n$ online vertices, in the learning-augmented setting: The algorithm is provided with untrusted predictions of the types (neighborhoods) of the online vertices. We build upon the work of Choo et al. (ICML 2024, pp. 8762-8781) who proposed an approach that uses a prefix of the arrival sequence as a sample to determine whether the predictions are close to the true arrival sequence and then either follows the predictions or uses a known baseline algorithm that ignores the predictions and is $\beta$-competitive. Their analysis is limited to the case that the optimal matching has size $n$, i.e., every online vertex can be matched. We generalize their approach and analysis by removing any assumptions on the size of the optimal matching while only requiring that the size of the predicted matching is at least $\alpha n$ for any constant $0 &lt; \alpha \le 1$. Our learning-augmented algorithm achieves $(1-o(1))$-consistency and $(\beta-o(1))$-robustness. Additionally, we show that the competitive ratio degrades smoothly between consistency and robustness with increasing prediction error.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.23388v1</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Kunanon Burathep, Thomas Erlebach, William K. Moses Jr</dc:creator>
    </item>
    <item>
      <title>Dynamic programming on bipartite tree decompositions</title>
      <link>https://arxiv.org/abs/2309.07754</link>
      <description>arXiv:2309.07754v2 Announce Type: replace 
Abstract: We revisit a graph width parameter that we dub bipartite treewidth (btw). Bipartite treewidth can be seen as a common generalization of treewidth and the odd cycle transversal number, and is closely related to odd-minors. Intuitively, a bipartite tree decomposition is a tree decomposition whose bags induce almost bipartite graphs and whose adhesions contain at most one "bipartite" vertex, while the width of such decomposition measures the number of "non-bipartite" vertices in a bag. We provide para-NP-completeness results and develop dynamic programming techniques to solve problems on graphs of small btw. In particular, we show that $K_t$-Subgraph-Cover, Weighted Independent Set, Odd Cycle Transversal, and Maximum Weighted Cut are $FPT$ parameterized by btw. We also provide the following dichotomy when $H$ is a 2-connected graph: if $H$ is bipartite, then $H$-Subgraph/Induced-Subgraph/Odd-Minor/Scattered-Packing is para-NP-complete parameterized by btw while, if $H$ is non-bipartite, then the problem is solvable in XP-time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.07754v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Lars Jaffke, Laure Morelle, Ignasi Sau, Dimitrios M. Thilikos</dc:creator>
    </item>
    <item>
      <title>Width Parameters for Minimum Flow Decomposition</title>
      <link>https://arxiv.org/abs/2409.20278</link>
      <description>arXiv:2409.20278v2 Announce Type: replace 
Abstract: Minimum flow decomposition (MFD) is the strongly NP-hard problem of finding a smallest set of integer weighted $s$-$t$ paths in an $s$-$t$ DAG $G$ whose weighted sum is equal to a given flow $f$ on $G$. Despite its many practical applications, we lack an understanding of graph structures that make MFD easy or hard. Recent progress is due to C\'aceres et al. [ACM TALG 2024], who showed that the DAG width, the minimum number of paths to cover all edges, plays an essential role in the approximation of the problem.
  Our first set of results regard the computational complexity of MFD parameterised by the width. This question was previously open, because MFD on width-1 DAGs (paths) is trivially solvable, and the existing NP-hardness proofs use DAGs of unbounded width. We show that MFD on width-2 DAGs is already NP-hard and that MFD on width-3 DAGs is strongly NP-hard.
  Our main contribution complements these hardness bounds, as we show that weak NP-hardness is the best we can hope for on width-2 DAGs. In fact, we prove the more general statement that MFD with unary coded input can be solved in quasi-polynomial time on DAGs of constant parallel-width, which includes width-2 DAGs. The parallel-width of a DAG $G$ (par-width$(G)$) was defined by Deligkas and Meir [MFCS 2017] as the size of the largest minimal $s$-$t$ cut-set. We obtain these results by, a) interpreting flow decompositions as a sequence of certain digraph minor operations defined by Deligkas and Meir [MFCS 2017], and b) defining a new notion of width of a flow network, flow-width of $(G,f)$, defined as the minimum number of paths covering all edges of $G$, where every edge $e$ can be covered by at most $f(e)$ paths. Using (a) and (b), we show as an intermediate result, an improved upper bound $(\lfloor\log \Vert f\Vert\rfloor+1) \cdot \text{par-width}(G)$ for MFD, where $\Vert f\Vert$ is the largest flow weight of all edges.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.20278v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andreas Grigorjew, Wanchote Jiamjitrak, Brendan Mumey, Alexandru I. Tomescu</dc:creator>
    </item>
    <item>
      <title>Asymptotically Optimal Representation of Palindromic Structure</title>
      <link>https://arxiv.org/abs/2410.09984</link>
      <description>arXiv:2410.09984v3 Announce Type: replace 
Abstract: We introduce an asymptotically optimal representation of the Manacher array of a string that supports constant-time access. The approach relies on the combinatorial properties of palindromes, yielding a compact yet efficient structure. This work fits within the broader study of compressed text indexing and highlights structural aspects of palindromic substrings that may inspire further algorithmic applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.09984v3</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Michael Itzhaki</dc:creator>
    </item>
    <item>
      <title>One-Shot Learning for k-SAT</title>
      <link>https://arxiv.org/abs/2502.07135</link>
      <description>arXiv:2502.07135v3 Announce Type: replace 
Abstract: Consider a $k$-SAT formula $\Phi$ where every variable appears at most $d$ times. Let $\sigma$ be a satisfying assignment, sampled proportionally to $e^{\beta m(\sigma)}$ where $m(\sigma)$ is the number of true variables and $\beta$ is a real parameter. Given $\Phi$ and $\sigma$, can we efficiently learn $\beta$?
  This problem falls into a recent line of work about single-sample (``one-shot'') learning of Markov random fields. Our $k$-SAT setting was recently studied by Galanis, Kalavasis, Kandiros (SODA24). They showed that single-sample learning is possible when roughly $d\leq 2^{k/6.45}$ and impossible when $d\geq (k+1) 2^{k-1}$. In addition to the gap in~$d$, their impossibility result left open the question of whether the feasibility threshold for one-shot learning is dictated by the satisfiability threshold for bounded-degree $k$-SAT formulas.
  Our main contribution is to answer this question negatively. We show that one-shot learning for $k$-SAT is infeasible well below the satisfiability threshold; in fact, we obtain impossibility results for degrees $d$ as low as $k^2$ when $\beta$ is sufficiently large, and bootstrap this to small values of $\beta$ when $d$ scales exponentially with $k$, via a probabilistic construction. On the positive side, we simplify the analysis of the learning algorithm, obtaining significantly stronger bounds on $d$ in terms of $\beta$. For the uniform case $\beta\rightarrow 0$, we show that learning is possible under the condition $d\lesssim 2^{k/2}$. This is (up to constant factors) all the way to the sampling threshold -- it is known that sampling a uniformly-distributed satisfying assignment is NP-hard for $d\gtrsim 2^{k/2}$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.07135v3</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <category>math.ST</category>
      <category>stat.ML</category>
      <category>stat.TH</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andreas Galanis, Leslie Ann Goldberg, Xusheng Zhang</dc:creator>
    </item>
    <item>
      <title>Maximizing the Margin between Desirable and Undesirable Elements in a Covering Problem</title>
      <link>https://arxiv.org/abs/2507.03817</link>
      <description>arXiv:2507.03817v2 Announce Type: replace 
Abstract: In many covering settings, it is natural to consider the presence both of elements that we seek to include and of elements that we seek to avoid. This paper introduces a novel combinatorial problem formalizing this tradeoff: from a collection of sets containing both "desirable" and "undesirable" items, pick the subcollection that maximizes the margin between the number of desirable and undesirable elements covered. We call this the Target Approximation Problem (TAP) and argue that many real-world scenarios are naturally modeled via this objective. We first show that TAP is hard, even when restricted to cases where the given sets are small or where elements appear in only a small number of sets. In a large swath of these cases, we show that TAP is hard even to approximate. We then exhibit exact polynomial-time algorithms for other restricted cases and provide an efficient 0.5-approximation for the case where elements occur at most twice, derived through a tight connection to the greedy algorithm for Unweighted Set Cover.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.03817v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sophie Boileau, Andrew Hong, David Liben-Nowell, Alistair Pattison, Anna N. Rafferty, Charlie Roslansky</dc:creator>
    </item>
    <item>
      <title>From Hop Reduction to Sparsification for Negative Length Shortest Paths</title>
      <link>https://arxiv.org/abs/2511.18253</link>
      <description>arXiv:2511.18253v2 Announce Type: replace 
Abstract: The textbook algorithm for real-weighted single-source shortest paths takes $O(mn)$ time on a graph with $m$ edges and $n$ vertices. A recent breakthrough algorithm by [Fin24] takes $\tilde{O}(mn^{8/9})$ randomized time. The running time was subsequently improved to $\tilde{O}(mn^{4/5})$ [HJQ25] and then $\tilde{O}(mn^{3/4}+m^{4/5}n)$ [HJQ26]. We build on the algorithms of [Fin24; HJQ25; HJQ26] to obtain faster strongly-polynomial randomized-time algorithms for negative-length shortest paths. An important new technique in this algorithm repurposes previous "hop-reducers" from [Fin24; HJQ26] into "negative edge sparsifiers", reducing the number of negative edges by essentially the same factor by which the "hops" were previously reduced. A simple recursive algorithm based on sparsifying the layered hop reducers of [Fin24] already gives an $\tilde{O}(mn^{\sqrt{3}-1})&lt;O(mn^{.7321})$ randomized running time, improving [HJQ26] uniformly. We also improve the construction of the bootstrapped hop reducers in [HJQ26] by proposing new sparse shortcut graphs replacing the dense shortcut graphs in [HJQ26]. Integrating all three of layered sparsification, recursion, and sparse bootstrapping into the algorithm of [HJQ26] gives new upper bounds of $O(mn^{.7193})$ randomized time for $m\geq n^{1.03456}$ and $O((mn)^{.8620})$ randomized time for $m&lt;n^{1.03456}$. Lastly, concurrent work by [LLRZ25] obtained an $\tilde{O}(n^{2.5})$ randomized time algorithm for the same problem, and along the way improved the running time of the "betweenness reduction" step in Fineman's framework. Dropping in this subroutine as a black box improves the running time of the simple recursive sparsification algorithm to $\tilde{O}(mn^{1/\sqrt{2}})&lt;O(mn^{.70711})$, and a slightly modified recursive sparsification algorithm runs in $O(mn^{.69562})$ randomized time for $m\geq n^{1.0274}$ and $O((mn)^{.85})$ for $m&lt;n^{1.0274}$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.18253v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Kent Quanrud, Navid Tajkhorshid</dc:creator>
    </item>
    <item>
      <title>Fast multiplication by two's complement addition of numbers represented as a set of polynomial radix 2 indexes, stored as an integer list for massively parallel computation</title>
      <link>https://arxiv.org/abs/2311.09922</link>
      <description>arXiv:2311.09922v4 Announce Type: replace-cross 
Abstract: We demonstrate a multiplication method based on numbers represented as set of polynomial radix 2 indices stored as an integer list. The 'polynomial integer index multiplication' method is a set of algorithms implemented in python code. We demonstrate the method to be faster than both the Number Theoretic Transform (NTT) and Karatsuba for multiplication within a certain bit range. Also implemented in python code for comparison purposes with the polynomial radix 2 integer method. We demonstrate that it is possible to express any integer or real number as a list of integer indices, representing a finite series in base two. The finite series of integer index representation of a number can then be stored and distributed across multiple CPUs / GPUs. We show that operations of addition and multiplication can be applied as two's complement additions operating on the index integer representations and can be fully distributed across a given CPU / GPU architecture. We demonstrate fully distributed arithmetic operations such that the 'polynomial integer index multiplication' method overcomes the current limitation of parallel multiplication methods. Ie, the need to share common core memory and common disk for the calculation of results and intermediate results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.09922v4</guid>
      <category>cs.MS</category>
      <category>cs.DC</category>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mark Stocks</dc:creator>
    </item>
    <item>
      <title>Optimal Information Design in Sender-Receiver Cheap Talk Interactions</title>
      <link>https://arxiv.org/abs/2401.03671</link>
      <description>arXiv:2401.03671v2 Announce Type: replace-cross 
Abstract: This paper considers the dynamics of cheap talk interactions between an oblivious receiver and a sender with different amounts of information. Even though it may seem that having additional information about the state of the game is always beneficial to the sender, we show that there are cases in which garbling the information of a fully informed sender can improve not only receiver's utility in equilibrium, but also that of the sender herself. We also provide efficient algorithms that output the optimal amount of information in sender-receiver scenarios with binary actions and extend some of these results to settings with multiple senders and one receiver.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.03671v2</guid>
      <category>cs.GT</category>
      <category>cs.DS</category>
      <category>econ.TH</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.437.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 437, 2025, pp. 31-45</arxiv:journal_reference>
      <dc:creator>Itai Arieli (Technion), Ivan Geffner (Utrecht University), Moshe Tennenholtz (Technion)</dc:creator>
    </item>
    <item>
      <title>The Mixed Birth-death/death-Birth Moran Process</title>
      <link>https://arxiv.org/abs/2511.18252</link>
      <description>arXiv:2511.18252v2 Announce Type: replace-cross 
Abstract: We study evolutionary dynamics on graphs in which each step consists of one birth and one death, also known as the Moran processes. There are two types of individuals: residents with fitness $1$ and mutants with fitness $r$. Two standard update rules are used in the literature. In Birth-death (Bd), a vertex is chosen to reproduce proportional to fitness, and one of its neighbors is selected uniformly at random to be replaced by the offspring. In death-Birth (dB), a vertex is chosen uniformly to die, and then one of its neighbors is chosen, proportional to fitness, to place an offspring into the vacancy. We formalize and study a unified model, the $\lambda$-mixed Moran process, in which each step is independently a Bd step with probability $\lambda \in [0,1]$ and a dB step otherwise. We analyze this mixed process for undirected, connected graphs. As an interesting special case, we show at $\lambda=1/2$, for any graph that the fixation probability when $r=1$ with a single mutant initially on the graph is exactly $1/n$, and also at $\lambda=1/2$ that the absorption time for any $r$ is $O_r(n^4)$. We also show results for graphs that are "almost regular," in a manner defined in the paper. We use this to show that for suitable random graphs from $G \sim G(n,p)$ and fixed $r&gt;1$, with high probability over the choice of graph, the absorption time is $O_r(n^4)$, the fixation probability is $\Omega_r(n^{-2})$, and we can approximate the fixation probability in polynomial time. Another special case is when the graph has only two distinct degree values $\{d_1, d_2\}$ with $d_1 \leq d_2$. For those graphs, we give exact formulas for fixation probabilities when $r = 1$ and any $\lambda$, and establish an absorption time of $O_r(n^4 \alpha^4)$ for all $\lambda$, where $\alpha = d_2 / d_1$. We also provide explicit formulas for the star and cycle under any $r$ or $\lambda$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.18252v2</guid>
      <category>math.PR</category>
      <category>cs.DS</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>David A. Brewster, Yichen Huang, Michael Mitzenmacher, Martin A. Nowak</dc:creator>
    </item>
    <item>
      <title>REWA: A General Theory of Witness-Based Similarity</title>
      <link>https://arxiv.org/abs/2511.19998</link>
      <description>arXiv:2511.19998v2 Announce Type: replace-cross 
Abstract: We present a universal framework for similarity-preserving encodings that subsumes all discrete, continuous, algebraic, and learned similarity methods under a single theoretical umbrella. By formulating similarity as functional witness projection over monoids, we prove that \[ O\!\left(\frac{1}{\Delta^{2}}\log N\right) \] encoding complexity with ranking preservation holds for arbitrary algebraic structures. This unification reveals that Bloom filters, Locality Sensitive Hashing (LSH), Count-Min sketches, Random Fourier Features, and Transformer attention kernels are instances of the same underlying mechanism. We provide complete proofs with explicit constants under 4-wise independent hashing, handle heavy-tailed witnesses via normalization and clipping, and prove \[ O(\log N) \] complexity for all major similarity methods from 1970-2024. We give explicit constructions for Boolean, Natural, Real, Tropical, and Product monoids, prove tight concentration bounds, and demonstrate compositional properties enabling multi-primitive similarity systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.19998v2</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <category>cs.IR</category>
      <pubDate>Mon, 01 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nikit Phadke</dc:creator>
    </item>
  </channel>
</rss>
