<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Apr 2025 04:00:34 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Refinement orders for quantum programs</title>
      <link>https://arxiv.org/abs/2504.14158</link>
      <description>arXiv:2504.14158v1 Announce Type: new 
Abstract: Refinement is an influential technique used in the verification and development of computer programs. It provides a systematic and rigorous approach to software development through stepwise refinement, where a high-level abstract specification is progressively transformed into an implementation that meets the desired requirements. Central to this technique is the notion of a refinement order, which ensures that each refinement step preserves program correctness. Different orders can be defined with respect to partial and total correctness, as well as for deterministic and nondeterministic programs. In the realm of quantum programs, the theory becomes even more intricate due to the existence of various quantum state predicates, leading to different notions of specifications. This paper thoroughly explores different refinement orders for quantum programs and examines the relationships between them.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.14158v1</guid>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yuan Feng, Li Zhou</dc:creator>
    </item>
    <item>
      <title>Ordered Completion for Non-Locally Tight mini-gringo Programs</title>
      <link>https://arxiv.org/abs/2504.14252</link>
      <description>arXiv:2504.14252v1 Announce Type: new 
Abstract: Completion is a well-known transformation that captures the stable model semantics of logic programs by turning a program into a set of first-order definitions. Stable models are models of the completion, but not all models of the completion are stable models. For tight programs (programs without positive recursion) the two semantics coincide. Recently this correspondence was extended to locally tight programs, which avoid non-terminating recursion. However, unlike tightness, local tightness cannot be checked with simple syntactic methods. Completion is crucial for verifying answer set programs, especially for external equivalence: a form of equivalence based on selected output predicates under certain inputs. Standard equivalence and adherence to a first-order specification are special cases of external equivalence. The anthem verification tool has two limitations for checking external equivalence: (1) there is no way to check local tightness automatically, and (2) it is not possible to verify programs that are not locally tight. Therefore, alternatives to completion are of interest. This thesis investigates ordered completion, introduced in [Asuncion et al., 2012], which captures stable models of arbitrary logic programs, but only for finite models. This work extends ordered completion to the mini-gringo language (a subset of the language used by the clingo solver). Additionally, it introduces a modification of ordered completion to handle infinite stable models. This extended ordered completion is implemented in anthem as a translation, and initial experiments demonstrate its use for verifying simple logic programs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.14252v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jan Heuer</dc:creator>
    </item>
    <item>
      <title>Convergence Laws for Extensions of First-Order Logic with Averaging</title>
      <link>https://arxiv.org/abs/2504.14270</link>
      <description>arXiv:2504.14270v1 Announce Type: new 
Abstract: For many standard models of random structure, first-order logic sentences exhibit a convergence phenomenon on random inputs. The most well-known example is for random graphs with constant edge probability, where the probabilities of first-order sentences converge to 0 or 1. In other cases, such as certain ``sparse random graph'' models, the probabilities of sentences converge, although not necessarily to 0 or 1. In this work we deal with extensions of first-order logic with aggregate operators, variations of averaging. These logics will consist of real-valued terms, and we allow arbitrary Lipschitz functions to be used as ``connectives''. We show that some of the well-known convergence laws extend to this setting.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.14270v1</guid>
      <category>cs.LO</category>
      <category>math.CO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sam Adam-Day, Michael Benedikt, Alberto Larrauri</dc:creator>
    </item>
    <item>
      <title>Cyclic Proofs in Hoare Logic and its Reverse</title>
      <link>https://arxiv.org/abs/2504.14283</link>
      <description>arXiv:2504.14283v1 Announce Type: new 
Abstract: We examine the relationships between axiomatic and cyclic proof systems for the partial and total versions of Hoare logic and those of its dual, known as reverse Hoare logic (or sometimes incorrectness logic). In the axiomatic proof systems for these logics, the proof rules for looping constructs involve an explicit loop invariant, which in the case of the total versions additionally require a well-founded termination measure. In the cyclic systems, these are replaced by rules that simply unroll the loops, together with a principle allowing the formation of cycles in the proof, subject to a global soundness condition that ensures the well-foundedness of the circular reasoning. Interestingly, the cyclic soundness conditions for partial Hoare logic and its reverse are similar and essentially coinductive in character, while those for the total versions are also similar and essentially inductive. We show that these cyclic systems are sound, by direct argument, and relatively complete, by translation from axiomatic to cyclic proofs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.14283v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>James Brotherston, Quang Loc Le, Gauri Desai, Yukihiro Oda</dc:creator>
    </item>
    <item>
      <title>On the $p$-adic Skolem Problem</title>
      <link>https://arxiv.org/abs/2504.14413</link>
      <description>arXiv:2504.14413v1 Announce Type: new 
Abstract: The Skolem Problem asks to determine whether a given linear recurrence sequence (LRS) has a zero term. Showing decidability of this problem is equivalent to giving an effective proof of the Skolem-Mahler-Lech Theorem, which asserts that a non-degenerate LRS has finitely many zeros. The latter result was proven over 90 years ago via an ineffective method showing that such an LRS has only finitely many $p$-adic zeros. In this paper we consider the problem of determining whether a given LRS has a $p$-adic zero, as well as the corresponding function problem of computing all $p$-adic zeros up to arbitrary precision. We present algorithms for both problems and report on their implementation within the Skolem tool. The output of the algorithms is unconditionally correct, and termination is guaranteed subject to the $p$-adic Schanuel Conjecture (a standard number-theoretic hypothesis concerning the $p$-adic exponential function). While these algorithms do not solve the Skolem Problem, they can be exploited to find natural-number and rational zeros under additional hypotheses. To illustrate this, we apply our results to show decidability of the Simultaneous Skolem Problem (determine whether two coprime linear recurrences have a common natural-number zero), again subject to the $p$-adic Schanuel Conjecture.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.14413v1</guid>
      <category>cs.LO</category>
      <category>math.NT</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Piotr Bacik, Jo\"el Ouaknine, David Purser, James Worrell</dc:creator>
    </item>
    <item>
      <title>Proof Scores: A Survey (full version)</title>
      <link>https://arxiv.org/abs/2504.14561</link>
      <description>arXiv:2504.14561v1 Announce Type: new 
Abstract: Proof scores can be regarded as outlines of the formal verification of system properties. They have been historically used by the OBJ family of specification languages. The main advantage of proof scores is that they follow the same syntax as the specification language they are used in, so specifiers can easily adopt them and use as many features as the particular language provides. In this way, proof scores have been successfully used to prove properties of a large number of systems and protocols. However, proof scores also present a number of disadvantages that prevented a large audience from adopting them as proving mechanism. In this paper we present the theoretical foundations of proof scores; the different systems where they have been adopted and their latest developments; the classes of systems successfully verified using proof scores, including the main techniques used for it; the main reasons why they have not been widely adopted; and finally we discuss some directions of future work that might solve the problems discussed previously.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.14561v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3729166</arxiv:DOI>
      <dc:creator>Adrian Riesco, Kazuhiro Ogata, Masaki Nakamura, Daniel Gaina, Duong Dinh Tran, Kokichi Futatsugi</dc:creator>
    </item>
    <item>
      <title>The Model Counting Competitions 2021-2023</title>
      <link>https://arxiv.org/abs/2504.13842</link>
      <description>arXiv:2504.13842v1 Announce Type: cross 
Abstract: Modern society is full of computational challenges that rely on probabilistic reasoning, statistics, and combinatorics. Interestingly, many of these questions can be formulated by encoding them into propositional formulas and then asking for its number of models. With a growing interest in practical problem-solving for tasks that involve model counting, the community established the Model Counting (MC) Competition in fall of 2019 with its first iteration in 2020. The competition aims at advancing applications, identifying challenging benchmarks, fostering new solver development, and enhancing existing solvers for model counting problems and their variants. The first iteration, brought together various researchers, identified challenges, and inspired numerous new applications. In this paper, we present a comprehensive overview of the 2021-2023 iterations of the Model Counting Competition. We detail its execution and outcomes. The competition comprised four tracks, each focusing on a different variant of the model counting problem. The first track centered on the model counting problem (MC), which seeks the count of models for a given propositional formula. The second track challenged developers to submit programs capable of solving the weighted model counting problem (WMC). The third track was dedicated to projected model counting (PMC). Finally, we initiated a track that combined projected and weighted model counting (PWMC). The competition continued with a high level of participation, with seven to nine solvers submitted in various different version and based on quite diverging techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.13842v1</guid>
      <category>cs.AI</category>
      <category>cs.DS</category>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Johannes K. Fichte, Markus Hecher</dc:creator>
    </item>
    <item>
      <title>Decidability of Querying First-Order Theories via Countermodels of Finite Width</title>
      <link>https://arxiv.org/abs/2304.06348</link>
      <description>arXiv:2304.06348v5 Announce Type: replace 
Abstract: We propose a generic framework for establishing the decidability of a wide range of logical entailment problems (briefly called querying), based on the existence of countermodels that are structurally simple, gauged by certain types of width measures (with treewidth and cliquewidth as popular examples). As an important special case of our framework, we identify logics exhibiting width-finite finitely universal model sets, warranting decidable entailment for a wide range of homomorphism-closed queries, subsuming a diverse set of practically relevant query languages. As a particularly powerful width measure, we propose to employ Blumensath's partitionwidth, which subsumes various other commonly considered width measures and exhibits highly favorable computational and structural properties. Focusing on the formalism of existential rules as a popular showcase, we explain how finite partitionwidth sets of rules subsume other known abstract decidable classes but - leveraging existing notions of stratification - also cover a wide range of new rulesets. We expose natural limitations for fitting the class of finite unification sets into our picture and suggest several options for remedy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2304.06348v5</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.DB</category>
      <category>cs.DM</category>
      <category>math.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Thomas Feller, Tim S. Lyon, Piotr Ostropolski-Nalewaja, Sebastian Rudolph</dc:creator>
    </item>
    <item>
      <title>Representing Sugihara monoids via weakening relations</title>
      <link>https://arxiv.org/abs/2310.12935</link>
      <description>arXiv:2310.12935v3 Announce Type: replace 
Abstract: We show that all Sugihara monoids can be represented as algebras of binary relations, with the monoid operation given by relational composition. Moreover, the binary relations are weakening relations. The first step is to obtain an explicit relational representation of all finite odd Sugihara chains. Our construction mimics that of Maddux (2010), where a relational representation of the finite even Sugihara chains is given. We define the class of representable Sugihara monoids as those which can be represented as reducts of distributive involutive FL-algebras of binary relations. We then show that the class of representable distributive involutive FL-algebras is closed under ultraproducts. This fact is used to demonstrate that the two infinite Sugihara monoids that generate the quasivariety are also representable. From this it follows that all Sugihara monoids are representable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.12935v3</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Andrew Craig, Claudette Robinson</dc:creator>
    </item>
    <item>
      <title>Proof-Producing Translation of Functional Programs into a Time \&amp; Space Reasonable Model</title>
      <link>https://arxiv.org/abs/2503.02975</link>
      <description>arXiv:2503.02975v2 Announce Type: replace 
Abstract: We present a semi-automated framework to construct and reason about programs in a deeply-embedded while-language. The while-language we consider is a simple computation model that can simulate (and be simulated by) Turing Machines with a quadratic time and constant space blow-up. Our framework derives while-programs from functional programs written in a subset of Isabelle/HOL, namely tail-recursive functions with first-order arguments and algebraic datatypes. As far as we are aware, it is the first framework targeting a computation model that is reasonable in time and space from a complexity-theoretic perspective.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.02975v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kevin Kappelmann, Fabian Huch, Lukas Stevens, Mohammad Abdulaziz</dc:creator>
    </item>
    <item>
      <title>Probabilistic Strategies: Definability and the Tensor Completeness Problem</title>
      <link>https://arxiv.org/abs/2504.09392</link>
      <description>arXiv:2504.09392v2 Announce Type: replace 
Abstract: Programs that combine I/O and countable probabilistic choice, modulo either bisimilarity or trace equivalence, can be seen as describing a probabilistic strategy. For well-founded programs, we might expect to axiomatize bisimilarity via a sum of equational theories and trace equivalence via a tensor of such theories. This is by analogy with similar results for nondeterminism, established previously.
  While bisimilarity is indeed axiomatized via a sum of theories, and the tensor is indeed at least sound for trace equivalence, completeness in general, remains an open problem. Nevertheless, we show completeness in the case that either the probabilistic choice or the I/O operations used are finitary. We also show completeness up to impersonation, i.e. that the tensor theory regards trace equivalent programs as solving the same system of equations. This entails completeness up to the cancellation law of the probabilistic choice operator.
  Furthermore, we show that a probabilistic trace strategy arises as the semantics of a well-founded program iff it is victorious. This means that, when the strategy is played against any partial counterstrategy, the probability of play continuing forever is zero.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.09392v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nathan Bowler, Sergey Goncharov, Paul Blain Levy</dc:creator>
    </item>
    <item>
      <title>Anonymous Public Announcements</title>
      <link>https://arxiv.org/abs/2504.12546</link>
      <description>arXiv:2504.12546v2 Announce Type: replace 
Abstract: We formalise the notion of an anonymous public announcement in the tradition of public announcement logic. Such announcements can be seen as in-between a public announcement from ``the outside" (an announcement of $\phi$) and a public announcement by one of the agents (an announcement of $K_a\phi$): we get more information than just $\phi$, but not (necessarily) about exactly who made it. Even if such an announcement is prima facie anonymous, depending on the background knowledge of the agents it might reveal the identity of the announcer: if I post something on a message board, the information might reveal who I am even if I don't sign my name. Furthermore, like in the Russian Cards puzzle, if we assume that the announcer's intention was to stay anonymous, that in fact might reveal more information. In this paper we first look at the case when no assumption about intentions are made, in which case the logic with an anonymous public announcement operator is reducible to epistemic logic. We then look at the case when we assume common knowledge of the intention to stay anonymous, which is both more complex and more interesting: in several ways it boils down to the notion of a ``safe" announcement (again, similarly to Russian Cards). Main results include formal expressivity results and axiomatic completeness for key logical languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.12546v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.CR</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Thomas {\AA}gotnes, Rustam Galimullin, Ken Satoh, Satoshi Tojo</dc:creator>
    </item>
    <item>
      <title>Degrees of incomputability, realizability and constructive reverse mathematics</title>
      <link>https://arxiv.org/abs/2002.10712</link>
      <description>arXiv:2002.10712v2 Announce Type: replace-cross 
Abstract: There is a way of assigning a realizability notion to each degree of incomputability. In our setting, we make use of Weihrauch degrees (degrees of incomputability/discontinuity of partial multi-valued functions) to obtain Lifschitz-like relative realizability predicates. In this note, we present sample examples on how to lift some separation results on Weihrauch degrees to those over intuitionistic Zermelo-Fraenkel set theory ${\bf IZF}$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2002.10712v2</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Takayuki Kihara</dc:creator>
    </item>
    <item>
      <title>Three Fundamental Questions in Modern Infinite-Domain Constraint Satisfaction</title>
      <link>https://arxiv.org/abs/2502.06621</link>
      <description>arXiv:2502.06621v2 Announce Type: replace-cross 
Abstract: The Feder-Vardi dichotomy conjecture for Constraint Satisfaction Problems (CSPs) with finite templates, confirmed independently by Bulatov and Zhuk, has an extension to certain well-behaved infinite templates due to Bodirsky and Pinsker which remains wide open. We provide answers to three fundamental questions on the scope of the Bodirsky-Pinsker conjecture. Our first two main results provide two simplifications of this scope, one of structural, and the other one of algebraic nature. The former simplification implies that the conjecture is equivalent to its restriction to templates without algebraicity, a crucial assumption in the most powerful classification methods. The latter yields that the higher-arity invariants of any template within its scope can be assumed to be essentially injective, and any algebraic condition characterizing any complexity class within the conjecture closed under Datalog reductions must be satisfiable by injections, thus lifting the mystery of the better applicability of certain conditions over others. Our third main result uses the first one to show that any non-trivially tractable template within the scope serves, up to a Datalog-computable modification of it, as the witness of the tractability of a non-finitely tractable finite-domain Promise Constraint Satisfaction Problem (PCSP) by the so-called sandwich method. This generalizes a recent result of Mottet and provides a strong hitherto unknown connection between the Bodirsky-Pinsker conjecture and finite-domain PCSPs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.06621v2</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Tue, 22 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Michael Pinsker, Jakub Rydval, Moritz Sch\"obi, Christoph Spiess</dc:creator>
    </item>
  </channel>
</rss>
