<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CC</link>
    <description>cs.CC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Jun 2024 04:00:01 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 14 Jun 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>A Polynomial Time Algorithm for 3SAT</title>
      <link>https://arxiv.org/abs/2406.08489</link>
      <description>arXiv:2406.08489v1 Announce Type: new 
Abstract: It is shown that any two clauses in an instance of 3SAT sharing the same terminal which is positive in one clause and negated in the other can imply a new clause composed of the remaining terms from both clauses. Clauses can also imply other clauses as long as all the terms in the implying clauses exist in the implied clause. It is shown an instance of 3SAT is unsatisfiable if and only if it can derive contradicting 1-terminal clauses in exponential time. It is further shown that these contradicting clauses can be implied with the aforementioned techniques without processing clauses of length 4 or greater, reducing the computation to polynomial time. Therefore there is a polynomial time algorithm that will produce contradicting 1-terminal clauses if and only if the instance of 3SAT is unsatisfiable. Since such an algorithm exists and 3SAT is NP-Complete, P = NP.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08489v1</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Robert Quigley</dc:creator>
    </item>
    <item>
      <title>An origami Universal Turing Machine design</title>
      <link>https://arxiv.org/abs/2406.08490</link>
      <description>arXiv:2406.08490v1 Announce Type: new 
Abstract: It has been known since 1996 that deciding whether a collection of creases on a piece of paper can be fully folded flat without causing self-intersection or adding new creases is an NP-Hard problem (Bern and Hayes). In their proof, a binary state was implemented as a pleat, with the state corresponding to the pleat layering order; states then interact via pleat intersections. Building on some of the machinery of their result, we will present a method for constructing an origami NAND logic gate, leading to a theoretical origami Universal Turing Machine.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08490v1</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Michael Assis</dc:creator>
    </item>
    <item>
      <title>Equivalence of Countable and Computable</title>
      <link>https://arxiv.org/abs/2406.08493</link>
      <description>arXiv:2406.08493v1 Announce Type: new 
Abstract: The concept of ``countable set'' is attributed to Georg Cantor, who set the boundary between countable and uncountable sets in 1874. The concept of ``computable set'' arose in the study of computing models in the 1930s by the founders of computer science, including \Godel, Church, and Turing. However, the connection between countability and computability has not been thoroughly studied in the past eight decades. A {\em counting bijection} of a set $S$ is a bijection from the set of natural numbers to $S$. We say $S$ is {\em enumerable} if either $S$ is finite or $S$ has a computable counting bijection. We prove that $S$ is enumerable if and only if $S$ is computable. This equivalence provides insights to the study of set theory and computability theory and reveals that the concept of countability is related to space and time complexity. We show that the set of total computable functions (or deciders, algorithms) is unenumerable. We also provide a sufficient and necessary condition for a set to be enumerable and use the concept of {\em counting order} to explain why some sets are unenumerable. We show that some popular statements about countable sets, such as ``every subset of a countable set is countable'' or ``every formal language is countable,'' lack a valid proof. These unproven statements are widely taught in college courses on discrete mathematics, set theory, and computability theory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08493v1</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hantao Zhang</dc:creator>
    </item>
    <item>
      <title>What If Turing Had Preceded G\"odel?</title>
      <link>https://arxiv.org/abs/2406.08494</link>
      <description>arXiv:2406.08494v1 Announce Type: new 
Abstract: The overarching theme of the following pages is that mathematical logic -- centered around the incompleteness theorems -- is first and foremost an investigation of $\textit{computation}$, not arithmetic. Guided by this intuition we will show the following.
  * First, we'll all but eliminate the need for G\"odel numbers.
  * Next, we'll introduce a novel notational device for representable functions and walk through a condensed demonstration that Peano Arithmetic can represent every computable function. It has achieved Turing completeness.
  * Continuing, we'll derive the Diagonal Lemma and First Incompleteness Theorem using significantly simplified proofs.
  * Approaching the Second Incompleteness Theorem, we'll be able to use some self-referential trickery to avoid much of the technical morass surrounding it; arriving at three separate versions.
  * Extending the analogy between the First Incompleteness Theorem and the Unsolvability of the Halting Problem produces an equivalent of the Nondeterministic Time Hierarchy Theorem from the field of computational complexity.
  * Lastly, we'll briefly peer into the realm of the uncomputable by connecting our ideas to oracles.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08494v1</guid>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Sebastian Oberhoff</dc:creator>
    </item>
    <item>
      <title>A Brief Note on a Recent Claim About NP-Hard Problems and BQP</title>
      <link>https://arxiv.org/abs/2406.08495</link>
      <description>arXiv:2406.08495v1 Announce Type: new 
Abstract: This short note outlines some of the issues in Czerwinski's paper [Cze23] claiming that NP-hard problems are not in BQP. We outline one major issue and two minor issues, and conclude that their paper does not establish what they claim it does.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08495v1</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Michael C. Chavrimootoo</dc:creator>
    </item>
    <item>
      <title>On the Simulation Power of Surface Chemical Reaction Networks</title>
      <link>https://arxiv.org/abs/2406.08497</link>
      <description>arXiv:2406.08497v1 Announce Type: new 
Abstract: The Chemical Reaction Network (CRN) is a well-studied model that describes the interaction of molecules in well-mixed solutions. In 2014, Qian and Winfree [22] proposed the abstract surface chemical reaction network model (sCRN), which takes the advantage of spatial separation by placing molecules on a structured surface, limiting the interaction between molecules. In this model, molecules can only react with their immediate neighbors. Many follow up works study the computational and pattern-construction power of sCRNs. In this work, our goal is to describe the power of sCRN by relating the model to other well-studied models in distributed computation. In this work, our main result is to show that, given the same initial configuration, sCRN, affinity strengthening tile automata, cellular automata, and amoebot can all simulate each other (up to unavoidable rotation and reflection of the pattern). One of our techniques is a coloring on-the-fly, which allows all molecules in sCRN to have a global orientation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08497v1</guid>
      <category>cs.CC</category>
      <category>cs.ET</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yi-Xuan Lee, Ho-Lin Chen</dc:creator>
    </item>
    <item>
      <title>More Efficient $k$-wise Independent Permutations from Random Reversible Circuits via log-Sobolev Inequalities</title>
      <link>https://arxiv.org/abs/2406.08499</link>
      <description>arXiv:2406.08499v1 Announce Type: new 
Abstract: We prove that the permutation computed by a reversible circuit with $\tilde{O}(nk\cdot \log(1/\varepsilon))$ random $3$-bit gates is $\varepsilon$-approximately $k$-wise independent. Our bound improves on currently known bounds in the regime when the approximation error $\varepsilon$ is not too small. We obtain our results by analyzing the log-Sobolev constants of appropriate Markov chains rather than their spectral gaps.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08499v1</guid>
      <category>cs.CC</category>
      <category>cs.CR</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Lucas Gretta, William He, Angelos Pelecanos</dc:creator>
    </item>
    <item>
      <title>Newman's theorem via Carath\'eodory</title>
      <link>https://arxiv.org/abs/2406.08500</link>
      <description>arXiv:2406.08500v1 Announce Type: new 
Abstract: We give a streamlined short proof of Newman's theorem in communication complexity by applying the classical and the approximate Carath\'eodory's theorems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08500v1</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ali Mohammad Lavasani, Yaqiao Li, Mehran Shakerinava</dc:creator>
    </item>
    <item>
      <title>A Refinement of the McCreight-Meyer Union Theorem</title>
      <link>https://arxiv.org/abs/2406.08600</link>
      <description>arXiv:2406.08600v1 Announce Type: new 
Abstract: Using properties of Blum complexity measures and certain complexity class operators, we exhibit a total computable and non-decreasing function $t_{\mathsf{poly}}$ such that for all $k$, $\Sigma_k\mathsf{P} = \Sigma_k\mathsf{TIME}(t_{\mathsf{poly}})$, $\mathsf{BPP} = \mathsf{BPTIME}(t_{\mathsf{poly}})$, $\mathsf{RP} = \mathsf{RTIME}(t_{\mathsf{poly}})$, $\mathsf{UP} = \mathsf{UTIME}(t_{\mathsf{poly}})$, $\mathsf{PP} = \mathsf{PTIME}(t_{\mathsf{poly}})$, $\mathsf{Mod}_k\mathsf{P} = \mathsf{Mod}_k\mathsf{TIME}(t_{\mathsf{poly}})$, $\mathsf{PSPACE} = \mathsf{DSPACE}(t_{\mathsf{poly}})$, and so forth. A similar statement holds for any collection of language classes, provided that each class is definable by applying a certain complexity class operator to some Blum complexity class.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.08600v1</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Matthew Fox, Chaitanya Karamchedu</dc:creator>
    </item>
    <item>
      <title>On the Expressibility of the Reconstructional Color Refinement</title>
      <link>https://arxiv.org/abs/2406.09351</link>
      <description>arXiv:2406.09351v1 Announce Type: new 
Abstract: One of the most basic facts related to the famous Ulam reconstruction conjecture is that the connectedness of a graph can be determined by the deck of its vertex-deleted subgraphs, which are considered up to isomorphism. We strengthen this result by proving that connectedness can still be determined when the subgraphs in the deck are given up to equivalence under the color refinement isomorphism test. Consequently, this implies that connectedness is recognizable by Reconstruction Graph Neural Networks, a recently introduced GNN architecture inspired by the reconstruction conjecture (Cotta, Morris, Ribeiro 2021).</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.09351v1</guid>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <category>cs.LG</category>
      <category>math.CO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>V. Arvind, Johannes K\"obler, Oleg Verbitsky</dc:creator>
    </item>
    <item>
      <title>XOR Lemmas for Communication via Marginal Information</title>
      <link>https://arxiv.org/abs/2312.03076</link>
      <description>arXiv:2312.03076v2 Announce Type: replace 
Abstract: We define the $\textit{marginal information}$ of a communication protocol, and use it to prove XOR lemmas for communication complexity. We show that if every $C$-bit protocol has bounded advantage for computing a Boolean function $f$, then every $\tilde \Omega(C \sqrt{n})$-bit protocol has advantage $\exp(-\Omega(n))$ for computing the $n$-fold xor $f^{\oplus n}$. We prove exponentially small bounds in the average case setting, and near optimal bounds for product distributions and for bounded-round protocols.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.03076v2</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Siddharth Iyer, Anup Rao</dc:creator>
    </item>
    <item>
      <title>Relations between monotone complexity measures based on decision tree complexity</title>
      <link>https://arxiv.org/abs/2406.07859</link>
      <description>arXiv:2406.07859v2 Announce Type: replace 
Abstract: In a recent result, Knop, Lovett, McGuire and Yuan (STOC 2021) proved the log-rank conjecture for communication complexity, up to log n factor, for any Boolean function composed with AND function as the inner gadget. One of the main tools in this result was the relationship between monotone analogues of well-studied Boolean complexity measures like block sensitivity and certificate complexity. The relationship between the standard measures has been a long line of research, with a landmark result by Huang (Annals of Mathematics 2019), finally showing that sensitivity is polynomially related to all other standard measures. In this article, we study the monotone analogues of standard measures like block sensitivity (mbs(f)), certificate complexity (MCC(f)) and fractional block sensitivity (fmbs(f)); and study the relationship between these measures given their connection with AND-decision tree and sparsity of a Boolean function. We show the following results: 1) Given a Boolean function $f : \{0, 1\}^{n} \rightarrow \{0, 1\}$, the ratio $fmbs(f^l )/mbs(f^l )$ is bounded by a function of n (and not l). A similar result was known for the corresponding standard measures (Tal, ITCS 2013). This result allows us to extend any upper bound by a well behaved measure on monotone block sensitivity to monotone fractional block sensitivity. 2) The question of the best possible upper bound on monotone block sensitivity by the logarithm of sparsity is equivalent to the natural question of best upper bound by degree on sensitivity. One side of this relationship was used in the proof by Knop, Lovett, McGuire and Yuan (STOC 2021). 3) For two natural classes of functions, symmetric and monotone, hitting set complexity (MCC) is equal to monotone sensitivity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.07859v2</guid>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Farzan Byramji, Vatsal Jha, Chandrima Kayal, Rajat Mittal</dc:creator>
    </item>
    <item>
      <title>Lower Bounds for Unitary Property Testing with Proofs and Advice</title>
      <link>https://arxiv.org/abs/2401.07912</link>
      <description>arXiv:2401.07912v2 Announce Type: replace-cross 
Abstract: In unitary property testing a quantum algorithm, also known as a tester, is given query access to a black-box unitary and has to decide whether it satisfies some property. We propose a new technique for proving lower bounds on the quantum query complexity of unitary property testing and related problems, which utilises its connection to unitary channel discrimination. The main advantage of this technique is that all obtained lower bounds hold for any $\mathsf{C}$-tester with $\mathsf{C} \subseteq \mathsf{QMA}(2)/\mathsf{qpoly}$, showing that even having access to both (unentangled) quantum proofs and advice does not help for many unitary problems. We apply our technique to prove lower bounds for problems like quantum phase estimation, the entanglement entropy problem, quantum Gibbs sampling and more, removing all logarithmic factors in the lower bounds obtained by the sample-to-query lifting theorem of Wang and Zhang (2023). As a direct corollary, we show that there exist quantum oracles relative to which $\mathsf{QMA}(2) \not\supset \mathsf{SBQP}$ and $\mathsf{QMA}/\mathsf{qpoly} \not\supset \mathsf{SBQP}$. The former shows that, at least in a black-box way, having unentangled quantum proofs does not help in solving problems that require high precision.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.07912v2</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jordi Weggemans</dc:creator>
    </item>
  </channel>
</rss>
