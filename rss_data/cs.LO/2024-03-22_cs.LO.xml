<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Mar 2024 04:00:12 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 22 Mar 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>The equational theory of the Weihrauch lattice with multiplication</title>
      <link>https://arxiv.org/abs/2403.13975</link>
      <description>arXiv:2403.13975v1 Announce Type: new 
Abstract: We study the equational theory of the Weihrauch lattice with multiplication, meaning the collection of equations between terms built from variables, the lattice operations $\sqcup$, $\sqcap$, the product $\times$, and the finite parallelization $(-)^*$ which are true however we substitute Weihrauch degrees for the variables. We provide a combinatorial description of these in terms of a reducibility between finite graphs, and moreover, show that deciding which equations are true in this sense is complete for the third level of the polynomial hierarchy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.13975v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Eike Neumann, Arno Pauly, C\'ecilia Pradic</dc:creator>
    </item>
    <item>
      <title>Complexity of the Model Checking problem for inquisitive propositional and modal logic</title>
      <link>https://arxiv.org/abs/2403.14260</link>
      <description>arXiv:2403.14260v1 Announce Type: new 
Abstract: The aim of this paper is to study the complexity of the model checking problem MC for inquisitive propositional logic InqB and for inquisitive modal logic InqM, that is, the problem of deciding whether a given finite structure for the logic satisfies a given formula. In recent years, this problem has been thoroughly investigated for several variations of dependence and teams logics, systems closely related to inquisitive logic. Building upon some ideas presented by Yang, we prove that the model checking problems for InqB and InqM are both AP-complete.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.14260v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Gianluca Grilletti, Ivano Ciardelli</dc:creator>
    </item>
    <item>
      <title>Fully Evaluated Left-Sequential Logics</title>
      <link>https://arxiv.org/abs/2403.14576</link>
      <description>arXiv:2403.14576v1 Announce Type: new 
Abstract: We consider a family of two-valued "fully evaluated left-sequential logics" (FELs), of which Free FEL (defined by Staudt in 2012) is most distinguishing (weakest) and immune to atomic side effects. Next is Memorising FEL, in which evaluations of subexpressions are memorised. The following stronger logic is Conditional FEL (inspired by Guzm\'an and Squier's Conditional logic, 1990). The strongest FEL is static FEL, a sequential version of propositional logic. We use evaluation trees as a simple, intuitive semantics and provide complete axiomatisations for closed terms (left-sequential propositional expressions).
  For each FEL except Static FEL, we also define its three-valued version, with a constant U for "undefinedness" and again provide complete, independent aziomatisations, each one containing two additional axioms for U on top of the axiomatisations of the two-valued case. In this setting, the strongest FEL is equivalent to Bochvar's strict logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.14576v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alban Ponse, Daan J. C. Staudt</dc:creator>
    </item>
    <item>
      <title>Circuit Transformer: End-to-end Circuit Design by Predicting the Next Gate</title>
      <link>https://arxiv.org/abs/2403.13838</link>
      <description>arXiv:2403.13838v1 Announce Type: cross 
Abstract: Language, a prominent human ability to express through sequential symbols, has been computationally mastered by recent advances of large language models (LLMs). By predicting the next word recurrently with huge neural models, LLMs have shown unprecedented capabilities in understanding and reasoning. Circuit, as the "language" of electronic design, specifies the functionality of an electronic device by cascade connections of logic gates. Then, can circuits also be mastered by a a sufficiently large "circuit model", which can conquer electronic design tasks by simply predicting the next logic gate? In this work, we take the first step to explore such possibilities. Two primary barriers impede the straightforward application of LLMs to circuits: their complex, non-sequential structure, and the intolerance of hallucination due to strict constraints (e.g., equivalence). For the first barrier, we encode a circuit as a memory-less, depth-first traversal trajectory, which allows Transformer-based neural models to better leverage its structural information, and predict the next gate on the trajectory as a circuit model. For the second barrier, we introduce an equivalence-preserving decoding process, which ensures that every token in the generated trajectory adheres to the specified equivalence constraints. Moreover, the circuit model can also be regarded as a stochastic policy to tackle optimization-oriented circuit design tasks. Experimentally, we trained a Transformer-based model of 88M parameters, named "Circuit Transformer", which demonstrates impressive performance in end-to-end logic synthesis. With Monte-Carlo tree search, Circuit Transformer significantly improves over resyn2 while retaining strict equivalence, showcasing the potential of generative AI in conquering electronic design challenges.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.13838v1</guid>
      <category>cs.LG</category>
      <category>cs.AR</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Xihan Li, Xing Li, Lei Chen, Xing Zhang, Mingxuan Yuan, Jun Wang</dc:creator>
    </item>
    <item>
      <title>Database Dependencies and Formal Concept Analysis</title>
      <link>https://arxiv.org/abs/2403.13914</link>
      <description>arXiv:2403.13914v1 Announce Type: cross 
Abstract: This is an account of the characterization of database dependencies with Formal Concept Analysis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.13914v1</guid>
      <category>cs.DB</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jaume Baixeries</dc:creator>
    </item>
    <item>
      <title>Modal logic, fundamentally</title>
      <link>https://arxiv.org/abs/2403.14043</link>
      <description>arXiv:2403.14043v1 Announce Type: cross 
Abstract: Non-classical generalizations of classical modal logic have been developed in the contexts of constructive mathematics and natural language semantics. In this paper, we discuss a general approach to the semantics of non-classical modal logics via algebraic representation theorems. We begin with complete lattices $L$ equipped with an antitone operation $\neg$ sending $1$ to $0$, a completely multiplicative operation $\Box$, and a completely additive operation $\Diamond$. Such lattice expansions can be represented by means of a set $X$ together with binary relations $\vartriangleleft$, $R$, and $Q$, satisfying some first-order conditions, used to represent $(L,\neg)$, $\Box$, and $\Diamond$, respectively. Indeed, any lattice $L$ equipped with such a $\neg$, a multiplicative $\Box$, and an additive $\Diamond$ embeds into the lattice of propositions of a frame $(X,\vartriangleleft,R,Q)$. Building on our recent study of "fundamental logic", we focus on the case where $\neg$ is dually self-adjoint ($a\leq \neg b$ implies $b\leq\neg a$) and $\Diamond \neg a\leq\neg\Box a$. In this case, the representations can be constrained so that $R=Q$, i.e., we need only add a single relation to $(X,\vartriangleleft)$ to represent both $\Box$ and $\Diamond$. Using these results, we prove that a system of fundamental modal logic is sound and complete with respect to an elementary class of bi-relational structures $(X,\vartriangleleft, R)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.14043v1</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Wesley H. Holliday</dc:creator>
    </item>
    <item>
      <title>The addition of temporal neighborhood makes the logic of prefixes and sub-intervals EXPSPACE-complete</title>
      <link>https://arxiv.org/abs/2202.07881</link>
      <description>arXiv:2202.07881v5 Announce Type: replace 
Abstract: A classic result by Stockmeyer gives a non-elementary lower bound to the emptiness problem for star-free generalized regular expressions. This result is intimately connected to the satisfiability problem for interval temporal logic, notably for formulas that make use of the so-called chop operator. Such an operator can indeed be interpreted as the inverse of the concatenation operation on regular languages, and this correspondence enables reductions between non-emptiness of star-free generalized regular expressions and satisfiability of formulas of the interval temporal logic of chop under the homogeneity assumption. In this paper, we study the complexity of the satisfiability problem for suitable weakenings of the chop interval temporal logic, that can be equivalently viewed as fragments of Halpern and Shoham interval logic. We first consider the logic $\mathsf{BD}_{hom}$ featuring modalities $B$, for \emph{begins}, corresponding to the prefix relation on pairs of intervals, and $D$, for \emph{during}, corresponding to the infix relation. The homogeneous models of $\mathsf{BD}_{hom}$ naturally correspond to languages defined by restricted forms of regular expressions, that use union, complementation, and the inverses of the prefix and infix relations. Such a fragment has been recently shown to be PSPACE-complete . In this paper, we study the extension $\mathsf{BD}_{hom}$ with the temporal neighborhood modality $A$ (corresponding to the Allen relation \emph{Meets}), and prove that it increases both its expressiveness and complexity. In particular, we show that the resulting logic $\mathsf{BDA}_{hom}$ is EXPSPACE-complete.</description>
      <guid isPermaLink="false">oai:arXiv.org:2202.07881v5</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>L. Bozzelli, A. Montanari, A. Peron, P. Sala</dc:creator>
    </item>
    <item>
      <title>Combining Type Checking and Set Constraint Solving to Improve Automated Software Verification</title>
      <link>https://arxiv.org/abs/2205.01713</link>
      <description>arXiv:2205.01713v3 Announce Type: replace 
Abstract: In this paper we show how prescritive type checking and constraint solving can be combined to increase automation during software verification. We do so by defining a type system and implementing a typechecker for {log} (read `setlog'), a Constraint Logic Programming (CLP) language and satisfiability solver based on set theory. Hence, we proceed as follows: a) a type system for {log} is defined; b) the constraint solver is proved to be safe w.r.t. the type system; c) the implementation of a concrete typechecker is presented; d) the integration of type checking and set constraint solving to increase automation during software verification is discussed; and f) two industrial-strength case studies are presented where this combination is used with very good results.
  Under consideration in Theory and Practice of Logic Programming (TPLP)</description>
      <guid isPermaLink="false">oai:arXiv.org:2205.01713v3</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Maximiliano Cristi\'a, Gianfranco Rossi</dc:creator>
    </item>
  </channel>
</rss>
