<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Nov 2024 04:10:03 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Probabilistic Obstruction Temporal Logic: a Probabilistic Logic to Reason about Dynamic Models</title>
      <link>https://arxiv.org/abs/2411.00025</link>
      <description>arXiv:2411.00025v1 Announce Type: new 
Abstract: In this paper, we propose a novel formalism called Probabilistic Obstruction Temporal Logic (POTL), which extends Obstruction Logic (OL) by incorporating probabilistic elements. POTL provides a robust framework for reasoning about the probabilistic behaviors and strategic interactions between attackers and defenders in environments where probabilistic events influence outcomes. We explore the model checking complexity of POTL and demonstrate that it is not higher than that of Probabilistic Computation Tree Logic (PCTL), making it both expressive and computationally feasible for cybersecurity and privacy applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00025v1</guid>
      <category>cs.LO</category>
      <category>cs.GT</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jean Leneutre, Vadim Malvone, James Ortiz</dc:creator>
    </item>
    <item>
      <title>Revisiting Assumptions Ordering in CAR-Based Model Checking</title>
      <link>https://arxiv.org/abs/2411.00026</link>
      <description>arXiv:2411.00026v1 Announce Type: new 
Abstract: Model checking is an automatic formal verification technique that is widely used in hardware verification. The state-of-the-art complete model-checking techniques, based on IC3/PDR and its general variant CAR, are based on computing symbolically sets of under - and over-approximating state sets (called frames) with multiple calls to a SAT solver. The performance of those techniques is sensitive to the order of the assumptions with which the SAT solver is invoked, because it affects the unsatisfiable cores - which the solver emits when the formula is unsatisfiable - that crucially affect the search process. This observation was previously published in [15], where two partial assumption ordering strategies, intersection and rotation were suggested (partial in the sense that they determine the order of only a subset of the literals). In this paper we extend and improve these strategies based on an analysis of the reason for their effectiveness. We prove that intersection is effective because of what we call locality of the cores, and our improved strategy is based on this observation. We conclude our paper with an extensive empirical evaluation of the various ordering techniques. One of our strategies, Hybrid-CAR, which switches between strategies at runtime, not only outperforms other, fixed ordering strategies, but also outperforms other state-of-the-art bug-finding algorithms such as ABC-BMC.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00026v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Yibo Dong, Yu Chen, Jianwen Li, Geguang Pu, Ofer Strichman</dc:creator>
    </item>
    <item>
      <title>A Theoretical Review on Solving Algebra Problems</title>
      <link>https://arxiv.org/abs/2411.00031</link>
      <description>arXiv:2411.00031v1 Announce Type: new 
Abstract: Solving algebra problems (APs) continues to attract significant research interest as evidenced by the large number of algorithms and theories proposed over the past decade. Despite these important research contributions, however, the body of work remains incomplete in terms of theoretical justification and scope. The current contribution intends to fill the gap by developing a review framework that aims to lay a theoretical base, create an evaluation scheme, and extend the scope of the investigation. This paper first develops the State Transform Theory (STT), which emphasizes that the problem-solving algorithms are structured according to states and transforms unlike the understanding that underlies traditional surveys which merely emphasize the progress of transforms. The STT, thus, lays the theoretical basis for a new framework for reviewing algorithms. This new construct accommodates the relation-centric algorithms for solving both word and diagrammatic algebra problems. The latter not only highlights the necessity of introducing new states but also allows revelation of contributions of individual algorithms obscured in prior reviews without this approach.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00031v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.SC</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Xinguo Yu, Weina Cheng, Chuanzhi Yang, Ting Zhang</dc:creator>
    </item>
    <item>
      <title>Towards the Usage of Window Counting Constraints in the Synthesis of Reactive Systems to Reduce State Space Explosion</title>
      <link>https://arxiv.org/abs/2411.00048</link>
      <description>arXiv:2411.00048v1 Announce Type: new 
Abstract: The synthesis of reactive systems aims for the automated construction of strategies for systems that interact with their environment. Whereas the synthesis approach has the potential to change the development of reactive systems significantly due to the avoidance of manual implementation, it still suffers from a lack of efficient synthesis algorithms for many application scenarios. The translation of the system specification into an automaton that allows for strategy construction is nonelementary in the length of the specification in S1S and double exponential for LTL, raising the need of highly specialized algorithms.  In this paper, we present an approach on how to reduce this state space explosion in the construction of this automaton by exploiting a monotony property of specifications. For this, we introduce window counting constraints that allow for step-wise refinement or abstraction of specifications. In an iterating synthesis procedure, those window counting constraints are used to construct automata representing over- or under-approximations (depending on the counting constraint) of constraint-compliant behavior. Analysis results on winning regions of previous iterations are used to reduce the size of the next automaton, leading to an overall reduction of the state space explosion extend. We present the implementation results of the iterated synthesis for a zero-sum game setting as proof of concept. Furthermore, we discuss the current limitations of the approach in a zero-sum setting and sketch future work in non-zero-sum settings.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00048v1</guid>
      <category>cs.LO</category>
      <category>cs.GT</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.409.8</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 409, 2024, pp. 53-69</arxiv:journal_reference>
      <dc:creator>Linda Feeken, Martin Fr\"anzle</dc:creator>
    </item>
    <item>
      <title>Openness And Partial Adjacency In One Variable TPTL</title>
      <link>https://arxiv.org/abs/2411.00117</link>
      <description>arXiv:2411.00117v1 Announce Type: new 
Abstract: Metric Temporal Logic (MTL) and Timed Propositional Temporal Logic (TPTL) extend Linear Temporal Logic (LTL) for real-time constraints, with MTL using time-bounded modalities and TPTL employing freeze quantifiers. Satisfiability for both is generally undecidable; however, MTL becomes decidable under certain non-punctual and partially-punctual restrictions. Punctuality can be restored trivially under similar non-punctual restrictions on TPTL even for one variable fragment. Our first contribution is to study more restricted notion of openness for 1-TPTL, under which punctuality can not be recovered. We show that even under such restrictions, the satisfiability checking does not get computationally easier. This implies that 1-TPTL (and hence TPTL) does not enjoy benefits of relaxing punctuality unlike MTL. As our second contribution we introduce a refined, partially adjacent restriction in 1-TPTL (PA-1-TPTL), and prove decidability for its satisfiability checking. We show that this logic is strictly more expressive than partially punctual Metric Temporal Logic, making this as one of the most expressive known boolean-closed decidable timed logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00117v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shankara Narayanan Krishna, Khushraj Madnani, Agnipratim Nag, Paritosh Pandya</dc:creator>
    </item>
    <item>
      <title>A "Symbolic" Representation of Object-Nets (Extended Version)</title>
      <link>https://arxiv.org/abs/2411.00149</link>
      <description>arXiv:2411.00149v1 Announce Type: new 
Abstract: In this contribution we extend the concept of a Petri net morphism to Elementary Object Systems (EOS). EOS are a nets-within-nets formalism, i.e. we allow the tokens of a Petri net to be Petri nets again. This nested structure has the consequence that even systems defined by very small Petri nets have a quite huge reachability graph. In this contribution we use automorphism to describe symmetries of the Petri net topology. Since these symmetries carry over to markings as well this leads to a condensed state space, too.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00149v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Michael K\"ohler-Bussmeier, Lorenzo Capra</dc:creator>
    </item>
    <item>
      <title>Total Outcome Logic: Proving Termination and Nontermination in Programs with Branching</title>
      <link>https://arxiv.org/abs/2411.00197</link>
      <description>arXiv:2411.00197v1 Announce Type: new 
Abstract: While there is a long tradition of reasoning about termination (and nontermination) in the context of program analysis, specialized logics are typically needed to give different termination guarantees. This includes partial correctness, where termination is not guaranteed, and total correctness, where it is guaranteed. We present Total Outcome Logic, a single logic which can express the full spectrum of termination conditions and program properties offered by the aforementioned logics. Total Outcome Logic extends termination and incorrectness reasoning across different kinds of branching effects, so that a single metatheory powers this reasoning in different kinds of programs, including nondeterministic and probabilistic. We demonstrate the utility of this approach through a variety of case studies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00197v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>James Li, Noam Zilberstein, Alexandra Silva</dc:creator>
    </item>
    <item>
      <title>Sound Statistical Model Checking for Probabilities and Expected Rewards</title>
      <link>https://arxiv.org/abs/2411.00559</link>
      <description>arXiv:2411.00559v1 Announce Type: new 
Abstract: Statistical model checking estimates probabilities and expectations of interest in probabilistic system models by using random simulations. Its results come with statistical guarantees. However, many tools use unsound statistical methods that produce incorrect results more often than they claim. In this paper, we provide a comprehensive overview of tools and their correctness, as well as of sound methods available for estimating probabilities from the literature. For expected rewards, we investigate how to bound the path reward distribution to apply sound statistical methods for bounded distributions, of which we recommend the Dvoretzky-Kiefer-Wolfowitz inequality that has not been used in SMC so far. We prove that even reachability rewards can be bounded in theory, and formalise the concept of limit-PAC procedures for a practical solution. The 'modes' SMC tool implements our methods and recommendations, which we use to experimentally confirm our results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00559v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Carlos E. Budde, Arnd Hartmanns, Tobias Meggendorfer, Maximilian Weininger, Patrick Wienh\"oft</dc:creator>
    </item>
    <item>
      <title>Early Announcement: Parametricity for GADTs</title>
      <link>https://arxiv.org/abs/2411.00589</link>
      <description>arXiv:2411.00589v1 Announce Type: new 
Abstract: Relational parametricity was first introduced by Reynolds for System F. Although System F provides a strong model for the type systems at the core of modern functional programming languages, it lacks features of daily programming practice such as complex data types. In order to reason parametrically about such objects, Reynolds' seminal ideas need to be generalized to extensions of System F. Here, we explore such a generalization for the extension of System F by Generalized Algebraic Data Types (GADTs) as found in Haskell. Although GADTs generalize Algebraic Data Types (ADTs) -- i.e., simple recursive types such as lists, trees, etc. -- we show that naively extending the parametric treatment of these recursive types is not enough to tackle GADTs. We propose a tentative workaround for this issue, borrowing ideas from the categorical semantics of GADTs known as (functorial) completion. We discuss some applications, as well as some limitations, of this solution.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00589v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Pierre Cagne, Patricia Johann</dc:creator>
    </item>
    <item>
      <title>Integrating Fuzzy Logic into Deep Symbolic Regression</title>
      <link>https://arxiv.org/abs/2411.00431</link>
      <description>arXiv:2411.00431v1 Announce Type: cross 
Abstract: Credit card fraud detection is a critical concern for financial institutions, intensified by the rise of contactless payment technologies. While deep learning models offer high accuracy, their lack of explainability poses significant challenges in financial settings. This paper explores the integration of fuzzy logic into Deep Symbolic Regression (DSR) to enhance both performance and explainability in fraud detection. We investigate the effectiveness of different fuzzy logic implications, specifically {\L}ukasiewicz, G\"odel, and Product, in handling the complexity and uncertainty of fraud detection datasets. Our analysis suggest that the {\L}ukasiewicz implication achieves the highest F1-score and overall accuracy, while the Product implication offers a favorable balance between performance and explainability. Despite having a performance lower than state-of-the-art (SOTA) models due to information loss in data transformation, our approach provides novelty and insights into into integrating fuzzy logic into DSR for fraud detection, providing a comprehensive comparison between different implications and methods.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00431v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Wout Gerdes, Erman Acar</dc:creator>
    </item>
    <item>
      <title>Polymorphic Metaprogramming with Memory Management -- An Adjoint Analysis of Metaprogramming</title>
      <link>https://arxiv.org/abs/2411.00752</link>
      <description>arXiv:2411.00752v1 Announce Type: cross 
Abstract: We describe Elevator, a unifying polymorphic foundation for metaprogramming with memory management based on adjoint modalities. In this setting, we distinguish between multiple memory regions using modes where each mode has a specific set of structural properties. This allows us not only to capture linear (i.e. garbage-free) memory regions and (ordinary) intuitionistic (i.e. garbage-collected or persistent) memory regions, but also to capture accessibility between the memory regions using a preorder between modes. This preorder gives us the power to describe monadic and comonadic programming. As a consequence, it extends the existing logical view of metaprogramming in two directions: first, it ensures that code generation can be done efficiently by controlling memory accesses; second, it allows us to provide resource guarantees about the generated code (i.e. code that is for example garbage-free).
  We present the static and dynamic semantics of Elevator. In particular, we prove the substructurality of variable references and type safety of the language. We also establish mode safety, which guarantees that the evaluation of a term does not access a value in an inaccessible memory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.00752v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Junyoung Jang, Brigitte Pientka</dc:creator>
    </item>
    <item>
      <title>Distributed controller synthesis for deadlock avoidance</title>
      <link>https://arxiv.org/abs/2204.12409</link>
      <description>arXiv:2204.12409v4 Announce Type: replace 
Abstract: We consider the distributed control synthesis problem for systems with locks. The goal is to find local controllers so that the global system does not deadlock. With no restriction this problem is undecidable even for three processes each using a fixed number of locks. We propose two restrictions that make distributed control decidable. The first one is to allow each process to use at most two locks. The problem then becomes Sigma2P-complete, and even in PTIME under some additional assumptions. The dining philosophers problem satisfies these assumptions. The second restriction is a nested usage of locks. In this case the synthesis problem is NEXPTIME-complete. The drinking philosophers problem falls in this case.</description>
      <guid isPermaLink="false">oai:arXiv.org:2204.12409v4</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hugo Gimbert, Corto Mascle, Anca Muscholl, Igor Walukiewicz</dc:creator>
    </item>
    <item>
      <title>What Monads Can and Cannot Do with a Few Extra Pages</title>
      <link>https://arxiv.org/abs/2311.15919</link>
      <description>arXiv:2311.15919v2 Announce Type: replace 
Abstract: The delay monad provides a way to introduce general recursion in type theory. To write programs that use a wide range of computational effects directly in type theory, we need to combine the delay monad with the monads of these effects. Here we present a first systematic study of such combinations.
  We study both the coinductive delay monad and its guarded recursive cousin, giving concrete examples of combining these with well-known computational effects. We also provide general theorems stating which algebraic effects distribute over the delay monad, and which do not. Lastly, we salvage some of the impossible cases by considering distributive laws up to weak bisimilarity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.15919v2</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Rasmus Ejlers M{\o}gelberg, Maaike Zwart</dc:creator>
    </item>
    <item>
      <title>Context, Judgement, Deduction</title>
      <link>https://arxiv.org/abs/2111.09438</link>
      <description>arXiv:2111.09438v3 Announce Type: replace-cross 
Abstract: We introduce judgemental theories and their calculi as a general framework to present and study deductive systems. As an exemplification of their expressivity, we approach dependent type theory and natural deduction as special kinds of judgemental theories. Our analysis sheds light on both the topics, providing a new point of view. In the case of type theory, we provide an abstract definition of type constructor featuring the usual formation, introduction, elimination and computation rules. For natural deduction we offer a deep analysis of structural rules, demystifying some of their properties, and putting them into context. We finish the paper discussing the internal logic of a topos, a predicative topos, an elementary 2-topos et similia, and show how these can be organized in judgemental theories.</description>
      <guid isPermaLink="false">oai:arXiv.org:2111.09438v3</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Mon, 04 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Greta Coraglia, Ivan Di Liberti</dc:creator>
    </item>
  </channel>
</rss>
