<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Aug 2025 04:00:13 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Constructing Long Paths in Graph Streams</title>
      <link>https://arxiv.org/abs/2508.16022</link>
      <description>arXiv:2508.16022v1 Announce Type: new 
Abstract: In the graph stream model of computation, an algorithm processes the edges of an input graph in one or more sequential passes while using a memory sublinear in the input size. This model poses significant challenges for constructing long paths. Many known algorithms tasked with extending an existing path as a subroutine require an entire pass to add a single additional edge. This raises a fundamental question: Are multiple passes inherently necessary to construct paths of non-trivial lengths, or can a single pass suffice? To address this question, we study the Longest Path problem in the one-pass streaming model. In this problem, given a desired approximation factor $\alpha$, the objective is to compute a path of length at least $\lp(G) / \alpha$, where $\lp(G)$ is the length of a longest path in the input graph. We give algorithms as well as space lower bounds for both undirected and directed graphs. Our results include: We show that for undirected graphs, in both the insertion-only and the insertion-deletion models, there are semi-streaming algorithms, that compute a path of length at least $d /3$ with high probability, where $d$ is the average degree of the graph. These algorithms can also yield an $\alpha$-approximation to Longest Path using space $\tilde{O}(n^2 / \alpha)$. Next, we show that such a result cannot be achieved for directed graphs, even in the insertion-only model. We show that computing a $(n^{1 - o(1)})$-approximation to Longest Path in directed graphs in the insertion-only model requires space $\Omega(n^2)$. We further show two additional lower bounds. First, we show that semi-streaming space is insufficient for small constant factor approximations to Longest Path for undirected graphs in the insertion-only model. Last, in undirected graphs in the insertion-deletion model, we show that computing an $\alpha$-approximation requires space $\Omega(n^2 / \alpha^3)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16022v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christian Konrad, Chhaya Trehan</dc:creator>
    </item>
    <item>
      <title>PIPQ: Strict Insert-Optimized Concurrent Priority Queue</title>
      <link>https://arxiv.org/abs/2508.16023</link>
      <description>arXiv:2508.16023v1 Announce Type: new 
Abstract: This paper presents PIPQ, a strict and linearizable concurrent priority queue whose design differs from existing solutions in literature because it focuses on enabling parallelism of insert operations as opposed to accelerating delete-min operations, as traditionally done. In a nutshell, PIPQ's structure includes two levels: the worker level and the leader level. The worker level provides per-thread data structures enabling fast and parallel insertions. The leader level contains the highest priority elements in the priority queue and can thus serve delete-min operations. Our evaluation, which includes an exploration of different data access patterns, operation mixes, runtime settings, and an integration into a graph-based application, shows that PIPQ outperforms competitors in a variety of cases, especially with insert-dominant workloads.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16023v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Olivia Grimes, Ahmed Hassan, Panagiota Fatourou, Roberto Palmieri</dc:creator>
    </item>
    <item>
      <title>On the number of MUSs crossing a position</title>
      <link>https://arxiv.org/abs/2508.16092</link>
      <description>arXiv:2508.16092v1 Announce Type: new 
Abstract: A string $w$ is said to be a minimal unique substring (MUS) of a string $T$ if $w$ occurs exactly once in $T$, and any proper substring of $w$ occurs at least twice in $T$. It is known that the number of MUSs in a string $T$ of length $n$ is at most $n$, and that the set $MUS(T)$ of all MUSs in $T$ can be computed in $O(n)$ time [Ilie and Smyth, 2011]. Let $MUS(T,i)$ denote the set of MUSs that contain a position $i$ in a string $T$. In this short paper, we present matching $\Theta(\sqrt{n})$ upper and lower bounds for the number $|MUS(T,i)|$ of MUSs containing a position $i$ in a string $T$ of length $n$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16092v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hiroto Fujimaru, Takuya Mieno, Shunsuke Inenaga</dc:creator>
    </item>
    <item>
      <title>Symmetry-breaking symmetry in directed spectral partitioning</title>
      <link>https://arxiv.org/abs/2508.16173</link>
      <description>arXiv:2508.16173v1 Announce Type: new 
Abstract: We break the symmetry in classical spectral bi-partitioning in order to incentivise the alignment of directed cut edges. We use this to generate acyclic bi-partitions and furthermore topological orders of directed acyclic graphs with superb locality. The new approach outperforms the state-of-the-art Gorder algorithm by up to $17\times$ on total reuse distance and minimum linear arrangement.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16173v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dimosthenis Pasadakis, Raphael S. Steiner, P\'al Andr\'as Papp, Toni B\"ohnlein, Albert-Jan N. Yzelman</dc:creator>
    </item>
    <item>
      <title>Linear Layouts Revisited: Stacks, Queues, and Exact Algorithms</title>
      <link>https://arxiv.org/abs/2508.16319</link>
      <description>arXiv:2508.16319v1 Announce Type: new 
Abstract: In spite of the extensive study of stack and queue layouts, many fundamental questions remain open concerning the complexity-theoretic frontiers for computing stack and queue layouts. A stack (resp. queue) layout places vertices along a line and assigns edges to pages so that no two edges on the same page are crossing (resp. nested). We provide three new algorithms which together substantially expand our understanding of these problems:
  (1) A fixed-parameter algorithm for computing minimum-page stack and queue layouts w.r.t. the vertex integrity of an n-vertex graph G. This result is motivated by an open question in the literature and generalizes the previous algorithms parameterizing by the vertex cover number of G. The proof relies on a newly developed Ramsey pruning technique. Vertex integrity intuitively measures the vertex deletion distance to a subgraph with only small connected components.
  (2) An n^(O(q * l)) algorithm for computing l-page stack and queue layouts of page width at most q. This is the first algorithm avoiding a double-exponential dependency on the parameters. The page width of a layout measures the maximum number of edges one needs to cross on any page to reach the outer face.
  (3) A 2^(O(n)) algorithm for computing 1-page queue layouts. This improves upon the previously fastest n^(O(n)) algorithm and can be seen as a counterpart to the recent subexponential algorithm for computing 2-page stack layouts [ICALP'24], but relies on an entirely different technique.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16319v1</guid>
      <category>cs.DS</category>
      <category>cs.CG</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Thomas Depian, Simon D. Fink, Robert Ganian, Vaishali Surianarayanan</dc:creator>
    </item>
    <item>
      <title>Going Beyond Twin-width? CSPs with Unbounded Domain and Few Variables</title>
      <link>https://arxiv.org/abs/2508.16389</link>
      <description>arXiv:2508.16389v1 Announce Type: new 
Abstract: We study a model of constraint satisfaction problems geared towards instances with few variables but with domain of unbounded size (udCSP). Our model is inspired by recent work on FPT algorithms for MinCSP where frequently both upper and lower bounds on the parameterized complexity of a problem correspond to $k$-variable udCSPs; e.g., the FPT algorithms for Boolean MinCSP (Kim et al., SODA 2023) and Directed Multicut with three cut requests (Hatzel et al., SODA 2023) both reduce to k-variable udCSPs, and the canonical W[1]-hardness construction in the area, Paired Min Cut by Marx and Razgon (IPL 2009), is effectively a k-variable udCSP.
  The udCSP framework represents constraints with unbounded domains via a collection $\mathcal{M}$ of unary maps into a finite-domain base language $\Gamma$. We develop an algebraic theory for studying the complexity of udCSP$(\Gamma,\mathcal{M})$ with a Galois connection based on partial multifunctions.
  We study three types of maps: unrestricted, one-hot, and monotone. For unrestricted maps, the problem is W[1]-hard for all but trivial cases, and for one-hot maps, the characterization coincides with Marx' FPT dichotomy for Boolean Weighted CSPs (Computational Complexity 2005). For the case of monotone maps Mo, we show that the complexity depends on restricted identifies we call ordered polymorphisms; we identify the "connector" polymorphism as the likely FPT boundary. We show that its absence implies that udCSP($\Gamma$,Mo) defines all permutations, and the problem is W[1]-hard; while its presence for a binary language implies bounded twin-width, and the problem is FPT (Twin-Width IV; Bonnet et al., JACM 2024). For non-binary languages, where twin-width does not apply, the polymorphism coincides with a notion of bounded projected grid-rank; however, we leave the FPT question for this case open.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16389v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Peter Jonsson, Victor Lagerkvist, Jorke M. de Vlas, Magnus Wahlstr\"om</dc:creator>
    </item>
    <item>
      <title>Quality control in sublinear time: a case study via random graphs</title>
      <link>https://arxiv.org/abs/2508.16531</link>
      <description>arXiv:2508.16531v1 Announce Type: new 
Abstract: Many algorithms are designed to work well on average over inputs. When running such an algorithm on an arbitrary input, we must ask: Can we trust the algorithm on this input? We identify a new class of algorithmic problems addressing this, which we call "Quality Control Problems." These problems are specified by a (positive, real-valued) "quality function" $\rho$ and a distribution $D$ such that, with high probability, a sample drawn from $D$ is "high quality," meaning its $\rho$-value is near $1$. The goal is to accept inputs $x \sim D$ and reject potentially adversarially generated inputs $x$ with $\rho(x)$ far from $1$. The objective of quality control is thus weaker than either component problem: testing for "$\rho(x) \approx 1$" or testing if $x \sim D$, and offers the possibility of more efficient algorithms.
  In this work, we consider the sublinear version of the quality control problem, where $D \in \Delta(\{0,1\}^N)$ and the goal is to solve the $(D ,\rho)$-quality problem with $o(N)$ queries and time. As a case study, we consider random graphs, i.e., $D = G_{n,p}$ (and $N = \binom{n}2$), and the $k$-clique count function $\rho_k := C_k(G)/\mathbb{E}_{G' \sim G_{n,p}}[C_k(G')]$, where $C_k(G)$ is the number of $k$-cliques in $G$. Testing if $G \sim G_{n,p}$ with one sample, let alone with sublinear query access to the sample, is of course impossible. Testing if $\rho_k(G)\approx 1$ requires $p^{-\Omega(k^2)}$ samples. In contrast, we show that the quality control problem for $G_{n,p}$ (with $n \geq p^{-ck}$ for some constant $c$) with respect to $\rho_k$ can be tested with $p^{-O(k)}$ queries and time, showing quality control is provably superpolynomially more efficient in this setting. More generally, for a motif $H$ of maximum degree $\Delta(H)$, the respective quality control problem can be solved with $p^{-O(\Delta(H))}$ queries and running time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16531v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <category>math.CO</category>
      <category>math.PR</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Cassandra Marcussen, Ronitt Rubinfeld, Madhu Sudan</dc:creator>
    </item>
    <item>
      <title>Tight (Double) Exponential Bounds for Identification Problems: Locating-Dominating Set and Test Cover</title>
      <link>https://arxiv.org/abs/2402.08346</link>
      <description>arXiv:2402.08346v4 Announce Type: replace 
Abstract: We investigate fine-grained algorithmic aspects of identification problems in graphs and set systems, with a focus on Locating-Dominating Set and Test Cover. We prove the (tight) conditional lower bounds for these problems when parameterized by treewidth and solution as. Formally, \textsc{Locating-Dominating Set} (respectively, \textsc{Test Cover}) parameterized by the treewidth of the input graph (respectively, of the natural auxiliary graph) does not admit an algorithm running in time $2^{2^{o(tw)}} \cdot poly(n)$ (respectively, $2^{2^{o(tw)}} \cdot poly(|U| + |\mathcal{F}|))$. This result augments the small list of NP-Complete problems that admit double exponential lower bounds when parameterized by treewidth. Then, we first prove that \textsc{Locating-Dominating Set} does not admit an algorithm running in time $2^{o(k^2)} \cdot poly(n)$, nor a polynomial time kernelization algorithm that reduces the solution size and outputs a kernel with $2^{o(k)}$ vertices, unless the \ETH\ fails. To the best of our knowledge, \textsc{Locating-Dominating Set} is the first problem that admits such an algorithmic lower-bound (with a quadratic function in the exponent) when parameterized by the solution size. Finally, we prove that \textsc{Test Cover} does not admit an algorithm running in time $2^{2^{o(k)}} \cdot poly(|U| + |\mathcal{F}|)$. This is also a rare example of the problem that admits a double exponential lower bound when parameterized by the solution size.
  We also present algorithms whose running times match the above lower bounds.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.08346v4</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dipayan Chakraborty, Florent Foucaud, Diptapriyo Majumdar, Prafullkumar Tale</dc:creator>
    </item>
    <item>
      <title>The Complexity Landscape of Dynamic Distributed Subgraph Finding</title>
      <link>https://arxiv.org/abs/2411.11544</link>
      <description>arXiv:2411.11544v3 Announce Type: replace 
Abstract: Bonne and Censor-Hillel (ICALP 2019) initiated the study of distributed subgraph finding in dynamic networks of limited bandwidth. For the case where the target subgraph is a clique, they determined the tight bandwidth complexity bounds in nearly all settings. However, several open questions remain, and very little is known about finding subgraphs beyond cliques. In this work, we consider these questions and explore subgraphs beyond cliques in the deterministic setting.
  For finding cliques, we establish an $\Omega(\log \log n)$ bandwidth lower bound for one-round membership-detection under edge insertions only and an $\Omega(\log \log \log n)$ bandwidth lower bound for one-round detection under both edge insertions and node insertions. Moreover, we demonstrate new algorithms to show that our lower bounds are \emph{tight} in bounded-degree networks when the target subgraph is a triangle. Prior to our work, no lower bounds were known for these problems.
  For finding subgraphs beyond cliques, we present a complete characterization of the bandwidth complexity of the membership-listing problem for every target subgraph, every number of rounds, and every type of topological change: node insertions, node deletions, edge insertions, and edge deletions. We also show partial characterizations for one-round membership-detection and listing.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.11544v3</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yi-Jun Chang, Lyuting Chen, Yanyu Chen, Gopinath Mishra, Mingyang Yang</dc:creator>
    </item>
    <item>
      <title>A unified worst case for classical simplex and policy iteration pivot rules</title>
      <link>https://arxiv.org/abs/2309.14034</link>
      <description>arXiv:2309.14034v2 Announce Type: replace-cross 
Abstract: We construct a family of Markov decision processes for which the policy iteration algorithm needs an exponential number of improving switches with Dantzig's rule, with Bland's rule, and with the Largest Increase pivot rule. This immediately translates to a family of linear programs for which the simplex algorithm needs an exponential number of pivot steps with the same three pivot rules. Our results yield a unified construction that simultaneously reproduces well-known lower bounds for these classical pivot rules, and we are able to infer that any (deterministic or randomized) combination of them cannot avoid an exponential worst-case behavior. Regarding the policy iteration algorithm, pivot rules typically switch multiple edges simultaneously and our lower bound for Dantzig's rule and the Largest Increase rule, which perform only single switches, seem novel. Regarding the simplex algorithm, the individual lower bounds were previously obtained separately via deformed hypercube constructions. In contrast to previous bounds for the simplex algorithm via Markov decision processes, our rigorous analysis is reasonably concise.</description>
      <guid isPermaLink="false">oai:arXiv.org:2309.14034v2</guid>
      <category>cs.DM</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yann Disser, Nils Mosis</dc:creator>
    </item>
    <item>
      <title>Static Pricing for Single Sample Multi-unit Prophet Inequalities</title>
      <link>https://arxiv.org/abs/2409.07719</link>
      <description>arXiv:2409.07719v2 Announce Type: replace-cross 
Abstract: In this paper, we study $k$-unit single sample prophet inequalities. A seller has $k$ identical, indivisible items to sell. A sequence of buyers arrive one-by-one, with each buyer's private value for the item, $X_i$, revealed to the seller when they arrive. While the seller is unaware of the distribution from which $X_i$ is drawn, they have access to a single sample, $Y_i$ drawn from the same distribution as $X_i$. What strategies can the seller adopt for selling items so as to maximize social welfare?
  Previous work has demonstrated that when $k = 1$, if the seller sets a price equal to the maximum of the samples, they can achieve a competitive ratio of $\frac{1}{2}$ of the social welfare, and recently Pashkovich and Sayutina established an analogous result for $k = 2$. In this paper, we prove that for $k \geq 3$, setting a (static) price equal to the $k^{\text{th}}$ largest sample also obtains a competitive ratio of $\frac{1}{2}$, resolving a conjecture Pashkovich and Sayutina pose.
  We also consider the situation where $k$ is large. We demonstrate that setting a price equal to the $(k-\sqrt{2k\log k})^{\text{th}}$ largest sample obtains a competitive ratio of $1 - \sqrt{\frac{2\log k}{k}} - o\left(\sqrt{\frac{\log k}{k}}\right)$, and that this is the optimal possible ratio achievable with a static pricing scheme with access to a single sample. This should be compared against a competitive ratio $1 - \sqrt{\frac{\log k}{k}} - o\left(\sqrt{\frac{\log k}{k}}\right)$, which is the optimal possible ratio achievable with a static pricing scheme with knowledge of the distributions of the values.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.07719v2</guid>
      <category>cs.GT</category>
      <category>cs.DS</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Pranav Nuti, Peter Westbrook</dc:creator>
    </item>
    <item>
      <title>An $O(\log \log n)$-approximate budget feasible mechanism for subadditive valuations</title>
      <link>https://arxiv.org/abs/2506.04665</link>
      <description>arXiv:2506.04665v4 Announce Type: replace-cross 
Abstract: In budget-feasible mechanism design, there is a set of items $U$, each owned by a distinct seller. The seller of item $e$ incurs a private cost $\overline{c}_e$ for supplying her item. A buyer wishes to procure a set of items from the sellers of maximum value, where the value of a set $S\subseteq U$ of items is given by a valuation function $v:2^U\to \mathbb{R}_+$. The buyer has a budget of $B \in \mathbb{R}_+$ for the total payments made to the sellers. We wish to design a mechanism that is truthful, that is, sellers are incentivized to report their true costs, budget-feasible, that is, the sum of the payments made to the sellers is at most the budget $B$, and that outputs a set whose value is large compared to $\text{OPT}:=\max\{v(S):\overline{c}(S)\le B,S\subseteq U\}$.
  Budget-feasible mechanism design has been extensively studied, with the literature focussing on (classes of) subadditive valuation functions, and various polytime, budget-feasible mechanisms, achieving constant-factor approximation, have been devised for the special cases of additive, submodular, and XOS valuations. However, for general subadditive valuations, the best-known approximation factor achievable by a polytime budget-feasible mechanism (given access to demand oracles) was only $O(\log n / \log \log n)$, where $n$ is the number of items.
  We improve this state-of-the-art significantly by designing a randomized budget-feasible mechanism for subadditive valuations that achieves a substantially-improved approximation factor of $O(\log\log n)$ and runs in polynomial time, given access to demand oracles.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.04665v4</guid>
      <category>cs.GT</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Mon, 25 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Rian Neogi, Kanstantsin Pashkovich, Chaitanya Swamy</dc:creator>
    </item>
  </channel>
</rss>
