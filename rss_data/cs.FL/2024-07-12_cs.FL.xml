<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Jul 2024 04:00:15 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 12 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>More on Maximally Permissive Similarity Control of Discrete Event Systems</title>
      <link>https://arxiv.org/abs/2407.08068</link>
      <description>arXiv:2407.08068v1 Announce Type: new 
Abstract: Takai proposed a method for constructing a maximally permissive supervisor for the similarity control problem (IEEE Transactions on Automatic Control, 66(7):3197-3204, 2021). This paper points out flaws in his results by providing a counterexample. Inspired by Takai's construction, the notion of a (saturated) (G, R)-automaton is introduced and metatheorems concerning (maximally permissive) supervisors for the similarity control problem are provided in terms of this notion. As an application of these metatheorems, the flaws in Takai's work are corrected.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08068v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yu Wang, Zhaohui Zhu, Rob van Glabbeek, Jinjin Zhang, Lixing Tan</dc:creator>
    </item>
    <item>
      <title>Finite-State Automaton To/From Regular Expression Visualization</title>
      <link>https://arxiv.org/abs/2407.08088</link>
      <description>arXiv:2407.08088v1 Announce Type: new 
Abstract: Most Formal Languages and Automata Theory courses explore the duality between computation models to recognize words in a language and computation models to generate words in a language. For students unaccustomed to formal statements, these transformations are rarely intuitive. To assist students with such transformations, visualization tools can play a pivotal role. This article presents visualization tools developed for FSM -- a domain-specific language for the Automata Theory classroom -- to transform a finite state automaton to a regular expression and vice versa. Using these tools, the user may provide an arbitrary finite-state machine or an arbitrary regular expression and step forward and step backwards through a transformation. At each step, the visualization describes the step taken. The tools are outlined, their implementation is described, and they are compared with related work. In addition, empirical data collected from a control group is presented. The empirical data suggests that the tools are well-received, effective, and learning how to use them has a low extraneous cognitive load.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08088v1</guid>
      <category>cs.FL</category>
      <category>cs.GR</category>
      <category>cs.HC</category>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.405.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 405, 2024, pp. 36-55</arxiv:journal_reference>
      <dc:creator>Marco T. Moraz\'an (Seton Hall University), Tijana Mini\'c (Seton Hall University)</dc:creator>
    </item>
    <item>
      <title>A quadratic upper bound on the reset thresholds of synchronizing automata containing a transitive permutation group</title>
      <link>https://arxiv.org/abs/2407.08135</link>
      <description>arXiv:2407.08135v1 Announce Type: new 
Abstract: For any synchronizing $n$-state deterministic automaton, \v{C}ern\'{y} conjectures the existence of a synchronizing word of length at most $(n-1)^2$. We prove that there exists a synchronizing word of length at most $2n^2 - 7n + 7$ for every synchronizing $n$-state deterministic automaton that satisfies the following two properties: 1. The image of the action of each letter contains at least $n-1$ states; 2. The actions of bijective letters generate a transitive permutation group on the state set.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08135v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yinfeng Zhu</dc:creator>
    </item>
    <item>
      <title>On Tree Automata, Generating Functions, and Differential Equations</title>
      <link>https://arxiv.org/abs/2407.08218</link>
      <description>arXiv:2407.08218v1 Announce Type: new 
Abstract: In this paper we introduce holonomic tree automata: a common extension of weighted tree automata and holonomic recurrences. We show that the generating function of the tree series represented by such an automaton is differentially algebraic. Conversely, we give an algorithm that inputs a differentially algebraic power series, represented as a solution of a rational dynamical system, and outputs an automaton whose generating function is the given series. Such an automaton yields a recurrence that can be used to compute the terms of the power series. We use the algorithm to obtain automaton representations of exponential generating functions of families of combinatorial objects given as combinatorial species. Using techniques from differential algebra, we show that it is decidable both whether two automata represent the same formal tree series and whether they have the same generating function.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08218v1</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Rida Ait El Manssour, Vincent Cheval, Mahsa Shirmohammadi, James Worrell</dc:creator>
    </item>
    <item>
      <title>MITL Model Checking via Generalized Timed Automata and a New Liveness Algorithm</title>
      <link>https://arxiv.org/abs/2407.08452</link>
      <description>arXiv:2407.08452v1 Announce Type: new 
Abstract: The translation of Metric Interval Temporal Logic (MITL) to timed automata is a topic that has been extensively studied. A key challenge here is the conversion of future modalities into equivalent automata. Typical conversions equip the automata with a guess-and-check mechanism to ascertain the truth of future modalities. Guess-and-check can be naturally implemented via alternation. However, since timed automata tools do not handle alternation, existing methods perform an additional step of converting the alternating timed automata into timed automata. This de-alternation step proceeds by an intricate finite abstraction of the space of configurations of the alternating automaton.
  Recently, a model of generalized timed automata (GTA) has been proposed. The model comes with several powerful additional features, and yet, the best known zone-based reachability algorithms for timed automata have been extended to the GTA model, with the same complexity for all the zone operations. We provide a new concise translation from MITL to GTA. In particular, for the timed until modality, our translation offers an exponential improvement w.r.t. the state-of-the-art.
  Thanks to this conversion, MITL model checking reduces to checking liveness for GTAs. However, no liveness algorithm is known for GTAs. Due to the presence of future clocks, there is no finite time-abstract bisimulation (region equivalence) for GTAs, whereas liveness algorithms for timed automata crucially rely on the presence of the finite region equivalence. As our second contribution, we provide a new zone-based algorithm for checking Buchi non-emptiness in GTAs, which circumvents this fundamental challenge.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08452v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>S. Akshay, Paul Gastin, R. Govind, B. Srivathsan</dc:creator>
    </item>
    <item>
      <title>History-Determinism vs Fair Simulation</title>
      <link>https://arxiv.org/abs/2407.08620</link>
      <description>arXiv:2407.08620v1 Announce Type: new 
Abstract: An automaton is history-deterministic if its nondeterminism can be resolved on the fly, only using the prefix of the word read so far. This mild form of nondeterminism has attracted particular attention for its applications in synthesis problems. An automaton $A$ is guidable with respect to a class $C$ of automata if it can fairly simulate every automaton in $C$ whose language is contained in that of $A$. In other words, guidable automata are those for which inclusion and simulation coincide, making them particularly interesting for model-checking.
  We study the connection between these two notions, and specifically the question of when they coincide. For classes of automata on which they do, deciding guidability, an otherwise challenging decision problem, reduces to deciding history-determinism, a problem that is starting to be well-understood for many classes.
  We provide a selection of sufficient criteria for a class of automata to guarantee the coincidence of the notions, and use them to show that the notions coincide for the most common automata classes, among which are $\omega$-regular automata and many infinite-state automata with safety and reachability acceptance conditions, including vector addition systems with states, one-counter nets, pushdown-, Parikh-, and timed-automata.
  We also demonstrate that history-determinism and guidability do not always coincide, for example, for the classes of timed automata with a fixed number of clocks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08620v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Udi Boker, Thomas A. Henzinger, Karoliina Lehtinen, Aditya Prakash</dc:creator>
    </item>
    <item>
      <title>Automata-based constraints for language model decoding</title>
      <link>https://arxiv.org/abs/2407.08103</link>
      <description>arXiv:2407.08103v1 Announce Type: cross 
Abstract: LMs are often expected to generate strings in some formal language; for example, structured data, API calls, or code snippets. Although LMs can be tuned to improve their adherence to formal syntax, this does not guarantee conformance, especially with smaller LMs suitable for large-scale deployment. In addition, tuning requires significant resources, making it impractical for uncommon or task-specific formats. To prevent downstream parsing errors we would ideally constrain the LM to only produce valid output, but this is severely complicated by tokenization, which is typically both ambiguous and misaligned with the formal grammar. We solve these issues through the application of automata theory, deriving an efficient closed-form solution for the regular languages, a broad class of formal languages with many practical applications, including API calls or schema-guided JSON and YAML. We also discuss pragmatic extensions for coping with the issue of high branching factor. Finally, we extend our techniques to deterministic context-free languages, which similarly admit an efficient closed-form solution. In spite of its flexibility and representative power, our approach only requires access to per-token decoding logits and lowers into simple calculations that are independent of LM size, making it both efficient and easy to apply to almost any LM architecture.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.08103v1</guid>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Terry Koo, Frederick Liu, Luheng He</dc:creator>
    </item>
    <item>
      <title>Nominal Tree Automata With Name Allocation</title>
      <link>https://arxiv.org/abs/2405.14272</link>
      <description>arXiv:2405.14272v2 Announce Type: replace 
Abstract: Data trees serve as an abstraction of structured data, such as XML documents. A number of specification formalisms for languages of data trees have been developed, many of them adhering to the paradigm of register automata, which is based on storing data values encountered on the tree in registers for subsequent comparison with further data values. Already on word languages, the expressiveness of such automata models typically increases with the power of control (e.g. deterministic, non-deterministic, alternating). Language inclusion is typically undecidable for non-deterministic or alternating models unless the number of registers is radically restricted, and even then often remains non-elementary. We present an automaton model for data trees that retains a reasonable level of expressiveness, in particular allows non-determinism and any number of registers, while admitting language inclusion checking in elementary complexity, in fact in parametrized exponential time. We phrase the description of our automaton model in the language of nominal sets, building on the recently introduced paradigm of explicit name allocation in nominal automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.14272v2</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Simon Prucker, Lutz Schr\"oder</dc:creator>
    </item>
    <item>
      <title>Bi-reachability in Petri nets with data</title>
      <link>https://arxiv.org/abs/2405.16176</link>
      <description>arXiv:2405.16176v2 Announce Type: replace-cross 
Abstract: We investigate Petri nets with data, an extension of plain Petri nets where tokens carry values from an infinite data domain, and executability of transitions is conditioned by equalities between data values. We provide a decision procedure for the bi-reachability problem: given a Petri net and its two configurations, we ask if each of the configurations is reachable from the other. This pushes forward the decidability borderline, as the bi-reachability problem subsumes the coverability problem (which is known to be decidable) and is subsumed by the reachability problem (whose decidability status is unknown).</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.16176v2</guid>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>{\L}ukasz Kami\'nski, S{\l}awomir Lasota</dc:creator>
    </item>
    <item>
      <title>An automata-based approach for synchronizable mailbox communication</title>
      <link>https://arxiv.org/abs/2407.06968</link>
      <description>arXiv:2407.06968v2 Announce Type: replace-cross 
Abstract: We revisit finite-state communicating systems with round-based communication under mailbox semantics. Mailboxes correspond to one FIFO buffer per process (instead of one buffer per pair of processes in peer-to-peer systems). Round-based communication corresponds to sequences of rounds in which processes can first send messages, then only receive (and receives must be in the same round as their sends). A system is called synchronizable if every execution can be re-scheduled into an equivalent execution that is a sequence of rounds. Previous work mostly considered the setting where rounds have fixed size. Our main contribution shows that the problem whether a mailbox communication system complies with the round-based policy, with no size limitation on rounds, is Pspace-complete. For this we use a novel automata-based approach, that also allows to determine the precise complexity (Pspace) of several questions considered in previous literature.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.06968v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Romain Delpy, Anca Muschcoll, Gr\'egoire Sutre</dc:creator>
    </item>
  </channel>
</rss>
