<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 May 2025 04:00:18 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Inquisitive Team Semantics of LTL</title>
      <link>https://arxiv.org/abs/2505.10700</link>
      <description>arXiv:2505.10700v1 Announce Type: new 
Abstract: In this paper, we introduce a novel team semantics of LTL inspired by inquisitive logic. The main features of the resulting logic, we call InqLTL, are the intuitionistic interpretation of implication and the Boolean semantics of disjunction. We show that InqLTL with Boolean negation is highly undecidable and strictly less expressive than TeamLTL with Boolean negation. On the positive side, we identify a meaningful fragment of InqLTL with a decidable model-checking problem which can express relevant classes of hyperproperties. To the best of our knowledge, this fragment represents
  the first hyper logic with a decidable model-checking problem which allows unrestricted use of temporal modalities and
  universal second-order quantification over traces.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.10700v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Laura Bozzelli, Tadeusz Litak, Munyque Mittelmann, Aniello Murano</dc:creator>
    </item>
    <item>
      <title>Internal Effectful Forcing in System T</title>
      <link>https://arxiv.org/abs/2505.11055</link>
      <description>arXiv:2505.11055v1 Announce Type: new 
Abstract: The effectful forcing technique allows one to show that the denotation of a closed System T term of type $(\iota \to \iota) \to \iota$ in the set-theoretical model is a continuous function $(\mathbb{N} \to \mathbb{N}) \to \mathbb{N}$. For this purpose, an alternative dialogue-tree semantics is defined and related to the set-theoretical semantics by a logical relation. In this paper, we apply effectful forcing to show that the dialogue tree of a System T term is itself System T-definable, using the Church encoding of trees.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.11055v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Martin H. Escardo, Bruno da Rocha Paiva, Vincent Rahli, Ayberk Tosun</dc:creator>
    </item>
    <item>
      <title>Most General Explanations of Tree Ensembles</title>
      <link>https://arxiv.org/abs/2505.10991</link>
      <description>arXiv:2505.10991v1 Announce Type: cross 
Abstract: Explainable Artificial Intelligence (XAI) is critical for attaining trust in the operation of AI systems. A key question of an AI system is ``why was this decision made this way''. Formal approaches to XAI use a formal model of the AI system to identify abductive explanations. While abductive explanations may be applicable to a large number of inputs sharing the same concrete values, more general explanations may be preferred for numeric inputs. So-called inflated abductive explanations give intervals for each feature ensuring that any input whose values fall withing these intervals is still guaranteed to make the same prediction. Inflated explanations cover a larger portion of the input space, and hence are deemed more general explanations. But there can be many (inflated) abductive explanations for an instance. Which is the best? In this paper, we show how to find a most general abductive explanation for an AI decision. This explanation covers as much of the input space as possible, while still being a correct formal explanation of the model's behaviour. Given that we only want to give a human one explanation for a decision, the most general explanation gives us the explanation with the broadest applicability, and hence the one most likely to seem sensible. (The paper has been accepted at IJCAI2025 conference.)</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.10991v1</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Yacine Izza, Alexey Ignatiev, Joao Marques-Silva, Peter J. Stuckey</dc:creator>
    </item>
    <item>
      <title>Halting Recurrent GNNs and the Graded $\mu$-Calculus</title>
      <link>https://arxiv.org/abs/2505.11050</link>
      <description>arXiv:2505.11050v1 Announce Type: cross 
Abstract: Graph Neural Networks (GNNs) are a class of machine-learning models that operate on graph-structured data. Their expressive power is intimately related to logics that are invariant under graded bisimilarity. Current proposals for recurrent GNNs either assume that the graph size is given to the model, or suffer from a lack of termination guarantees. In this paper, we propose a halting mechanism for recurrent GNNs. We prove that our halting model can express all node classifiers definable in graded modal mu-calculus, even for the standard GNN variant that is oblivious to the graph size. A recent breakthrough in the study of the expressivity of graded modal mu-calculus in the finite suggests that conversely, restricted to node classifiers definable in monadic second-order logic, recurrent GNNs can express only node classifiers definable in graded modal mu-calculus. To prove our main result, we develop a new approximate semantics for graded mu-calculus, which we believe to be of independent interest. We leverage this new semantics into a new model-checking algorithm, called the counting algorithm, which is oblivious to the graph size. In a final step we show that the counting algorithm can be implemented on a halting recurrent GNN.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.11050v1</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jeroen Bollen, Jan Van den Bussche, Stijn Vansummeren, Jonni Virtema</dc:creator>
    </item>
    <item>
      <title>Separability Properties of Monadically Dependent Graph Classes</title>
      <link>https://arxiv.org/abs/2505.11144</link>
      <description>arXiv:2505.11144v1 Announce Type: cross 
Abstract: A graph class $\mathcal C$ is monadically dependent if one cannot interpret all graphs in colored graphs from $\mathcal C$ using a fixed first-order interpretation. We prove that monadically dependent classes can be exactly characterized by the following property, which we call flip-separability: for every $r\in \mathbb{N}$, $\varepsilon&gt;0$, and every graph $G\in \mathcal{C}$ equipped with a weight function on vertices, one can apply a bounded (in terms of $\mathcal{C},r,\varepsilon$) number of flips (complementations of the adjacency relation on a subset of vertices) to $G$ so that in the resulting graph, every radius-$r$ ball contains at most an $\varepsilon$-fraction of the total weight. On the way to this result, we introduce a robust toolbox for working with various notions of local separations in monadically dependent classes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.11144v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>\'Edouard Bonnet, Samuel Braunfeld, Ioannis Eleftheriadis, Colin Geniet, Nikolas M\"ahlmann, Micha{\l} Pilipczuk, Wojciech Przybyszewski, Szymon Toru\'nczyk</dc:creator>
    </item>
    <item>
      <title>Symbolic Model Checking in External Memory</title>
      <link>https://arxiv.org/abs/2505.11229</link>
      <description>arXiv:2505.11229v1 Announce Type: cross 
Abstract: We extend the external memory BDD package Adiar with support for monotone variable substitution. Doing so, it now supports the relational product operation at the heart of symbolic model checking. We also identify additional avenues for merging variable substitution fully and the conjunction operation partially inside the relational product's existential quantification step. For smaller BDDs, these additional ideas improve the running of Adiar for model checking tasks up to 47%. For larger instances, the computation time is mostly unaffected as it is dominated by the existential quantification.
  Adiar's relational product is about one order of magnitude slower than conventional depth-first BDD implementations. Yet, its I/O-efficiency allows its running time to be virtually independent of the amount of internal memory. This allows it to compute on BDDs with much less internal memory and potentially to solve model checking tasks beyond the reach of conventional implementations.
  Compared to the only other external memory BDD package, CAL, Adiar is several orders of magnitude faster when computing on larger instances.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.11229v1</guid>
      <category>cs.DS</category>
      <category>cs.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Steffan Christ S{\o}lvsten, Jaco van de Pol</dc:creator>
    </item>
    <item>
      <title>Containment for Guarded Monotone Strict NP</title>
      <link>https://arxiv.org/abs/2310.01254</link>
      <description>arXiv:2310.01254v4 Announce Type: replace 
Abstract: Guarded Monotone Strict NP (GMSNP) extends Monotone Monadic Strict NP (MMSNP) by guarded existentially quantified predicates of arbitrary arities. We prove that the containment problem for GMSNP is decidable, thereby settling an open question of Bienvenu, ten Cate, Lutz, and Wolter, later restated by Bourhis and Lutz. Our proof also comes with a 2NEXPTIME upper bound on the complexity of the problem, which matches the lower bound for containment of MMSNP due to Bourhis and Lutz. In order to obtain these results, we significantly improve the state of knowledge of the model-theoretic properties of GMSNP. Bodirsky, Kn\"{a}uer, and Starke previously showed that every GMSNP sentence defines a finite union of CSPs of $\omega$-categorical structures. We show that these structures can be used to obtain a reduction from the containment problem for GMSNP to the much simpler problem of testing the existence of a certain map called recolouring, albeit in a more general setting than GMSNP; a careful analysis of this yields said upper bound. As a secondary contribution, we refine the construction of Bodirsky, Kn\"{a}uer, and Starke by adding a restricted form of homogeneity to the properties of these structures, making the logic amenable to future complexity classifications for query evaluation using techniques developed for infinite-domain CSPs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.01254v4</guid>
      <category>cs.LO</category>
      <category>cs.DB</category>
      <category>math.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexey Barsukov, Michael Pinsker, Jakub Rydval</dc:creator>
    </item>
    <item>
      <title>The Cost of Skeletal Call-by-Need, Smoothly</title>
      <link>https://arxiv.org/abs/2505.09242</link>
      <description>arXiv:2505.09242v2 Announce Type: replace 
Abstract: Skeletal call-by-need is an optimization of call-by-need evaluation also known as "fully lazy sharing": when the duplication of a value has to take place, it is first split into "skeleton", which is then duplicated, and "flesh" which is instead kept shared. Here, we provide two cost analyses of skeletal call-by-need. Firstly, we provide a family of terms showing that skeletal call-by-need can be asymptotically exponentially faster than call-by-need in both time and space; it is the first such evidence, to our knowledge. Secondly, we prove that skeletal call-by-need can be implemented efficiently, that is, with bi-linear overhead. This result is obtained by providing a new smooth presentation of ideas by Shivers and Wand for the reconstruction of skeletons, which is then smoothly plugged into the study of an abstract machine following the distillation technique by Accattoli et al.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.09242v2</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Beniamino Accattoli, Francesco Magliocca, Lo\"ic Peyrot, Claudio Sacerdoti Coen</dc:creator>
    </item>
    <item>
      <title>Random Variables, Conditional Independence and Categories of Abstract Sample Spaces</title>
      <link>https://arxiv.org/abs/2503.02477</link>
      <description>arXiv:2503.02477v2 Announce Type: replace-cross 
Abstract: Two high-level "pictures" of probability theory have emerged: one that takes as central the notion of random variable, and one that focuses on distributions and probability channels (Markov kernels). While the channel-based picture has been successfully axiomatized, and widely generalized, using the notion of Markov category, the categorical semantics of the random variable picture remain less clear. Simpson's probability sheaves are a recent approach, in which probabilistic concepts like random variables are allowed vary over a site of sample spaces. Simpson has identified rich structure on these sites, most notably an abstract notion of conditional independence, and given examples ranging from probability over databases to nominal sets. We aim bring this development together with the generality and abstraction of Markov categories: We show that for any suitable Markov category, a category of sample spaces can be defined which satisfies Simpson's axioms, and that a theory of probability sheaves can be developed purely synthetically in this setting. We recover Simpson's examples in a uniform fashion from well-known Markov categories, and consider further generalizations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.02477v2</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.PR</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dario Stein</dc:creator>
    </item>
    <item>
      <title>The commutativity problem for effective varieties of formal series, and applications</title>
      <link>https://arxiv.org/abs/2503.21697</link>
      <description>arXiv:2503.21697v2 Announce Type: replace-cross 
Abstract: A formal series in noncommuting variables $\Sigma$ over the rationals is a mapping $\Sigma^* \to \mathbb Q$. We say that a series is commutative if the value in the output does not depend on the order of the symbols in the input. The commutativity problem for a class of series takes as input a (finite presentation of) a series from the class and amounts to establishing whether it is commutative. This is a very natural, albeit nontrivial problem, which has not been considered before from an algorithmic perspective.
  We show that commutativity is decidable for all classes of series that constitute a so-called effective prevariety, a notion generalising Reutenauer's varieties of formal series. For example, the class of rational series, introduced by Sch\"utzenberger in the 1960's, is well-known to be an effective (pre)variety, and thus commutativity is decidable for it.
  In order to showcase the applicability of our result, we consider classes of formal series generalising the rational ones. We consider polynomial automata, shuffle automata, and infiltration automata, and we show that each of these models recognises an effective prevariety of formal series. Consequently, their commutativity problem is decidable, which is a novel result. We find it remarkable that commutativity can be decided in a uniform way for such disparate computation models.
  Finally, we present applications of commutativity outside the theory of formal series. We show that we can decide solvability in sequences and in power series for restricted classes of algebraic difference and differential equations, for which such problems are undecidable in full generality. Thanks to this, we can prove that the syntaxes of multivariate polynomial recursive sequences and of constructible differentially algebraic power series are effective, which are new results which were left open in previous work.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.21697v2</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <pubDate>Mon, 19 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Lorenzo Clemente</dc:creator>
    </item>
  </channel>
</rss>
