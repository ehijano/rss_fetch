<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CC</link>
    <description>cs.CC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Jul 2024 04:00:01 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 19 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Liquid Amortization: Proving Amortized Complexity with LiquidHaskell (Functional Pearl)</title>
      <link>https://arxiv.org/abs/2407.13671</link>
      <description>arXiv:2407.13671v1 Announce Type: new 
Abstract: Formal reasoning about the time complexity of algorithms and data structures is usually done in interactive theorem provers like Isabelle/HOL. This includes reasoning about amortized time complexity which looks at the worst case performance over a series of operations. However, most programs are not written within a theorem prover and thus use the data structures of the production language. To verify the correctness it is necessary to translate the data structures from the production language into the language of the prover. Such a translation step could introduce errors, for example due to a mismatch in features between the two languages. We show how to prove amortized complexity of data structures directly in Haskell using LiquidHaskell. Besides skipping the translation step, our approach can also provide a didactic advantage. Learners do not have to learn an additional language for proofs and can focus on the new concepts only. For this paper, we do not assume prior knowledge of amortized complexity as we explain the concepts and apply them in our first case study, a simple stack with multipop. Moving to more complicated (and useful) data structures, we show that the same technique works for binomial heaps which can be used to implement a priority queue. We also prove amortized complexity bounds for Claessen's version of the finger tree, a sequence-like data structure with constant-time cons/uncons on either end. Finally we discuss the current limitations of LiquidHaskell that made certain versions of the data structures not feasible.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.13671v1</guid>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3677999.3678282</arxiv:DOI>
      <dc:creator>Jan van Br\"ugge</dc:creator>
    </item>
    <item>
      <title>On the Computation of the Zariski Closure of Finitely Generated Groups of Matrices</title>
      <link>https://arxiv.org/abs/2106.01853</link>
      <description>arXiv:2106.01853v5 Announce Type: replace 
Abstract: We investigate the complexity of computing the Zariski closure of a finitely generated group of matrices. The Zariski closure was previously shown to be computable by Derksen, Jeandel, and Koiran, but the termination argument for their algorithm appears not to yield any complexity bound. In this paper we follow a different approach and obtain a bound on the degree of the polynomials that define the closure. Our bound shows that the closure can be computed in elementary time. We also obtain upper bounds on the length of chains of linear algebraic groups, where all the groups are generated over a fixed number field.</description>
      <guid isPermaLink="false">oai:arXiv.org:2106.01853v5</guid>
      <category>cs.CC</category>
      <category>math.AG</category>
      <category>math.GR</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1145/3476446.3536172</arxiv:DOI>
      <arxiv:journal_reference>Proceedings of the 2022 International Symposium on Symbolic and Algebraic Computation (ISSAC'22), pp. 129--138</arxiv:journal_reference>
      <dc:creator>Klara Nosan, Amaury Pouly, Sylvain Schmitz, Mahsa Shirmohammadi, James Worrell</dc:creator>
    </item>
    <item>
      <title>Parameterized Complexity of Streaming Diameter and Connectivity Problems</title>
      <link>https://arxiv.org/abs/2207.04872</link>
      <description>arXiv:2207.04872v2 Announce Type: replace-cross 
Abstract: We initiate the investigation of the parameterized complexity of Diameter and Connectivity in the streaming paradigm. On the positive end, we show that knowing a vertex cover of size $k$ allows for algorithms in the Adjacency List (AL) streaming model whose number of passes is constant and memory is $O(\log n)$ for any fixed $k$. Underlying these algorithms is a method to execute a breadth-first search in $O(k)$ passes and $O(k \log n)$ bits of memory. On the negative end, we show that many other parameters lead to lower bounds in the AL model, where $\Omega(n/p)$ bits of memory is needed for any $p$-pass algorithm even for constant parameter values. In particular, this holds for graphs with a known modulator (deletion set) of constant size to a graph that has no induced subgraph isomorphic to a fixed graph $H$, for most $H$. For some cases, we can also show one-pass, $\Omega(n \log n)$ bits of memory lower bounds. We also prove a much stronger $\Omega(n^2/p)$ lower bound for Diameter on bipartite graphs.
  Finally, using the insights we developed into streaming parameterized graph exploration algorithms, we show a new streaming kernelization algorithm for computing a vertex cover of size $k$. This yields a kernel of $2k$ vertices (with $O(k^2)$ edges) produced as a stream in $\text{poly}(k)$ passes and only $O(k \log n)$ bits of memory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2207.04872v2</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jelle J. Oostveen, Erik Jan van Leeuwen</dc:creator>
    </item>
    <item>
      <title>Classical and quantum Merlin-Arthur automata</title>
      <link>https://arxiv.org/abs/2212.13801</link>
      <description>arXiv:2212.13801v2 Announce Type: replace-cross 
Abstract: We introduce Merlin-Arthur (MA) automata where Merlin provides a certificate at the beginning of computation and it is scanned by Arthur before reading the input. We define Merlin-Arthur deterministic, probabilistic, and quantum finite state automata (resp., MA-DFAs, MA-PFAs, and MA-QFAs) and postselecting MA-PFAs and MA-QFAs (resp., MA-PostPFA and MA-PostQFA). We present several results using different certificate lengths.
  We show that MA-DFAs use constant length certificates, and they are equivalent to multi-entry DFAs. Thus, they recognize all and only regular languages, but they can be exponential and polynomial state efficient over binary and unary languages, respectively. With sublinear length certificates, MA-PFAs can recognize several nonstochastic unary languages with cutpoint 1/2. With linear length certificates, MA-PostPFAs can recognize these nonstochastic unary languages with bounded error. With arbitrarily long certificates, bounded-error MA-PostPFAs can verify every unary decidable language. With sublinear length certificates, bounded-error MA-PostQFAs can verify several nonstochastic unary languages. With linear length certificates, they can verify every unary language and some NP-complete binary languages. With exponential length certificates, they can verify every binary language.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.13801v2</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <category>quant-ph</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Abuzer Yakary{\i}lmaz</dc:creator>
    </item>
    <item>
      <title>On the Pauli Spectrum of QAC0</title>
      <link>https://arxiv.org/abs/2311.09631</link>
      <description>arXiv:2311.09631v4 Announce Type: replace-cross 
Abstract: The circuit class $\mathsf{QAC}^0$ was introduced by Moore (1999) as a model for constant depth quantum circuits where the gate set includes many-qubit Toffoli gates. Proving lower bounds against such circuits is a longstanding challenge in quantum circuit complexity; in particular, showing that polynomial-size $\mathsf{QAC}^0$ cannot compute the parity function has remained an open question for over 20 years.
  In this work, we identify a notion of the Pauli spectrum of $\mathsf{QAC}^0$ circuits, which can be viewed as the quantum analogue of the Fourier spectrum of classical $\mathsf{AC}^0$ circuits. We conjecture that the Pauli spectrum of $\mathsf{QAC}^0$ circuits satisfies low-degree concentration, in analogy to the famous Linial, Nisan, Mansour theorem on the low-degree Fourier concentration of $\mathsf{AC}^0$ circuits. If true, this conjecture immediately implies that polynomial-size $\mathsf{QAC}^0$ circuits cannot compute parity.
  We prove this conjecture for the class of depth-$d$, polynomial-size $\mathsf{QAC}^0$ circuits with at most $n^{O(1/d)}$ auxiliary qubits. We obtain new circuit lower bounds and learning results as applications: this class of circuits cannot correctly compute
  - the $n$-bit parity function on more than $(\frac{1}{2} + 2^{-\Omega(n^{1/d})})$-fraction of inputs, and
  - the $n$-bit majority function on more than $(1 - \Omega(n^{-1/2}))$-fraction of inputs.
  Additionally we show that this class of $\mathsf{QAC}^0$ circuits with limited auxiliary qubits can be learned with quasipolynomial sample complexity, giving the first learning result for $\mathsf{QAC}^0$ circuits.
  More broadly, our results add evidence that "Pauli-analytic" techniques can be a powerful tool in studying quantum circuits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.09631v4</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3618260.3649662</arxiv:DOI>
      <arxiv:journal_reference>STOC 2024: Proceedings of the 56th Annual ACM Symposium on Theory of Computing, 1498-1506</arxiv:journal_reference>
      <dc:creator>Shivam Nadimpalli, Natalie Parham, Francisca Vasconcelos, Henry Yuen</dc:creator>
    </item>
  </channel>
</rss>
