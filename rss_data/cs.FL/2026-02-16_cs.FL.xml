<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Feb 2026 05:00:05 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 16 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Fast and General Automatic Differentiation for Finite-State Methods</title>
      <link>https://arxiv.org/abs/2602.12300</link>
      <description>arXiv:2602.12300v1 Announce Type: new 
Abstract: We propose a new method, that we coined the ``morphism-trick'', to integrate custom implementations of vector-Jacobian products in automatic differentiation softwares, applicable to a wide range of semiring-based computations. Our approach leads to efficient and semiring-agnostic implementations of the backward pass of dynamic programming algorithms. For the particular case of finite-state methods, we introduce an algorithm that computes and differentiates the $\oplus$-sum of all paths' weight of a finite-state automaton. Results show that, with minimal effort from the user, our novel library allows computing the gradient of a function w.r.t. to the weights of a finite state automaton orders of magnitude faster than state-of-the-art automatic differentiation systems. Implementations are made available via an open-source library distributed under a permissive license.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.12300v1</guid>
      <category>cs.FL</category>
      <pubDate>Mon, 16 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Lucas Ondel Yang (LISN, CNRS), Tina Raissi (RWTH Aachen), Martin Kocour (FIT / BUT, BUT), Pablo Riera (ICC), Caio Corro (LinkMedia, INSA Rennes, IRISA)</dc:creator>
    </item>
    <item>
      <title>Out-of-Order Membership to Regular Languages</title>
      <link>https://arxiv.org/abs/2602.13100</link>
      <description>arXiv:2602.13100v1 Announce Type: new 
Abstract: We introduce the task of out-of-order membership to a formal language L, where the letters of a word w are revealed one by one in an adversarial order. The length |w| is known in advance, but the content of w is streamed as pairs (i, w[i]), received exactly once for each position i, in arbitrary order. We study efficient algorithms for this task when L is regular, seeking tight complexity bounds as a function of |w| for a fixed target language. Most of our results apply to an algebraically defined variant dubbed out-of-order evaluation: this problem is defined for a fixed finite monoid or semigroup S, and our goal is to compute the ordered product of the streamed elements of w.
  We show that, for any fixed regular language or finite semigroup, both problems can be solved in constant time per streamed symbol and in linear space. However, the precise space complexity strongly depends on the algebraic structure of the target language or evaluation semigroup. Our main contributions are therefore to show (deterministic) space complexity characterizations, which we do for out-of-order evaluation of monoids and semigroups.
  For monoids, we establish a trichotomy: the space complexity is either {\Theta}(1), {\Theta}(log n), or {\Theta}(n), where n = |w|. More specifically, the problem admits a constant-space solution for commutative monoids, while all non-commutative monoids require {\Omega}(log n) space. We further identify a class of monoids admitting an O(log n)-space algorithm, and show that all remaining monoids require {\Omega}(n) space.
  For general semigroups, the situation is more intricate. We characterize a class of semigroups admitting constant-space algorithms for out-of-order evaluation, and show that semigroups outside this class require at least {\Omega}(log n) space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.13100v1</guid>
      <category>cs.FL</category>
      <category>cs.DS</category>
      <pubDate>Mon, 16 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antoine Amarilli, Sebastien Labbe, Charles Paperman</dc:creator>
    </item>
    <item>
      <title>Interpolation-Inspired Closure Certificates</title>
      <link>https://arxiv.org/abs/2602.12436</link>
      <description>arXiv:2602.12436v1 Announce Type: cross 
Abstract: Barrier certificates, a form of state invariants, provide an automated approach to the verification of the safety of dynamical systems. Similarly to barrier certificates, recent works explore the notion of closure certificates, a form of transition invariants, to verify dynamical systems against $\omega$-regular properties including safety. A closure certificate, defined over state pairs of a dynamical system, is a real-valued function whose zero superlevel set characterizes an inductive transition invariant of the system. The search for such a certificate can be effectively automated by assuming it to be within a specific template class, e.g. a polynomial of a fixed degree, and then using optimization techniques such as sum-of-squares (SOS) programming to find it. Unfortunately, one may not be able to find such a certificate for a fixed template. In such a case, one must change the template, e.g. increase the degree of the polynomial. In this paper, we consider a notion of multiple closure certificates dubbed interpolation-inspired closure certificates. An interpolation-inspired closure certificate consists of a set of functions which jointly over-approximate a transition invariant by first considering one-step transitions, then two, and so on until a transition invariant is obtained. The advantage of interpolation-inspired closure certificates is that they allow us to prove properties even when a single function for a fixed template cannot be found using standard approaches. We present SOS programming and a scenario program to find these sets of functions and demonstrate the effectiveness of our proposed method to verify persistence and general $\omega$-regular specifications in some case studies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.12436v1</guid>
      <category>eess.SY</category>
      <category>cs.FL</category>
      <category>cs.SY</category>
      <pubDate>Mon, 16 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Mohammed Adib Oumer, Vishnu Murali, Majid Zamani</dc:creator>
    </item>
    <item>
      <title>Continuous Diffusion Models Can Obey Formal Syntax</title>
      <link>https://arxiv.org/abs/2602.12468</link>
      <description>arXiv:2602.12468v1 Announce Type: cross 
Abstract: Diffusion language models offer a promising alternative to autoregressive models due to their global, non-causal generation process, but their continuous latent dynamics make discrete constraints -- e.g., the output should be a JSON file that matches a given schema -- difficult to impose. We introduce a training-free guidance method for steering continuous diffusion language models to satisfy formal syntactic constraints expressed using regular expressions. Our approach constructs an analytic score estimating the probability that a latent state decodes to a valid string accepted by a given regular expression, and uses its gradient to guide sampling, without training auxiliary classifiers. The denoising process targets the base model conditioned on syntactic validity.
  We implement our method in Diffinity on top of the PLAID diffusion model and evaluate it on 180 regular-expression constraints over JSON and natural-language benchmarks. Diffinity achieves 68-96\% constraint satisfaction while incurring only a small perplexity cost relative to unconstrained sampling, outperforming autoregressive constrained decoding in both constraint satisfaction and output quality.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.12468v1</guid>
      <category>cs.LG</category>
      <category>cs.FL</category>
      <pubDate>Mon, 16 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jinwoo Kim, Taylor Berg-Kirkpatrick, Loris D'Antoni</dc:creator>
    </item>
    <item>
      <title>Classification of Local Optimization Problems in Directed Cycles</title>
      <link>https://arxiv.org/abs/2602.13046</link>
      <description>arXiv:2602.13046v1 Announce Type: cross 
Abstract: We present a complete classification of the distributed computational complexity of local optimization problems in directed cycles for both the deterministic and the randomized LOCAL model. We show that for any local optimization problem $\Pi$ (that can be of the form min-sum, max-sum, min-max, or max-min, for any local cost or utility function over some finite alphabet), and for any \emph{constant} approximation ratio $\alpha$, the task of finding an $\alpha$-approximation of $\Pi$ in directed cycles has one of the following complexities:
  1. $O(1)$ rounds in deterministic LOCAL, $O(1)$ rounds in randomized LOCAL,
  2. $\Theta(\log^* n)$ rounds in deterministic LOCAL, $O(1)$ rounds in randomized LOCAL,
  3. $\Theta(\log^* n)$ rounds in deterministic LOCAL, $\Theta(\log^* n)$ rounds in randomized LOCAL,
  4. $\Theta(n)$ rounds in deterministic LOCAL, $\Theta(n)$ rounds in randomized LOCAL.
  Moreover, for any given $\Pi$ and $\alpha$, we can determine the complexity class automatically, with an efficient (centralized, sequential) meta-algorithm, and we can also efficiently synthesize an asymptotically optimal distributed algorithm.
  Before this work, similar results were only known for local search problems (e.g., locally checkable labeling problems). The family of local optimization problems is a strict generalization of local search problems, and it contains numerous commonly studied distributed tasks, such as the problems of finding approximations of the maximum independent set, minimum vertex cover, minimum dominating set, and minimum vertex coloring.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.13046v1</guid>
      <category>cs.DC</category>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <pubDate>Mon, 16 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Thomas Boudier, Fabian Kuhn, Augusto Modanese, Ronja Stimpert, Jukka Suomela</dc:creator>
    </item>
    <item>
      <title>Online Monitoring of Metric Temporal Logic using Sequential Networks</title>
      <link>https://arxiv.org/abs/1901.00175</link>
      <description>arXiv:1901.00175v5 Announce Type: replace-cross 
Abstract: Metric Temporal Logic (MTL) is a popular formalism to specify temporal patterns with timing constraints over the behavior of cyber-physical systems with application areas ranging in property-based testing, robotics, optimization, and learning. This paper focuses on the unified construction of sequential networks from MTL specifications over discrete and dense time behaviors to provide an efficient and scalable online monitoring framework. Our core technique, future temporal marking, utilizes interval-based symbolic representations of future discrete and dense timelines. Building upon this, we develop efficient update and output functions for sequential network nodes for timed temporal operations. Finally, we extensively test and compare our proposed technique with existing approaches and runtime verification tools. Results highlight the performance and scalability advantages of our monitoring approach and sequential networks.</description>
      <guid isPermaLink="false">oai:arXiv.org:1901.00175v5</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Mon, 16 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dogan Ulus</dc:creator>
    </item>
  </channel>
</rss>
