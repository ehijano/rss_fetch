<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Jun 2025 04:00:02 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Relative Error Fair Clustering in the Weak-Strong Oracle Model</title>
      <link>https://arxiv.org/abs/2506.12287</link>
      <description>arXiv:2506.12287v1 Announce Type: new 
Abstract: We study fair clustering problems in a setting where distance information is obtained from two sources: a strong oracle providing exact distances, but at a high cost, and a weak oracle providing potentially inaccurate distance estimates at a low cost. The goal is to produce a near-optimal fair clustering on $n$ input points with a minimum number of strong oracle queries. This models the increasingly common trade-off between accurate but expensive similarity measures (e.g., large-scale embeddings) and cheaper but inaccurate alternatives. The study of fair clustering in the model is motivated by the important quest of achieving fairness with the presence of inaccurate information. We achieve the first $(1+\varepsilon)$-coresets for fair $k$-median clustering using $\text{poly}\left(\frac{k}{\varepsilon}\cdot\log n\right)$ queries to the strong oracle. Furthermore, our results imply coresets for the standard setting (without fairness constraints), and we could in fact obtain $(1+\varepsilon)$-coresets for $(k,z)$-clustering for general $z=O(1)$ with a similar number of strong oracle queries. In contrast, previous results achieved a constant-factor $(&gt;10)$ approximation for the standard $k$-clustering problems, and no previous work considered the fair $k$-median clustering problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12287v1</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vladimir Braverman, Prathamesh Dharangutte, Shaofeng H. -C. Jiang, Hoai-An Nguyen, Chen Wang, Yubo Zhang, Samson Zhou</dc:creator>
    </item>
    <item>
      <title>A polynomial delay algorithm generating all potential maximal cliques in triconnected planar graphs</title>
      <link>https://arxiv.org/abs/2506.12635</link>
      <description>arXiv:2506.12635v1 Announce Type: new 
Abstract: We develop a new characterization of potential maximal cliques of a triconnected planar graph and, using this characterization, give a polynomial delay algorithm generating all potential maximal cliques of a given triconnected planar graph. Combined with the dynamic programming algorithms due to Bouchitt{\'e} and Todinca, this algorithm leads to a treewidth algorithm for general planar graphs that runs in time linear in the number of potential maximal cliques and polynomial in the number of vertices.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12635v1</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander Grigoriev, Yasuaki Kobayashi, Hisao Tamaki, Tom C. van der Zanden</dc:creator>
    </item>
    <item>
      <title>Approximations for Fault-Tolerant Total and Partial Positive Influence Domination</title>
      <link>https://arxiv.org/abs/2506.12828</link>
      <description>arXiv:2506.12828v1 Announce Type: new 
Abstract: In $\textit{total domination}$, given a graph $G=(V,E)$, we seek a minimum-size set of nodes $S\subseteq V$, such that every node in $V$ has at least one neighbor in $S$. We define a $\textit{fault-tolerant}$ version of total domination, where we require any node in $V \setminus S$ to have at least $m$ neighbors in $S$. Let $\Delta$ denote the maximum degree in $G$. We prove a first $1 + \ln(\Delta + m - 1)$ approximation for fault-tolerant total domination. We also consider fault-tolerant variants of the weighted $\textit{partial positive influence dominating set}$ problem, where we seek a minimum-size set of nodes $S\subseteq V$, such that every node in $V$ is either a member of $S$ or the sum of weights of its incident edges leading to nodes in $S$ is at least half of the sum of weights over all its incident edges. We prove the first logarithmic approximations for the simple, total, and connected variants of this problem. To prove the result for the connected case, we extend the general approximation framework for non-submodular functions from integer-valued to fractional-valued functions, which we believe is of independent interest.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12828v1</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ioannis Lamprou, Ioannis Sigalas, Ioannis Vaxevanakis, Vassilis Zissimopoulos</dc:creator>
    </item>
    <item>
      <title>Downstream: efficient cross-platform algorithms for fixed-capacity stream downsampling</title>
      <link>https://arxiv.org/abs/2506.12975</link>
      <description>arXiv:2506.12975v1 Announce Type: new 
Abstract: Due to ongoing accrual over long durations, a defining characteristic of real-world data streams is the requirement for rolling, often real-time, mechanisms to coarsen or summarize stream history. One common data structure for this purpose is the ring buffer, which maintains a running downsample comprising most recent stream data. In some downsampling scenarios, however, it can instead be necessary to maintain data items spanning the entirety of elapsed stream history. Fortunately, approaches generalizing the ring buffer mechanism have been devised to support alternate downsample compositions, while maintaining the ring buffer's update efficiency and optimal use of memory capacity. The Downstream library implements algorithms supporting three such downsampling generalizations: (1) "steady," which curates data evenly spaced across the stream history; (2) "stretched," which prioritizes older data; and (3) "tilted," which prioritizes recent data. To enable a broad spectrum of applications ranging from embedded devices to high-performance computing nodes and AI/ML hardware accelerators, Downstream supports multiple programming languages, including C++, Rust, Python, Zig, and the Cerebras Software Language. For seamless interoperation, the library incorporates distribution through multiple packaging frameworks, extensive cross-implementation testing, and cross-implementation documentation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12975v1</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Connor Yang, Joey Wagner, Emily Dolson, Luis Zaman, Matthew Andres Moreno</dc:creator>
    </item>
    <item>
      <title>The Densest SWAMP problem: subhypergraphs with arbitrary monotonic partial edge rewards</title>
      <link>https://arxiv.org/abs/2506.12998</link>
      <description>arXiv:2506.12998v1 Announce Type: new 
Abstract: We consider a generalization of the densest subhypergraph problem where nonnegative rewards are given for including partial hyperedges in a dense subhypergraph. Prior work addressed this problem only in cases where reward functions are convex, in which case the problem is poly-time solvable. We consider a broader setting where rewards are monotonic but otherwise arbitrary. We first prove hardness results for a wide class of non-convex rewards, then design a 1/k-approximation by projecting to the nearest set of convex rewards, where k is the maximum hyperedge size. We also design another 1/k-approximation using a faster peeling algorithm, which (somewhat surprisingly) differs from the standard greedy peeling algorithm used to approximate other variants of the densest subgraph problem. Our results include an empirical analysis of our algorithm across several real-world hypergraphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12998v1</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vedangi Bengali, Nikolaj Tatti, Iiro Kumpulainen, Florian Adriaens, Nate Veldt</dc:creator>
    </item>
    <item>
      <title>Efficient Approximate Temporal Triangle Counting in Streaming with Predictions</title>
      <link>https://arxiv.org/abs/2506.13173</link>
      <description>arXiv:2506.13173v1 Announce Type: new 
Abstract: Triangle counting is a fundamental and widely studied problem on static graphs, and recently on temporal graphs, where edges carry information on the timings of the associated events. Streaming processing and resource efficiency are crucial requirements for counting triangles in modern massive temporal graphs, with millions of nodes and up to billions of temporal edges. However, current exact and approximate algorithms are unable to handle large-scale temporal graphs. To fill such a gap, we introduce STEP, a scalable and efficient algorithm to approximate temporal triangle counts from a stream of temporal edges. STEP combines predictions to the number of triangles a temporal edge is involved in, with a simple sampling strategy, leading to scalability, efficiency, and accurate approximation of all eight temporal triangle types simultaneously. We analytically prove that, by using a sublinear amount of memory, STEP obtains unbiased and very accurate estimates. In fact, even noisy predictions can significantly reduce the variance of STEP's estimates. Our extensive experiments on massive temporal graphs with up to billions of edges demonstrate that STEP outputs high-quality estimates and is more efficient than state-of-the-art methods.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.13173v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <category>cs.SI</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Giorgio Venturin, Ilie Sarpe, Fabio Vandin</dc:creator>
    </item>
    <item>
      <title>Ultra-Resilient Superimposed Codes: Near-Optimal Construction and Applications</title>
      <link>https://arxiv.org/abs/2506.13489</link>
      <description>arXiv:2506.13489v1 Announce Type: new 
Abstract: A superimposed code is a collection of binary vectors (codewords) with the property that no vector is contained in the Boolean sum of any $k$ others, enabling unique identification of codewords within any group of $k$. Superimposed codes are foundational combinatorial tools with applications in areas ranging from distributed computing and data retrieval to fault-tolerant communication. However, classical superimposed codes rely on strict alignment assumptions, limiting their effectiveness in asynchronous and fault-prone environments, which are common in modern systems and applications.
  We introduce Ultra-Resilient Superimposed Codes (URSCs), a new class of codes that extends the classic superimposed framework by ensuring a stronger codewords' isolation property and resilience to two types of adversarial perturbations: arbitrary cyclic shifts and partial bitwise corruption (flips). Additionally, URSCs exhibit universality, adapting seamlessly to any number $k$ of concurrent codewords without prior knowledge. This is a combination of properties not achieved in any previous construction.
  We provide the first polynomial-time construction of URSCs with near-optimal length, significantly outperforming previous constructions with less general features, all without requiring prior knowledge of the number of concurrent codewords, $k$. % We demonstrate that our URSCs significantly advance the state of the art in multiple applications, including uncoordinated beeping networks, where our codes reduce time complexity for local broadcast by nearly two orders of magnitude, and generalized contention resolution in multi-access channel communication.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.13489v1</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gianluca De Marco, Dariusz R. Kowalski</dc:creator>
    </item>
    <item>
      <title>Towards Energy-Efficient Distributed Agreement</title>
      <link>https://arxiv.org/abs/2506.12282</link>
      <description>arXiv:2506.12282v1 Announce Type: cross 
Abstract: We study fault-tolerant consensus in a variant of the synchronous message passing model, where, in each round, every node can choose to be awake or asleep. This is known as the sleeping model (Chatterjee, Gmyr, Pandurangan PODC 2020) and defines the awake complexity (also called \emph{energy complexity}), which measures the maximum number of rounds that any node is awake throughout the execution. Only awake nodes can send and receive messages in a given round and all messages sent to sleeping nodes are lost. We present new deterministic consensus algorithms that tolerate up to $f&lt;n$ crash failures, where $n$ is the number of nodes. Our algorithms match the optimal time complexity lower bound of $f+1$ rounds. For multi-value consensus, where the input values are chosen from some possibly large set, we achieve an energy complexity of ${O}(\lceil f^2 / n \rceil)$ rounds, whereas for binary consensus, we show that ${O}(\lceil f / \sqrt{n} \rceil)$ rounds are possible.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12282v1</guid>
      <category>cs.DC</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hugo Mirault, Peter Robinson</dc:creator>
    </item>
    <item>
      <title>Permutation-Avoiding FFT-Based Convolution</title>
      <link>https://arxiv.org/abs/2506.12718</link>
      <description>arXiv:2506.12718v1 Announce Type: cross 
Abstract: Fast Fourier Transform (FFT) libraries are widely used for evaluating discrete convolutions. Most FFT implementations follow some variant of the Cooley-Tukey framework, in which the transform is decomposed into butterfly operations and index-reversal permutations. While butterfly operations dominate the floating-point operation count, the memory access patterns induced by index-reversal permutations significantly degrade the FFT's arithmetic intensity. In practice, discrete convolutions are often applied repeatedly with a fixed filter. In such cases, we show that the index-reversal permutations involved in both the forward and backward transforms of standard FFT-based convolution implementations can be avoided by deferring to a single offline permutation of the filter. We propose a multi-dimensional, permutation-avoiding convolution procedure within a general radix Cooley-Tukey framework. We perform numerical experiments to benchmark our algorithms against state-of-the-art FFT-based convolution implementations. Our results suggest that developers of FFT libraries should consider supporting permutation-avoiding convolution kernels.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12718v1</guid>
      <category>math.NA</category>
      <category>cs.DS</category>
      <category>cs.MS</category>
      <category>cs.NA</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Nicolas Venkovic, Hartwig Anzt</dc:creator>
    </item>
    <item>
      <title>Private List Learnability vs. Online List Learnability</title>
      <link>https://arxiv.org/abs/2506.12856</link>
      <description>arXiv:2506.12856v1 Announce Type: cross 
Abstract: This work explores the connection between differential privacy (DP) and online learning in the context of PAC list learning. In this setting, a $k$-list learner outputs a list of $k$ potential predictions for an instance $x$ and incurs a loss if the true label of $x$ is not included in the list. A basic result in the multiclass PAC framework with a finite number of labels states that private learnability is equivalent to online learnability [Alon, Livni, Malliaris, and Moran (2019); Bun, Livni, and Moran (2020); Jung, Kim, and Tewari (2020)]. Perhaps surprisingly, we show that this equivalence does not hold in the context of list learning. Specifically, we prove that, unlike in the multiclass setting, a finite $k$-Littlestone dimensio--a variant of the classical Littlestone dimension that characterizes online $k$-list learnability--is not a sufficient condition for DP $k$-list learnability. However, similar to the multiclass case, we prove that it remains a necessary condition.
  To demonstrate where the equivalence breaks down, we provide an example showing that the class of monotone functions with $k+1$ labels over $\mathbb{N}$ is online $k$-list learnable, but not DP $k$-list learnable. This leads us to introduce a new combinatorial dimension, the \emph{$k$-monotone dimension}, which serves as a generalization of the threshold dimension. Unlike the multiclass setting, where the Littlestone and threshold dimensions are finite together, for $k&gt;1$, the $k$-Littlestone and $k$-monotone dimensions do not exhibit this relationship. We prove that a finite $k$-monotone dimension is another necessary condition for DP $k$-list learnability, alongside finite $k$-Littlestone dimension. Whether the finiteness of both dimensions implies private $k$-list learnability remains an open question.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12856v1</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Steve Hanneke, Shay Moran, Hilla Schefler, Iska Tsubari</dc:creator>
    </item>
    <item>
      <title>Distributed Computing From First Principles</title>
      <link>https://arxiv.org/abs/2506.12959</link>
      <description>arXiv:2506.12959v1 Announce Type: cross 
Abstract: This book on Distributed Computing aims to benefit a diverse audience, ranging from aspiring engineers, and seasoned researchers, to a wide range of professionals. Driven by my passion for making the core concepts of distributed computing accessible, this work is a significant undertaking designed to empower individuals from all backgrounds to gain valuable insight. Have you ever wondered how a typical distributed system works under the hood? Are you looking for a pedagogical guide with complete implementations? In this work, we have implemented several foundational algorithms in Distributed Computing. Whether your expertise lies in the theoretical foundations or the practical applications of the principles of Distributed Systems, this book is for you.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.12959v1</guid>
      <category>cs.DC</category>
      <category>cs.DS</category>
      <category>cs.SE</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kenneth Odoh</dc:creator>
    </item>
    <item>
      <title>Stochastic Multi-Objective Multi-Armed Bandits: Regret Definition and Algorithm</title>
      <link>https://arxiv.org/abs/2506.13125</link>
      <description>arXiv:2506.13125v1 Announce Type: cross 
Abstract: Multi-armed bandit (MAB) problems are widely applied to online optimization tasks that require balancing exploration and exploitation. In practical scenarios, these tasks often involve multiple conflicting objectives, giving rise to multi-objective multi-armed bandits (MO-MAB). Existing MO-MAB approaches predominantly rely on the Pareto regret metric introduced in \cite{drugan2013designing}. However, this metric has notable limitations, particularly in accounting for all Pareto-optimal arms simultaneously. To address these challenges, we propose a novel and comprehensive regret metric that ensures balanced performance across conflicting objectives. Additionally, we introduce the concept of \textit{Efficient Pareto-Optimal} arms, which are specifically designed for online optimization. Based on our new metric, we develop a two-phase MO-MAB algorithm that achieves sublinear regret for both Pareto-optimal and efficient Pareto-optimal arms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.13125v1</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Mansoor Davoodi, Setareh Maghsudi</dc:creator>
    </item>
    <item>
      <title>FPT Constant Approximation Algorithms for Colorful Sum of Radii</title>
      <link>https://arxiv.org/abs/2506.13191</link>
      <description>arXiv:2506.13191v1 Announce Type: cross 
Abstract: We study the colorful sum of radii problem, where the input is a point set $P$ partitioned into classes $P_1, P_2, \dots, P_\omega$, along with per-class outlier bounds $m_1, m_2, \dots, m_\omega$, summing to $m$. The goal is to select a subset $\mathcal{C} \subseteq P$ of $k$ centers and assign points to centers in $\mathcal{C}$, allowing up to $m_i$ unassigned points (outliers) from each class $P_i$, while minimizing the sum of cluster radii. The radius of a cluster is defined as the maximum distance from any point in the cluster to its center. The classical (non-colorful) version of the sum of radii problem is known to be NP-hard, even on weighted planar graphs. The colorful sum of radii is introduced by Chekuri et al. (2022), who provide an $O(\log \omega)$-approximation algorithm. In this paper, we present the first constant-factor approximation algorithms for the colorful sum of radii running in FPT (fixed-parameter tractable) time. Our contributions are twofold: We design an iterative covering algorithm that achieves a $(2+\varepsilon)$-approximation with running time exponential in both $k$ and $m$; We further develop a $(7+\varepsilon)$-approximation algorithm by leveraging a colorful $k$-center subroutine, improving the running time by removing the exponential dependency on $m$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.13191v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shuilian Liu, Gregory Gutin, Yicheng Xu, Yong Zhang</dc:creator>
    </item>
    <item>
      <title>Learning Augmented Graph $k$-Clustering</title>
      <link>https://arxiv.org/abs/2506.13533</link>
      <description>arXiv:2506.13533v1 Announce Type: cross 
Abstract: Clustering is a fundamental task in unsupervised learning. Previous research has focused on learning-augmented $k$-means in Euclidean metrics, limiting its applicability to complex data representations. In this paper, we generalize learning-augmented $k$-clustering to operate on general metrics, enabling its application to graph-structured and non-Euclidean domains. Our framework also relaxes restrictive cluster size constraints, providing greater flexibility for datasets with imbalanced or unknown cluster distributions. Furthermore, we extend the hardness of query complexity to general metrics: under the Exponential Time Hypothesis (ETH), we show that any polynomial-time algorithm must perform approximately $\Omega(k / \alpha)$ queries to achieve a $(1 + \alpha)$-approximation. These contributions strengthen both the theoretical foundations and practical applicability of learning-augmented clustering, bridging gaps between traditional methods and real-world challenges.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.13533v1</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Chenglin Fan, Kijun Shin</dc:creator>
    </item>
    <item>
      <title>Avoiding Obfuscation with Prover-Estimator Debate</title>
      <link>https://arxiv.org/abs/2506.13609</link>
      <description>arXiv:2506.13609v1 Announce Type: cross 
Abstract: Training powerful AI systems to exhibit desired behaviors hinges on the ability to provide accurate human supervision on increasingly complex tasks. A promising approach to this problem is to amplify human judgement by leveraging the power of two competing AIs in a debate about the correct solution to a given problem. Prior theoretical work has provided a complexity-theoretic formalization of AI debate, and posed the problem of designing protocols for AI debate that guarantee the correctness of human judgements for as complex a class of problems as possible. Recursive debates, in which debaters decompose a complex problem into simpler subproblems, hold promise for growing the class of problems that can be accurately judged in a debate. However, existing protocols for recursive debate run into the obfuscated arguments problem: a dishonest debater can use a computationally efficient strategy that forces an honest opponent to solve a computationally intractable problem to win. We mitigate this problem with a new recursive debate protocol that, under certain stability assumptions, ensures that an honest debater can win with a strategy requiring computational efficiency comparable to their opponent.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.13609v1</guid>
      <category>cs.AI</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jonah Brown-Cohen, Geoffrey Irving, Georgios Piliouras</dc:creator>
    </item>
    <item>
      <title>On Computing the Dollo-1 phylogeny in polynomial time</title>
      <link>https://arxiv.org/abs/1611.01017</link>
      <description>arXiv:1611.01017v2 Announce Type: replace 
Abstract: The Dollo model for reconstructing evolutionary trees from binary characters has been proposed as a generalization of the infinite sites model, also known as the Perfect Phylogeny. In particular, the Dollo model is considered more realistic than the Perfect Phylogeny for inferring the evolution of tumor mutations. In the case of binary matrices, the Dollo-$k$ model requires an evolutionary tree in which each character, corresponding to a column in the input matrix, may change from $0$ to $1$ at most once, and from $1$ to $0$ at most $k$ times throughout the entire tree. Given a binary matrix, the problem of deciding whether there exists a Dollo-$k$ tree compatible with the matrix is NP-complete for any fixed $k \geq 2$, while computing a Dollo-$0$ tree corresponds to the Perfect Phylogeny decision problem, which admits a simple linear-time algorithm. The Dollo-$1$ tree problem corresponds to the Persistent Phylogeny problem, whose computational complexity, albeit under an equivalent formulation, was posed as an open question 20 years ago. We solve this problem by presenting a polynomial-time algorithm for the Persistent Phylogeny problem. Our solution relies on efficiently solving a specific class of binary matrices, represented as bipartite graphs called \emph{skeleton graphs}, or simply skeletons. In these graphs, characters are \emph{maximal}, that is their corresponding sets of species are not related by inclusion.</description>
      <guid isPermaLink="false">oai:arXiv.org:1611.01017v2</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Paola Bonizzoni, Gianluca Della Vedova, Mauricio Soto Gomez, Gabriella Trucco</dc:creator>
    </item>
    <item>
      <title>Beyond Value Iteration for Parity Games: Strategy Iteration with Universal Trees</title>
      <link>https://arxiv.org/abs/2108.13338</link>
      <description>arXiv:2108.13338v5 Announce Type: replace 
Abstract: Parity games have witnessed several new quasi-polynomial algorithms since the breakthrough result of Calude et al. (STOC 2017). The combinatorial object underlying these approaches is a universal tree, as identified by Czerwi\'nski et al. (SODA 2019). By proving a quasi-polynomial lower bound on the size of a universal tree, they have highlighted a barrier that must be overcome by all existing approaches to attain polynomial running time. This is due to the existence of worst case instances which force these algorithms to explore a large portion of the tree.

As an attempt to overcome this barrier, we propose a strategy iteration framework which can be applied on any universal tree. It is at least as fast as its value iteration counterparts, while allowing one to take bigger leaps in the universal tree. Our main technical contribution is an efficient method for computing the least fixed point of 1-player games. This is achieved via a careful adaptation of shortest path algorithms to the setting of ordered trees. By plugging in the universal tree of Jurdzi\'nski and Lazi\'c (LICS 2017), or the Strahler universal tree of Daviaud et al. (ICALP 2020), we obtain instantiations of the general framework that take time $O(mn^2\log n\log d)$ and $O(mn^2\log^3 n \log d)$ respectively per iteration.</description>
      <guid isPermaLink="false">oai:arXiv.org:2108.13338v5</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Zhuan Khye Koh, Georg Loho</dc:creator>
    </item>
    <item>
      <title>Simple Length-Constrained Minimum Spanning Trees</title>
      <link>https://arxiv.org/abs/2410.08170</link>
      <description>arXiv:2410.08170v2 Announce Type: replace 
Abstract: In the length-constrained minimum spanning tree (MST) problem, we are given an $n$-node edge-weighted graph $G$ and a length constraint $h \geq 1$. Our goal is to find a spanning tree of $G$ whose diameter is at most $h$ with minimum weight. Prior work of Marathe et al.\ gave a poly-time algorithm which repeatedly computes maximum cardinality matchings of minimum weight to output a spanning tree whose weight is $O(\log n)$-approximate with diameter $O(\log n)\cdot h$.
  In this work, we show that a simple random sampling approach recovers the results of Marathe et al. -- no computation of min-weight max-matchings needed! Furthermore, the simplicity of our approach allows us to tradeoff between the approximation factor and the loss in diameter: we show that for any $\epsilon \geq 1/\operatorname{poly}(n)$, one can output a spanning tree whose weight is $O(n^\epsilon / \epsilon)$-approximate with diameter $O(1/\epsilon)\cdot h$ with high probability in poly-time. This immediately gives the first poly-time $\operatorname{poly}(\log n)$-approximation for length-constrained MST whose loss in diameter is $o(\log n)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.08170v2</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>D Ellis Hershkowitz, Richard Z Huang</dc:creator>
    </item>
    <item>
      <title>Single-Source Regular Path Querying in Terms of Linear Algebra</title>
      <link>https://arxiv.org/abs/2412.10287</link>
      <description>arXiv:2412.10287v2 Announce Type: replace 
Abstract: Two-way regular path queries (2-RPQs) allow one to use regular languages over edges and inverted edges in edge-labelled graph to constrain paths of interest. 2-RPQs are (partially) adopted in different real-world graph analysis systems and have become a part of the GQL ISO standard. However the performance of 2-RPQs on real-world graphs remains a bottleneck for wider adoption. Utilisation of high-performance sparse linear algebra libraries for the algorithm implementation allows one to achieve significant speedup over competitors on real-world data and queries. We propose a new breadth-first-search-based algorithm that leverages linear algebra for evaluating single-source regular path queries. We integrate it into the LAGraph graph processing algorithm infrastructure and provide in-depth performance comparison on the large real-world knowledge bases. Additionally, we present extensive analysis of its performance across different query types using synthetic data, comparing it with various databases and other linear algebra-based approaches.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.10287v2</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Georgiy Belyanin, Semyon Grigoriev, Rodion Suvorov</dc:creator>
    </item>
    <item>
      <title>Isometric-Universal Graphs for Trees</title>
      <link>https://arxiv.org/abs/2506.11704</link>
      <description>arXiv:2506.11704v2 Announce Type: replace 
Abstract: We consider the problem of finding the smallest graph that contains two input trees each with at most $n$ vertices preserving their distances. In other words, we look for an isometric-universal graph with the minimum number of vertices for two given trees. We prove that this problem can be solved in time $O(n^{5/2}\log{n})$. We extend this result to forests instead of trees, and propose an algorithm with running time $O(n^{7/2}\log{n})$. As a key ingredient, we show that a smallest isometric-universal graph of two trees essentially is a tree. Furthermore, we prove that these results cannot be extended. Firstly, we show that deciding whether there exists an isometric-universal graph with $t$ vertices for three forests is NP-complete. Secondly, we show that any smallest isometric-universal graph cannot be a tree for some families of three trees. This latter result has implications for greedy strategies solving the smallest isometric-universal graph problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.11704v2</guid>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Edgar Baucher, Fran\c{c}ois Dross, Cyril Gavoille</dc:creator>
    </item>
    <item>
      <title>Glauber dynamics for the hard-core model on bounded-degree $H$-free graphs</title>
      <link>https://arxiv.org/abs/2404.07615</link>
      <description>arXiv:2404.07615v2 Announce Type: replace-cross 
Abstract: The hard-core model has as its configurations the independent sets of some graph instance $G$. The probability distribution on independent sets is controlled by a `fugacity' $\lambda&gt;0$, with higher $\lambda$ leading to denser configurations. We investigate the mixing time of Glauber (single-site) dynamics for the hard-core model on restricted classes of bounded-degree graphs in which a particular graph $H$ is excluded as an induced subgraph. If $H$ is a subdivided claw then, for all $\lambda$, the mixing time is $O(n\log n)$, where $n$ is the order of $G$. This extends a result of Chen and Gu for claw-free graphs. When $H$ is a path, the set of possible instances is finite. For all other $H$, the mixing time is exponential in $n$ for sufficiently large $\lambda$, depending on $H$ and the maximum degree of $G$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.07615v2</guid>
      <category>math.PR</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mark Jerrum</dc:creator>
    </item>
    <item>
      <title>Decentralized Distributed Graph Coloring: Cluster Graphs</title>
      <link>https://arxiv.org/abs/2405.07725</link>
      <description>arXiv:2405.07725v2 Announce Type: replace-cross 
Abstract: Graph coloring is fundamental to distributed computing. We give the first sub-logarithmic distributed algorithm for coloring cluster graphs. These graphs are obtained from the underlying communication network by contracting nodes and edges, and they appear frequently as components in the study of distributed algorithms. In particular, we give a $O(\log^* n)$-round algorithm to $(\Delta+1)$-color cluster graphs of at least polylogarithmic degree. The previous best bound known was $\operatorname{poly}(\log n)$ [Flin et al., SODA'24]. This properly generalizes results in the CONGEST model and shows that distributed graph problems can be solved quickly even when the node itself is decentralized.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.07725v2</guid>
      <category>cs.DC</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Maxime Flin, Magnus M. Halldorsson, Alexandre Nolin</dc:creator>
    </item>
    <item>
      <title>Delta-modular ILP Problems of Bounded Codimension, Discrepancy, and Convolution (new version)</title>
      <link>https://arxiv.org/abs/2405.17001</link>
      <description>arXiv:2405.17001v5 Announce Type: replace-cross 
Abstract: For integers $k,n \geq 0$ and a cost vector $c \in Z^n$, we study two fundamental integer linear programming (ILP) problems: \[
  \text{(Standard Form)} \quad \max\bigl\{c^\top x \colon Ax = b,\ x \in Z^n_{\geq 0}\bigr\} \text{ with } A \in Z^{k \times n}, \text{rank}(A) = k, b \in Z^k, \] \[
  \text{(Canonical Form)} \quad \max\bigl\{c^\top x \colon Ax \leq b,\ x \in Z^n\bigr\} \text{ with } A \in Z^{(n+k) \times n}, \text{rank}(A) = n, b \in Z^{n+k}. \] We present improved algorithms for both problems and their feasibility versions, parameterized by $k$ and $\Delta$, where $\Delta$ denotes the maximum absolute value of $\text{rank}(A) \times \text{rank}(A)$ subdeterminants of $A$. Our main complexity results, stated in terms of required arithmetic operations, are: \[ \text{Optimization:}\quad O(\log k)^{2k} \cdot \Delta^2 / 2^{\Omega(\sqrt{\log \Delta})} + 2^{O(k)} \cdot \text{poly}(\varphi), \] \[ \text{Feasibility:} \quad O(\log k)^k \cdot \Delta \cdot (\log \Delta)^3 + 2^{O(k)} \cdot \text{poly}(\varphi), \] where $\varphi$ represents the input size measured by the bit-encoding length of $(A,b,c)$. We also examine several special cases when $k \in \{0,1\}$, which have important applications in: expected computational complexity of ILP with varying right-hand side $b$, ILP problems with generic constraint matrices, ILP problems on simplices. Our results yield improved complexity bounds for these specific scenarios.
  As independent contributions, we present: An $n^2/2^{\Omega(\sqrt{\log n})}$-time algorithm for the tropical convolution problem on sequences indexed by elements of a finite Abelian group of order $n$; A complete and self-contained error analysis of the generalized DFT over Abelian groups in the Word-RAM model.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.17001v5</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <category>math.AC</category>
      <category>math.OC</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>M. Cherniavskii, D. Gribanov, D. Malyshev, P. M. Pardalos</dc:creator>
    </item>
    <item>
      <title>Galled Perfect Transfer Networks</title>
      <link>https://arxiv.org/abs/2409.03935</link>
      <description>arXiv:2409.03935v4 Announce Type: replace-cross 
Abstract: Predicting horizontal gene transfers often requires comparative sequence data, but recent work has shown that character-based approaches could also be useful for this task. Notably, perfect transfer networks (PTN) explain the character diversity of a set of taxa for traits that are gained once, rarely lost, but that can be transferred laterally. Characterizing the structure of such characters is an important step towards understanding more complex characters. Although efficient algorithms can infer such networks from character data, they can sometimes predict overly complicated transfer histories. With the goal of recovering the simplest possible scenarios in this model, we introduce galled perfect transfer networks, which are PTNs that are galled trees. Such networks are useful for characters that are incompatible in terms of tree-like evolution, but that do fit in an almost-tree scenario. We provide polynomial-time algorithms for two problems: deciding whether one can add transfer edges to a tree to transform it into a galled PTN, and deciding whether a set of characters are galled-compatible, that is, they can be explained by some galled PTN. We also analyze a real dataset comprising of a bacterial species trees and KEGG functions as characters, and derive several conclusions on the difficulty of explaining characters in a galled tree, which provide several directions for future research.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.03935v4</guid>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>q-bio.PE</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Alitzel L\'opez S\'anchez, Manuel Lafond</dc:creator>
    </item>
    <item>
      <title>Algorithms with Calibrated Machine Learning Predictions</title>
      <link>https://arxiv.org/abs/2502.02861</link>
      <description>arXiv:2502.02861v3 Announce Type: replace-cross 
Abstract: The field of algorithms with predictions incorporates machine learning advice in the design of online algorithms to improve real-world performance. A central consideration is the extent to which predictions can be trusted -- while existing approaches often require users to specify an aggregate trust level, modern machine learning models can provide estimates of prediction-level uncertainty. In this paper, we propose calibration as a principled and practical tool to bridge this gap, demonstrating the benefits of calibrated advice through two case studies: the ski rental and online job scheduling problems. For ski rental, we design an algorithm that achieves near-optimal prediction-dependent performance and prove that, in high-variance settings, calibrated advice offers more effective guidance than alternative methods for uncertainty quantification. For job scheduling, we demonstrate that using a calibrated predictor leads to significant performance improvements over existing methods. Evaluations on real-world data validate our theoretical findings, highlighting the practical impact of calibration for algorithms with predictions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.02861v3</guid>
      <category>stat.ML</category>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Judy Hanwen Shen, Ellen Vitercik, Anders Wikum</dc:creator>
    </item>
    <item>
      <title>Deterministic factorization of constant-depth algebraic circuits in subexponential time</title>
      <link>https://arxiv.org/abs/2504.08063</link>
      <description>arXiv:2504.08063v2 Announce Type: replace-cross 
Abstract: While efficient randomized algorithms for factorization of polynomials given by algebraic circuits have been known for decades, obtaining an even slightly non-trivial deterministic algorithm for this problem has remained an open question of great interest. This is true even when the input algebraic circuit has additional structure, for instance, when it is a constant-depth circuit. Indeed, no efficient deterministic algorithms are known even for the seemingly easier problem of factoring sparse polynomials or even the problem of testing the irreducibility of sparse polynomials.
  In this work, we make progress on these questions: we design a deterministic algorithm that runs in subexponential time, and when given as input a constant-depth algebraic circuit $C$ over the field of rational numbers, it outputs algebraic circuits (of potentially unbounded depth) for all the irreducible factors of $C$, together with their multiplicities. In particular, we give the first subexponential time deterministic algorithm for factoring sparse polynomials.
  For our proofs, we rely on a finer understanding of the structure of power series roots of constant-depth circuits and the analysis of the Kabanets-Impagliazzo generator. In particular, we show that the Kabanets-Impagliazzo generator constructed using low-degree hard polynomials (explicitly constructed in the work of Limaye, Srinivasan &amp; Tavenas) preserves not only the non-zeroness of small constant-depth circuits (as shown by Chou, Kumar &amp; Solomon), but also their irreducibility and the irreducibility of their factors.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.08063v2</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Somnath Bhattacharjee, Mrinal Kumar, Varun Ramanathan, Ramprasad Saptharishi, Shubhangi Saraf</dc:creator>
    </item>
    <item>
      <title>Success probability in Shor's Algorithm</title>
      <link>https://arxiv.org/abs/2505.00433</link>
      <description>arXiv:2505.00433v2 Announce Type: replace-cross 
Abstract: This paper aims to determine the exact success probability at each step of Shor's algorithm. Although the literature usually provides a lower bound on this probability, we present an improved bound. The derived formulas enable the identification of all failure cases in Shor's algorithm, which correspond to a success probability of zero. A simulation routine is provided to evaluate the theoretical success probability for a given integer when its prime factorization is known with potential applications in quantum resource estimation and algorithm benchmarking.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.00433v2</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ali Abbassi, Lionel Bayle</dc:creator>
    </item>
  </channel>
</rss>
