<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Jun 2025 04:00:54 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Smallest Suffixient Sets as a Repetitiveness Measure</title>
      <link>https://arxiv.org/abs/2506.05638</link>
      <description>arXiv:2506.05638v1 Announce Type: new 
Abstract: Suffixient sets are a novel combinatorial object that capture the essential information of repetitive strings in a way that, provided with a random-access mechanism, supports various forms of pattern matching. In this paper we study the size $\chi$ of the smallest suffixient set as a repetitiveness measure: we place it between known measures and study its sensitivity to various string operations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.05638v1</guid>
      <category>cs.FL</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Gonzalo Navarro, Giuseppe Romana, Cristian Urbina</dc:creator>
    </item>
    <item>
      <title>Positive Varieties of Lattice Languages</title>
      <link>https://arxiv.org/abs/2506.05824</link>
      <description>arXiv:2506.05824v1 Announce Type: new 
Abstract: While a language assigns a value of either `yes' or `no' to each word, a lattice language assigns an element of a given lattice to each word. An advantage of lattice languages is that joins and meets of languages can be defined as generalizations of unions and intersections. This fact also allows for the definition of positive varieties -- classes closed under joins, meets, quotients, and inverse homomorphisms -- of lattice languages. In this paper, we extend Pin's positive variety theorem, proving a one-to-one correspondence between positive varieties of regular lattice languages and pseudo-varieties of finite ordered monoids. Additionally, we briefly explore algebraic approaches to finite-state Markov chains as an application of our framework.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.05824v1</guid>
      <category>cs.FL</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yusuke Inoue, Yuji Komatsu</dc:creator>
    </item>
    <item>
      <title>Infinite Time Turing Machines and their Applications</title>
      <link>https://arxiv.org/abs/2506.05351</link>
      <description>arXiv:2506.05351v1 Announce Type: cross 
Abstract: This work establishes a rigorous theoretical foundation for analyzing deep learning systems by leveraging Infinite Time Turing Machines (ITTMs), which extend classical computation into transfinite ordinal steps. Using ITTMs, we reinterpret modern architectures like Transformers, revealing fundamental limitations in scalability, efficiency, and interpretability. Building on these insights, we propose the Universal State Machine (USM), a novel computational paradigm designed from first principles. The USM employs a dynamic, queryable computation graph that evolves in real time, enabling modular, interpretable, and resource-efficient computation. This framework not only overcomes the inefficiencies and rigidity of current models but also lays the groundwork for scalable, generalizable artificial intelligence systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.05351v1</guid>
      <category>cs.CC</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Rukmal Weerawarana, Maxwell Braun</dc:creator>
    </item>
    <item>
      <title>Compression of executable QR codes or sQRy for Industry: an example for Wi-Fi access points</title>
      <link>https://arxiv.org/abs/2506.06100</link>
      <description>arXiv:2506.06100v1 Announce Type: cross 
Abstract: Executable QR codes, or sQRy, is a technology dated 2022 that permits to include a runnable program inside a QR code, enabling interaction with the user even in the absence of an Internet connection. sQRy are enablers for different practical applications, including network equipment configuration, diagnostics, and enhanced smart manuals in industrial contexts. Many other non-industry-related fields can also benefit from this technology. Regardless of where sQRy are used, text strings are among the most commonly embedded data. However, due to strict limitations on the available payload, the occupancy of strings limits the length of the programs that can be embedded. In this work, we propose a simple yet effective strategy that can reduce the space taken by strings, hence broadening sQRy applicability.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.06100v1</guid>
      <category>cs.HC</category>
      <category>cs.CY</category>
      <category>cs.FL</category>
      <category>cs.IT</category>
      <category>math.IT</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:journal_reference>21st IEEE International Conference on Factory Communication Systems (WFCS 2025)</arxiv:journal_reference>
      <dc:creator>Stefano Scanzio, Gabriele Formis, Pietro Chiavassa, Lukasz Wisniewski, Gianluca Cena</dc:creator>
    </item>
    <item>
      <title>Monitorability for the Modal mu-Calculus over Systems with Data: From Practice to Theory</title>
      <link>https://arxiv.org/abs/2506.06172</link>
      <description>arXiv:2506.06172v1 Announce Type: cross 
Abstract: Runtime verification, also known as runtime monitoring, consists of checking whether a system satisfies a given specification by observing the trace it produces during its execution. It is used as a lightweight verification technique to complement or substitute costlier methods such as model-checking.
  In the regular setting, Hennessy-Milner logic with recursion, a variant of the modal mu-calculus, provides a versatile formalism for expressing linear- and branching-time specifications of the control flow of the system.
  In this paper, we shift the focus from control to data and study the monitorability of an extension of this logic that allows one to express properties of the data flow. Data values are modelled as values from an infinite domain. They are stored using data variables and manipulated using predicates and first-order quantification.
  The resulting logic is closely related to register automata with guessing. This correspondence yields a monitor synthesis algorithm, and allows us to derive a strict monitorability hierarchy between the different fragments of the logic, in stark contrast to the regular setting. In particular, restricting to deterministic monitors strictly reduces the set of monitorable properties.
  Last, we exhibit a fragment of the logic that can express all monitorable formulae in the logic without greatest fixed-points but not in the full logic. We finally show that this is unavoidable because, in fact, there is no decidable fragment of the logic that captures all monitorable properties.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.06172v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Luca Aceto, Antonis Achilleos, Duncan Paul Attard, L\'eo Exibard, Adrian Francalanza, Anna Ing\'olfsd\'ottir, Karoliina Lehtinen</dc:creator>
    </item>
    <item>
      <title>Thin Coalgebraic Behaviours Are Inductive</title>
      <link>https://arxiv.org/abs/2504.07013</link>
      <description>arXiv:2504.07013v2 Announce Type: replace 
Abstract: Coalgebras for analytic functors uniformly model graph-like systems where the successors of a state may admit certain symmetries. Examples of successor structure include ordered tuples, cyclic lists and multisets. Motivated by goals in automata-based verification and results on thin trees, we introduce thin coalgebras as those coalgebras with only countably many infinite paths from each state. Our main result is an inductive characterisation of thinness via an initial algebra. To this end, we develop a syntax for thin behaviours and capture with a single equation when two terms represent the same thin behaviour. Finally, for the special case of polynomial functors, we retrieve from our syntax the notion of Cantor-Bendixson rank of a thin tree.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.07013v2</guid>
      <category>cs.FL</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anton Chernev, Corina C\^irstea, Helle Hvid Hansen, Clemens Kupke</dc:creator>
    </item>
    <item>
      <title>Rauzy dimension and finite-state dimension</title>
      <link>https://arxiv.org/abs/2406.18383</link>
      <description>arXiv:2406.18383v2 Announce Type: replace-cross 
Abstract: In 1976, Rauzy studied two complexity functions, $\underline{\beta}$ and $\overline{\beta}$, for infinite sequences over a finite alphabet. The function $\underline{\beta}$ achieves its maximum precisely for Borel normal sequences, while $\overline{\beta}$ reaches its minimum for sequences that, when added to any Borel normal sequence, result in another Borel normal sequence. We establish a connection between Rauzy's complexity functions, $\underline{\beta}$ and $\overline{\beta}$, and the notions of non-aligned block entropy, $\underline{h}$ and $\overline{h}$, by providing sharp upper and lower bounds for $\underline{h}$ in terms of $\underline{\beta}$, and sharp upper and lower bounds for $\overline{h}$ in terms of $\overline{\beta}$. We adopt a probabilistic approach by considering an infinite sequence of random variables over a finite alphabet. The proof relies on a new characterization of non-aligned block entropies, $\overline{h}$ and $\underline{h}$, in terms of Shannon's conditional entropy. The bounds imply that sequences with $\overline{h} = 0$ coincide with those for which $\overline{\beta} = 0$. We also show that the non-aligned block entropies, $\underline{h}$ and $\overline{h}$, are essentially subadditive.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.18383v2</guid>
      <category>cs.IT</category>
      <category>cs.FL</category>
      <category>math.IT</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ver\'onica Becher, Olivier Carton, Santiago Figueira</dc:creator>
    </item>
    <item>
      <title>Beyond Winning Strategies: Admissible and Admissible Winning Strategies for Quantitative Reachability Games</title>
      <link>https://arxiv.org/abs/2408.13369</link>
      <description>arXiv:2408.13369v3 Announce Type: replace-cross 
Abstract: Classical reactive synthesis approaches aim to synthesize a reactive system that always satisfies a given specifications. These approaches often reduce to playing a two-player zero-sum game where the goal is to synthesize a winning strategy. However, in many pragmatic domains, such as robotics, a winning strategy does not always exist, yet it is desirable for the system to make an effort to satisfy its requirements instead of "giving up". To this end, this paper investigates the notion of admissible strategies, which formalize "doing-your-best", in quantitative reachability games. We show that, unlike the qualitative case, quantitative admissible strategies are history-dependent even for finite payoff functions, making synthesis a challenging task. In addition, we prove that admissible strategies always exist but may produce undesirable optimistic behaviors. To mitigate this, we propose admissible winning strategies, which enforce the best possible outcome while being admissible. We show that both strategies always exist but are not memoryless. We provide necessary and sufficient conditions for the existence of both strategies and propose synthesis algorithms. Finally, we illustrate the strategies on gridworld and robot manipulator domains.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.13369v3</guid>
      <category>cs.GT</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>cs.RO</category>
      <pubDate>Mon, 09 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Karan Muvvala, Qi Heng Ho, Morteza Lahijanian</dc:creator>
    </item>
  </channel>
</rss>
