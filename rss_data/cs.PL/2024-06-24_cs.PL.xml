<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 Jun 2024 02:34:11 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 24 Jun 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Grokking the Sequent Calculus (Functional Pearl)</title>
      <link>https://arxiv.org/abs/2406.14719</link>
      <description>arXiv:2406.14719v1 Announce Type: new 
Abstract: The sequent calculus is a proof system which was designed as a more symmetric alternative to natural deduction. The {\lambda}{\mu}{\mu}-calculus is a term assignment system for the sequent calculus and a great foundation for compiler intermediate languages due to its first-class representation of evaluation contexts. Unfortunately, only experts of the sequent calculus can appreciate its beauty. To remedy this, we present the first introduction to the {\lambda}{\mu}{\mu}-calculus which is not directed at type theorists or logicians but at compiler hackers and programming-language enthusiasts. We do this by writing a compiler from a small but interesting surface language to the {\lambda}{\mu}{\mu}-calculus as a compiler intermediate language.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.14719v1</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>David Binder, Marco Tzschentke, Marius M\"uller, Klaus Ostermann</dc:creator>
    </item>
    <item>
      <title>Suki: Choreographed Distributed Dataflow in Rust</title>
      <link>https://arxiv.org/abs/2406.14733</link>
      <description>arXiv:2406.14733v1 Announce Type: new 
Abstract: Programming models for distributed dataflow have long focused on analytical workloads that allow the runtime to dynamically place and schedule compute logic. Meanwhile, models that enable fine-grained control over placement, such as actors, make global optimization difficult. In this extended abstract, we present Suki, an embedded Rust DSL that lets developers implement streaming dataflow with explicit placement of computation. Key to this choreographic programming approach is our use of staged programming, which lets us expose a high-level Rust API while compiling local compute units into individual binaries with zero-overhead. We also explore how this approach, combined with Rust's trait system, enables a type-safe API for mapping dataflow programs to cloud computing resources.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.14733v1</guid>
      <category>cs.PL</category>
      <category>cs.DC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shadaj Laddad, Alvin Cheung, Joseph M. Hellerstein</dc:creator>
    </item>
    <item>
      <title>Story of Your Lazy Function's Life: A Bidirectional Demand Semantics for Mechanized Cost Analysis of Lazy Programs</title>
      <link>https://arxiv.org/abs/2406.14787</link>
      <description>arXiv:2406.14787v1 Announce Type: new 
Abstract: Lazy evaluation is a powerful tool that enables better compositionality and potentially better performance in functional programming, but it is challenging to analyze its computation cost. Existing works either require manually annotating sharing, or rely on separation logic to reason about heaps of mutable cells. In this paper, we propose a bidirectional demand semantics that allows for extrinsic reasoning about the computation cost of lazy programs without relying on special program logics. To show the effectiveness of our approach, we apply the demand semantics to a variety of case studies including insertion sort, selection sort, Okasaki's banker's queue, and the implicit queue. We formally prove that the banker's queue and the implicit queue are both amortized and persistent using the Rocq Prover (formerly known as Coq). We also propose the reverse physicist's method, a novel variant of the classical physicist's method, which enables mechanized, modular and compositional reasoning about amortization and persistence with the demand semantics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.14787v1</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Li-yao Xia, Laura Israel, Maite Kramarz, Nicholas Coltharp, Koen Claessen, Stephanie Weirich, Yao Li</dc:creator>
    </item>
    <item>
      <title>Qrisp: A Framework for Compilable High-Level Programming of Gate-Based Quantum Computers</title>
      <link>https://arxiv.org/abs/2406.14792</link>
      <description>arXiv:2406.14792v1 Announce Type: cross 
Abstract: While significant progress has been made on the hardware side of quantum computing, support for high-level quantum programming abstractions remains underdeveloped compared to classical programming languages. In this article, we introduce Qrisp, a framework designed to bridge several gaps between high-level programming paradigms in state-of-the-art software engineering and the physical reality of today's quantum hardware. The framework aims to provide a systematic approach to quantum algorithm development such that they can be effortlessly implemented, maintained and improved. We propose a number of programming abstractions that are inspired by classical paradigms, yet consistently focus on the particular needs of a quantum developer. Unlike many other high-level language approaches, Qrisp's standout feature is its ability to compile programs to the circuit level, making them executable on most existing physical backends. The introduced abstractions enable the Qrisp compiler to leverage algorithm structure for increased compilation efficiency. Finally, we present a set of code examples, including an implementation of Shor's factoring algorithm. For the latter, the resulting circuit shows significantly reduced quantum resource requirements, strongly supporting the claim that systematic quantum algorithm development can give quantitative benefits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.14792v1</guid>
      <category>quant-ph</category>
      <category>cs.PL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Raphael Seidel, Sebastian Bock, Ren\'e Zander, Matic Petri\v{c}, Niklas Steinmann, Nikolay Tcholtchev, Manfred Hauswirth</dc:creator>
    </item>
    <item>
      <title>KATch: A Fast Symbolic Verifier for NetKAT</title>
      <link>https://arxiv.org/abs/2404.04760</link>
      <description>arXiv:2404.04760v2 Announce Type: replace 
Abstract: We develop new data structures and algorithms for checking verification queries in NetKAT, a domain-specific language for specifying the behavior of network data planes. Our results extend the techniques obtained in prior work on symbolic automata and provide a framework for building efficient and scalable verification tools. We present KATch, an implementation of these ideas in Scala, featuring an extended set of NetKAT operators that are useful for expressing network-wide specifications, and a verification engine that constructs a bisimulation or generates a counter-example showing that none exists. We evaluate the performance of our implementation on real-world and synthetic benchmarks, verifying properties such as reachability and slice isolation, typically returning a result in well under a second, which is orders of magnitude faster than previous approaches. Our advancements underscore NetKAT's potential as a practical, declarative language for network specification and verification.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04760v2</guid>
      <category>cs.PL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3656454</arxiv:DOI>
      <dc:creator>Mark Moeller, Jules Jacobs, Olivier Savary Belanger, David Darais, Cole Schlesinger, Steffen Smolka, Nate Foster, Alexandra Silva</dc:creator>
    </item>
    <item>
      <title>Secure Composition of Robust and Optimising Compilers</title>
      <link>https://arxiv.org/abs/2307.08681</link>
      <description>arXiv:2307.08681v2 Announce Type: replace-cross 
Abstract: To ensure that secure applications do not leak their secrets, they are required to uphold several security properties such as spatial and temporal memory safety as well as cryptographic constant time. Existing work shows how to enforce these properties individually, in an architecture-independent way, by using secure compiler passes that each focus on an individual property. Unfortunately, given two secure compiler passes that each preserve a possibly different security property, it is unclear what kind of security property is preserved by the composition of those secure compiler passes. This paper is the first to study what security properties are preserved across the composition of different secure compiler passes. Starting from a general theory of property composition for security-relevant properties (such as the aforementioned ones), this paper formalises a theory of composition of secure compilers. Then, it showcases this theory a secure multi-pass compiler that preserves the aforementioned security-relevant properties. Crucially, this paper derives the security of the multi-pass compiler from the composition of the security properties preserved by its individual passes, which include security-preserving as well as optimisation passes. From an engineering perspective, this is the desirable approach to building secure compilers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.08681v2</guid>
      <category>cs.CR</category>
      <category>cs.PL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Matthis Kruse, Michael Backes, Marco Patrignani</dc:creator>
    </item>
  </channel>
</rss>
