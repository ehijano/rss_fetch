<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Dec 2024 05:00:54 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Semantics Foundation of Reductive Reasoning</title>
      <link>https://arxiv.org/abs/2412.14758</link>
      <description>arXiv:2412.14758v1 Announce Type: new 
Abstract: The development of logic has largely been through the 'deductive' paradigm: conclusions are inferred from established premisses. However, the use of logic in the context of both human and machine reasoning is typically through the dual 'reductive' perspective: collections of sufficient premisses are generated from putative conclusions. We call this paradigm, 'reductive logic'. This expression of logic encompass as diverse reasoning activities as proving a formula in a formal system to seeking to meet a friend before noon on Saturday. This paper is a semantical analysis of reductive logic. In particular, we provide mathematical foundations for representing and reasoning about 'reduction operators'. Heuristically, reduction operators may be thought of as `backwards' inference rules. In this paper, we address their mathematical representation, how they are used in the context of reductive reasoning, and, crucially, what makes them 'valid'.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14758v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:journal_reference>Topoi 2024, Special issue 'Meaning and Understanding via Proofs'</arxiv:journal_reference>
      <dc:creator>Alexander V. Gheorghiu, David J. Pym</dc:creator>
    </item>
    <item>
      <title>Le chameau et le serpent rentrent dans un bar : v\'erification quasi-automatique de code OCaml en logique de s\'eparation</title>
      <link>https://arxiv.org/abs/2412.14894</link>
      <description>arXiv:2412.14894v1 Announce Type: new 
Abstract: This paper presents a translation from Gospel-annotated OCaml programs into Viper, an intermediate verification language featuring Separation Logic. The practical goal is to extend Cameleer with a new back-end to prove heap-dependent OCaml programs. The logical specification of such OCaml programs is described using an extension of Gospel to support Separation Logic features, which we describe in the paper.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14894v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Charl\`ene Gros, M\'ario Pereira</dc:creator>
    </item>
    <item>
      <title>Cirbo: A New Tool for Boolean Circuit Analysis and Synthesis</title>
      <link>https://arxiv.org/abs/2412.14933</link>
      <description>arXiv:2412.14933v1 Announce Type: new 
Abstract: We present an open-source tool for manipulating Boolean circuits. It implements efficient algorithms, both existing and novel, for a rich variety of frequently used circuit tasks such as satisfiability, synthesis, and minimization. We tested the tool on a wide range of practically relevant circuits (computing, in particular, symmetric and arithmetic functions) that have been optimized intensively by the community for the last three years. The tool helped us to win the IWLS 2024 Programming Contest. In 2023, it was Google DeepMind who took the first place in the competition. We were able to reduce the size of the best circuits from 2023 by 12\% on average, whereas for some individual circuits, our size reduction was as large as 83\%.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14933v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniil Averkov, Tatiana Belova, Gregory Emdin, Mikhail Goncharov, Viktoriia Krivogornitsyna, Alexander S. Kulikov, Fedor Kurmazov, Daniil Levtsov, Georgie Levtsov, Vsevolod Vaskin, Aleksey Vorobiev</dc:creator>
    </item>
    <item>
      <title>Expressivity of AuDaLa: Turing Completeness and Possible Extensions</title>
      <link>https://arxiv.org/abs/2412.14938</link>
      <description>arXiv:2412.14938v1 Announce Type: new 
Abstract: AuDaLa is a recently introduced programming language that follows the new data autonomous paradigm. In this paradigm, small pieces of data execute functions autonomously. Considering the paradigm and the design choices of AuDaLa, it is interesting to determine the expressiveness of the language and to create verification methods for it. In this paper, we implement Turing machines in AuDaLa and prove that implementation correct. This proves that AuDaLa is Turing complete, giving an initial indication of AuDaLa's expressiveness, and by proving the implementation correct this contributes to the creation of verification methods for AuDaLa. Additionally, we give examples of how to add in possible extensions for AuDaLa to increase its expressivity to better match conventional parallel languages, allowing for a smoother and more performant implementation of algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14938v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tom T. P. Franken, Thomas Neele</dc:creator>
    </item>
    <item>
      <title>Towards Provable Security in Industrial Control Systems Via Dynamic Protocol Attestation</title>
      <link>https://arxiv.org/abs/2412.14467</link>
      <description>arXiv:2412.14467v1 Announce Type: cross 
Abstract: Industrial control systems (ICSs) increasingly rely on digital technologies vulnerable to cyber attacks. Cyber attackers can infiltrate ICSs and execute malicious actions. Individually, each action seems innocuous. But taken together, they cause the system to enter an unsafe state. These attacks have resulted in dramatic consequences such as physical damage, economic loss, and environmental catastrophes. This paper introduces a methodology that restricts actions using protocols. These protocols only allow safe actions to execute. Protocols are written in a domain specific language we have embedded in an interactive theorem prover (ITP). The ITP enables formal, machine-checked proofs to ensure protocols maintain safety properties. We use dynamic attestation to ensure ICSs conform to their protocol even if an adversary compromises a component. Since protocol conformance prevents unsafe actions, the previously mentioned cyber attacks become impossible. We demonstrate the effectiveness of our methodology using an example from the Fischertechnik Industry 4.0 platform. We measure dynamic attestation's impact on latency and throughput. Our approach is a starting point for studying how to combine formal methods and protocol design to thwart attacks intended to cripple ICSs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14467v1</guid>
      <category>cs.CR</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Arthur Amorim, Trevor Kann, Max Taylor, Lance Joneckis</dc:creator>
    </item>
    <item>
      <title>Towards Projected and Incremental Pseudo-Boolean Model Counting</title>
      <link>https://arxiv.org/abs/2412.14485</link>
      <description>arXiv:2412.14485v1 Announce Type: cross 
Abstract: Model counting is a fundamental task that involves determining the number of satisfying assignments to a logical formula, typically in conjunctive normal form (CNF). While CNF model counting has received extensive attention over recent decades, interest in Pseudo-Boolean (PB) model counting is just emerging partly due to the greater flexibility of PB formulas. As such, we observed feature gaps in existing PB counters such as a lack of support for projected and incremental settings, which could hinder adoption.
  In this work, our main contribution is the introduction of the PB model counter PBCount2, the first exact PB model counter with support for projected and incremental model counting. Our counter, PBCount2, uses our Least Occurrence Weighted Min Degree (LOW-MD) computation ordering heuristic to support projected model counting and a cache mechanism to enable incremental model counting. In our evaluations, PBCount2 completed at least 1.40x the number of benchmarks of competing methods for projected model counting and at least 1.18x of competing methods in incremental model counting.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14485v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Suwei Yang, Kuldeep S. Meel</dc:creator>
    </item>
    <item>
      <title>Reachability in Vector Addition System with States Parameterized by Geometric Dimension</title>
      <link>https://arxiv.org/abs/2412.14608</link>
      <description>arXiv:2412.14608v1 Announce Type: cross 
Abstract: The geometric dimension of a Vector Addition System with States (VASS), emerged in Leroux and Schmitz (2019) and formalized by Fu, Yang, and Zheng (2024), quantifies the dimension of the vector space spanned by cycle effects in the system. This paper explores the VASS reachability problem through the lens of geometric dimension, revealing key differences from the traditional dimensional parameterization. Notably, we establish that the reachability problem for both geometrically 1-dimensional and 2-dimensional VASS is PSPACE-complete, achieved by extending the pumping technique originally proposed by Czerwi\'nski et al. (2019).</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14608v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yangluo Zheng</dc:creator>
    </item>
    <item>
      <title>LTLf Synthesis Under Unreliable Input</title>
      <link>https://arxiv.org/abs/2412.14728</link>
      <description>arXiv:2412.14728v1 Announce Type: cross 
Abstract: We study the problem of realizing strategies for an LTLf goal specification while ensuring that at least an LTLf backup specification is satisfied in case of unreliability of certain input variables. We formally define the problem and characterize its worst-case complexity as 2EXPTIME-complete, like standard LTLf synthesis. Then we devise three different solution techniques: one based on direct automata manipulation, which is 2EXPTIME, one disregarding unreliable input variables by adopting a belief construction, which is 3EXPTIME, and one leveraging second-order quantified LTLf (QLTLf), which is 2EXPTIME and allows for a direct encoding into monadic second-order logic, which in turn is worst-case nonelementary. We prove their correctness and evaluate them against each other empirically. Interestingly, theoretical worst-case bounds do not translate into observed performance; the MSO technique performs best, followed by belief construction and direct automata manipulation. As a byproduct of our study, we provide a general synthesis procedure for arbitrary QLTLf specifications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14728v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christian Hagemeier, Giuseppe de Giacomo, Moshe Y. Vardi</dc:creator>
    </item>
    <item>
      <title>Probabilistic Strategy Logic with Degrees of Observability</title>
      <link>https://arxiv.org/abs/2412.15135</link>
      <description>arXiv:2412.15135v1 Announce Type: cross 
Abstract: There has been considerable work on reasoning about the strategic ability of agents under imperfect information. However, existing logics such as Probabilistic Strategy Logic are unable to express properties relating to information transparency. Information transparency concerns the extent to which agents' actions and behaviours are observable by other agents. Reasoning about information transparency is useful in many domains including security, privacy, and decision-making. In this paper, we present a formal framework for reasoning about information transparency properties in stochastic multi-agent systems. We extend Probabilistic Strategy Logic with new observability operators that capture the degree of observability of temporal properties by agents. We show that the model checking problem for the resulting logic is decidable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.15135v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Chunyan Mu, Nima Motamed, Natasha Alechina, Brian Logan</dc:creator>
    </item>
    <item>
      <title>The Church Synthesis Problem over Continuous Time</title>
      <link>https://arxiv.org/abs/2404.04782</link>
      <description>arXiv:2404.04782v2 Announce Type: replace 
Abstract: The Church Problem asks for the construction of a procedure which, given a logical specification A(I,O) between input omega-strings I and output omega-strings O, determines whether there exists an operator F that implements the specification in the sense that A(I, F(I)) holds for all inputs I. Buchi and Landweber provided a procedure to solve the Church problem for MSO specifications and operators computable by finite-state automata. We investigate a generalization of the Church synthesis problem to the continuous time domain of the non-negative reals.
  We show that in the continuous time domain there are phenomena which are very different from the canonical discrete time domain of the natural numbers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04782v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander Rabinovich, Daniel Fattal</dc:creator>
    </item>
    <item>
      <title>An automata-based approach for synchronizable mailbox communication</title>
      <link>https://arxiv.org/abs/2407.06968</link>
      <description>arXiv:2407.06968v5 Announce Type: replace 
Abstract: We revisit finite-state communicating systems with round-based communication under mailbox semantics. Mailboxes correspond to one FIFO buffer per process (instead of one buffer per pair of processes in peer-to-peer systems). Round-based communication corresponds to sequences of rounds in which processes can first send messages, then only receive (and receives must be in the same round as their sends). A system is called synchronizable if every execution can be re-scheduled into an equivalent execution that is a sequence of rounds. Previous work mostly considered the setting where rounds have fixed size. Our main contribution shows that the problem whether a mailbox communication system complies with the round-based policy, with no size limitation on rounds, is Pspace-complete. For this we use a novel automata-based approach, that also allows to determine the precise complexity (Pspace) of several questions considered in previous literature.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.06968v5</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Romain Delpy, Anca Muscholl, Gr\'egoire Sutre</dc:creator>
    </item>
    <item>
      <title>A Syntactic Approach to Computing Complete and Sound Abstraction in the Situation Calculus</title>
      <link>https://arxiv.org/abs/2412.11217</link>
      <description>arXiv:2412.11217v2 Announce Type: replace 
Abstract: Abstraction is an important and useful concept in the field of artificial intelligence. To the best of our knowledge, there is no syntactic method to compute a sound and complete abstraction from a given low-level basic action theory and a refinement mapping. This paper aims to address this issue.To this end, we first present a variant of situation calculus,namely linear integer situation calculus, which serves as the formalization of high-level basic action theory. We then migrate Banihashemi, De Giacomo, and Lesp\'erance's abstraction framework to one from linear integer situation calculus to extended situation calculus. Furthermore, we identify a class of Golog programs, namely guarded actions,that is used to restrict low-level Golog programs, and impose some restrictions on refinement mappings. Finally, we design a syntactic approach to computing a sound and complete abstraction from a low-level basic action theory and a restricted refinement mapping.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.11217v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Liangda Fang, Xiaoman Wang, Zhang Chen, Kailun Luo, Zhenhe Cui, Quanlong Guan</dc:creator>
    </item>
    <item>
      <title>A flexible specification approach for verifying total correctness of fine-grained concurrent modules</title>
      <link>https://arxiv.org/abs/2312.15379</link>
      <description>arXiv:2312.15379v2 Announce Type: replace-cross 
Abstract: A well-established approach to proving progress properties such as deadlock-freedom and termination is to associate obligations with threads. For example, in most existing work the proof rule for lock acquisition prescribes a standard usage protocol by burdening the acquiring thread with an obligation to release the lock. The fact that the obligation creation is hardcoded into the acquire operation, however, rules out non-standard clients e.g. where the release happens in a different thread.
  We overcome this limitation by instead having the blocking operations take the obligation creation operations required for the specific client scenario as arguments. We dub this simple instance of higher-order programming with auxiliary code Sassy. To illustrate Sassy, we extend HeapLang, a simple, higher-order, concurrent programming language with erasable code and state. The resulting language gets stuck if no progress is made. Consequently, we can apply standard safety separation logic to compositionally reason about termination in a fine-grained concurrent setting.
  We validated Sassy by developing (non-foundational) machine-checked proofs of representative locks -- an unfair Spinlock (competitive succession), a fair Ticketlock (direct handoff succession) and the hierarchically constructed Cohortlock that is starvation-free if the underlying locks are starvation-free -- against our specifications using an encoding of the approach in the VeriFast program verifier for C and Java.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.15379v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Justus Fasse, Bart Jacobs</dc:creator>
    </item>
    <item>
      <title>An independence of the MIN principle from the PHP principle</title>
      <link>https://arxiv.org/abs/2406.14930</link>
      <description>arXiv:2406.14930v3 Announce Type: replace-cross 
Abstract: We extend the typical forcing of M. M\"uller and derive conditions on the forcing frame for which generic expansions preserve injective/bijective pigeonhole principle for polynomial-time computable graphs of functions. Applying this machinery, we show that the bounded arithmetic theory $\forall \textsf{T}^1_2(\textsf{PV}(\alpha))$ augmented by the polynomial-time injective pigeonhole principle does not prove the linear ordering, tournament, and dual weak pigeonhole principles.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.14930v3</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Fri, 20 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mykyta Narusevych</dc:creator>
    </item>
  </channel>
</rss>
