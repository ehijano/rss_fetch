<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Apr 2024 04:00:12 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 23 Apr 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Characterization of Isometric Words based on Swap and Mismatch Distance</title>
      <link>https://arxiv.org/abs/2404.13577</link>
      <description>arXiv:2404.13577v1 Announce Type: new 
Abstract: In this paper we consider an edit distance with swap and mismatch operations, called tilde-distance, and introduce the corresponding definition of tilde-isometric word. Isometric words are classically defined with respect to Hamming distance and combine the notion of edit distance with the property that a word does not appear as factor in other words. A word f is said tilde-isometric if, for any pair of f-free words u and v, there exists a transformation from u to v via the related edit operations such that all the intermediate words are also f -free. This new setting is here studied giving a full characterization of the tilde-isometric words in terms of overlaps with errors.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.13577v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>M. Anselmo, G. Castiglione, M. Flores, D. Giammarresi, M. Madonia, S. Mantaci</dc:creator>
    </item>
    <item>
      <title>Opacity complexity of automatic sequences. The general case</title>
      <link>https://arxiv.org/abs/2404.13601</link>
      <description>arXiv:2404.13601v1 Announce Type: new 
Abstract: In this work we introduce a new notion called opacity complexity to measure the complexity of automatic sequences. We study basic properties of this notion, and exhibit an algorithm to compute it. As applications, we compute the opacity complexity of some well-known automatic sequences, including in particular constant sequences, purely periodic sequences, the Thue-Morse sequence, the period-doubling sequence, the Golay-Shapiro(-Rudin) sequence, the paperfolding sequence, the Baum-Sweet sequence, the Tower of Hanoi sequence, and so on.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.13601v1</guid>
      <category>cs.FL</category>
      <category>math.CO</category>
      <category>math.NT</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>J. -P. Allouche, J. -Y. Yao</dc:creator>
    </item>
    <item>
      <title>Unambiguous and Co-Nondeterministic Computations of Finite Automata and Pushdown Automata Families and the Effects of Multiple Counters</title>
      <link>https://arxiv.org/abs/2404.13254</link>
      <description>arXiv:2404.13254v1 Announce Type: cross 
Abstract: Nonuniform families of polynomial-size finite automata and pushdown automata respectively have strong connections to nonuniform-NL and nonuniform-LOGCFL. We examine the behaviors of unambiguous and co-nondeterministic computations produced by such families of automata operating multiple counters. As its consequences, we obtain various collapses of the complexity classes of families of promise problems solvable by finite and pushdown automata families when all valid instances are limited to either polynomially long strings or unary strings. A key technical ingredient of our proofs is an inductive counting of reachable vertices of each computation graph of finite and pushdown automata that operate multiple counters simultaneously.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.13254v1</guid>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tomoyuki Yamakami</dc:creator>
    </item>
    <item>
      <title>Functional Closure Properties of Finite $\mathbb{N}$-weighted Automata</title>
      <link>https://arxiv.org/abs/2404.14245</link>
      <description>arXiv:2404.14245v1 Announce Type: cross 
Abstract: We determine all functional closure properties of finite $\mathbb{N}$-weighted automata, even all multivariate ones, and in particular all multivariate polynomials. We also determine all univariate closure properties in the promise setting, and all multivariate closure properties under certain assumptions on the promise, in particular we determine all multivariate closure properties where the output vector lies on a monotone algebraic graph variety.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.14245v1</guid>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Julian D\"orfler, Christian Ikenmeyer</dc:creator>
    </item>
    <item>
      <title>Constructing Concise Characteristic Samples for Acceptors of Omega Regular Languages</title>
      <link>https://arxiv.org/abs/2209.09336</link>
      <description>arXiv:2209.09336v3 Announce Type: replace 
Abstract: A characteristic sample for a language $L$ and a learning algorithm $\textbf{L}$ is a finite sample of words $T_L$ labeled by their membership in $L$ such that for any sample $T \supseteq T_L$ consistent with $L$, on input $T$ the learning algorithm $\textbf{L}$ returns a hypothesis equivalent to $L$. Which omega automata have characteristic sets of polynomial size, and can these sets be constructed in polynomial time? We address these questions here.
  In brief, non-deterministic omega automata of any of the common types, in particular B\"uchi, do not have characteristic samples of polynomial size. For deterministic omega automata that are isomorphic to their right congruence automata, the fully informative languages, polynomial time algorithms for constructing characteristic samples and learning from them are given.
  The algorithms for constructing characteristic sets in polynomial time for the different omega automata (of types B\"uchi, coB\"uchi, parity, Rabin, Street, or Muller), require deterministic polynomial time algorithms for (1) equivalence of the respective omega automata, and (2) testing membership of the language of the automaton in the informative classes, which we provide.</description>
      <guid isPermaLink="false">oai:arXiv.org:2209.09336v3</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dana Angluin, Dana Fisman</dc:creator>
    </item>
    <item>
      <title>From Muller to Parity and Rabin Automata: Optimal Transformations Preserving (History) Determinism</title>
      <link>https://arxiv.org/abs/2305.04323</link>
      <description>arXiv:2305.04323v3 Announce Type: replace 
Abstract: We study transformations of automata and games using Muller conditions into equivalent ones using parity or Rabin conditions. We present two transformations, one that turns a deterministic Muller automaton into an equivalent deterministic parity automaton, and another that provides an equivalent history-deterministic Rabin automaton. We show a strong optimality result: the obtained automata are minimal amongst those that can be derived from the original automaton by duplication of states. We introduce the notions of locally bijective morphisms and history-deterministic mappings to formalise the correctness and optimality of these transformations.
  The proposed transformations are based on a novel structure, called the alternating cycle decomposition, inspired by and extending Zielonka trees. In addition to providing optimal transformations of automata, the alternating cycle decomposition offers fundamental information on their structure. We use this information to give crisp characterisations on the possibility of relabelling automata with different acceptance conditions and to perform a systematic study of a normal form for parity automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.04323v3</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.46298/theoretics.24.12</arxiv:DOI>
      <arxiv:journal_reference>TheoretiCS, Volume 3 (2024), Article 12, 1-110</arxiv:journal_reference>
      <dc:creator>Antonio Casares, Thomas Colcombet, Nathana\"el Fijalkow, Karoliina Lehtinen</dc:creator>
    </item>
    <item>
      <title>Lemur: Integrating Large Language Models in Automated Program Verification</title>
      <link>https://arxiv.org/abs/2310.04870</link>
      <description>arXiv:2310.04870v4 Announce Type: replace 
Abstract: The demonstrated code-understanding capability of LLMs raises the question of whether they can be used for automated program verification, a task that demands high-level abstract reasoning about program properties that is challenging for verification tools. We propose a general methodology to combine the power of LLMs and automated reasoners for automated program verification. We formally describe this methodology as a set of transition rules and prove its soundness. We instantiate the calculus as a sound automated verification procedure and demonstrate practical improvements on a set of synthetic and competition benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.04870v4</guid>
      <category>cs.FL</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Haoze Wu, Clark Barrett, Nina Narodytska</dc:creator>
    </item>
    <item>
      <title>Preserving self-similarity in free products of semigroups</title>
      <link>https://arxiv.org/abs/2003.12810</link>
      <description>arXiv:2003.12810v3 Announce Type: replace-cross 
Abstract: We improve on earlier results on the closure under free products of the class of automaton semigroups. We consider partial automata and show that the free product of two self-similar semigroups (or automaton semigroups) is self-similar (an automaton semigroup) if there is a homomorphism from one of the base semigroups to the other. The construction used is computable and yields further consequences. One of them is that we can adjoin a free generator to any self-similar semigroup (or automaton semigroup) and preserve the property of self-similarity (or being an automaton semigroup).
  The existence of a homomorphism between two semigroups is a very lax requirement; in particular, it is satisfied if one of the semigroups contains an idempotent. To explore the limits of this requirement, we show that no simple or $0$-simple idempotent-free semigroup is a finitely generated self-similar semigroup (or an automaton semigroup). Furthermore, we give an example of a pair of residually finite semigroups without a homomorphism from one to the other.</description>
      <guid isPermaLink="false">oai:arXiv.org:2003.12810v3</guid>
      <category>math.GR</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Tara Macalister Brough, Jan Philipp W\"achter, Janette Welker</dc:creator>
    </item>
    <item>
      <title>Walking on Words</title>
      <link>https://arxiv.org/abs/2208.08913</link>
      <description>arXiv:2208.08913v2 Announce Type: replace-cross 
Abstract: Take any word over some alphabet. If it is non-empty, go to any position and print out the letter being scanned. Now repeat the following any number of times (possibly zero): either stay at the current letter, or move one letter leftwards (if possible) or move one letter rightwards (if possible); then print out the letter being scanned. In effect, we are going for a walk on the input word. Let u be the infix of the input word comprising the visited positions, and w the word printed out (empty if the input word is). Since any unvisited prefix or suffix of the input word cannot influence w, we may as well discard them, and say that u generates w. We ask: given a word w, what words u generate it? The answer is surprising. Call u a primitive generator of w if u generates w and is not generated by any word shorter than u. We show that, excepting some degenerate cases, every word has precisely two primitive generators.</description>
      <guid isPermaLink="false">oai:arXiv.org:2208.08913v2</guid>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ian Pratt-Hartmann</dc:creator>
    </item>
  </channel>
</rss>
