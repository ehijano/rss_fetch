<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Jan 2025 03:45:48 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 27 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Fined-Grained Complexity of Ambiguity Problems on Automata and Directed Graphs</title>
      <link>https://arxiv.org/abs/2501.14725</link>
      <description>arXiv:2501.14725v1 Announce Type: new 
Abstract: Two fundamental classes of finite automata are deterministic and nondeterministic ones (DFAs and NFAs). Natural intermediate classes arise from bounds on an NFA's allowed ambiguity, i.e. number of accepting runs per word: unambiguous, finitely ambiguous, and polynomially ambiguous finite automata. It is known that deciding whether a given NFA is unambiguous and whether it is polynomially ambiguous is possible in quadratic time, and deciding finite ambiguity is possible in cubic time. We provide matching lower bounds showing these running times to be optimal, assuming popular fine-grained complexity hypotheses.
  We improve the upper bounds for unary automata, which are essentially directed graphs with a source and a target. In this view, unambiguity asks whether all walks from the source to the target have different lengths. The running time analysis of our algorithm reduces to bounding the entry-wise 1-norm of a GCD matrix, yielding a near-linear upper bound. For finite and polynomial ambiguity, we provide simple linear-time algorithms in the unary case.
  Finally, we study the twins property for weighted automata over the tropical semiring, which characterises the determinisability of unambiguous weighted automata. It occurs naturally in our context as deciding the twins property is an intermediate step in determinisability algorithms for weighted automata with bounded ambiguity. We show that Allauzen and Mohri's quadratic-time algorithm checking the twins property is optimal up to the same fine-grained hypotheses as for unambiguity. For unary automata, we show that the problem can be rephrased to whether all cycles in a weighted directed graph have the same average weight and give a linear-time algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14725v1</guid>
      <category>cs.FL</category>
      <pubDate>Mon, 27 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Karolina Drabik, Anita D\"urr, Fabian Frei, Filip Mazowiecki, Karol W\k{e}grzycki</dc:creator>
    </item>
    <item>
      <title>In System Alignments we Trust! Explainable Alignments via Projections</title>
      <link>https://arxiv.org/abs/2501.14360</link>
      <description>arXiv:2501.14360v1 Announce Type: cross 
Abstract: Alignments are a well-known process mining technique for reconciling system logs and normative process models. Evidence of certain behaviors in a real system may only be present in one representation - either a log or a model - but not in the other. Since for processes in which multiple entities, like objects and resources, are involved in the activities, their interactions affect the behavior and are therefore essential to take into account in the alignments.
  Additionally, both logged and modeled representations of reality may be imprecise and only partially represent some of these entities, but not all. In this paper, we introduce the concept of "relaxations" through projections for alignments to deal with partially correct models and logs. Relaxed alignments help to distinguish between trustworthy and untrustworthy content of the two representations (the log and the model) to achieve a better understanding of the underlying process and expose quality issues.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14360v1</guid>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <pubDate>Mon, 27 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dominique Sommers, Natalia Sidorova, Boudewijn van Dongen</dc:creator>
    </item>
    <item>
      <title>A Naturally-Colored Translation from LTL to Parity and COCOA</title>
      <link>https://arxiv.org/abs/2410.01021</link>
      <description>arXiv:2410.01021v2 Announce Type: replace 
Abstract: Chains of co-Buechi automata (COCOA) have recently been introduced as a new canonical representation of omega-regular languages. The co-Buechi automata in a chain assign to each omega-word its natural color, which depends only on the language itself and not on its automaton representation. The automata in such a chain can be minimized in polynomial time and are good-for-games, making the representation attractive for verification and reactive synthesis applications. However, since in such applications, a specification is usually given in linear temporal logic (LTL), to make COCOA useful, the specification first has to be translated into such a chain of automata. Currently, the only known translation procedure involves a detour through deterministic parity automata (LTL to DPW to COCOA), where the first step neglects the natural colors and requires intricate constructions by Safra or Esparza et al. This observation raises the question whether, by leveraging the definition of the natural color of words, these complex constructions can be avoided, leading to a more direct translation from LTL to COCOA.
  In this paper, we present a surprisingly simple translation from LTL to COCOA, along with a variant that translates from LTL to DPW. Our procedure relies on standard operations on weak alternating automata, Miyano-Hayashi's breakpoint construction, an augmented subset construction, and simple graph algorithms. With weak alternating automata as a starting point, the procedure can also handle specifications in linear dynamic logic. Although the translation procedure runs in sub-optimal triply-exponential time (vs. doubly-exponential optimal), it constitutes a novel path for translating from LTL to DPW, avoiding the aforementioned intricate constructions entirely.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.01021v2</guid>
      <category>cs.FL</category>
      <pubDate>Mon, 27 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>R\"udiger Ehlers, Ayrat Khalimov</dc:creator>
    </item>
    <item>
      <title>Checking Timed Bisimilarity with Virtual Clocks</title>
      <link>https://arxiv.org/abs/2412.15799</link>
      <description>arXiv:2412.15799v4 Announce Type: replace 
Abstract: Timed automata are a widely used formalism for specifying the discrete-state/continuous-time behavior of time-critical reactive systems. For the fundamental verification problem of comparing two timed automata, it has been shown that timed trace equivalence is undecidable, while timed bisimulation is decidable. The corresponding decidability proof uses region graphs, a finite but space-consuming characterization of timed automata semantics. Most verification tools use zone graphs instead, a symbolic and, on average, more space-efficient representation of timed automata semantics. However, zone graphs provide correct results only for those verification tasks that are reducible to reachability problems, and are too imprecise for timed bisimilarity checking. To the best of our knowledge, there is currently no practical tool for automated timed bisimilarity checking. In this paper, we propose a new representation of timed automata semantics that extends zone graphs by so-called virtual clocks. Our zone-based construction is, on average, significantly smaller than the corresponding region graph representation. We also present experimental results obtained by applying our tool implementation to timed automata models, which are often used to evaluate timed automata analysis techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.15799v4</guid>
      <category>cs.FL</category>
      <pubDate>Mon, 27 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Alexander Lieb, Hendrik G\"ottmann, Lars Luthmann, Malte Lochau, Andy Sch\"urr</dc:creator>
    </item>
    <item>
      <title>On the Representational Capacity of Neural Language Models with Chain-of-Thought Reasoning</title>
      <link>https://arxiv.org/abs/2406.14197</link>
      <description>arXiv:2406.14197v2 Announce Type: replace-cross 
Abstract: The performance of modern language models (LMs) has been improved by chain-of-thought (CoT) reasoning, i.e., the process of generating intermediate results that guide the model towards a final answer. A possible explanation for this improvement is that CoT reasoning extends an LM's computational power, as RNNs and transformers with additional scratch space are known to be Turing complete. Comparing LMs to Turing machines, however, introduces a category error - Turing machines decide language membership, whereas LMs define distributions over strings. To bridge this gap, we formalize CoT reasoning in a probabilistic setting. We present several results on the representational capacity of recurrent and transformer LMs with CoT reasoning, showing that they can represent the same family of distributions over strings as probabilistic Turing machines.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.14197v2</guid>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <pubDate>Mon, 27 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Franz Nowak, Anej Svete, Alexandra Butoi, Ryan Cotterell</dc:creator>
    </item>
  </channel>
</rss>
