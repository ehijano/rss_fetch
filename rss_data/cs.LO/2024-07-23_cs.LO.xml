<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Jul 2024 01:41:25 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 23 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>A Cobham theorem for scalar multiplication</title>
      <link>https://arxiv.org/abs/2407.15118</link>
      <description>arXiv:2407.15118v1 Announce Type: cross 
Abstract: Let $\alpha,\beta \in \mathbb{R}_{&gt;0}$ be such that $\alpha,\beta$ are quadratic and $\mathbb{Q}(\alpha)\neq \mathbb{Q}(\beta)$. Then every subset of $\mathbb{R}^n$ definable in both $(\mathbb{R},{&lt;},+,\mathbb{Z},x\mapsto \alpha x)$ and $(\mathbb{R},{&lt;},+,\mathbb{Z},x\mapsto \beta x)$ is already definable in $(\mathbb{R},{&lt;},+,\mathbb{Z})$. As a consequence we generalize Cobham-Semenov theorems for sets of real numbers to $\beta$-numeration systems, where $\beta$ is a quadratic irrational.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.15118v1</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Philipp Hieronymi, Sven Manthe, Chris Schulz</dc:creator>
    </item>
    <item>
      <title>Error Detection and Constraint Recovery in Hierarchical Multi-Label Classification without Prior Knowledge</title>
      <link>https://arxiv.org/abs/2407.15192</link>
      <description>arXiv:2407.15192v1 Announce Type: cross 
Abstract: Recent advances in Hierarchical Multi-label Classification (HMC), particularly neurosymbolic-based approaches, have demonstrated improved consistency and accuracy by enforcing constraints on a neural model during training. However, such work assumes the existence of such constraints a-priori. In this paper, we relax this strong assumption and present an approach based on Error Detection Rules (EDR) that allow for learning explainable rules about the failure modes of machine learning models. We show that these rules are not only effective in detecting when a machine learning classifier has made an error but also can be leveraged as constraints for HMC, thereby allowing the recovery of explainable constraints even if they are not provided. We show that our approach is effective in detecting machine learning errors and recovering constraints, is noise tolerant, and can function as a source of knowledge for neurosymbolic models on multiple datasets, including a newly introduced military vehicle recognition dataset.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.15192v1</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Joshua Shay Kricheli, Khoa Vo, Aniruddha Datta, Spencer Ozgur, Paulo Shakarian</dc:creator>
    </item>
    <item>
      <title>Algebraic anti-unification</title>
      <link>https://arxiv.org/abs/2407.15510</link>
      <description>arXiv:2407.15510v1 Announce Type: cross 
Abstract: Abstraction is key to human and artificial intelligence as it allows one to see common structure in otherwise distinct objects or situations and as such it is a key element for generality in AI. Anti-unification (or generalization) is \textit{the} part of theoretical computer science and AI studying abstraction. It has been successfully applied to various AI-related problems, most importantly inductive logic programming. Up to this date, anti-unification is studied only from a syntactic perspective in the literature. The purpose of this paper is to initiate an algebraic (i.e. semantic) theory of anti-unification within general algebras. This is motivated by recent applications to similarity and analogical proportions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.15510v1</guid>
      <category>cs.AI</category>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Christian Anti\'c</dc:creator>
    </item>
    <item>
      <title>Coalgebraic Satisfiability Checking for Arithmetic $\mu$-Calculi</title>
      <link>https://arxiv.org/abs/2212.11055</link>
      <description>arXiv:2212.11055v5 Announce Type: replace 
Abstract: The coalgebraic $\mu$-calculus provides a generic semantic framework for fixpoint logics over systems whose branching type goes beyond the standard relational setup, e.g. probabilistic, weighted, or game-based. Previous work on the coalgebraic $\mu$-calculus includes an exponential-time upper bound on satisfiability checking, which however relies on the availability of tableau rules for the next-step modalities that are sufficiently well-behaved in a formally defined sense; in particular, rule matches need to be representable by polynomial-sized codes, and the sequent duals of the rules need to absorb cut. While such rule sets have been identified for some important cases, they are not known to exist in all cases of interest, in particular ones involving either integer weights as in the graded $\mu$-calculus, or real-valued weights in combination with non-linear arithmetic. In the present work, we prove the same upper complexity bound under more general assumptions, specifically regarding the complexity of the (much simpler) satisfiability problem for the underlying one-step logic, roughly described as the nesting-free next-step fragment of the logic. The bound is realized by a generic global caching algorithm that supports on-the-fly satisfiability checking. Notably, our approach directly accommodates unguarded formulae, and thus avoids use of the guardedness transformation. Example applications include new exponential-time upper bounds for satisfiability checking in an extension of the graded $\mu$-calculus with polynomial inequalities (including positive Presburger arithmetic), as well as an extension of the (two-valued) probabilistic $\mu$-calculus with polynomial inequalities.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.11055v5</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Hausmann, Lutz Schr\"oder</dc:creator>
    </item>
    <item>
      <title>Practical Deductive Verification of OCaml Programs (Extended Version)</title>
      <link>https://arxiv.org/abs/2404.17901</link>
      <description>arXiv:2404.17901v2 Announce Type: replace 
Abstract: In this paper, we provide a comprehensive, hands-on tutorial on how to apply deductive verification to programs written in OCaml. In particular, we show how one can use the GOSPEL specification language and the Cameleer tool to conduct mostly-automated verification on OCaml code. In our presentation, we focus on two main classes of programs: first, purely functional programs with no mutable state; then on imperative programs, where one can mix mutable state with subtle control-flow primitives, such as locally-defined exceptions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.17901v2</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>M\'ario Pereira</dc:creator>
    </item>
    <item>
      <title>Around Classical and Intuitionistic Linear Processes</title>
      <link>https://arxiv.org/abs/2407.06391</link>
      <description>arXiv:2407.06391v3 Announce Type: replace 
Abstract: Curry-Howard correspondences between Linear Logic (LL) and session types provide a firm foundation for concurrent processes. As the correspondences hold for intuitionistic and classic versions of LL (ILL and CLL), we obtain two different families of type systems for concurrency. An open question remains: how do these two families exactly relate to each other? Based upon a translation from CLL to ILL due to Laurent (2018), we provide two complementary answers, in the form of full abstraction results based on a typed observational equivalence due to Atkey (2017). Our results elucidate hitherto missing formal links between seemingly related yet different type systems for concurrency.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.06391v3</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Juan C. Jaramillo, Dan Frumin, Jorge A. P\'erez</dc:creator>
    </item>
    <item>
      <title>Tree algebras and bisimulation-invariant MSO on finite graphs</title>
      <link>https://arxiv.org/abs/2407.12677</link>
      <description>arXiv:2407.12677v3 Announce Type: replace 
Abstract: We establish that the bisimulation invariant fragment of MSO over finite transition systems is expressively equivalent over finite transition systems to modal mu-calculus, a question that had remained open for several decades. The proof goes by translating the question to an algebraic framework, and showing that the languages of regular trees that are recognized by finitary tree algebras whose sorts zero and one are finite are the regular ones, ie. the ones expressible in mu-calculus. This corresponds for trees to a weak form of the key translation of Wilke algebras to omega-semigroup over infinite words, and was also a missing piece in the algebraic theory of regular languages of infinite trees since twenty years.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.12677v3</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Thomas Colcombet, Amina Doumane, Denis Kuperberg</dc:creator>
    </item>
    <item>
      <title>Learn from Failure: Fine-Tuning LLMs with Trial-and-Error Data for Intuitionistic Propositional Logic Proving</title>
      <link>https://arxiv.org/abs/2404.07382</link>
      <description>arXiv:2404.07382v2 Announce Type: replace-cross 
Abstract: Recent advances in Automated Theorem Proving have shown the effectiveness of leveraging a (large) language model that generates tactics (i.e. proof steps) to search through proof states. The current model, while trained solely on successful proof paths, faces a discrepancy at the inference stage, as it must sample and try various tactics at each proof state until finding success, unlike its training which does not incorporate learning from failed attempts. Intuitively, a tactic that leads to a failed search path would indicate that similar tactics should receive less attention during the following trials. In this paper, we demonstrate the benefit of training models that additionally learn from failed search paths. Facing the lack of such trial-and-error data in existing open-source theorem-proving datasets, we curate a dataset on intuitionistic propositional logic theorems and formalize it in Lean, such that we can reliably check the correctness of proofs. We compare our model trained on relatively short trial-and-error information (TrialMaster) with models trained only on the correct paths and discover that the former solves more unseen theorems with lower trial searches.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.07382v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Chenyang An, Zhibo Chen, Qihao Ye, Emily First, Letian Peng, Jiayun Zhang, Zihan Wang, Sorin Lerner, Jingbo Shang</dc:creator>
    </item>
  </channel>
</rss>
