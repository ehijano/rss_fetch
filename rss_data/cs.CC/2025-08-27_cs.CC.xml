<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CC</link>
    <description>cs.CC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Aug 2025 04:01:05 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Pointer Chasing with Unlimited Interaction</title>
      <link>https://arxiv.org/abs/2508.19158</link>
      <description>arXiv:2508.19158v1 Announce Type: new 
Abstract: Pointer-chasing is a central problem in two-party communication complexity: given input size $n$ and a parameter $k$, the two players Alice and Bob are given functions $N_A, N_B: [n] \rightarrow [n]$, respectively, and their goal is to compute the value of $p_k$, where $p_0 = 1$, $p_1 = N_A(p_0)$, $p_2 = N_B(p_1) = N_B(N_A(p_0))$, $p_3 = N_A(p_2) = N_A(N_B(N_A(p_0)))$ and so on, applying $N_A$ in even steps and $N_B$ in odd steps, for a total of $k$ steps. It is trivial to solve the problem using $k$ communication rounds, with Alice speaking first, by simply ``chasing the function'' for $k$ steps. Many works have studied the communication complexity of pointer chasing, although the focus has always been on protocols with $k-1$ communication rounds, or with $k$ rounds where Bob (the ``wrong player'') speaks first. Many works have studied this setting giving sometimes tight or near-tight results.
  In this paper we study the communication complexity of the pointer chasing problem when the interaction between the two players is unlimited, i.e., without any restriction on the number of rounds. Perhaps surprisingly, this question was not studied before, to the best of our knowledge. Our main result is that the trivial $k$-round protocol is nearly tight (even) when the number of rounds is not restricted: we give a lower bound of $\Omega(k \log (n/k))$ on the randomized communication complexity of the pointer chasing problem with unlimited interaction, and a somewhat stronger lower bound of $\Omega(k \log \log{k})$ for protocols with zero error.
  When combined with prior work, our results also give a nearly-tight bound on the communication complexity of protocols using at most $k-1$ rounds, across all regimes of $k$; for $k &gt; \sqrt{n}$ there was previously a significant gap between the upper and lower bound.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.19158v1</guid>
      <category>cs.CC</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Orr Fischer, Rotem Oshman, Adi Rosen, Tal Roth</dc:creator>
    </item>
    <item>
      <title>Quantifying The Limits of AI Reasoning: Systematic Neural Network Representations of Algorithms</title>
      <link>https://arxiv.org/abs/2508.18526</link>
      <description>arXiv:2508.18526v1 Announce Type: cross 
Abstract: A main open question in contemporary AI research is quantifying the forms of reasoning neural networks can perform when perfectly trained. This paper answers this by interpreting reasoning tasks as circuit emulation, where the gates define the type of reasoning; e.g. Boolean gates for predicate logic, tropical circuits for dynamic programming, arithmetic and analytic gates for symbolic mathematical representation, and hybrids thereof for deeper reasoning; e.g. higher-order logic.
  We present a systematic meta-algorithm that converts essentially any circuit into a feedforward neural network (NN) with ReLU activations by iteratively replacing each gate with a canonical ReLU MLP emulator. We show that, on any digital computer, our construction emulates the circuit exactly--no approximation, no rounding, modular overflow included--demonstrating that no reasoning task lies beyond the reach of neural networks. The number of neurons in the resulting network (parametric complexity) scales with the circuit's complexity, and the network's computational graph (structure) mirrors that of the emulated circuit. This formalizes the folklore that NNs networks trade algorithmic run-time (circuit runtime) for space complexity (number of neurons).
  We derive a range of applications of our main result, from emulating shortest-path algorithms on graphs with cubic--size NNs, to simulating stopped Turing machines with roughly quadratically--large NNs, and even the emulation of randomized Boolean circuits. Lastly, we demonstrate that our result is strictly more powerful than a classical universal approximation theorem: any universal function approximator can be encoded as a circuit and directly emulated by a NN.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.18526v1</guid>
      <category>cs.LG</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <category>cs.NA</category>
      <category>cs.NE</category>
      <category>math.NA</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Anastasis Kratsios, Dennis Zvigelsky, Bradd Hart</dc:creator>
    </item>
    <item>
      <title>Random Unitaries in Constant (Quantum) Time</title>
      <link>https://arxiv.org/abs/2508.11487</link>
      <description>arXiv:2508.11487v2 Announce Type: replace-cross 
Abstract: Random unitaries are a central object of study in quantum information, with applications to quantum computation, quantum many-body physics, and quantum cryptography. Recent work has constructed unitary designs and pseudorandom unitaries (PRUs) using $\Theta(\log \log n)$-depth unitary circuits with two-qubit gates.
  In this work, we show that unitary designs and PRUs can be efficiently constructed in several well-studied models of $\textit{constant-time}$ quantum computation (i.e., the time complexity on the quantum computer is independent of the system size). These models are constant-depth circuits augmented with certain nonlocal operations, such as (a) many-qubit TOFFOLI gates, (b) many-qubit FANOUT gates, or (c) mid-circuit measurements with classical feedforward control. Recent advances in quantum computing hardware suggest experimental feasibility of these models in the near future.
  Our results demonstrate that unitary designs and PRUs can be constructed in much weaker circuit models than previously thought. Furthermore, our construction of PRUs in constant-depth with many-qubit TOFFOLI gates shows that, under cryptographic assumptions, there is no polynomial-time learning algorithm for the circuit class $\mathsf{QAC}^0$. Finally, our results suggest a new approach towards proving that PARITY is not computable in $\mathsf{QAC}^0$, a long-standing question in quantum complexity theory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.11487v2</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ben Foxman, Natalie Parham, Francisca Vasconcelos, Henry Yuen</dc:creator>
    </item>
  </channel>
</rss>
