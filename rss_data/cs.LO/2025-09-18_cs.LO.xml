<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 18 Sep 2025 04:01:05 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Multi-Threaded Software Model Checking via Parallel Trace Abstraction Refinement</title>
      <link>https://arxiv.org/abs/2509.13699</link>
      <description>arXiv:2509.13699v1 Announce Type: new 
Abstract: Automatic software verification is a valuable means for software quality assurance. However, automatic verification and in particular software model checking can be time-consuming, which hinders their practical applicability e.g., the use in continuous integration. One solution to address the issue is to reduce the response time of the verification procedure by leveraging today's multi-core CPUs.
  In this paper, we propose a solution to parallelize trace abstraction, an abstraction-based approach to software model checking. The underlying idea of our approach is to parallelize the abstraction refinement. More concretely, our approach analyzes different traces (syntactic program paths) that could violate the safety property in parallel. We realize our parallelized version of trace abstraction in the verification tool Ulti mate Automizer and perform a thorough evaluation. Our evaluation shows that our parallelization is more effective than sequential trace abstraction and can provide results significantly faster on many time-consuming tasks. Also, our approach is more effective than DSS, a recent parallel approach to abstraction-based software model checking.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.13699v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Max Barth, Marie-Christine Jakobs</dc:creator>
    </item>
    <item>
      <title>Algorithmic Perspective on Toda's Theorem</title>
      <link>https://arxiv.org/abs/2509.13871</link>
      <description>arXiv:2509.13871v1 Announce Type: new 
Abstract: Toda's Theorem is a fundamental result in computational complexity theory, whose proof relies on a reduction from a QBF problem with a constant number of quantifiers to a model counting problem. While this reduction, henceforth called Toda's reduction, is of a purely theoretical nature, the recent progress of model counting tools raises the question of whether the reduction can be utilized to an efficient algorithm for solving QBF. In this work, we address this question by looking at Toda's reduction from an algorithmic perspective. We first convert the reduction into a concrete algorithm that given a QBF formula and a probability measure, produces the correct result with a confidence level corresponding to the given measure. Beyond obtaining a naive prototype, our algorithm and the analysis that follows shed light on the fine details of the reduction that are so far left elusive. Then, we improve this prototype through various theoretical and algorithmic refinements. While our results show a significant progress over the naive prototype, they also provide a clearer understanding of the remaining challenges in turning Toda's reduction into a competitive solver.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.13871v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Dror Fried, Etay Segal, Gad E. Yaron</dc:creator>
    </item>
    <item>
      <title>The Complexity of Deciding Characteristic Formulae Modulo Nested Simulation (extended abstract)</title>
      <link>https://arxiv.org/abs/2509.14089</link>
      <description>arXiv:2509.14089v1 Announce Type: new 
Abstract: This paper studies the complexity of determining whether a formula in the modal logics characterizing the nested-simulation semantics is characteristic for some process, which is equivalent to determining whether the formula is satisfiable and prime. The main results are that the problem of determining whether a formula is prime in the modal logic characterizing the 2-nested-simulation preorder is coNP-complete and is PSPACE-complete in the case of the n-nested-simulation preorder, when n&gt;=3. This establishes that deciding characteristic formulae for the n-nested simulation semantics is PSPACE-complete, when n&gt;=3. In the case of the 2-nested simulation semantics, that problem lies in the complexity class DP,  which consists of languages that can be expressed as the intersection of one language in NP and of one in coNP.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14089v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.428.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 428, 2025, pp. 13-28</arxiv:journal_reference>
      <dc:creator>Luca Aceto, Antonis Achilleos, Aggeliki Chalki, Anna Ing\'olfsd\'ottir</dc:creator>
    </item>
    <item>
      <title>An Automaton-based Characterisation of First-Order Logic over Infinite Trees</title>
      <link>https://arxiv.org/abs/2509.14090</link>
      <description>arXiv:2509.14090v1 Announce Type: new 
Abstract: In this paper, we study First Order Logic (FO)  over (unordered) infinite trees and its connection with branching-time temporal logics. More specifically, we provide an automata-theoretic characterisation of FO interpreted over infinite trees. To this end, two different classes of hesitant tree automata are introduced and proved to capture precisely the expressive power of two branching time temporal  logics, denoted polcCTLp and cCTL*[f], which are, respectively, a restricted version of counting CTL with past and counting CTL* over finite paths, both of which have been previously shown equivalent to FO over infinite trees. The two automata characterisations naturally lead to normal forms for the two temporal logics, and highlight the fact that FO can only express properties of the tree branches which are either safety or co-safety in nature.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14090v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.428.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 428, 2025, pp. 45-61</arxiv:journal_reference>
      <dc:creator>Massimo Benerecetti (Universit\`a degli Studi di Napoli "Federico II"), Dario Della Monica (Universit\`a degli Studi di Udine), Angelo Matteo (Universit\`a degli Studi di Udine), Fabio Mogavero (Universit\`a degli Studi di Napoli "Federico II"), Gabriele Puppis (Universit\`a degli Studi di Udine)</dc:creator>
    </item>
    <item>
      <title>Metric Equational Theories</title>
      <link>https://arxiv.org/abs/2509.14094</link>
      <description>arXiv:2509.14094v1 Announce Type: new 
Abstract: This paper proposes appropriate sound and complete proof systems for algebraic structures over metric spaces by combining the development of Quantitative Equational Theories (QET) with the Enriched Lawvere Theories. We extend QETs to Metric Equational Theories (METs) where operations no longer have finite sets as arities (as in QETs and the general theory of universal algebras), but arities are now drawn from countable metric spaces. This extension is inspired by the theory of Enriched Lawvere Theories, which suggests that the arities of operations should be the lambda-presentable objects of the underlying lambda-accessible category. In this setting, the validity of terms in METs can no longer be guaranteed independently of the validity of equations, as is the case with QET. We solve this problem, and adapt the sound and complete proof system for QETs to these more general METs, taking advantage of the specific structure of metric spaces.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14094v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.428.11</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 428, 2025, pp. 144-160</arxiv:journal_reference>
      <dc:creator>Radu Mardare (Heriot-Watt University, Edinburgh, Scotland), Neil Ghani (University of Strathclyde, Glasgow, Scotland), Eigil Rischel (University of Strathclyde, Glasgow, Scotland)</dc:creator>
    </item>
    <item>
      <title>The Complexity of Generalized HyperLTL with Stuttering and Contexts</title>
      <link>https://arxiv.org/abs/2509.14095</link>
      <description>arXiv:2509.14095v1 Announce Type: new 
Abstract: We settle the complexity of satisfiability and model-checking for generalized HyperLTL with stuttering and contexts, an expressive logic for the specification of asynchronous hyperproperties. Such properties cannot be specified in HyperLTL, as it is restricted to synchronous hyperproperties. Nevertheless, we prove that satisfiability is $\Sigma_1^1$-complete and thus not harder than for HyperLTL. On the other hand, we prove that model-checking is equivalent to truth in second-order arithmetic, and thus much harder than the decidable HyperLTL model-checking problem. The lower bounds for the model-checking problem hold even when only allowing stuttering or only allowing contexts.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14095v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.428.12</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 428, 2025, pp. 161-176</arxiv:journal_reference>
      <dc:creator>Ga\"etan Regaud (ENS Rennes), Martin Zimmermann (Aalborg University)</dc:creator>
    </item>
    <item>
      <title>Smaller Circuits for Bit Addition</title>
      <link>https://arxiv.org/abs/2509.13966</link>
      <description>arXiv:2509.13966v1 Announce Type: cross 
Abstract: Bit addition arises virtually everywhere in digital circuits: arithmetic operations, increment/decrement operators, computing addresses and table indices, and so on. Since bit addition is such a basic task in Boolean circuit synthesis, a lot of research has been done on constructing efficient circuits for various special cases of it. A vast majority of these results are devoted to optimizing the circuit depth (also known as delay).
  In this paper, we investigate the circuit size (also known as area) over the full binary basis of bit addition. Though most of the known circuits are built from Half Adders and Full Adders, we show that, in many interesting scenarios, these circuits have suboptimal size. Namely, we improve an upper bound $5n-3m$ to $4.5n-2m$, where $n$ is the number of input bits and $m$ is the number of output bits. In the regimes where $m$ is small compared to $n$ (for example, for computing the sum of $n$ bits or multiplying two $n$-bit integers), this leads to $10\%$ improvement.
  We complement our theoretical result by an open-source implementation of generators producing circuits for bit addition and multiplication. The generators allow one to produce the corresponding circuits in two lines of code and to compare them to existing designs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.13966v1</guid>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mikhail Goncharov, Alexander S. Kulikov, Georgie Levtsov</dc:creator>
    </item>
    <item>
      <title>How Concise are Chains of co-B\"uchi Automata?</title>
      <link>https://arxiv.org/abs/2509.14087</link>
      <description>arXiv:2509.14087v1 Announce Type: cross 
Abstract: Chains of co-B\"uchi automata (COCOA) have recently been introduced as a new canonical model for representing arbitrary omega-regular languages. They can be minimized in polynomial time and are hence an attractive language representation for applications in which normally, deterministic omega-automata are used. While it is known how to build COCOA from deterministic parity automata, little is currently known about their relationship to automaton models introduced earlier than COCOA.
  In this paper, we analyze the conciseness of chains of co-B\"uchi automata. We show that even in the case that all automata in the chain are deterministic, chains of co-B\"uchi automata can be exponentially more concise than deterministic parity automata. We then answer the question if this conciseness is retained when performing Boolean operations (such as disjunction and conjunction) over COCOA by showing that there exist families of languages for which these operations lead to an exponential growth of the sizes of the automata. The families have the property that when representing them using deterministic parity automata, taking the disjunction or conjunction of them only requires a polynomial blow-up, which shows that Boolean operations over COCOA do not retain their conciseness in general.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14087v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.428.9</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 428, 2025, pp. 111-126</arxiv:journal_reference>
      <dc:creator>R\"udiger Ehlers</dc:creator>
    </item>
    <item>
      <title>Generalised Reachability Games Revisited</title>
      <link>https://arxiv.org/abs/2509.14091</link>
      <description>arXiv:2509.14091v1 Announce Type: cross 
Abstract: Classic reachability games on graphs are zero-sum games, where the goal of one player, Eve, is to visit a vertex from a given target set, and that of other player, Adam, is to prevent this. Generalised reachability games, studied by Fijalkow and Horn, are a generalisation of reachability objectives, where instead of a single target set, there is a family of target sets and Eve must visit all of them in any order. In this work, we further study the complexity of solving two-player games on graphs with generalised reachability objectives. Our results are twofold: first, we provide an improved complexity picture for generalised reachability games, expanding the known tractable class from games in which all target sets are singleton to additionally allowing a logarithmic number of target sets of arbitrary size. Second, we study optimisation variants of generalised reachability with a focus on the size of the target sets. For these problems, we show intractability for most interesting cases. Particularly, in contrast to the tractability in the classic variant for singleton target sets, the optimisation problem is NP-hard when Eve tries to maximise the number of singleton target sets that are visited. Tractability can be recovered in the optimisation setting when all target sets are singleton by requiring that Eve pledges a maximum sized subset of target sets that she can guarantee to visit.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14091v1</guid>
      <category>cs.GT</category>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.428.7</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 428, 2025, pp. 76-90</arxiv:journal_reference>
      <dc:creator>Sougata Bose (UMONS - Universit\'e de Mons), Daniel Hausmann (University of Liverpool), Soumyajit Paul (University of Liverpool), Sven Schewe (University of Liverpool), Tansholpan Zhanabekova (University of Liverpool)</dc:creator>
    </item>
    <item>
      <title>Case Study: Verified Vampire Proofs in the LambdaPi-calculus Modulo</title>
      <link>https://arxiv.org/abs/2503.15541</link>
      <description>arXiv:2503.15541v2 Announce Type: replace 
Abstract: The Vampire automated theorem prover is extended to output machine-checkable proofs in the Dedukti concrete syntax for the LambdaPi-calculus modulo. This significantly reduces the trusted computing base, and in principle eases proof reconstruction in other proof-checking systems. Existing theory is adapted to deal with Vampire's internal logic and inference system. Implementation experience is reported, encouraging adoption of verified proofs in other automated systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.15541v2</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Anja Petkovi\'c Komel, Michael Rawson, Martin Suda</dc:creator>
    </item>
    <item>
      <title>A SHACL-based Data Consistency Solution for Contract Compliance Verification (Extended Paper)</title>
      <link>https://arxiv.org/abs/2507.15420</link>
      <description>arXiv:2507.15420v5 Announce Type: replace 
Abstract: In recent years, there have been many developments for GDPR-compliant data access and sharing based on consent. For more complex data sharing scenarios, where consent might not be sufficient, many parties rely on contracts. Before a contract is signed, it must undergo the process of contract negotiation within the contract lifecycle, which consists of negotiating the obligations associated with the contract. Contract compliance verification (CCV) provides a means to verify whether a contract is GDPR-compliant, i.e., adheres to legal obligations and there are no violations. The rise of knowledge graph (KG) adoption, enabling semantic interoperability using well-defined semantics, allows CCV to be applied on KGs. In the scenario of different participants negotiating obligations, there is a need for data consistency to ensure that CCV is done correctly. Recent work introduced the automated contracting tool (ACT), a KG-based and ODRL-employing tool for GDPR CCV, which was developed in the Horizon 2020 project smashHit (https://smashhit.eu). Although the tool reports violations with respect to obligations, it had limitations in verifying and ensuring compliance, as it did not use an interoperable semantic formalism, such as SHACL, and did not support users in resolving data inconsistencies. In this work, we propose a novel approach to overcome these limitations of ACT. We semi-automatically resolve CCV inconsistencies by providing repair strategies, which automatically propose (optimal) solutions to the user to re-establish data consistency and thereby support them in managing GDPR-compliant contract lifecycle data. We have implemented the approach, integrated it into ACT and tested its correctness and performance against basic CCV consistency requirements.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15420v5</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Robert David, Albin Ahmeti, Geni Bushati, Amar Tauqeer, Anna Fensel</dc:creator>
    </item>
    <item>
      <title>Interpolation for Converse PDL</title>
      <link>https://arxiv.org/abs/2508.21485</link>
      <description>arXiv:2508.21485v2 Announce Type: replace 
Abstract: Converse PDL is the extension of propositional dynamic logic with a converse operation on programs. Our main result states that Converse PDL enjoys the (local) Craig Interpolation Property, with respect to both atomic programs and propositional variables. As a corollary we establish the Beth Definability Property for the logic.
  Our interpolation proof is based on an adaptation of Maehara's proof-theoretic method. For this purpose we introduce a sound and complete cyclic sequent system for this logic. This calculus features an analytic cut rule and uses a focus mechanism for recognising successful cycles.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.21485v2</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Johannes Kloibhofer, Valentina Trucco Dalmas, Yde Venema</dc:creator>
    </item>
    <item>
      <title>Quantum Petri Nets with Event Structure semantics</title>
      <link>https://arxiv.org/abs/2509.01423</link>
      <description>arXiv:2509.01423v2 Announce Type: replace 
Abstract: Classical Petri nets provide a canonical model of concurrency, with unfolding semantics linking nets, occurrence nets, and event structures. No comparable framework exists for quantum concurrency: existing ''quantum Petri nets'' lack rigorous concurrent and sound quantum semantics, analysis tools, and unfolding theory. We introduce Quantum Petri Nets (QPNs), Petri nets equipped with a quantum valuation compatible with the quantum event structure semantics of Clairambault, De Visme, and Winskel (2019). Our contributions are: (i) a local definition of Quantum Occurrence Nets (LQONs) compatible with quantum event structures, (ii) a construction of QPNs with a well-defined unfolding semantics, (iii) a compositional framework for QPNs. This establishes a semantically well grounded model of quantum concurrency, bridging Petri net theory and quantum programming.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.01423v2</guid>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Thu, 18 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Julien Saan Joachim (ENS Paris Saclay, LMF, Inria), Marc de Visme (LMF, Inria, CNRS, ENS Paris Saclay), Stefan Haar (Inria), Glynn Winskel (Queen Mary University of London)</dc:creator>
    </item>
  </channel>
</rss>
