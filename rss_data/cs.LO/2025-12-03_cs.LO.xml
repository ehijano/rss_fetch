<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 Dec 2025 05:00:43 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>The role of counting quantifiers in laminar set systems</title>
      <link>https://arxiv.org/abs/2512.02617</link>
      <description>arXiv:2512.02617v1 Announce Type: new 
Abstract: Laminar set systems consist of non-crossing subsets of a universe with set inclusion essentially corresponding to the descendant relationship of a tree, the so-called laminar tree. Laminar set systems lie at the core of many graph decompositions such as modular decompositions, split decompositions, and bi-join decompositions. We show that from a laminar set system we can obtain the corresponding laminar tree by means of a monadic second order logic (MSO) transduction. This resolves an open question originally asked by Courcelle and is a satisfying resolution as MSO is the natural logic for set systems and is sufficient to define the property ``laminar''. Using results from Campbell et al. [STACS 2025], we can now obtain transductions for obtaining modular decompositions, co-trees, split decompositions and bi-join decompositions using MSO instead of CMSO. We further gain some insight into the expressive power of counting quantifiers and provide some results towards determining when counting quantifiers can be simulated in MSO in laminar set systems and when they cannot.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.02617v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Rutger Campbell, Noleen K\"ohler</dc:creator>
    </item>
    <item>
      <title>Local-Order-Invariant Logic on Classes of Bounded Degree</title>
      <link>https://arxiv.org/abs/2512.02039</link>
      <description>arXiv:2512.02039v1 Announce Type: cross 
Abstract: Local-order-invariant (first-order) logic is an extension of first-order logic where formulae have access to a ternary local order relation on the Gaifman graph, provided that the truth value does not depend on the specific order relation chosen. Weinstein asked a number of questions about the expressive power of order-invariant and local-order-invariant logics on classes of finite structures of bounded degree, classes of finite structures in general, and classes of locally finite structures. We answer four of his five questions, including showing that local-order-invariant logic collapses to first-order logic on classes of bounded degree. We also investigate epsilon-invariant logic. We show that epsilon-invariant logic collapses to first-order logic on classes of bounded degree by containing it in local-order-invariant logic in this setting, and we give an upper bound for epsilon-invariant logic in terms of local-order-invariant logic on general finite structures. Finally, in the process of proving these theorems, we demonstrate some principles which suggest further directions for showing upper bounds on invariant logics, including an upper bound on epsilon-invariant logic in general.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.02039v1</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Derek Aoki</dc:creator>
    </item>
    <item>
      <title>Logic of Sets with Atoms</title>
      <link>https://arxiv.org/abs/2512.02041</link>
      <description>arXiv:2512.02041v1 Announce Type: cross 
Abstract: Orbit-finite models of computation generalise the standard models of computation, to allow computation over infinite objects that are finite up to symmetries on atoms, denoted by $\mathbb{A}$. Set theory with atoms is used to reason about these objects. Recent work assumes that $\mathbb{A}$ is countable and that the symmetries are the automorphisms of a structure on $\mathbb{A}$. We study this set theory to understand generalisations of this approach. We show that: this construction is well-defined and sufficiently expressive; and that automorphism groups are adequate.
  Certain uncountable structures appear similar to countable structures, suggesting that the theory of orbit-finite constructions may apply to these uncountable structures. We prove results guaranteeing that the theory of symmetries of two structures are equal. Let: $PM(\mathcal{A})$ be the universe of symmetries induced by adding atoms in bijection with $\mathcal{A}$ and considering the symmetric universe; $\underline{\mathcal{A}}$ be the image of $\mathcal{A}$ on the atoms; and $\phi ^{PM(\mathcal{A})}$ be the relativisation of $\phi$ to $PM(\mathcal{A})$. We prove that all symmetric universes of equality atoms have theory $Th(PM(\left\langle \mathbb{N}\right\rangle))$. We prove that for structures $\mathcal{A}$, `nicely' covered by a set of cardinality $\kappa$, there is a structure $\mathcal{B}\equiv\mathcal{A}$ of size $\kappa$ such that for all formulae $\phi(x)$ in one variable, \begin{equation*}
  ZFC\vdash \phi(\underline{\mathcal{A}})^{PM(\mathcal{A})}\leftrightarrow\phi(\underline{\mathcal{B}})^{PM(\mathcal{B})} \end{equation*}</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.02041v1</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jake Masters</dc:creator>
    </item>
    <item>
      <title>Devil's Games and $\text{Q}\mathbb{R}$: Continuous Games complete for the First-Order Theory of the Reals</title>
      <link>https://arxiv.org/abs/2512.02779</link>
      <description>arXiv:2512.02779v1 Announce Type: cross 
Abstract: We introduce the complexity class Quantified Reals ($\text{Q}\mathbb{R}$). Let FOTR be the set of true sentences in the first-order theory of the reals. A language $L$ is in $\text{Q}\mathbb{R}$, if there is a polynomial time reduction from $L$ to FOTR. This seems the first time this complexity class is studied. We show that $\text{Q}\mathbb{R}$ can also be defined using real Turing machines. It is known that deciding FOTR requires at least exponential time unconditionally [Berman, 1980].
  We focus on devil's games with two defining properties: (1) Players (human and devil) alternate turns and (2) each turn has a continuum of options.
  First, we show that FOTRINV is $\text{Q}\mathbb{R}$-complete. FOTRINV has only inversion and addition constraints and all variables are in a compact interval. FOTRINV is a stepping stone for further reductions.
  Second, we show that the Packing Game is $\text{Q}\mathbb{R}$-complete. In the Packing Game we are given a container and two sets of pieces. One set of pieces for the human and one set for the devil. The human and the devil alternate by placing a piece into the container. Both rotations and translations are allowed. The first player that cannot place a piece loses.
  Third, we show that the Planar Extension Game is $\text{Q}\mathbb{R}$-complete. We are given a partially drawn plane graph and the human and the devil alternate by placing vertices and the corresponding edges in a straight-line manner. The vertices and edges to be placed are prescribed before hand. The first player that cannot place a vertex loses.
  Finally, we show that the Order Type Game is $\text{Q}\mathbb{R}$-complete. We are given an order-type together with a linear order. The human and the devil alternate in placing a point in the Euclidean plane following the linear order. The first player that cannot place a point correctly loses.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.02779v1</guid>
      <category>cs.CG</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Lucas Meijer, Arnaud de Mesmay, Tillmann Miltzow, Marcus Schaefer, Jack Stade</dc:creator>
    </item>
    <item>
      <title>Symbolic {\omega}-automata with obligations</title>
      <link>https://arxiv.org/abs/2512.02873</link>
      <description>arXiv:2512.02873v1 Announce Type: cross 
Abstract: Extensions of {\omega}-automata to infinite alphabets typically rely on symbolic guards to keep the transition relation finite, and on registers or memory cells to preserve information from past symbols. Symbolic transitions alone are ill-suited to act on this information, and register automata have intricate formal semantics and issues with tractability. We propose a slightly different approach based on obligations, i.e., assignment-like constructs attached to transitions. Whenever a transition with an obligation is taken, the obligation is evaluated against the current symbol and yields a constraint on the next symbol that the automaton will read. We formalize obligation automata with existential and universal branching and Emerson-Lei acceptance conditions, which subsume classic families such as B\"uchi, Rabin, Strett, and parity automata. We show that these automata recognise a strict superset of {\omega}-regular languages. To illustrate the practicality of our proposal, we also introduce a machine-readable format to express obligation automata and describe a tool implementing several operations over them, including automata product and emptiness checking.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.02873v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Luca Di Stefano</dc:creator>
    </item>
    <item>
      <title>Model-Based Diagnosis with Multiple Observations: A Unified Approach for C Software and Boolean Circuits</title>
      <link>https://arxiv.org/abs/2512.02898</link>
      <description>arXiv:2512.02898v1 Announce Type: cross 
Abstract: Debugging is one of the most time-consuming and expensive tasks in software development and circuit design. Several formula-based fault localisation (FBFL) methods have been proposed, but they fail to guarantee a set of diagnoses across all failing tests or may produce redundant diagnoses that are not subset-minimal, particularly for programs/circuits with multiple faults.
  This paper introduces CFaults, a novel fault localisation tool for C software and Boolean circuits with multiple faults. CFaults leverages Model-Based Diagnosis (MBD) with multiple observations and aggregates all failing test cases into a unified Maximum Satisfiability (MaxSAT) formula. Consequently, our method guarantees consistency across observations and simplifies the fault localisation procedure. Experimental results on three benchmark sets, two of C programs, TCAS and C-Pack-IPAs, and one of Boolean circuits, ISCAS85, show that CFaults is faster at localising faults in C software than other FBFL approaches such as BugAssist, SNIPER, and HSD. On the ISCAS85 benchmark, CFaults is generally slower than HSD; however, it localises faults in only 6% fewer circuits, demonstrating that it remains competitive in this domain. Furthermore, CFaults produces only subset-minimal diagnoses of faulty statements, whereas the other approaches tend to enumerate redundant diagnoses (e.g., BugAssist and SNIPER).</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.02898v1</guid>
      <category>cs.SE</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pedro Orvalho, Marta Kwiatkowska, Mikol\'a\v{s} Janota, Vasco Manquinho</dc:creator>
    </item>
    <item>
      <title>Support + Belief = Decision Trust</title>
      <link>https://arxiv.org/abs/2409.00666</link>
      <description>arXiv:2409.00666v2 Announce Type: replace 
Abstract: We present SBTrust, a logical framework designed to formalize decision trust. Our logic integrates a doxastic modality with a novel non-monotonic conditional operator that establishes a positive support relation between statements, and is closely related to a known dyadic deontic modality. For SBTrust, we provide semantics, proof theory and complexity results, as well as motivating examples. Compared to existing approaches, our framework seamlessly accommodates the integration of multiple factors in the emergence of trust.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.00666v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alessandro Aldini, Agata Ciabattoni, Dominik Pichler, Mirko Tagliaferri</dc:creator>
    </item>
    <item>
      <title>Classical notions of computation and the Hasegawa-Thielecke theorem (extended version)</title>
      <link>https://arxiv.org/abs/2502.13033</link>
      <description>arXiv:2502.13033v4 Announce Type: replace 
Abstract: In the spirit of the Curry-Howard correspondence between proofs and programs, we define and study a syntax and semantics for classical logic equipped with a computationally involutive negation, using a polarised effect calculus, the linear classical L-calculus. A main challenge in designing a denotational semantics for the calculus is to accommodate both call-by-value and call-by-name evaluation strategies, which leads to a failure of associativity of composition. In order to tackle this issue, we define a notion of adjunction between graph morphisms on non-associative categories, which we use to formulate polarized and non-associative notions of symmetric monoidal closed duploid and of dialogue duploid. We show that they provide a direct style counterpart to adjunction models: linear effect adjunctions for the (linear) call-by-push-value calculus and dialogue chiralities for linear continuations, respectively. In particular, we show that the syntax of the linear classical L-calculus can be interpreted in any dialogue duploid, and that it defines in fact a syntactic dialogue duploid. As an application, we establish, by semantic as well as syntactic means, the Hasegawa-Thielecke theorem, which states that the notions of central map and of thunkable map coincide in any dialogue duploid (in particular, for any double negation monad on a symmetric monoidal category).</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.13033v4</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.CT</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3776715</arxiv:DOI>
      <dc:creator>\'El\'eonore Mangel, Paul-Andr\'e Melli\`es, Guillaume Munch-Maccagnoni</dc:creator>
    </item>
    <item>
      <title>Parameterized Verification of Quantum Circuits (Technical Report)</title>
      <link>https://arxiv.org/abs/2511.19897</link>
      <description>arXiv:2511.19897v3 Announce Type: replace 
Abstract: We present the first fully automatic framework for verifying relational properties of parameterized quantum programs, i.e., a program that, given an input size, generates a corresponding quantum circuit. We focus on verifying input-output correctness as well as equivalence. At the core of our approach is a new automata model, synchronized weighted tree automata (SWTAs), which compactly and precisely captures the infinite families of quantum states produced by parameterized programs. We introduce a class of transducers to model quantum gate semantics and develop composition algorithms for constructing transducers of parameterized circuits. Verification is reduced to functional inclusion or equivalence checking between SWTAs, for which we provide decision procedures. Our implementation demonstrates both the expressiveness and practical efficiency of the framework by verifying a diverse set of representative parameterized quantum programs with verification times ranging from milliseconds to seconds.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.19897v3</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Parosh Aziz Abdulla, Yu-Fang Chen, Michal He\v{c}ko, Luk\'a\v{s} Hol\'ik, Ond\v{r}ej Leng\'al, Jyun-Ao Lin, Ramanathan S. Thinniyam</dc:creator>
    </item>
    <item>
      <title>Hardness of monadic second-order formulae over succinct graphs</title>
      <link>https://arxiv.org/abs/2302.04522</link>
      <description>arXiv:2302.04522v4 Announce Type: replace-cross 
Abstract: Our main result is a succinct counterpoint to Courcelle's meta-theorem as follows: every cw-nontrivial monadic second-order (MSO) property is either NP-hard or coNP-hard over graphs given by succinct representations. Succint representations are Boolean circuits computing the adjacency relation. Cw-nontrivial properties are those which have infinitely many models and infinitely many countermodels with bounded cliquewidth. Moreover, we explore what happens when the cw-nontriviality condition is dropped and show that, under a reasonable complexity assumption, the previous dichotomy fails, even for questions expressible in first-order logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.04522v4</guid>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guilhem Gamard (MOCQUA), Ali\'enor Goubault-Larrecq (LIS), Pierre Guillon (I2M), Pierre Ohlmann (LIS), K\'evin Perrot (LIS), Guillaume Theyssier (I2M)</dc:creator>
    </item>
    <item>
      <title>A process algebraic framework for multi-agent dynamic epistemic systems</title>
      <link>https://arxiv.org/abs/2407.17537</link>
      <description>arXiv:2407.17537v2 Announce Type: replace-cross 
Abstract: This paper combines the classical model of labeled transition systems with the epistemic model for reasoning about knowledge. The result is a unifying framework for modeling and analyzing multi-agent, knowledge-based, dynamic systems. On the modeling side, we propose a process algebraic, agent-oriented specification language that makes such a framework easy to use for practical purposes. On the verification side, we define a modal logic encompassing temporal and epistemic operators.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.17537v2</guid>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alessandro Aldini</dc:creator>
    </item>
    <item>
      <title>A taxonomy of categories for relations</title>
      <link>https://arxiv.org/abs/2502.10323</link>
      <description>arXiv:2502.10323v4 Announce Type: replace-cross 
Abstract: The study of categories that abstract the structural properties of relations has been extensively developed over the years, resulting in a rich and diverse body of work. This paper strives to provide a modern presentation of these ``categories for relations'', including their enriched version, further showing how they arise as Kleisli categories of symmetric monoidal monads. The resulting taxonomy aims at bringing clarity and organisation to the many related concepts and frameworks occurring in the literature.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.10323v4</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Cipriano Junior Cioffo, Fabio Gadducci, Davide Trotta</dc:creator>
    </item>
    <item>
      <title>The Richness of CSP Non-redundancy</title>
      <link>https://arxiv.org/abs/2507.07942</link>
      <description>arXiv:2507.07942v2 Announce Type: replace-cross 
Abstract: In the field of constraint satisfaction problems (CSP), a clause is called redundant if its satisfaction is implied by satisfying all other clauses. An instance of CSP$(P)$ is called non-redundant if it does not contain any redundant clause. The non-redundancy (NRD) of a predicate $P$ is the maximum number of clauses in a non-redundant instance of CSP$(P)$, as a function of the number of variables $n$. Recent progress has shown that non-redundancy is crucially linked to many other important questions in computer science and mathematics including sparsification, kernelization, query complexity, universal algebra, and extremal combinatorics. Given that non-redundancy is a nexus for many of these important problems, the central goal of this paper is to more deeply understand non-redundancy.
  Our first main result shows that for every rational number $r \ge 1$, there exists a finite CSP predicate $P$ such that the non-redundancy of $P$ is $\Theta(n^r)$. Our second main result explores the concept of conditional non-redundancy first coined by Brakensiek and Guruswami [STOC 2025]. We completely classify the conditional non-redundancy of all binary predicates (i.e., constraints on two variables) by connecting these non-redundancy problems to the structure of high-girth graphs in extremal combinatorics.
  Inspired by these concrete results, we build off the work of Carbonnel [CP 2022] to develop an algebraic theory of conditional non-redundancy. As an application of this algebraic theory, we revisit the notion of Mal'tsev embeddings, which is the most general technique known to date for establishing that a predicate has linear non-redundancy. For example, we provide the first example of predicate with a Mal'tsev embedding that cannot be attributed to the structure of an Abelian group, but rather to the structure of the quantum Pauli group.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.07942v2</guid>
      <category>cs.DM</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <category>math.CO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Joshua Brakensiek, Venkatesan Guruswami, Bart M. P. Jansen, Victor Lagerkvist, Magnus Wahlstr\"om</dc:creator>
    </item>
    <item>
      <title>Bayesian Separation Logic</title>
      <link>https://arxiv.org/abs/2507.15530</link>
      <description>arXiv:2507.15530v2 Announce Type: replace-cross 
Abstract: Bayesian probabilistic programming languages (BPPLs) let users denote statistical models as code while the interpreter infers the posterior distribution. The semantics of BPPLs are usually mathematically complex and unable to reason about desirable properties such as expected values and independence of random variables. To reason about these properties in a non-Bayesian setting, probabilistic separation logics such as PSL and Lilac interpret separating conjunction as probabilistic independence of random variables. However, no existing separation logic can handle Bayesian updating, which is the key distinguishing feature of BPPLs.
  To close this gap, we introduce Bayesian separation logic (BaSL), a probabilistic separation logic that gives semantics to BPPL. We prove an internal version of Bayes' theorem using a result in measure theory known as the Rokhlin-Simmons disintegration theorem. Consequently, BaSL can model probabilistic programming concepts such as Bayesian updating, unnormalised distribution, conditional distribution, soft constraint, conjugate prior and improper prior while maintaining modularity via the frame rule. The model of BaSL is based on a novel instantiation of Kripke resource monoid via $\sigma$-finite measure spaces over the Hilbert cube, and the semantics of Hoare triple is compatible with an existing denotational semantics of BPPL based on the category of $s$-finite kernels. Using BaSL, we then prove properties of statistical models such as the expected value of Bayesian coin flip, correlation of random variables in the collider Bayesian network, the posterior distributions of the burglar alarm model, a parameter estimation algorithm, and the Gaussian mixture model.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.15530v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shing Hin Ho, Nicolas Wu, Azalea Raad</dc:creator>
    </item>
    <item>
      <title>The Dual of Quantifier Elimination: Boolean Elimination over C and R</title>
      <link>https://arxiv.org/abs/2511.20743</link>
      <description>arXiv:2511.20743v2 Announce Type: replace-cross 
Abstract: We show that every finite Boolean combination of polynomial equalities and inequalities in C^n admits two uniform normal forms: an $\exists\forall$ form and a $\forall\exists$ form, each using a single polynomial equation. Both forms have one existentially quantified variable and one universally quantified variable; regardless of the complexity of the original formula, no longer quantifier blocks are needed. The constructions are explicit and have linear degree bounds. Optimality results demonstrate that no purely existential or universal normal form is possible over C.
  Over R, similar normal forms exist, including a singly-quantified $\exists$ form for Boolean combinations of equations and inequations, and $\exists^d$ and $\forall\exists$ forms for Boolean combinations involving order inequalities. Prior results establish the existence of a $\exists$ normal form for R by other methods. Finally, similar forms exist over Q as well.
  These results may be viewed as a dual to classical quantifier elimination: instead of removing quantifiers at the cost of increased Boolean complexity, they remove Boolean structure at the cost of a short, fixed quantifier prefix.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.20743v2</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Matthew Frank</dc:creator>
    </item>
    <item>
      <title>RapunSL: Untangling Quantum Computing with Separation, Linear Combination and Mixing</title>
      <link>https://arxiv.org/abs/2511.23472</link>
      <description>arXiv:2511.23472v2 Announce Type: replace-cross 
Abstract: Quantum Separation Logic (QSL) has been proposed as an effective tool to improve the scalability of deductive reasoning for quantum programs. In QSL, separation is interpreted as disentanglement, and the frame rule brings a notion of entanglement-local specification (one that only talks about the qubits entangled with those acted upon by the program). In this paper, we identify two notions of locality unique to the quantum domain, and we construct a novel quantum separation logic, RapunSL, which is able to soundly reduce reasoning about superposition states to reasoning about pure states (basis-locality), and reasoning about mixed states arising from measurement to reasoning about pure states (outcome-locality). To do so, we introduce two connectives, linear combination and mixing, which together with separation provide a dramatic improvement in the scalability of reasoning, as we demonstrate on a series of challenging case studies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.23472v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Wed, 03 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3776648</arxiv:DOI>
      <dc:creator>Yusuke Matsushita, Kengo Hirata, Ryo Wakizaka, Emanuele D'Osualdo</dc:creator>
    </item>
  </channel>
</rss>
