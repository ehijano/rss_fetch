<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 09 Jan 2026 02:40:10 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>MHRC-Bench: A Multilingual Hardware Repository-Level Code Completion benchmark</title>
      <link>https://arxiv.org/abs/2601.03708</link>
      <description>arXiv:2601.03708v1 Announce Type: new 
Abstract: Large language models (LLMs) have achieved strong performance on code completion tasks in general-purpose programming languages. However, existing repository-level code completion benchmarks focus almost exclusively on software code and largely overlook hardware description languages. In this work, we present \textbf{MHRC-Bench}, consisting of \textbf{MHRC-Bench-Train} and \textbf{MHRC-Bench-Eval}, the first benchmark designed for multilingual hardware code completion at the repository level. Our benchmark targets completion tasks and covers three major hardware design coding styles. Each completion target is annotated with code-structure-level and hardware-oriented semantic labels derived from concrete syntax tree analysis. We conduct a comprehensive evaluation of models on MHRC-Bench-Eval. Comprehensive evaluation results and analysis demonstrate the effectiveness of MHRC-Bench.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.03708v1</guid>
      <category>cs.PL</category>
      <category>cs.AI</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Qingyun Zou, Jiahao Cui, Nuo Chen, Bingsheng He, Weng-Fai Wong</dc:creator>
    </item>
    <item>
      <title>Agentic Proof Automation: A Case Study</title>
      <link>https://arxiv.org/abs/2601.03768</link>
      <description>arXiv:2601.03768v1 Announce Type: new 
Abstract: Proof engineering is notoriously labor-intensive: proofs that are straightforward on paper often require lengthy scripts in theorem provers. Recent advances in large language models (LLMs) create new opportunities for proof automation: modern LLMs not only generate proof scripts, but also support agentic behavior, exploring codebases and iteratively refining their outputs against prover feedback. These advances enable an emerging scheme where LLM-based agents undertake most proof engineering under human guidance. Humans provide mathematical insight (definitions, theorems, proof strategies); agents handle the mechanical work of proof development. We call this scheme agentic proof automation. We present this scheme through a case study: mechanizing the semantic type soundness of a sophisticated formal system, System Capless, in Lean 4, comprising over 14,000 lines of code. Using off-the-shelf LLM agents with a single lightweight proof-checking tool, the agents completed 189 proof engineering tasks with an 87% success rate, only 16% requiring human intervention. The case study demonstrates that agents are capable proof engineers that substantially boost productivity, though they fall short in creative reasoning and still require human guidance in certain cases. We release an interactive explorer where readers can examine all agent interactions; the mechanization is open-sourced for experiments and extensions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.03768v1</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yichen Xu, Martin Odersky</dc:creator>
    </item>
    <item>
      <title>Logic Programming with Extensible Types</title>
      <link>https://arxiv.org/abs/2601.03836</link>
      <description>arXiv:2601.03836v1 Announce Type: new 
Abstract: Logic programming languages present clear advantages in terms of declarativeness and conciseness. However, the ideas of logic programming have been met with resistance in other programming communities, and have not generally been adopted by other paradigms and languages. This paper proposes a novel way to incorporate logic programming in an existing codebase in a typed functional programming language. Our approach integrates with the host language without sacrificing static typing, and leverages strengths of typed functional programming such as polymorphism and higher-order. We do so by combining three ideas. First, we use the extensible types technique to allow values of the host language to contain logic variables. Second, we implement a unification algorithm that works for any data structure that supports certain operations.Third, we introduce a domain-specific language to define and query predicates. We demonstrate our proposal via a series of examples, and provide aids to make the notation convenient for users, showing that the proposed approach is not just technically possible but also practical. Our ideas have been implemented in the language Haskell with very good results.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.03836v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.439.18</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 439, 2026, pp. 248-262</arxiv:journal_reference>
      <dc:creator>Ivan Perez (KBR @ NASA Ames Research Center), Angel Herranz (Universidad Politecnica de Madrid)</dc:creator>
    </item>
    <item>
      <title>Inductive First-Order Formula Synthesis by ASP: A Case Study in Invariant Inference</title>
      <link>https://arxiv.org/abs/2601.03854</link>
      <description>arXiv:2601.03854v1 Announce Type: new 
Abstract: We present a framework for synthesising formulas in first-order logic (FOL) from examples, which unifies and advances state-of-the-art approaches for inference of transition system invariants. To do so, we study and categorise the existing methodologies, encoding techniques in their formula synthesis via answer set programming (ASP). Based on the derived categorisation, we propose orthogonal slices, a new technique for formula enumeration that partitions the search space into manageable chunks, enabling two approaches for incremental candidate pruning. Using a combination of existing techniques for first-order (FO) invariant synthesis and the orthogonal slices implemented in our framework FORCE, we significantly accelerate a state-of-the-art algorithm for distributed system invariant inference. We also show that our approach facilitates composition of different invariant inference frameworks, allowing for novel optimisations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.03854v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.439.35</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 439, 2026, pp. 511-527</arxiv:journal_reference>
      <dc:creator>Ziyi Yang, George P\^irlea, Ilya Sergey</dc:creator>
    </item>
    <item>
      <title>Implementing Binary Search Trees in GP 2 (Extended Abstract)</title>
      <link>https://arxiv.org/abs/2601.03897</link>
      <description>arXiv:2601.03897v1 Announce Type: new 
Abstract: We present an approach to implement binary search trees in the rule-based graph programming language GP 2. Our implementation uses GP 2's rooted graph transformation rules to be fast and supports insertion, deletion and query operations. We argue that the worst-case runtime for each of the operations is O(n) for a tree with n nodes. In addition, we expect that, on average, the operations run in time O(log(n)). Hence the implementation would match the time complexity of binary search trees implementations in imperative languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.03897v1</guid>
      <category>cs.PL</category>
      <category>cs.DS</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.440.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 440, 2026, pp. 6-12</arxiv:journal_reference>
      <dc:creator>Ziad Ismaili Alaoui (Department of Computer Science, University of Liverpool, Liverpool, United Kingdom), Detlef Plump (Department of Computer Science, University of York, York, United Kingdom)</dc:creator>
    </item>
    <item>
      <title>CSSG: Measuring Code Similarity with Semantic Graphs</title>
      <link>https://arxiv.org/abs/2601.04085</link>
      <description>arXiv:2601.04085v1 Announce Type: new 
Abstract: Existing code similarity metrics, such as BLEU, CodeBLEU, and TSED, largely rely on surface-level string overlap or abstract syntax tree structures, and often fail to capture deeper semantic relationships between programs.We propose CSSG (Code Similarity using Semantic Graphs), a novel metric that leverages program dependence graphs to explicitly model control dependencies and variable interactions, providing a semantics-aware representation of code.Experiments on the CodeContests+ dataset show that CSSG consistently outperforms existing metrics in distinguishing more similar code from less similar code under both monolingual and cross-lingual settings, demonstrating that dependency-aware graph representations offer a more effective alternative to surface-level or syntax-based similarity measures.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.04085v1</guid>
      <category>cs.PL</category>
      <category>cs.AI</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jingwen Xu, Yiyang Lu, Changze Lv, Zisu Huang, Zhengkang Guo, Zhengyuan Wang, Muzhao Tian, Xuanjing Huang, Xiaoqing Zheng</dc:creator>
    </item>
    <item>
      <title>Implementing the First-Order Logic of Here and There</title>
      <link>https://arxiv.org/abs/2601.03848</link>
      <description>arXiv:2601.03848v1 Announce Type: cross 
Abstract: We present automated theorem provers for the first-order logic of here and there (HT). They are based on a native sequent calculus for the logic of HT and an axiomatic embedding of the logic of HT into intuitionistic logic. The analytic proof search in the sequent calculus is optimized by using free variables and skolemization. The embedding is used in combination with sequent, tableau and connection calculi for intuitionistic first-order logic. All provers are evaluated on a large benchmark set of first-order formulas, providing a foundation for the development of more efficient HT provers.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.03848v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.PL</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.439.31</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 439, 2026, pp. 453-468</arxiv:journal_reference>
      <dc:creator>Jens Otten (University of Pernambuco), Torsten Schaub (University of Potsdam)</dc:creator>
    </item>
    <item>
      <title>Automated Theorem Proving for Prolog Verification</title>
      <link>https://arxiv.org/abs/2601.03849</link>
      <description>arXiv:2601.03849v1 Announce Type: cross 
Abstract: LPTP (Logic Program Theorem Prover) is an interactive natural-deduction-based theorem  prover for pure Prolog programs with negation as failure, unification with the occurs check, and a restricted but extensible set of built-in predicates. With LPTP, one can formally prove termination  and partial correctness of such Prolog programs. LPTP was designed in the mid-1990's by Robert F. Staerk.  It is written in ISO-Prolog and comes with an Emacs user-interface. 
  From a theoretical point of view, in his publications about LPTP, Staerk associates a set of first-order axioms IND(P) to the considered Prolog program P.  IND(P) contains the Clark's equality theory for P,  definitions of success, failure and termination for each user-defined logic procedure in P,  axioms relating these three points of view, and an axiom schema for  proving inductive properties. LPTP is thus a dedicated proof editor where these axioms are hard-wired. 
  We propose to translate these axioms as first-order formulas (FOFs), and apply automated theorem provers to  check the property of interest. Using  FOF  as an intermediary language, we experiment the use of automated theorem  provers for Prolog program verification. We evaluate the approach over  a benchmark of about 400 properties of Prolog  programs from the library available with LPTP. Both the  compiler which generates a set of FOF files from a given input  Prolog program together with its properties and the benchmark are publicly available.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.03849v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.439.32</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 439, 2026, pp. 469-481</arxiv:journal_reference>
      <dc:creator>Fred Mesnard (LIM, universit\'e de La R\'eunion), Thierry Marianne (LIM, universit\'e de La R\'eunion), \'Etienne Payet (LIM, universit\'e de La R\'eunion)</dc:creator>
    </item>
    <item>
      <title>Static Deadlock Detection for Rust Programs</title>
      <link>https://arxiv.org/abs/2401.01114</link>
      <description>arXiv:2401.01114v2 Announce Type: replace 
Abstract: Rust relies on its unique ownership mechanism to ensure thread and memory safety. However, numerous potential security vulnerabilities persist in practical applications. New language features in Rust pose new challenges for vulnerability detection. This paper proposes a static deadlock detection method tailored for Rust programs, aiming to identify various deadlock types, including double lock, conflict lock, and deadlock associated with conditional variables. With due consideration for Rust's ownership and lifetimes, we first complete the pointer analysis. Then, based on the obtained points-to information, we analyze dependencies among variables to identify potential deadlocks. We develop a tool and conduct experiments based on the proposed method. The experimental results demonstrate that our method outperforms existing deadlock detection methods in precision.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.01114v2</guid>
      <category>cs.PL</category>
      <category>cs.CR</category>
      <category>cs.SE</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yu Zhang, Kaiwen Zhang, Guanjun Liu</dc:creator>
    </item>
    <item>
      <title>A Refined Operational Semantics for FreeCHR</title>
      <link>https://arxiv.org/abs/2504.04962</link>
      <description>arXiv:2504.04962v4 Announce Type: replace 
Abstract: Constraint Handling Rules (CHR) is a rule-based programming language which is typically embedded into a general-purpose language. There exists a plethora of implementations for numerous host languages. However, the existing implementations often re-invent the way to embed CHR, which impedes maintenance and weakens assertions of correctness. To formalize and thereby standardize the embedding into arbitrary host languages, we introduced the framework FreeCHR and proved it to be a valid representation of classical ground CHR. Until now, this framework only includes a translation of the very abstract operational semantics which, due to its abstract nature, is not a sufficient base for practical implementations. In this paper we present a translation of the refined operational semantics for FreeCHR and prove it to be both a valid concretization of the very abstract semantics of FreeCHR, and an equivalent representation of the refined semantics of CHR. This will establish implementations of FreeCHR as equivalent in behavior and expressiveness to existing implementations of CHR.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.04962v4</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.439.20</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 439, 2026, pp. 278-293</arxiv:journal_reference>
      <dc:creator>Sascha Rechenberger (Ulm University), Thom Fr\"uhwirth (Ulm University)</dc:creator>
    </item>
    <item>
      <title>Deadlock-free Context-free Session Types</title>
      <link>https://arxiv.org/abs/2506.20356</link>
      <description>arXiv:2506.20356v2 Announce Type: replace 
Abstract: We tackle the problem of statically ensuring that message-passing programs never run into deadlocks. We focus on concurrent functional programs governed by context-free session types, which can express rich tree-like structures not expressible in standard session types. We propose a new type system based on context-free session types: it enforces both protocol conformance and deadlock freedom, also for programs implementing cyclic communication topologies with recursion and polymorphism. We show how the priority-based approach to deadlock freedom can be extended to this expressive setting. We prove that well-typed concurrent programs respect their protocols and never deadlock.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.20356v2</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andreia Mordido, Jorge A. P\'erez</dc:creator>
    </item>
    <item>
      <title>Picat Through the Lens of Advent of Code</title>
      <link>https://arxiv.org/abs/2507.11731</link>
      <description>arXiv:2507.11731v2 Announce Type: replace 
Abstract: Picat is a logic-based, multi-paradigm programming language that integrates features from logic, functional, constraint, and imperative programming paradigms. This paper presents solutions to several problems from the 2024 Advent of Code (AoC). While AoC problems are not designed for any specific programming language, certain problem types, such as reverse engineering and path-finding, are particularly well-suited to Picat due to its built-in constraint solving, pattern matching, backtracking, and dynamic programming with tabling. This paper demonstrates that Picat's features, especially its SAT-based constraint solving and tabling, enable concise, declarative, and highly efficient implementations of problems that would require significantly more effort in imperative languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.11731v2</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.439.36</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 439, 2026, pp. 528-541</arxiv:journal_reference>
      <dc:creator>Neng-Fa Zhou (CUNY Brooklyn College,Graduate Center), Cristian Grozea (Fraunhofer Institute FOKUS), H{\aa}kan Kjellerstrand (Independent Researcher, hakank.org), Ois\'in Mac Fheara\'i</dc:creator>
    </item>
    <item>
      <title>Algebraic and Algorithmic Methods for Computing Polynomial Loop Invariants</title>
      <link>https://arxiv.org/abs/2412.14043</link>
      <description>arXiv:2412.14043v2 Announce Type: replace-cross 
Abstract: Loop invariants are properties of a program loop that hold both before and after each iteration of the loop. They are often used to verify programs and ensure that algorithms consistently produce correct results during execution. Consequently, generating invariants becomes a crucial task for loops. We specifically focus on polynomial loops, where both the loop conditions and the assignments within the loop are expressed as polynomials. Although computing polynomial invariants for general loops is undecidable, efficient algorithms have been developed for certain classes of loops. For instance, when all assignments within a while loop involve linear polynomials, the loop becomes solvable. In this work, we study the more general case, where the polynomials can have arbitrary degrees.
  Using tools from algebraic geometry, we present two algorithms designed to generate all polynomial invariants within a given vector subspace, for a branching loop with nondeterministic conditional statements. These algorithms combine linear algebraic subroutines with computations on polynomial ideals. They differ depending on whether the initial values of the loop variables are specified or treated as parameters. Additionally, we present a much more efficient algorithm for generating polynomial invariants of a specific form, applicable to all initial values. This algorithm avoids expensive ideal computations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.14043v2</guid>
      <category>cs.SC</category>
      <category>cs.PL</category>
      <category>math.AG</category>
      <pubDate>Thu, 08 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1016/j.jsc.2025.102551</arxiv:DOI>
      <arxiv:journal_reference>Journal of Symbolic Computation Vol. 135, 2026, p.102551</arxiv:journal_reference>
      <dc:creator>Erdenebayar Bayarmagnai, Fatemeh Mohammadi, R\'emi Pr\'ebet</dc:creator>
    </item>
  </channel>
</rss>
