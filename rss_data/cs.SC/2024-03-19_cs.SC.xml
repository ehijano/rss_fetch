<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.SC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.SC</link>
    <description>cs.SC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.SC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 20 Mar 2024 04:00:18 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 20 Mar 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Routing and Scheduling in Answer Set Programming applied to Multi-Agent Path Finding: Preliminary Report</title>
      <link>https://arxiv.org/abs/2403.12153</link>
      <description>arXiv:2403.12153v1 Announce Type: cross 
Abstract: We present alternative approaches to routing and scheduling in Answer Set Programming (ASP), and explore them in the context of Multi-agent Path Finding. The idea is to capture the flow of time in terms of partial orders rather than time steps attached to actions and fluents. This also abolishes the need for fixed upper bounds on the length of plans. The trade-off for this avoidance is that (parts of) temporal trajectories must be acyclic, since multiple occurrences of the same action or fluent cannot be distinguished anymore. While this approach provides an interesting alternative for modeling routing, it is without alternative for scheduling since fine-grained timings cannot be represented in ASP in a feasible way. This is different for partial orders that can be efficiently handled by external means such as acyclicity and difference constraints. We formally elaborate upon this idea and present several resulting ASP encodings. Finally, we demonstrate their effectiveness via an empirical analysis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.12153v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Roland Kaminski, Torsten Schaub, Tran Cao Son, Ji\v{r}\'i \v{S}vancara, Philipp Wanko</dc:creator>
    </item>
    <item>
      <title>SCL(FOL) Revisited</title>
      <link>https://arxiv.org/abs/2302.05954</link>
      <description>arXiv:2302.05954v2 Announce Type: replace-cross 
Abstract: This paper presents an up-to-date and refined version of the SCL calculus for first-order logic without equality. The refinement mainly consists of the following two parts: First, we incorporate a stronger notion of regularity into SCL(FOL). Our regularity definition is adapted from the SCL(T) calculus. This adapted definition guarantees non-redundant clause learning during a run of SCL. However, in contrast to the original presentation, it does not require exhaustive propagation. Second, we introduce trail and model bounding to achieve termination guarantees. In previous versions, no termination guarantees about SCL were achieved. Last, we give rigorous proofs for soundness, completeness and clause learning guarantees of SCL(FOL) and put SCL(FOL) into context of existing first-order calculi.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.05954v2</guid>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Martin Bromberger, Simon Schwarz, Christoph Weidenbach</dc:creator>
    </item>
  </channel>
</rss>
