<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Nov 2024 04:05:26 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Semantics for Linear-time Temporal Logic with Finite Observations</title>
      <link>https://arxiv.org/abs/2411.14581</link>
      <description>arXiv:2411.14581v1 Announce Type: new 
Abstract: LTL3 is a multi-valued variant of Linear-time Temporal Logic for runtime verification applications. The semantic descriptions of LTL3 in previous work are given only in terms of the relationship to conventional LTL. Our approach, by contrast, gives a full model-based inductive accounting of the semantics of LTL3, in terms of families of definitive prefix sets. We show that our definitive prefix sets are isomorphic to linear-time temporal properties (sets of infinite traces), and thereby show that our semantics of LTL3 directly correspond to the semantics of conventional LTL. In addition, we formalise the formula progression evaluation technique, popularly used in runtime verification and testing contexts, and show its soundness and completeness up to finite traces with respect to our semantics. All of our definitions and proofs are mechanised in Isabelle/HOL.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14581v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.412.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 412, 2024, pp. 35-50</arxiv:journal_reference>
      <dc:creator>Rayhana Amjad (University of Edinburgh), Rob van Glabbeek (University of Edinburgh), Liam O'Connor (Australian National University)</dc:creator>
    </item>
    <item>
      <title>Expansion Laws for Forward-Reverse, Forward, and Reverse Bisimilarities via Proved Encodings</title>
      <link>https://arxiv.org/abs/2411.14583</link>
      <description>arXiv:2411.14583v1 Announce Type: new 
Abstract: Reversible systems exhibit both forward computations and backward computations, where the aim of the latter is to undo the effects of the former. Such systems can be compared via forward-reverse bisimilarity as well as its two components, i.e., forward bisimilarity and reverse bisimilarity. The congruence, equational, and logical properties of these equivalences have already been studied in the setting of sequential processes. In this paper we address concurrent processes and investigate compositionality and axiomatizations of forward bisimilarity, which is interleaving, and reverse and forward-reverse bisimilarities, which are truly concurrent. To uniformly derive expansion laws for the three equivalences, we develop encodings based on the proved trees approach of Degano &amp; Priami. In the case of reverse and forward-reverse bisimilarities, we show that in the encoding every action prefix needs to be extended with the backward ready set of the reached process.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14583v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.412.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 412, 2024, pp. 51-70</arxiv:journal_reference>
      <dc:creator>Marco Bernardo (University of Urbino), Andrea Esposito (University of Urbino), Claudio A. Mezzina (University of Urbino)</dc:creator>
    </item>
    <item>
      <title>One Energy Game for the Spectrum between Branching Bisimilarity and Weak Trace Semantics</title>
      <link>https://arxiv.org/abs/2411.14584</link>
      <description>arXiv:2411.14584v1 Announce Type: new 
Abstract: We provide the first generalized game characterization of van Glabbeek's linear-time--branching-time spectrum with silent steps. Thereby, one multi-dimensional energy game can be used to characterize and decide a wide array of weak behavioral equivalences between stability-respecting branching bisimilarity and weak trace equivalence in one go. To establish correctness, we relate attacker-winning energy budgets and distinguishing sublanguages of Hennessy--Milner logic that we characterize by eight dimensions of formula expressiveness.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14584v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.412.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 412, 2024, pp. 71-88</arxiv:journal_reference>
      <dc:creator>Benjamin Bisping (TU Berlin), David N. Jansen (Institute of Software, Chinese Academy of Sciences)</dc:creator>
    </item>
    <item>
      <title>A Rewriting Theory for Quantum Lambda-Calculus</title>
      <link>https://arxiv.org/abs/2411.14856</link>
      <description>arXiv:2411.14856v1 Announce Type: new 
Abstract: Quantum lambda calculus has been studied mainly as an idealized programming language -- the evaluation essentially corresponds to a deterministic abstract machine. Very little work has been done to develop a rewriting theory for quantum lambda calculus. Recent advances in the theory of probabilistic rewriting give us a way to tackle this task with tools unavailable a decade ago. Our primary focus is standardization and normalization results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14856v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Claudia Faggian, Gaetan Lopez, Beno\^it Valiron</dc:creator>
    </item>
    <item>
      <title>Application of AI to formal methods -- an analysis of current trends</title>
      <link>https://arxiv.org/abs/2411.14870</link>
      <description>arXiv:2411.14870v1 Announce Type: new 
Abstract: With artificial intelligence (AI) being well established within the daily lives of research communities, we turn our gaze toward an application area that appears intuitively unsuited for probabilistic decision-making: the area of formal methods (FM). FM aim to provide sound and understandable reasoning about problems in computer science, which seemingly collides with the black-box nature that inhibits many AI approaches. However, many researchers have crossed this gap and applied AI techniques to enhance FM approaches. As this dichotomy of FM and AI sparked our interest, we conducted a systematic mapping study to map the current landscape of research publications. In this study, we investigate the previous five years of applied AI to FM (2019-2023), as these correspond to periods of high activity. This investigation results in 189 entries, which we explore in more detail to find current trends, highlight research gaps, and give suggestions for future research.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14870v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sebastian Stock, Jannik Dunkelau, Atif Mashkoor</dc:creator>
    </item>
    <item>
      <title>Coslice Colimits in Homotopy Type Theory</title>
      <link>https://arxiv.org/abs/2411.15103</link>
      <description>arXiv:2411.15103v1 Announce Type: new 
Abstract: We contribute to the theory of (homotopy) colimits inside homotopy type theory. The heart of our work characterizes the connection between colimits in coslices of a universe, called coslice colimits, and colimits in the universe (i.e., ordinary colimits). To derive this characterization, we find an explicit construction of colimits in coslices that is tailored to reveal the connection. We use the construction to derive properties of colimits. Notably, we prove that the forgetful functor from a coslice creates colimits over trees. We also use the construction to examine how colimits interact with orthogonal factorization systems and with cohomology theories. As a consequence of their interaction with orthogonal factorization systems, all pointed colimits (special kinds of coslice colimits) preserve $n$-connectedness, which implies that higher groups are closed under colimits on directed graphs. We have formalized our main construction of the coslice colimit functor in Agda. The code for this paper is available at https://github.com/PHart3/colimits-agda</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.15103v1</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <category>math.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Perry Hart (Favonia), Kuen-Bang Hou (Favonia)</dc:creator>
    </item>
    <item>
      <title>Direct Access for Answers to Conjunctive Queries with Aggregation</title>
      <link>https://arxiv.org/abs/2303.05327</link>
      <description>arXiv:2303.05327v2 Announce Type: cross 
Abstract: We study the fine-grained complexity of conjunctive queries with grouping and aggregation. For common aggregate functions (e.g., min, max, count, sum), such a query can be phrased as an ordinary conjunctive query over a database annotated with a suitable commutative semiring. We investigate the ability to evaluate such queries by constructing in loglinear time a data structure that provides logarithmic-time direct access to the answers ordered by a given lexicographic order. This task is nontrivial since the number of answers might be larger than loglinear in the size of the input, so the data structure needs to provide a compact representation of the space of answers. In the absence of aggregation and annotation, past research established a sufficient tractability condition on queries and orders. For queries without self-joins, this condition is not just sufficient, but also necessary (under conventional lower-bound assumptions in fine-grained complexity).
  We show that all past results continue to hold for annotated databases, assuming that the annotation itself does not participate in the lexicographic order. Yet, past algorithms do not apply to the count-distinct aggregation, which has no efficient representation as a commutative semiring; for this aggregation, we establish the corresponding tractability condition. We then show how the complexity of the problem changes when we include the aggregate and annotation value in the order. We also study the impact of having all relations but one annotated by the multiplicative identity (one), as happens when we translate aggregate queries into semiring annotations, and having a semiring with an idempotent addition, such as the case of min, max, and count-distinct over a logarithmic-size domain.</description>
      <guid isPermaLink="false">oai:arXiv.org:2303.05327v2</guid>
      <category>cs.DB</category>
      <category>cs.DS</category>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Idan Eldar, Nofar Carmeli, Benny Kimelfeld</dc:creator>
    </item>
    <item>
      <title>Union of Finitely Generated Congruences on Ground Term Algebra</title>
      <link>https://arxiv.org/abs/2411.14559</link>
      <description>arXiv:2411.14559v1 Announce Type: cross 
Abstract: We show that for any ground term equation systems $E$ and $F$, (1) the union of the generated congruences by $E$ and $F$ is a congruence on the ground term algebra if and only if there exists a ground term equation system $H$ such that the congruence generated by $H$ is equal to the union of the congruences generated by $E$ and $F$ if and only if the congruence generated by the union of $E $ and $F$ is equal to the union of the congruences generated by $E $ and $F$, and (2) it is decidable in square time whether the congruence generated by the union of $E$ and $F$ is equal to the union of the congruences generated by $E $ and $F$, where the size of the input is the number of occurrences of symbols in $E$ plus the number of occurrences of symbols in $F$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14559v1</guid>
      <category>cs.SC</category>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>S\'andor V\'agv\"olgyi</dc:creator>
    </item>
    <item>
      <title>Functional Array Programming in an Extended Pi-Calculus</title>
      <link>https://arxiv.org/abs/2411.14579</link>
      <description>arXiv:2411.14579v1 Announce Type: cross 
Abstract:  We study the data-parallel language BUTF, inspired by the Futhark language for array programming. We give a translation of BUTF into a version of the pi-calculus with broadcasting and labeled names. The translation is both complete and sound. Moreover, we propose a cost model by annotating translated BUTF processes.  This is used for a complexity analysis of the translation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.14579v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.412.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 412, 2024, pp. 2-18</arxiv:journal_reference>
      <dc:creator>Hans H\"uttel (Department of Computer Science, University of Copenhagen), Lars Jensen (Department of Computer Science, Aalborg University), Chris Oliver Paulsen (Department of Computer Science, Aalborg University), Julian Teule (Department of Computer Science, Aalborg University)</dc:creator>
    </item>
    <item>
      <title>Effective Littlestone Dimension</title>
      <link>https://arxiv.org/abs/2411.15109</link>
      <description>arXiv:2411.15109v1 Announce Type: cross 
Abstract: Delle Rose et al.~(COLT'23) introduced an effective version of the Vapnik-Chervonenkis dimension, and showed that it characterizes improper PAC learning with total computable learners. In this paper, we introduce and study a similar effectivization of the notion of Littlestone dimension. Finite effective Littlestone dimension is a necessary condition for computable online learning but is not a sufficient one -- which we already establish for classes of the effective Littlestone dimension 2. However, the effective Littlestone dimension equals the optimal mistake bound for computable learners in two special cases: a) for classes of Littlestone dimension 1 and b) when the learner receives as additional information an upper bound on the numbers to be guessed. Interestingly, finite effective Littlestone dimension also guarantees that the class consists only of computable functions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.15109v1</guid>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Valentino Delle Rose, Alexander Kozachinskiy, Tomasz Steifer</dc:creator>
    </item>
    <item>
      <title>Disjoint Projected Enumeration for SAT and SMT without Blocking Clauses</title>
      <link>https://arxiv.org/abs/2410.18707</link>
      <description>arXiv:2410.18707v2 Announce Type: replace 
Abstract: All-Solution Satisfiability (AllSAT) and its extension, All-Solution Satisfiability Modulo Theories (AllSMT), have become more relevant in recent years, mainly in formal verification and artificial intelligence applications. The goal of these problems is the enumeration of all satisfying assignments of a formula (for SAT and SMT problems, respectively), making them useful for test generation, model checking, and probabilistic inference. Nevertheless, traditional AllSAT algorithms face significant computational challenges due to the exponential growth of the search space and inefficiencies caused by blocking clauses, which cause memory blowups and degrade unit propagation performances in the long term. This paper presents two novel solvers: tabularAllSAT, a projected AllSAT solver, and tabularAllSMT, a projected AllSMT solver. Both solvers combine Conflict-Driven Clause Learning (CDCL) with chronological backtracking to improve efficiency while ensuring disjoint enumeration. To retrieve compact partial assignments we propose a novel aggressive implicant shrinking algorithm, compatible with chronological backtracking, to minimize the number of partial assignments, reducing overall search complexity. Furthermore, we extend the solver framework to handle projected enumeration and SMT formulas effectively and efficiently, adapting the baseline framework to integrate theory reasoning and the distinction between important and non-important variables. An extensive experimental evaluation demonstrates the superiority of our approach compared to state-of-the-art solvers, particularly in scenarios requiring projection and SMT-based reasoning.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.18707v2</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Giuseppe Spallitta, Roberto Sebastiani, Armin Biere</dc:creator>
    </item>
    <item>
      <title>Different Strokes in Randomised Strategies: Revisiting Kuhn's Theorem under Finite-Memory Assumptions</title>
      <link>https://arxiv.org/abs/2201.10825</link>
      <description>arXiv:2201.10825v3 Announce Type: replace-cross 
Abstract: Two-player (antagonistic) games on (possibly stochastic) graphs are a prevalent model in theoretical computer science, notably as a framework for reactive synthesis.
  Optimal strategies may require randomisation when dealing with inherently probabilistic goals, balancing multiple objectives, or in contexts of partial information. There is no unique way to define randomised strategies. For instance, one can use so-called mixed strategies or behavioural ones. In the most general setting, these two classes do not share the same expressiveness. A seminal result in game theory -- Kuhn's theorem -- asserts their equivalence in games of perfect recall.
  This result crucially relies on the possibility for strategies to use infinite memory, i.e., unlimited knowledge of all past observations. However, computer systems are finite in practice. Hence it is pertinent to restrict our attention to finite-memory strategies, defined as automata with outputs. Randomisation can be implemented in these in different ways: the initialisation, outputs or transitions can be randomised or deterministic respectively. Depending on which aspects are randomised, the expressiveness of the corresponding class of finite-memory strategies differs.
  In this work, we study two-player concurrent stochastic games and provide a complete taxonomy of the classes of finite-memory strategies obtained by varying which of the three aforementioned components are randomised. Our taxonomy holds in games of perfect and imperfect information with perfect recall, and in games with more than two players. We also provide an adapted taxonomy for games with imperfect recall.</description>
      <guid isPermaLink="false">oai:arXiv.org:2201.10825v3</guid>
      <category>cs.GT</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 25 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>James C. A. Main, Mickael Randour</dc:creator>
    </item>
  </channel>
</rss>
