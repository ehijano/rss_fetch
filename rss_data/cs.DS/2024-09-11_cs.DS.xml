<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Sep 2024 01:44:43 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Fast ($\sim N$) Diffusion Map Algorithm</title>
      <link>https://arxiv.org/abs/2409.05901</link>
      <description>arXiv:2409.05901v1 Announce Type: new 
Abstract: In this work we explore parsimonious manifold learning techniques, specifically for Diffusion-maps. We demonstrate an algorithm and it's implementation with computational complexity (in both time and memory) of $\sim N$, with $N$ representing the number-of-samples. These techniques are essential for large-scale unsupervised learning tasks without any prior assumptions, due to sampling theorem limitations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.05901v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Julio Candanedo</dc:creator>
    </item>
    <item>
      <title>Robust Max Selection</title>
      <link>https://arxiv.org/abs/2409.06014</link>
      <description>arXiv:2409.06014v1 Announce Type: new 
Abstract: We introduce a new model to study algorithm design under unreliable information, and apply this model for the problem of finding the uncorrupted maximum element of a list containing $n$ elements, among which are $k$ corrupted elements. Under our model, algorithms can perform black-box comparison queries between any pair of elements. However, queries regarding corrupted elements may have arbitrary output. In particular, corrupted elements do not need to behave as any consistent values, and may introduce cycles in the elements' ordering. This imposes new challenges for designing correct algorithms under this setting. For example, one cannot simply output a single element, as it is impossible to distinguish elements of a list containing one corrupted and one uncorrupted element. To ensure correctness, algorithms under this setting must output a set to make sure the uncorrupted maximum element is included.
  We first show that any algorithm must output a set of size at least $\min\{n, 2k + 1\}$ to ensure that the uncorrupted maximum is contained in the output set. Restricted to algorithms whose output size is exactly $\min\{n, 2k + 1\}$, for deterministic algorithms, we show matching upper and lower bounds of $\Theta(nk)$ comparison queries to produce a set of elements that contains the uncorrupted maximum. On the randomized side, we propose a 2-stage algorithm that, with high probability, uses $O(n + k \operatorname{polylog} k)$ comparison queries to find such a set, almost matching the $\Omega(n)$ queries necessary for any randomized algorithm to obtain a constant probability of being correct.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06014v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Trung Dang, Zhiyi Huang</dc:creator>
    </item>
    <item>
      <title>Exploring monotonic priority queues for Dijkstra optimization</title>
      <link>https://arxiv.org/abs/2409.06061</link>
      <description>arXiv:2409.06061v1 Announce Type: new 
Abstract: This paper presents a comprehensive overview of monotone priority queues, focusing on their evolution and application in shortest path algorithms. Monotone priority queues are characterized by the property that their minimum key does not decrease over time, making them particularly effective for label-setting algorithms like Dijkstra's. Some key data structures within this category are explored, emphasizing those derived directly from Dial's algorithm, including variations of multi-level bucket structures and radix heaps. Theoretical complexities and practical considerations of these structures are discussed, with insights into their development and refinement provided through a historical timeline.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06061v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jonas Costa, Lucas Castro, Rosiane de Freitas</dc:creator>
    </item>
    <item>
      <title>Structured Downsampling for Fast, Memory-efficient Curation of Online Data Streams</title>
      <link>https://arxiv.org/abs/2409.06199</link>
      <description>arXiv:2409.06199v1 Announce Type: new 
Abstract: Operations over data streams typically hinge on efficient mechanisms to aggregate or summarize history on a rolling basis. For high-volume data steams, it is critical to manage state in a manner that is fast and memory efficient -- particularly in resource-constrained or real-time contexts. Here, we address the problem of extracting a fixed-capacity, rolling subsample from a data stream. Specifically, we explore ``data stream curation'' strategies to fulfill requirements on the composition of sample time points retained. Our ``DStream'' suite of algorithms targets three temporal coverage criteria: (1) steady coverage, where retained samples should spread evenly across elapsed data stream history; (2) stretched coverage, where early data items should be proportionally favored; and (3) tilted coverage, where recent data items should be proportionally favored. For each algorithm, we prove worst-case bounds on rolling coverage quality. We focus on the more practical, application-driven case of maximizing coverage quality given a fixed memory capacity. As a core simplifying assumption, we restrict algorithm design to a single update operation: writing from the data stream to a calculated buffer site -- with data never being read back, no metadata stored (e.g., sample timestamps), and data eviction occurring only implicitly via overwrite. Drawing only on primitive, low-level operations and ensuring full, overhead-free use of available memory, this ``DStream'' framework ideally suits domains that are resource-constrained, performance-critical, and fine-grained (e.g., individual data items as small as single bits or bytes). The proposed approach supports $\mathcal{O}(1)$ data ingestion via concise bit-level operations. To further practical applications, we provide plug-and-play open-source implementations targeting both scripted and compiled application domains.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06199v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Matthew Andres Moreno, Luis Zaman, Emily Dolson</dc:creator>
    </item>
    <item>
      <title>Learning Multiple Secrets in Mastermind</title>
      <link>https://arxiv.org/abs/2409.06453</link>
      <description>arXiv:2409.06453v1 Announce Type: new 
Abstract: In the Generalized Mastermind problem, there is an unknown subset $H$ of the hypercube $\{0,1\}^d$ containing $n$ points. The goal is to learn $H$ by making a few queries to an oracle, which, given a point $q$ in $\{0,1\}^d$, returns the point in $H$ nearest to $q$. We give a two-round adaptive algorithm for this problem that learns $H$ while making at most $\exp(\tilde{O}(\sqrt{d \log n}))$ queries. Furthermore, we show that any $r$-round adaptive randomized algorithm that learns $H$ with constant probability must make $\exp(\Omega(d^{3^{-(r-1)}}))$ queries even when the input has $\text{poly}(d)$ points; thus, any $\text{poly}(d)$ query algorithm must necessarily use $\Omega(\log \log d)$ rounds of adaptivity. We give optimal query complexity bounds for the variant of the problem where queries are allowed to be from $\{0,1,2\}^d$. We also study a continuous variant of the problem in which $H$ is a subset of unit vectors in $\mathbb{R}^d$, and one can query unit vectors in $\mathbb{R}^d$. For this setting, we give an $O(n^{d/2})$ query deterministic algorithm to learn the hidden set of points.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06453v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Milind Prabhu, David Woodruff</dc:creator>
    </item>
    <item>
      <title>OciorCOOL: Faster Byzantine Agreement and Reliable Broadcast</title>
      <link>https://arxiv.org/abs/2409.06008</link>
      <description>arXiv:2409.06008v1 Announce Type: cross 
Abstract: COOL (Chen'21) is an error-free and deterministic Byzantine agreement protocol that achieves consensus on an $\ell$-bit message with a communication complexity of $O(\max\{n\ell, n t \log t \})$ bits in four phases, given $n\geq 3t + 1$, for a network of $n$ nodes, where up to $t$ nodes may be dishonest. In this work we show that COOL can be optimized by reducing one communication round. The new protocol is called OciorCOOL. Additionally, building on OciorCOOL, we design an optimal reliable broadcast protocol that requires only six communication rounds.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06008v1</guid>
      <category>cs.DC</category>
      <category>cs.CR</category>
      <category>cs.DS</category>
      <category>cs.IT</category>
      <category>math.IT</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jinyuan Chen</dc:creator>
    </item>
    <item>
      <title>Reconstructing semi-directed level-1 networks using few quarnets</title>
      <link>https://arxiv.org/abs/2409.06034</link>
      <description>arXiv:2409.06034v1 Announce Type: cross 
Abstract: Semi-directed networks are partially directed graphs that model evolution where the directed edges represent reticulate evolutionary events. We present an algorithm that reconstructs binary $n$-leaf semi-directed level-1 networks in $O( n^2)$ time from its quarnets (4-leaf subnetworks). Our method assumes we have direct access to all quarnets, yet uses only an asymptotically optimal number of $O(n \log n)$ quarnets. Under group-based models of evolution with the Jukes-Cantor or Kimura 2-parameter constraints, it has been shown that only four-cycle quarnets and the splits of the other quarnets can practically be inferred with high accuracy from nucleotide sequence data. Our algorithm uses only this information, assuming the network contains no triangles. Additionally, we provide an $O(n^3)$ time algorithm that reconstructs the blobtree (or tree-of-blobs) of any binary $n$-leaf semi-directed network with unbounded level from $O(n^3)$ splits of its quarnets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06034v1</guid>
      <category>q-bio.PE</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Martin Frohn, Niels Holtgrefe, Leo van Iersel, Mark Jones, Steven Kelk</dc:creator>
    </item>
    <item>
      <title>On the joint embedding property for cographs and trees</title>
      <link>https://arxiv.org/abs/2409.06127</link>
      <description>arXiv:2409.06127v1 Announce Type: cross 
Abstract: A family of graphs $\mathcal{F}$ is said to have the joint embedding property (JEP) if for every $G_1, G_2\in \mathcal{F}$, there is an $H\in \mathcal{F}$ that contains both $G_1$ and $G_2$ as induced subgraphs. If $\mathcal{F}$ is given by a finite set $S$ of forbidden induced subgraphs, it is known that determining if $\mathcal{F}$ has JEP is undecidable. We prove that this problem is decidable if $P_4\in S$ and generalize this result to families of rooted labeled trees under topological containment, bounded treewidth families under the graph minor relation, and bounded cliquewidth families under the induced subgraph relation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06127v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Carter</dc:creator>
    </item>
    <item>
      <title>Position Fair Mechanisms Allocating Indivisible Goods</title>
      <link>https://arxiv.org/abs/2409.06423</link>
      <description>arXiv:2409.06423v1 Announce Type: cross 
Abstract: In the fair division problem for indivisible goods, mechanisms that output allocations satisfying fairness concepts, such as envy-freeness up to one good (EF1), have been extensively studied. These mechanisms usually require an arbitrary order of agents as input, which may cause some agents to feel unfair since the order affects the output allocations. In the context of the cake-cutting problem, Manabe and Okamoto (2012) introduced meta-envy-freeness to capture such kind of fairness, which guarantees the absence of envy compared to different orders of agents.
  In this paper, we introduce position envy-freeness and its relaxation, position envy-freeness up to $k$ goods (PEF$k$), for mechanisms in the fair division problem for indivisible goods, analogous to the meta-envy-freeness. While the round-robin or the envy-cycle mechanism is not PEF1, we propose a PEF1 mechanism that always outputs an EF1 allocation. In addition, in the case of two agents, we prove that any mechanism that always returns a maximum Nash social welfare allocation is PEF1, and propose a modified adjusted winner mechanism satisfying PEF1. We further investigate the round-robin and the envy-cycle mechanisms to measure how far they are from position envy-freeness.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06423v1</guid>
      <category>cs.GT</category>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ryoga Mahara, Ryuhei Mizutani, Taihei Oki, Tomohiko Yokoyama</dc:creator>
    </item>
    <item>
      <title>Coordinated Motion Planning: Multi-Agent Path Finding in a Densely Packed, Bounded Domain</title>
      <link>https://arxiv.org/abs/2409.06486</link>
      <description>arXiv:2409.06486v1 Announce Type: cross 
Abstract: We study Multi-Agent Path Finding for arrangements of labeled agents in the interior of a simply connected domain: Given a unique start and target position for each agent, the goal is to find a sequence of parallel, collision-free agent motions that minimizes the overall time (the makespan) until all agents have reached their respective targets. A natural case is that of a simply connected polygonal domain with axis-parallel boundaries and integer coordinates, i.e., a simple polyomino, which amounts to a simply connected union of lattice unit squares or cells. We focus on the particularly challenging setting of densely packed agents, i.e., one per cell, which strongly restricts the mobility of agents, and requires intricate coordination of motion.
  We provide a variety of novel results for this problem, including (1) a characterization of polyominoes in which a reconfiguration plan is guaranteed to exist; (2) a characterization of shape parameters that induce worst-case bounds on the makespan; (3) a suite of algorithms to achieve asymptotically worst-case optimal performance with respect to the achievable stretch for cases with severely limited maneuverability. This corresponds to bounding the ratio between obtained makespan and the lower bound provided by the max-min distance between the start and target position of any agent and our shape parameters.
  Our results extend findings by Demaine et al. (SIAM Journal on Computing, 2019) who investigated the problem for solid rectangular domains, and in the closely related field of Permutation Routing, as presented by Alpert et al. (Computational Geometry, 2022) for convex pieces of grid graphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06486v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>S\'andor P. Fekete, Ramin Kosfeld, Peter Kramer, Jonas Neutzner, Christian Rieck, Christian Scheffer</dc:creator>
    </item>
    <item>
      <title>Adversary Resilient Learned Bloom Filters</title>
      <link>https://arxiv.org/abs/2409.06556</link>
      <description>arXiv:2409.06556v1 Announce Type: cross 
Abstract: Creating an adversary resilient Learned Bloom Filter \cite{learnedindexstructures} with provable guarantees is an open problem \cite{reviriego1}. We define a strong adversarial model for the Learned Bloom Filter. We also construct two adversary resilient variants of the Learned Bloom Filter called the Uptown Bodega Filter and the Downtown Bodega Filter. Our adversarial model extends an existing adversarial model designed for the Classical (i.e not ``Learned'') Bloom Filter by Naor Yogev~\cite{moni1} and considers computationally bounded adversaries that run in probabilistic polynomial time (PPT). We show that if pseudo-random permutations exist, then a secure Learned Bloom Filter may be constructed with $\lambda$ extra bits of memory and at most one extra pseudo-random permutation in the critical path. We further show that, if pseudo-random permutations exist, then a \textit{high utility} Learned Bloom Filter may be constructed with $2\lambda$ extra bits of memory and at most one extra pseudo-random permutation in the critical path. Finally, we construct a hybrid adversarial model for the case where a fraction of the workload is chosen by an adversary. We show realistic scenarios where using the Downtown Bodega Filter gives better performance guarantees compared to alternative approaches in this hybrid model.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06556v1</guid>
      <category>cs.CR</category>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Allison Bishop, Hayder Tirmazi</dc:creator>
    </item>
    <item>
      <title>Structural Parameterizations of the Biclique-Free Vertex Deletion Problem</title>
      <link>https://arxiv.org/abs/2308.00501</link>
      <description>arXiv:2308.00501v3 Announce Type: replace 
Abstract: In this work, we study the Biclique-Free Vertex Deletion problem: Given a graph $G$ and integers $k$ and $i \le j$, find a set of at most $k$ vertices that intersects every (not necessarily induced) biclique $K_{i, j}$ in $G$. This is a natural generalization of the Bounded-Degree Deletion problem, wherein one asks whether there is a set of at most $k$ vertices whose deletion results in a graph of a given maximum degree $r$. The two problems coincide when $i = 1$ and $j = r + 1$. We show that Biclique-Free Vertex Deletion is fixed-parameter tractable with respect to $k + d$ for the degeneracy $d$ by developing a $2^{O(d k^2)} \cdot n^{O(1)}$-time algorithm. We also show that it can be solved in $2^{O(f k)} \cdot n^{O(1)}$ time for the feedback vertex number $f$ when $i \ge 2$. In contrast, we find that it is W[1]-hard for the treedepth for any integer $i \ge 1$. Finally, we show that Biclique-Free Vertex Deletion has a polynomial kernel for every $i \ge 1$ when parameterized by the feedback edge number. Previously, for this parameter, its fixed-parameter tractability for $i = 1$ was known (Betzler et al., 2012) but the existence of polynomial kernel was open.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.00501v3</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.46298/dmtcs.13018</arxiv:DOI>
      <arxiv:journal_reference>DMTCS vol. 26:3 #4 (2024)</arxiv:journal_reference>
      <dc:creator>Lito Goldmann, Leon Kellerhals, Tomohiro Koana</dc:creator>
    </item>
    <item>
      <title>Constant-time $\psi$ queries in $O \left( r \log \frac{n}{r} + r \log \sigma \right)$ bits</title>
      <link>https://arxiv.org/abs/2408.04537</link>
      <description>arXiv:2408.04537v3 Announce Type: replace 
Abstract: Given a text $T [1..n]$ over an alphabet of size $\sigma$ whose BWT has $r$ runs, we can store $T$ in $O \left( r \log \frac{n}{r} + r \log \sigma \right)$ bits such that we can answer $\psi$ queries in constant time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.04537v3</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Travis Gagie, Giovanni Manzini, Gonzalo Navarro, Marinella Sciortino</dc:creator>
    </item>
    <item>
      <title>Integer programs with bounded subdeterminants and two nonzeros per row</title>
      <link>https://arxiv.org/abs/2106.05947</link>
      <description>arXiv:2106.05947v4 Announce Type: replace-cross 
Abstract: We give a strongly polynomial-time algorithm for integer linear programs defined by integer coefficient matrices whose subdeterminants are bounded by a constant and that contain at most two nonzero entries in each row. The core of our approach is the first polynomial-time algorithm for the weighted stable set problem on graphs that do not contain more than $k$ vertex-disjoint odd cycles, where $k$ is any constant. Previously, polynomial-time algorithms were only known for $k=0$ (bipartite graphs) and for $k=1$.
  We observe that integer linear programs defined by coefficient matrices with bounded subdeterminants and two nonzeros per column can be also solved in strongly polynomial-time, using a reduction to $b$-matching.</description>
      <guid isPermaLink="false">oai:arXiv.org:2106.05947v4</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>math.OC</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Samuel Fiorini, Gwena\"el Joret, Stefan Weltge, Yelena Yuditsky</dc:creator>
    </item>
    <item>
      <title>Structured Decompositions: Structural and Algorithmic Compositionality</title>
      <link>https://arxiv.org/abs/2207.06091</link>
      <description>arXiv:2207.06091v4 Announce Type: replace-cross 
Abstract: We introduce structured decompositions. These are category-theoretic data structures which simlutaneously generalize notions from graph theory (including tree-width, layered tree-width, co-tree-width and graph decomposition width) geometric group theory (specifically Bass-Serre theory) and dynamical systems (e.g. hybrid dynamical systems). Furthermore, structured decompositions allow us to generalize these aforementioned combinatorial invariants, which have played a central role in the study of structural and algorithmic compositionality in both graph theory and parameterized complexity, to new settings. For example, in any category with enough colimits they describe algorithmically useful structural compositionality: as an application of our theory we prove an algorithmic meta-theorem for the Sub_P-composition problem. In concrete terms, when instantiated in the category of graphs, this meta-theorem yields compositional algorithms for NP-hard problems such as: Maximum Bipartite Subgraph, Maximum Planar Subgraph and Longest Path.</description>
      <guid isPermaLink="false">oai:arXiv.org:2207.06091v4</guid>
      <category>math.CT</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Wed, 11 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Benjamin Merlin Bumpus, Zoltan A. Kocsis, Jade Edenstar Master</dc:creator>
    </item>
  </channel>
</rss>
