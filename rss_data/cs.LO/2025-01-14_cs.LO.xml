<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Jan 2025 02:34:21 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Lazy Reimplication in Chronological Backtracking</title>
      <link>https://arxiv.org/abs/2501.07457</link>
      <description>arXiv:2501.07457v1 Announce Type: new 
Abstract: Chronological backtracking is an interesting SAT solving technique within CDCL reasoning, as it backtracks less aggressively upon conflicts. However, chronological backtracking is more difficult to maintain due to its weaker SAT solving invariants. This paper introduces a lazy reimplication procedure for missed lower implications in chronological backtracking. Our method saves propagations by reimplying literals on demand, rather than eagerly. Due to its modularity, our work can be replicated in other solvers, as shown by our results in the solvers CaDiCaL and Glucose.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.07457v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.SAT.2024.9</arxiv:DOI>
      <arxiv:journal_reference>27th International Conference on Theory and Applications of Satisfiability Testing (SAT 2024)</arxiv:journal_reference>
      <dc:creator>Robin Coutelier, Mathias Fleury, Laura Kov\'acs</dc:creator>
    </item>
    <item>
      <title>3D-grids are not transducible from planar graphs</title>
      <link>https://arxiv.org/abs/2501.07558</link>
      <description>arXiv:2501.07558v1 Announce Type: new 
Abstract: We prove that the class of 3D-grids is cannot be transduced from planar graphs, and more generally, from any class of graphs of bounded Euler genus. To prove our result, we introduce a new structural tool called slice decompositions, and show that every graph class transducible from a class of graphs of bounded Euler genus is a perturbation of a graph class that admits slice decompositions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.07558v1</guid>
      <category>cs.LO</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jakub Gajarsk\'y, Micha{\l} Pilipczuk, Filip Pokr\'yvka</dc:creator>
    </item>
    <item>
      <title>Dafny as Verification-Aware Intermediate Language for Code Generation</title>
      <link>https://arxiv.org/abs/2501.06283</link>
      <description>arXiv:2501.06283v1 Announce Type: cross 
Abstract: Using large language models (LLMs) to generate source code from natural language prompts is a popular and promising idea with a wide range of applications. One of its limitations is that the generated code can be faulty at times, often in a subtle way, despite being presented to the user as correct. In this paper, we explore ways in which formal methods can assist with increasing the quality of code generated by an LLM. Instead of emitting code in a target language directly, we propose that the user guides the LLM to first generate an opaque intermediate representation, in the verification-aware language Dafny, that can be automatically validated for correctness against agreed on specifications. The correct Dafny program is then compiled to the target language and returned to the user. All user-system interactions throughout the procedure occur via natural language; Dafny code is never exposed. We describe our current prototype and report on its performance on the HumanEval Python code generation benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.06283v1</guid>
      <category>cs.SE</category>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yue Chen Li, Stefan Zetzsche, Siva Somayyajula</dc:creator>
    </item>
    <item>
      <title>Inductive Learning of Robot Task Knowledge from Raw Data and Online Expert Feedback</title>
      <link>https://arxiv.org/abs/2501.07507</link>
      <description>arXiv:2501.07507v1 Announce Type: cross 
Abstract: The increasing level of autonomy of robots poses challenges of trust and social acceptance, especially in human-robot interaction scenarios. This requires an interpretable implementation of robotic cognitive capabilities, possibly based on formal methods as logics for the definition of task specifications. However, prior knowledge is often unavailable in complex realistic scenarios.
  In this paper, we propose an offline algorithm based on inductive logic programming from noisy examples to extract task specifications (i.e., action preconditions, constraints and effects) directly from raw data of few heterogeneous (i.e., not repetitive) robotic executions. Our algorithm leverages on the output of any unsupervised action identification algorithm from video-kinematic recordings. Combining it with the definition of very basic, almost task-agnostic, commonsense concepts about the environment, which contribute to the interpretability of our methodology, we are able to learn logical axioms encoding preconditions of actions, as well as their effects in the event calculus paradigm. Since the quality of learned specifications depends mainly on the accuracy of the action identification algorithm, we also propose an online framework for incremental refinement of task knowledge from user feedback, guaranteeing safe execution. Results in a standard manipulation task and benchmark for user training in the safety-critical surgical robotic scenario, show the robustness, data- and time-efficiency of our methodology, with promising results towards the scalability in more complex domains.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.07507v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.RO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Daniele Meli, Paolo Fiorini</dc:creator>
    </item>
    <item>
      <title>The Formal Theory of Monads, Univalently</title>
      <link>https://arxiv.org/abs/2212.08515</link>
      <description>arXiv:2212.08515v5 Announce Type: replace 
Abstract: We develop the formal theory of monads, as established by Street, in univalent foundations. This allows us to formally reason about various kinds of monads on the right level of abstraction. In particular, we define the bicategory of monads internal to a bicategory, and prove that it is univalent. We also define Eilenberg-Moore objects, and we show that both Eilenberg-Moore categories and Kleisli categories give rise to Eilenberg-Moore objects. Finally, we relate monads and adjunctions in arbitrary bicategories. Our work is formalized in Coq using the UniMath library.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.08515v5</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Niels van der Weide</dc:creator>
    </item>
    <item>
      <title>Semitopology: a topological approach to decentralised collaborative action</title>
      <link>https://arxiv.org/abs/2303.09287</link>
      <description>arXiv:2303.09287v5 Announce Type: replace 
Abstract: We introduce semitopology, a generalisation of point-set topology that removes the restriction that intersections of open sets need necessarily be open. The intuition is that points represent participants in a decentralised system, and open sets represent collections of participants that collectively have the authority to collaborate to update their local state; we call this an actionable coalition.
  Examples of actionable coalition include: majority stakes in proof-of-stake blockchains; communicating peers in peer-to-peer networks; and even pedestrians working together to not bump into one another in the street. Where actionable coalitions exist, they have in common that: collaborations are local (updating the states of the participants in the coalition, but not immediately those of the whole system); collaborations are voluntary (up to and including breaking rules); participants may be heterogeneous in their computing power or in their goals (not all pedestrians want to go to the same place); participants can choose with whom to collaborate; and they are not assumed subject to permission or synchronisation by a central authority.
  We develop a topology-flavoured mathematics that goes some way to explaining how and why these complex decentralised systems can exhibit order, and gives us new ways to understand existing practical implementations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2303.09287v5</guid>
      <category>cs.LO</category>
      <category>cs.DC</category>
      <category>math.GN</category>
      <category>math.LO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Murdoch Gabbay</dc:creator>
    </item>
    <item>
      <title>Discounted-Sum Automata with Multiple Discount Factors</title>
      <link>https://arxiv.org/abs/2307.08780</link>
      <description>arXiv:2307.08780v3 Announce Type: replace 
Abstract: Discounting the influence of future events is a key paradigm in economics and it is widely used in computer-science models, such as games, Markov decision processes (MDPs), reinforcement learning, and automata. While a single game or MDP may allow for several different discount factors, discounted-sum automata (NDAs) were only studied with respect to a single discount factor. It is known that every class of NDAs with an integer as the discount factor has good computational properties: It is closed under determinization and under the algebraic operations min, max, addition, and subtraction, and there are algorithms for its basic decision problems, such as automata equivalence and containment. Extending the integer discount factor to an arbitrary rational number, loses most of these good properties.
  We define and analyze nondeterministic discounted-sum automata in which each transition can have a different integral discount factor (integral NMDAs). We show that integral NMDAs with an arbitrary choice of discount factors are not closed under determinization and under algebraic operations and that their containment problem is undecidable. We then define and analyze a restricted class of integral NMDAs, which we call tidy NMDAs, in which the choice of discount factors depends on the prefix of the word read so far. Among their special cases are NMDAs that correlate discount factors to actions (alphabet letters) or to the elapsed time. We show that for every function $\theta$ that defines the choice of discount factors, the class of $\theta$-NMDAs enjoys all of the above good properties of NDAs with a single integral discount factor, as well as the same complexity of the required decision problems. Tidy NMDAs are also as expressive as deterministic integral NMDAs with an arbitrary choice of discount factors.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.08780v3</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Udi Boker, Guy Hefetz</dc:creator>
    </item>
    <item>
      <title>Asynchronous Composition of LTL Properties over Infinite and Finite Traces</title>
      <link>https://arxiv.org/abs/2312.14831</link>
      <description>arXiv:2312.14831v2 Announce Type: replace 
Abstract: The verification of asynchronous software components poses significant challenges due to the way components interleave and exchange input/output data concurrently. Compositional strategies aim to address this by separating the task of verifying individual components on local properties from the task of combining them to achieve global properties. This paper concentrates on employing symbolic model checking techniques to verify properties specified in Linear-time Temporal Logic (LTL) on asynchronous software components that interact through data ports. Unlike event-based composition, local properties can now impose constraints on input from other components, increasing the complexity of their composition. We consider both the standard semantics over infinite traces as well as the truncated semantics over finite traces to allow scheduling components only finitely many times.
  We propose a novel LTL rewriting approach, which converts a local property into a global one while considering the interleaving of infinite or finite execution traces of components. We prove the semantic equivalence of local properties and their rewritten version projected on the local symbols. The rewriting is also optimized to reduce formula size and to leave it unchanged when the temporal property is stutter invariant. These methods have been integrated into the OCRA tool, as part of the contract refinement verification suite. Finally, the different composition approaches were compared through an experimental evaluation that covers various types of specifications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.14831v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alberto Bombardelli, Stefano Tonetta</dc:creator>
    </item>
    <item>
      <title>On the Completeness of Interpolation Algorithms</title>
      <link>https://arxiv.org/abs/2402.02829</link>
      <description>arXiv:2402.02829v2 Announce Type: replace 
Abstract: Craig interpolation is a fundamental property of classical and non-classic logics with a plethora of applications from philosophical logic to computer-aided verification. The question of which interpolants can be obtained from an interpolation algorithm is of profound importance. Motivated by this question, we initiate the study of completeness properties of interpolation algorithms. An interpolation algorithm $\mathcal{I}$ is \emph{complete} if, for every semantically possible interpolant $C$ of an implication $A \to B$, there is a proof $P$ of $A \to B$ such that $C$ is logically equivalent to $\mathcal{I}(P)$. We establish incompleteness and different kinds of completeness results for several standard algorithms for resolution and the sequent calculus for propositional, modal, and first-order logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.02829v2</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Stefan Hetzl, Raheleh Jalali</dc:creator>
    </item>
    <item>
      <title>A minimal coalition logic</title>
      <link>https://arxiv.org/abs/2403.14704</link>
      <description>arXiv:2403.14704v2 Announce Type: replace 
Abstract: Coalition Logic is a central logic in logical studies of strategic reasoning, whose models are concurrent game models. In this paper, first, we systematically discuss three assumptions of concurrent game models and argue that they are too strong. The first is seriality; that is, every coalition always has an available joint action. The second is the independence of agents; that is, the merge of two available joint actions of two disjoint coalitions is always an available joint action of the union of the two coalitions. The third is determinism; that is, all available joint actions of the grand coalition always have a unique outcome. Second, we present a coalition logic based on general concurrent game models which do not have the three assumptions and show its completeness. This logic seems minimal for reasoning about coalitional powers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.14704v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yinfeng Li, Fengkui Ju</dc:creator>
    </item>
    <item>
      <title>Verification of Linear Dynamical Systems via O-Minimality of Real Numbers</title>
      <link>https://arxiv.org/abs/2410.13053</link>
      <description>arXiv:2410.13053v2 Announce Type: replace 
Abstract: We study decidability of the following problems for both discrete-time and continuous-time linear dynamical systems. Suppose we are given a matrix $M$, a set $S$ of starting points, and a set $T$ of unsafe points.
  (a) Does there exist $\varepsilon &gt; 0$ such that for every $s$ in the $\varepsilon$-ball around $S$, the trajectory of $s$ in the linear dynamical system defined by $M$ avoids $T$?
  (b) Does there exist $\varepsilon &gt; 0$ such that every $\varepsilon$-pseudo-orbit of a point $s \in S$ in the linear dynamical system defined by $M$ avoids $T$?
  These two problems correspond to two different notions of robust safety for linear dynamical systems. Restricting $S$ to be bounded in both questions, and $M$ to be diagonalisable in question (b), we prove decidability for discrete-time systems and conditional decidability assuming Schanuel's conjecture for continuous-time systems. Our main technical tool is the o-minimality of real numbers equipped with arithmetic operations and exponentiation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.13053v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Toghrul Karimov, Jo\"el Ouaknine, James Worrell</dc:creator>
    </item>
    <item>
      <title>Identity-Preserving Lax Extensions and Where to Find Them</title>
      <link>https://arxiv.org/abs/2410.14440</link>
      <description>arXiv:2410.14440v2 Announce Type: replace 
Abstract: Generic notions of bisimulation for various types of systems (nondeterministic, probabilistic, weighted etc.) rely on identity-preserving (normal) lax extensions of the functor encapsulating the system type, in the paradigm of universal coalgebra. It is known that preservation of weak pullbacks is a sufficient condition for a functor to admit a normal lax extension (the Barr extension, which in fact is then even strict); in the converse direction, nothing is currently known about necessary (weak) pullback preservation conditions for the existence of normal lax extensions. In the present work, we narrow this gap by showing on the one hand that functors admitting a normal lax extension preserve 1/4-iso pullbacks, i.e. pullbacks in which at least one of the projections is an isomorphism. On the other hand, we give sufficient conditions, showing that a functor admits a normal lax extension if it weakly preserves either 1/4-iso pullbacks and 4/4-epi pullbacks (i.e. pullbacks in which all morphisms are epic) or inverse images. We apply these criteria to concrete examples, in particular to functors modelling neighbourhood systems and weighted systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.14440v2</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sergey Goncharov, Dirk Hofmaan, Pedro Nora, Lutz Schr\"oder, Paul Wild</dc:creator>
    </item>
    <item>
      <title>A Syntactic Approach to Computing Complete and Sound Abstraction in the Situation Calculus</title>
      <link>https://arxiv.org/abs/2412.11217</link>
      <description>arXiv:2412.11217v3 Announce Type: replace 
Abstract: Abstraction is an important and useful concept in the field of artificial intelligence. To the best of our knowledge, there is no syntactic method to compute a sound and complete abstraction from a given low-level basic action theory and a refinement mapping. This paper aims to address this issue.To this end, we first present a variant of situation calculus,namely linear integer situation calculus, which serves as the formalization of high-level basic action theory. We then migrate Banihashemi, De Giacomo, and Lesp\'erance's abstraction framework to one from linear integer situation calculus to extended situation calculus. Furthermore, we identify a class of Golog programs, namely guarded actions,that is used to restrict low-level Golog programs, and impose some restrictions on refinement mappings. Finally, we design a syntactic approach to computing a sound and complete abstraction from a low-level basic action theory and a restricted refinement mapping.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.11217v3</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 14 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Liangda Fang, Xiaoman Wang, Zhang Chen, Kailun Luo, Zhenhe Cui, Quanlong Guan</dc:creator>
    </item>
  </channel>
</rss>
