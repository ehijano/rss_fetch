<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CG updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CG</link>
    <description>cs.CG updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CG" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Jan 2026 02:32:32 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Delaunay Triangulations with Predictions</title>
      <link>https://arxiv.org/abs/2601.08106</link>
      <description>arXiv:2601.08106v1 Announce Type: new 
Abstract: We investigate algorithms with predictions in computational geometry, specifically focusing on the basic problem of computing 2D Delaunay triangulations. Given a set $P$ of $n$ points in the plane and a triangulation $G$ that serves as a "prediction" of the Delaunay triangulation, we would like to use $G$ to compute the correct Delaunay triangulation $\textit{DT}(P)$ more quickly when $G$ is "close" to $\textit{DT}(P)$. We obtain a variety of results of this type, under different deterministic and probabilistic settings, including the following: 1. Define $D$ to be the number of edges in $G$ that are not in $\textit{DT}(P)$. We present a deterministic algorithm to compute $\textit{DT}(P)$ from $G$ in $O(n + D\log^3 n)$ time, and a randomized algorithm in $O(n+D\log n)$ expected time, the latter of which is optimal in terms of $D$. 2. Let $R$ be a random subset of the edges of $\textit{DT}(P)$, where each edge is chosen independently with probability $\rho$. Suppose $G$ is any triangulation of $P$ that contains $R$. We present an algorithm to compute $\textit{DT}(P)$ from $G$ in $O(n\log\log n + n\log(1/\rho))$ time with high probability. 3. Define $d_{\mbox{\scriptsize\rm vio}}$ to be the maximum number of points of $P$ strictly inside the circumcircle of a triangle in $G$ (the number is 0 if $G$ is equal to $\textit{DT}(P)$). We present a deterministic algorithm to compute $\textit{DT}(P)$ from $G$ in $O(n\log^*n + n\log d_{\mbox{\scriptsize\rm vio}})$ time. We also obtain results in similar settings for related problems such as 2D Euclidean minimum spanning trees, and hope that our work will open up a fruitful line of future research.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08106v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sergio Cabello, Timothy M. Chan, Panos Giannopoulos</dc:creator>
    </item>
    <item>
      <title>Lower Bounds for Dominating Set in Ball Graphs and for Weighted Dominating Set in Unit-Ball Graphs</title>
      <link>https://arxiv.org/abs/2601.08425</link>
      <description>arXiv:2601.08425v1 Announce Type: new 
Abstract: Recently it was shown that many classic graph problems -- Independent Set, Dominating Set, Hamiltonian Cycle, and more -- can be solved in subexponential time on unit-ball graphs. More precisely, these problems can be solved in $2^{O(n^{1-1/d})}$ time on unit-ball graphs in $\mathbb R^d$, which is tight under ETH. The result can be generalized to intersection graphs of similarly-sized fat objects. For Independent Set the same running time can be achieved for non-similarly-sized fat objects, and for the weighted version of the problem. We show that such generalizations most likely are not possible for Dominating Set: assuming ETH, we prove that - there is no algorithm with running time $2^{o(n)}$ for Dominating Set on (non-unit) ball graphs in $\mathbb R^3$; - there is no algorithm with running time $2^{o(n)}$ for Weighted Dominating Set on unit-ball graphs in $\mathbb R^3$; - there is no algorithm with running time $2^{o(n)}$ for Dominating Set, Connected Dominating Set, or Steiner Tree on intersections graphs of arbitrary convex (but non-constant-complexity) objects in the plane.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08425v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-030-42071-0_5</arxiv:DOI>
      <arxiv:journal_reference>In: Fomin, F.V., Kratsch, S., van Leeuwen, E.J. (eds) Treewidth, Kernels, and Algorithms (2020). Lecture Notes in Computer Science, vol 12160. Springer, Cham</arxiv:journal_reference>
      <dc:creator>Mark de Berg, S\'andor Kisfaludi-Bak</dc:creator>
    </item>
    <item>
      <title>In the Search for Good Neck Cuts</title>
      <link>https://arxiv.org/abs/2601.08566</link>
      <description>arXiv:2601.08566v1 Announce Type: new 
Abstract: We study the problem of finding neck-like features on a surface. Applications for such cuts include robotics, mesh segmentation, and algorithmic applications. We provide a new definition for a surface bottleneck -- informally, it is the shortest cycle relative to the size of the areas it separates. Inspired by the isoperimetric inequality, we formally define such optimal cuts, study their properties, and present several algorithms inspired by these ideas that work surprisingly well in practice. For examples of our algorithms, see https://neckcut.space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08566v1</guid>
      <category>cs.CG</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sam Ruggerio, Sariel Har-Peled</dc:creator>
    </item>
    <item>
      <title>Statistical learning on measures: an application to persistence diagrams</title>
      <link>https://arxiv.org/abs/2303.08456</link>
      <description>arXiv:2303.08456v3 Announce Type: replace 
Abstract: We consider a binary supervised learning classification problem where instead of having data in a finite-dimensional Euclidean space, we observe measures on a compact space $\mathcal{X}$. Formally, we observe data $D_N = (\mu_1, Y_1), \ldots, (\mu_N, Y_N)$ where $\mu_i$ is a measure on $\mathcal{X}$ and $Y_i$ is a label in $\{0, 1\}$. Given a set $\mathcal{F}$ of base-classifiers on $\mathcal{X}$, we build corresponding classifiers in the space of measures. We provide upper and lower bounds on the Rademacher complexity of this new class of classifiers that can be expressed simply in terms of corresponding quantities for the class $\mathcal{F}$. If the measures $\mu_i$ are uniform over a finite set, this classification task boils down to a multi-instance learning problem. However, our approach allows more flexibility and diversity in the input data we can deal with. While such a framework has many possible applications, this work strongly emphasizes on classifying data via topological descriptors called persistence diagrams. These objects are discrete measures on $\mathbb{R}^2$, where the coordinates of each point correspond to the range of scales at which a topological feature exists. We will present several classifiers on measures and show how they can heuristically and theoretically enable a good classification performance in various settings in the case of persistence diagrams.</description>
      <guid isPermaLink="false">oai:arXiv.org:2303.08456v3</guid>
      <category>cs.CG</category>
      <category>math.ST</category>
      <category>stat.ML</category>
      <category>stat.TH</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Olympio Hacquard (LMO, DATASHAPE), Gilles Blanchard (LMO, DATASHAPE), Cl\'ement Levrard (LPSM)</dc:creator>
    </item>
    <item>
      <title>Mend the gap: A smart repair algorithm for noisy polygonal tilings</title>
      <link>https://arxiv.org/abs/2312.11415</link>
      <description>arXiv:2312.11415v2 Announce Type: replace 
Abstract: Let $T^* = \{P^*_1, \ldots, P^*_N\}$ be a polygonal tiling of a simply connected region in the plane, and let $T = \{P_1, \ldots, P_N\}$ be a noisy version of $T^*$ obtained by making small perturbations to the coordinates of the vertices of the polygons in $T^*$. In general, $T$ will only be an approximate tiling, due to the presence of gaps and overlaps between the perturbed polygons in $T$. The areas of these gaps and overlaps are typically small relative to the areas of the polygons themselves.
  Suppose that we are given the approximate tiling $T$ and we wish to recover the tiling $T^*$. To address this problem, we introduce a new algorithm, called {\tt smart\_repair}, to modify the polygons in $T$ to produce a tiling $\widetilde{T} = \{\widetilde{P}_1, \ldots, \widetilde{P}_N\}$ that closely approximates $T^*$, with special attention given to reproducing the {\em adjacency relations} between the polygons in $T^*$ as closely as possible.
  The motivation for this algorithm comes from computational redistricting, where algorithms are used to build districts from smaller geographic units. Because districts in most U.S. states are required to be contiguous, these algorithms are fundamentally based on adjacency relations between units. Unfortunately, the best available map data for unit boundaries is often noisy, containing gaps and overlaps between units that can lead to substantial inaccuracies in the adjacency relations. Simple repair algorithms can exacerbate these inaccuracies, with the result that algorithmically drawn districts based on the ``repaired" units may be discontiguous, and hence not legally compliant. The algorithm presented here is specifically designed to avoid such problems.
  A Python implementation is publicly available as part of the MGGG Redistricting Lab's {\tt Maup} package, available at https://github.com/mggg/maup.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.11415v2</guid>
      <category>cs.CG</category>
      <category>cs.CY</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jeanne N. Clelland</dc:creator>
    </item>
  </channel>
</rss>
