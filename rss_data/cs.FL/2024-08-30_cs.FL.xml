<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2024 04:00:43 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 30 Aug 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>CFLOBDDs: Context-Free-Language Ordered Binary Decision Diagrams</title>
      <link>https://arxiv.org/abs/2211.06818</link>
      <description>arXiv:2211.06818v4 Announce Type: cross 
Abstract: This paper presents a new compressed representation of Boolean functions, called CFLOBDDs (for Context-Free-Language Ordered Binary Decision Diagrams). They are essentially a plug-compatible alternative to BDDs (Binary Decision Diagrams), and hence useful for representing certain classes of functions, matrices, graphs, relations, etc. in a highly compressed fashion. CFLOBDDs share many of the good properties of BDDs, but--in the best case--the CFLOBDD for a Boolean function can be exponentially smaller than any BDD for that function. Compared with the size of the decision tree for a function, a CFLOBDD--again, in the best case--can give a double-exponential reduction in size. They have the potential to permit applications to (i) execute much faster, and (ii) handle much larger problem instances than has been possible heretofore.
  CFLOBDDs are a new kind of decision diagram that go beyond BDDs (and their many relatives). The key insight is a new way to reuse sub-decision-diagrams: components of CFLOBDDs are structured hierarchically, so that sub-decision-diagrams can be treated as standalone ''procedures'' and reused.
  We applied CFLOBDDs to the problem of simulating quantum circuits, and found that for several standard problems the improvement in scalability--compared to simulation using BDDs--is quite dramatic. In particular, the number of qubits that could be handled using CFLOBDDs was larger, compared to BDDs, by a factor of 128x for GHZ; 1,024x for BV; 8,192x for DJ; and 128x for Grover's algorithm. (With a 15-minute timeout, the number of qubits that CFLOBDDs can handle are 65,536 for GHZ, 524,288 for BV; 4,194,304 for DJ; and 4,096 for Grover's Algorithm.)</description>
      <guid isPermaLink="false">oai:arXiv.org:2211.06818v4</guid>
      <category>cs.SC</category>
      <category>cs.FL</category>
      <category>quant-ph</category>
      <pubDate>Fri, 30 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1145/3651157</arxiv:DOI>
      <arxiv:journal_reference>TOPLAS 2024</arxiv:journal_reference>
      <dc:creator>Meghana Sistla, Swarat Chaudhuri, Thomas Reps</dc:creator>
    </item>
    <item>
      <title>A Connection Between Unbordered Partial Words and Sparse Rulers</title>
      <link>https://arxiv.org/abs/2408.16335</link>
      <description>arXiv:2408.16335v1 Announce Type: cross 
Abstract: $\textit{Partial words}$ are words that contain, in addition to letters, special symbols $\diamondsuit$ called $\textit{holes}$. Two partial words of $a=a_0 \dots a_n$ and $b=b_0 \dots b_n$ are $\textit{compatible}$ if for all $i$, $a_i = b_i$ or at least one of $a_i, b_i$ is a hole. A partial word is $\textit{unbordered}$ if it does not have a nonempty proper prefix and a suffix that are compatible. Otherwise the partial word is $\textit{bordered}$.
  A set $R \subseteq \{0, \dots, n\}$ is called a $\textit{complete sparse ruler of length $n$}$ if for all $k \in \{0, \dots, n\}$ there exists $r, s \in R$ such that $k = r - s$. These are also known as $\textit{restricted difference bases}$.
  From the definitions it follows that the more holes a partial word has, the more likely it is to be bordered. By introducing a connection between unbordered partial words and sparse rulers, we improve bounds on the maximum number of holes an unbordered partial word can have over alphabets of sizes $4$ or greater. We also provide a counterexample for a previously reported theorem.
  We then study a two-dimensional generalization of these results. We adapt methods from one-dimensional case to solve the correct asymptotic for the number of holes an unbordered two-dimensional binary partial word can have. This generalization might invoke further research questions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.16335v1</guid>
      <category>math.CO</category>
      <category>cs.FL</category>
      <pubDate>Fri, 30 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Aleksi Saarela, Aleksi Vanhatalo</dc:creator>
    </item>
    <item>
      <title>The $\mathsf{AC}^0$-Complexity Of Visibly Pushdown Languages</title>
      <link>https://arxiv.org/abs/2302.13116</link>
      <description>arXiv:2302.13116v3 Announce Type: replace 
Abstract: We study the question of which visibly pushdown languages (VPLs) are in the complexity class $\mathsf{AC}^0$ and how to effectively decide this question. Our contribution is to introduce a particular subclass of one-turn VPLs, called intermediate VPLs, for which the raised question is entirely unclear: to the best of our knowledge our research community is unaware of containment or non-containment in $\mathsf{AC}^0$ for any language in our newly introduced class.
  Our main result states that there is an algorithm that, given a visibly pushdown automaton, correctly outputs either that its language is in $\mathsf{AC}^0$, outputs some $m\geq 2$ such that $L$ is $\mathsf{ACC}^0(m)$-hard (implying that $L$ is not in $\mathsf{AC}^0$), or outputs a finite disjoint union of intermediate VPLs that $L$ is constant-depth equivalent to. In the latter case one can moreover effectively compute $k,l\in\mathbb{N}_{&gt;0}$ with $k\not=l$ such that the concrete intermediate VPL $L(S\rightarrow\varepsilon\mid a c^{k-1} S b_1\mid ac^{l-1}Sb_2)$ is constant-depth reducible to the language $L$. Due to their particular nature we conjecture that either all intermediate VPLs are in $\mathsf{AC}^0$ or all are not. As a corollary of our main result we obtain that in case the input language is a visibly counter language our algorithm can effectively determine if it is in $\mathsf{AC}^0$ -- hence our main result generalizes a result by Krebs et al. stating that it is decidable if a given visibly counter language is in $\mathsf{AC}^0$ (when restricted to well-matched words).
  For our proofs we revisit so-called Ext-algebras (introduced by Czarnetzki et al.), which are closely related to forest algebras (introduced by Boja\'nczyk and Walukiewicz), and use Green's relations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.13116v3</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Fri, 30 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Stefan G\"oller, Nathan Grosshans</dc:creator>
    </item>
    <item>
      <title>Weighted Context-Free-Language Ordered Binary Decision Diagrams</title>
      <link>https://arxiv.org/abs/2305.13610</link>
      <description>arXiv:2305.13610v2 Announce Type: replace 
Abstract: This paper presents a new data structure, called \emph{Weighted Context-Free-Language Ordered BDDs} (WCFLOBDDs), which are a hierarchically structured decision diagram, akin to Weighted BDDs (WBDDs) enhanced with a procedure-call mechanism. For some functions, WCFLOBDDs are exponentially more succinct than WBDDs. They are potentially beneficial for representing functions of type $\mathbb{B}^n \rightarrow D$, when a function's image $V \subseteq D$ has many different values. We apply WCFLOBDDs in quantum-circuit simulation, and find that they perform better than WBDDs on certain benchmarks. With a 15-minute timeout, the number of qubits that can be handled by WCFLOBDDs is 1-64$\times$ that of WBDDs (and 1-128$\times$ that of CFLOBDDs, which are an unweighted version of WCFLOBDDs). These results support the conclusion that for this application -- from the standpoint of problem size, measured as the number of qubits -- WCFLOBDDs provide the best of both worlds: performance roughly matches whichever of WBDDs and CFLOBDDs is better. (From the standpoint of running time, the results are more nuanced.)</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.13610v2</guid>
      <category>cs.FL</category>
      <category>quant-ph</category>
      <pubDate>Fri, 30 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Meghana Sistla, Swarat Chaudhuri, Thomas Reps</dc:creator>
    </item>
    <item>
      <title>The $\mu\mathcal{G}$ Language for Programming Graph Neural Networks</title>
      <link>https://arxiv.org/abs/2407.09441</link>
      <description>arXiv:2407.09441v2 Announce Type: replace 
Abstract: Graph neural networks form a class of deep learning architectures specifically designed to work with graph-structured data. As such, they share the inherent limitations and problems of deep learning, especially regarding the issues of explainability and trustworthiness. We propose $\mu\mathcal{G}$, an original domain-specific language for the specification of graph neural networks that aims to overcome these issues. The language's syntax is introduced, and its meaning is rigorously defined by a denotational semantics. An equivalent characterization in the form of an operational semantics is also provided and, together with a type system, is used to prove the type soundness of $\mu\mathcal{G}$. We show how $\mu\mathcal{G}$ programs can be represented in a more user-friendly graphical visualization, and provide examples of its generality by showing how it can be used to define some of the most popular graph neural network models, or to develop any custom graph processing application.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.09441v2</guid>
      <category>cs.FL</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <pubDate>Fri, 30 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Matteo Belenchia, Flavio Corradini, Michela Quadrini, Michele Loreti</dc:creator>
    </item>
  </channel>
</rss>
