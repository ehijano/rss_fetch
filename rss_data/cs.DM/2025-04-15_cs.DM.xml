<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DM updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DM</link>
    <description>cs.DM updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DM" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Apr 2025 04:01:35 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Self-Orthogonal Cellular Automata</title>
      <link>https://arxiv.org/abs/2504.09173</link>
      <description>arXiv:2504.09173v1 Announce Type: new 
Abstract: It is known that no-boundary Cellular Automata (CA) defined by bipermutive local rules give rise to Latin squares. In this paper, we study under which conditions the Latin square generated by a bipermutive CA is self-orthogonal, i.e. orthogonal to its transpose. We first enumerate all bipermutive CA over the binary alphabet up to diameter $d=6$, remarking that only some linear rules give rise to self-orthogonal Latin squares. We then give a full theoretical characterization of self-orthogonal linear CA, by considering the square matrix obtained by stacking the transition matrices of the CA and of its transpose, and determining when it is invertible. Interestingly, the stacked matrix turns out to have a circulant structure, for which there exists an extensive body of results to characterize its invertibility. Further, for the case of the binary alphabet we prove that irreducibility is a sufficient condition for self-orthogonality, and we derive a simpler characterization which boils down to computing the parity of the central coefficients of the local rule.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.09173v1</guid>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Luca Mariot, Federico Mazzone</dc:creator>
    </item>
    <item>
      <title>Relative-error testing of conjunctions and decision lists</title>
      <link>https://arxiv.org/abs/2504.08987</link>
      <description>arXiv:2504.08987v1 Announce Type: cross 
Abstract: We study the relative-error property testing model for Boolean functions that was recently introduced in the work of Chen et al. (SODA 2025). In relative-error testing, the testing algorithm gets uniform random satisfying assignments as well as black-box queries to $f$, and it must accept $f$ with high probability whenever $f$ has the property that is being tested and reject any $f$ that is relative-error far from having the property. Here the relative-error distance from $f$ to a function $g$ is measured with respect to $|f^{-1}(1)|$ rather than with respect to the entire domain size $2^n$ as in the Hamming distance measure that is used in the standard model; thus, unlike the standard model, relative-error testing allows us to study the testability of sparse Boolean functions that have few satisfying assignments. It was shown in Chen et al. (SODA 2025) that relative-error testing is at least as difficult as standard-model property testing, but for many natural and important Boolean function classes the precise relationship between the two notions is unknown.
  In this paper we consider the well-studied and fundamental properties of being a conjunction and being a decision list. In the relative-error setting, we give an efficient one-sided error tester for conjunctions with running time and query complexity $O(1/\epsilon)$.
  Secondly, we give a two-sided relative-error $\tilde{O}$$(1/\epsilon)$ tester for decision lists, matching the query complexity of the state-of-the-art algorithm in the standard model Bshouty (RANDOM 2020) and Diakonikolas et al. (FOCS 2007).</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.08987v1</guid>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Xi Chen, William Pires, Toniann Pitassi, Rocco A. Servedio</dc:creator>
    </item>
    <item>
      <title>Testing Juntas and Junta Subclasses with Relative Error</title>
      <link>https://arxiv.org/abs/2504.09312</link>
      <description>arXiv:2504.09312v1 Announce Type: cross 
Abstract: This papers considers the junta testing problem in a recently introduced ``relative error'' variant of the standard Boolean function property testing model. In relative-error testing we measure the distance from $f$ to $g$, where $f,g: \{0,1\}^n \to \{0,1\}$, by the ratio of $|f^{-1}(1) \triangle g^{-1}(1)|$ (the number of inputs on which $f$ and $g$ disagree) to $|f^{-1}(1)|$ (the number of satisfying assignments of $f$), and we give the testing algorithm both black-box access to $f$ and also access to independent uniform samples from $f^{-1}(1)$.
  Chen et al. (SODA 2025) observed that the class of $k$-juntas is $\text{poly}(2^k,1/\epsilon)$-query testable in the relative-error model, and asked whether $\text{poly}(k,1/\epsilon)$ queries is achievable. We answer this question affirmatively by giving a $\tilde{O}(k/\epsilon)$-query algorithm, matching the optimal complexity achieved in the less challenging standard model. Moreover, as our main result, we show that any subclass of $k$-juntas that is closed under permuting variables is relative-error testable with a similar complexity. This gives highly efficient relative-error testing algorithms for a number of well-studied function classes, including size-$k$ decision trees, size-$k$ branching programs, and size-$k$ Boolean formulas.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.09312v1</guid>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Xi Chen, William Pires, Toniann Pitassi, Rocco A. Servedio</dc:creator>
    </item>
    <item>
      <title>The Rate-Immediacy Barrier in Explicit Tree Code Constructions</title>
      <link>https://arxiv.org/abs/2504.09388</link>
      <description>arXiv:2504.09388v1 Announce Type: cross 
Abstract: Since the introduction of tree codes by Schulman (STOC 1993), explicit construction of such codes has remained a notorious challenge. While the construction of asymptotically-good explicit tree codes continues to be elusive, a work by Cohen, Haeupler and Schulman (STOC 2018), as well as the state-of-the-art construction by Ben Yaacov, Cohen, and Yankovitz (STOC 2022) have achieved codes with rate $\Omega(1/\log\log n)$, exponentially improving upon the original construction of Evans, Klugerman and Schulman from 1994. All of these constructions rely, at least in part, on increasingly sophisticated methods of combining (block) error-correcting codes.
  In this work, we identify a fundamental barrier to constructing tree codes using current techniques. We introduce a key property, which we call immediacy, that, while not required by the original definition of tree codes, is shared by all known constructions and inherently arises from recursive combinations of error-correcting codes. Our main technical contribution is the proof of a rate-immediacy tradeoff, which, in particular, implies that any tree code with constant distance and non-trivial immediacy must necessarily have vanishing rate. By applying our rate-immediacy tradeoff to existing constructions, we establish that their known rate analyses are essentially optimal. More broadly, our work highlights the need for fundamentally new ideas--beyond the recursive use of error-correcting codes--to achieve substantial progress in explicitly constructing asymptotically-good tree codes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.09388v1</guid>
      <category>cs.IT</category>
      <category>cs.CC</category>
      <category>cs.DM</category>
      <category>math.IT</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Gil Cohen, Leonard J. Schulman, Piyush Srivastava</dc:creator>
    </item>
    <item>
      <title>Optimal Graph Stretching for Distributed Averaging</title>
      <link>https://arxiv.org/abs/2504.10289</link>
      <description>arXiv:2504.10289v1 Announce Type: cross 
Abstract: The performance of distributed averaging depends heavily on the underlying topology. In various fields, including compressed sensing, multi-party computation, and abstract graph theory, graphs may be expected to be free of short cycles, i.e. to have high girth. Though extensive analyses and heuristics exist for optimising the performance of distributed averaging in general networks, these studies do not consider girth. As such, it is not clear what happens to convergence time when a graph is stretched to a higher girth.
  In this work, we introduce the optimal graph stretching problem, wherein we are interested in finding the set of edges for a particular graph that ensures optimal convergence time under constraint of a minimal girth. We compare various methods for choosing which edges to remove, and use various convergence heuristics to speed up the searching process. We generate many graphs with varying parameters, stretch and optimise them, and measure the duration of distributed averaging. We find that stretching by itself significantly increases convergence time. This decrease can be counteracted with a subsequent repair phase, guided by a convergence time heuristic. Existing heuristics are capable, but may be suboptimal.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.10289v1</guid>
      <category>cs.DC</category>
      <category>cs.DM</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Florine W. Dekker (Delft University of Technology, the Netherlands and), Zekeriya Erkin (Delft University of Technology, the Netherlands and), Mauro Conti (Universit\`a di Padova, Italy, Delft University of Technology, the Netherlands and)</dc:creator>
    </item>
    <item>
      <title>Expected Length of the Longest Common Subsequence of Multiple Strings</title>
      <link>https://arxiv.org/abs/2504.10425</link>
      <description>arXiv:2504.10425v1 Announce Type: cross 
Abstract: We study the generalized Chv\'atal-Sankoff constant $\gamma_{k,d}$, which represents the normalized expected length of the longest common subsequence (LCS) of $d$ independent uniformly random strings over an alphabet of size $k$. We derive asymptotically tight bounds for $\gamma_{2,d}$, establishing that $\gamma_{2,d} = \frac{1}{2} + \Theta\left(\frac{1}{\sqrt{d}}\right)$. We also derive asymptotically near-optimal bounds on $\gamma_{k,d}$ for $d\ge \Omega(\log k)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.10425v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>math.PR</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ray Li, William Ren, Yiran Wen</dc:creator>
    </item>
    <item>
      <title>Fortuitous sequences of flips of the top of a stack of n burnt pancakes for all n&gt;24</title>
      <link>https://arxiv.org/abs/1601.06278</link>
      <description>arXiv:1601.06278v2 Announce Type: replace 
Abstract: Burnt pancakes problem was defined by Gates and Papadimitriou in 1979. A stack $S$ of pancakes with a burnt side must be sorted by size, the smallest on top, and each pancake with burnt side down. The only operation allowed is to split stack in two parts and flip upper part. $g(S)$ is the minimal number of flips needed to sort stack $S$. Stack $S$ may be $-I_n$ when pancakes are in right order but upside down or $-f_n$ when all pancakes are right side up but sorted in reverse order. Gates et al. proved that $g(-f_n)\ge 3n/2-1$. In 1995 Cohen and Blum proved that $g(-I_n)=g(-f_n)+1\ge 3n/2$. In 1997 Heydari and Sudborough proved that $g(-I_n)\le 3(n+1)/2$ whenever some fortuitous sequence of flips exists. They gave fortuitous sequences for $n$=3, 15, 27 and 31. They showed that two fortuitous sequences $S_n$ and $S_{n'}$ may combine into another fortuitous sequence $S_{n''}$ with $n''=n+n'-3$. So a fortuitous sequence $S_n$ gives a fortuitous sequence $S_{n+12}$. This proves that $g(-I_n)\le 3(n+1)/2$ if $n$ is congruent to 3 modulo 4 and $n\ge 23$. In 2011 Josef Cibulka enhanced Gates and Papadimitriou's lower bound thanks to a potential function. He got so $g(-I_n)\ge3n/2+1$ if $n &gt; 1$ proving thereby, that $g(-I_n)=3(n+1)/2$ if $n$ is congruent to 3 modulo 4 and $n\ge 23$. This paper explains how to build generalized fortuitous sequences for $n=15, 19, 23$ and every $n\ge 25$, odd or even, proving thereby that $g(-I_n)=\lceil 3n/2\rceil+1$ for these $n$. It gives $g(-I_n)$ for all $n$.</description>
      <guid isPermaLink="false">oai:arXiv.org:1601.06278v2</guid>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Laurent Pierre</dc:creator>
    </item>
    <item>
      <title>Structure and computability of preimages in the Game of Life</title>
      <link>https://arxiv.org/abs/2308.10198</link>
      <description>arXiv:2308.10198v2 Announce Type: replace-cross 
Abstract: Conway's Game of Life is a two-dimensional cellular automaton. As a dynamical system, it is well-known to be computationally universal, i.e.\ capable of simulating an arbitrary Turing machine. We show that in a sense taking a single backwards step of the Game of Life is a computationally universal process, by constructing patterns whose preimage computation encodes an arbitrary circuit-satisfaction problem, or, equivalently, any tiling problem. As a corollary, we obtain for example that the set of orphans is coNP-complete, exhibit a $6210 \times 37800$-periodic configuration whose preimage is nonempty but contains no periodic configurations, and prove that the existence of a preimage for a periodic point is undecidable. Our constructions were obtained by a combination of computer searches and manual design.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.10198v2</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <category>math.DS</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ville Salo, Ilkka T\"orm\"a</dc:creator>
    </item>
    <item>
      <title>Membership problems in nilpotent groups</title>
      <link>https://arxiv.org/abs/2401.15504</link>
      <description>arXiv:2401.15504v4 Announce Type: replace-cross 
Abstract: We study both the Submonoid Membership problem and the Rational Subset Membership problem in finitely generated nilpotent groups. We give two reductions with important applications. First, Submonoid Membership in any nilpotent group can be reduced to Rational Subset Membership in smaller groups. As a corollary, we prove the existence of a group with decidable Submonoid Membership and undecidable Rational Subset Membership, confirming a conjecture of Lohrey and Steinberg. Second, the Rational Subset Membership problem in $H_3(\mathbb Z)$ can be reduced to the Knapsack problem in the same group, and is therefore decidable. Combining both results, we deduce that the filiform $3$-step nilpotent group has decidable Submonoid Membership.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.15504v4</guid>
      <category>math.GR</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Corentin Bodart</dc:creator>
    </item>
    <item>
      <title>Algebraic properties of Indigenous semirings</title>
      <link>https://arxiv.org/abs/2412.02118</link>
      <description>arXiv:2412.02118v2 Announce Type: replace-cross 
Abstract: In this paper, we introduce Indigenous semirings and show that they are examples of information algebras. We also attribute a graph to them and discuss their diameters, girths, and clique numbers. On the other hand, we prove that the Zariski topology of any Indigenous semiring is the Sierpi\'{n}ski space. Next, we investigate their algebraic properties (including ideal theory). In the last section, we characterize units and idempotent elements of formal power series over Indigenous semirings.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.02118v2</guid>
      <category>math.AC</category>
      <category>cs.DM</category>
      <category>math.RA</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1142/S2811007225500051</arxiv:DOI>
      <dc:creator>Hussein Behzadipour, Henk Koppelaar, Peyman Nasehpour</dc:creator>
    </item>
    <item>
      <title>The Beginner's Textbook for Fully Homomorphic Encryption</title>
      <link>https://arxiv.org/abs/2503.05136</link>
      <description>arXiv:2503.05136v4 Announce Type: replace-cross 
Abstract: Fully Homomorphic Encryption (FHE) is a cryptographic scheme that enables computations to be performed directly on encrypted data, as if the data were in plaintext. After all computations are performed on the encrypted data, it can be decrypted to reveal the result. The decrypted value matches the result that would have been obtained if the same computations were applied to the plaintext data.
  FHE supports basic operations such as addition and multiplication on encrypted numbers. Using these fundamental operations, more complex computations can be constructed, including subtraction, division, logic gates (e.g., AND, OR, XOR, NAND, MUX), and even advanced mathematical functions such as ReLU, sigmoid, and trigonometric functions (e.g., sin, cos). These functions can be implemented either as exact formulas or as approximations, depending on the trade-off between computational efficiency and accuracy.
  Fully Homomorphic Encryption (FHE) enables privacy-preserving machine learning by allowing a server to process the client's data in its encrypted form through an ML model. With FHE, the server learns neither the plaintext version of the input features nor the inference results. Only the client, using their secret key, can decrypt and access the results at the end of the service protocol.FHE can also be applied to confidential blockchain services, ensuring that sensitive data in smart contracts remains encrypted and confidential while maintaining the transparency and integrity of the execution process. Other applications of FHE include secure outsourcing of data analytics, encrypted database queries, privacy-preserving searches, efficient multi-party computation for digital signatures, and more.
  This article is designed to help the reader understand how FHE works from the mathematical level.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05136v4</guid>
      <category>cs.CR</category>
      <category>cs.DM</category>
      <pubDate>Tue, 15 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ronny Ko</dc:creator>
    </item>
  </channel>
</rss>
