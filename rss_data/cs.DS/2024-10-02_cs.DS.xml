<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 03 Oct 2024 02:10:25 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Closed Repeats</title>
      <link>https://arxiv.org/abs/2410.00209</link>
      <description>arXiv:2410.00209v1 Announce Type: new 
Abstract: Much research in stringology focuses on structures that can, in a way, ``grasp'' repeats (substrings that occur multiple times) as, for example, the so-called runs, a.k.a. maximal repetitions, compactly describe all tandem repeats. In this paper we introduce closed repeats: given a string $s$, its non-empty substring $s[i\,..\,j]$ is a right (left) closed repeat if its closest occurrence $s[i'\,..\,j']$ with $i' &gt; i$ cannot be ``extended'' to the right (respectively, left) matching $s[j{+}1] = s[j'{+}1]$ (respectively, $s[i{-}1] = s[i'{-}1]$); the repeat is closed if it is both left and right closed. We note that the closed repeats correspond to the maximal closed substrings recently proposed by Badkobeh et al. and they include all runs as a special case. We prove that the number of right/left closed repeats is $O(n \log n)$, where $n$ is the length of $s$, and we show that this bound is tight. The (right/left) closed repeats can be computed in the optimal time $O(n\log n)$; as we prove, the computation time cannot be lower than $\Omega(n\log\sigma)$ over a general ordered alphabet of size $\sigma$ even when the number of the closed repeats is $O(n)$. As an application, we describe data structures using the closed repeats for a number of substring queries: finding the period of the substring provided it is ``periodic'', finding the longest repeat in the substring, computing the rightmost LZ77 parsing of the substring.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.00209v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dmitry Kosolobov</dc:creator>
    </item>
    <item>
      <title>A Note on Approximation of Spanning Tree Congestion</title>
      <link>https://arxiv.org/abs/2410.00568</link>
      <description>arXiv:2410.00568v1 Announce Type: new 
Abstract: The {\em Spanning Tree Congestion} problem is an easy-to-state NP-hard problem: given a graph $G$, construct a spanning tree $T$ of $G$ minimizing its maximum edge congestion where the congestion of an edge $e\in T$ is the number of edges $uv$ in $G$ such that the unique path between $u$ and $v$ in $T$ passes through $e$; the optimum value for a given graph $G$ is denoted $STC(G)$.
  It is known that {\em every} spanning tree is an $n/2$-approximation. A long-standing problem is to design a better approximation algorithm. Our contribution towards this goal is an $O(\Delta\cdot\log^{3/2}n)$-approximation algorithm for the minimum congestion spanning tree problem where $\Delta$ is the maximum degree in $G$. For graphs with maximum degree bounded by polylog of the number of vertices, this is an exponential improvement over the previous best approximation. For graphs with maximum degree bounded by $o(n/\log^{3/2}n)$, we get $o(n)$-approximation; this is the largest class of graphs that we know of, for which sublinear approximation is known for this problem.
  Our main tool for the algorithm is a new lower bound on the spanning tree congestion which is of independent interest. We prove that for every graph $G$, $STC(G)\geq \Omega(hb(G)/\Delta)$ where $hb(G)$ denotes the maximum bisection width over all subgraphs of $G$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.00568v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Petr Kolman</dc:creator>
    </item>
    <item>
      <title>FPT Approximations for Fair $k$-Min-Sum-Radii</title>
      <link>https://arxiv.org/abs/2410.00598</link>
      <description>arXiv:2410.00598v1 Announce Type: new 
Abstract: We consider the $k$-min-sum-radii ($k$-MSR) clustering problem with fairness constraints. The $k$-min-sum-radii problem is a mixture of the classical $k$-center and $k$-median problems. We are given a set of points $P$ in a metric space and a number $k$ and aim to partition the points into $k$ clusters, each of the clusters having one designated center. The objective to minimize is the sum of the radii of the $k$ clusters (where in $k$-center we would only consider the maximum radius and in $k$-median we would consider the sum of the individual points' costs).
  Various notions of fair clustering have been introduced lately, and we follow the definitions due to Chierichetti, Kumar, Lattanzi and Vassilvitskii [NeurIPS 2017] which demand that cluster compositions shall follow the proportions of the input point set with respect to some given sensitive attribute. For the easier case where the sensitive attribute only has two possible values and each is equally frequent in the input, the aim is to compute a clustering where all clusters have a 1:1 ratio with respect to this attribute. We call this the 1:1 case.
  There has been a surge of FPT-approximation algorithms for the $k$-MSR problem lately, solving the problem both in the unconstrained case and in several constrained problem variants. We add to this research area by designing an FPT $(6+\epsilon)$-approximation that works for $k$-MSR under the mentioned general fairness notion. For the special 1:1 case, we improve our algorithm to achieve a $(3+\epsilon)$-approximation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.00598v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Lena Carta, Lukas Drexler, Annika Hennes, Clemens R\"osner, Melanie Schmidt</dc:creator>
    </item>
    <item>
      <title>$k$-local Graphs</title>
      <link>https://arxiv.org/abs/2410.00601</link>
      <description>arXiv:2410.00601v1 Announce Type: cross 
Abstract: In 2017 Day et al. introduced the notion of locality as a structural complexity-measure for patterns in the field of pattern matching established by Angluin in 1980. In 2019 Casel et al. showed that determining the locality of an arbitrary pattern is NP-complete. Inspired by hierarchical clustering, we extend the notion to coloured graphs, i.e., given a coloured graph determine an enumeration of the colours such that colouring the graph stepwise according to the enumeration leads to as few clusters as possible. Next to first theoretical results on graph classes, we propose a priority search algorithm to compute the $k$-locality of a graph. The algorithm is optimal in the number of marking prefix expansions, and is faster by orders of magnitude than an exhaustive search. Finally, we perform a case study on a DBLP subgraph to demonstrate the potential of $k$-locality for knowledge discovery.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.00601v1</guid>
      <category>math.CO</category>
      <category>cs.DS</category>
      <category>cs.SI</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christian Beth, Pamela Fleischmann, Annika Huch, Daniyal Kazempour, Peer Kr\"oger, Andrea Kulow, Matthias Renz</dc:creator>
    </item>
    <item>
      <title>Circuit and Graver Walks and Linear and Integer Programming</title>
      <link>https://arxiv.org/abs/2410.00656</link>
      <description>arXiv:2410.00656v1 Announce Type: cross 
Abstract: We show that a circuit walk from a given feasible point of a given linear program to an optimal point can be computed in polynomial time using only linear algebra operations and the solution of the single given linear program.
  We also show that a Graver walk from a given feasible point of a given integer program to an optimal point is polynomial time computable using an integer programming oracle, but without such an oracle, it is hard to compute such a walk even if an optimal solution to the given program is given as well.
  Combining our oracle algorithm with recent results on sparse integer programming, we also show that Graver walks from any point are polynomial time computable over matrices of bounded tree-depth and subdeterminants.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.00656v1</guid>
      <category>math.OC</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1016/j.disopt.2024.100862</arxiv:DOI>
      <arxiv:journal_reference>Discrete Optimization, 54:100862 (7 pages), 2024</arxiv:journal_reference>
      <dc:creator>Shmuel Onn</dc:creator>
    </item>
    <item>
      <title>Representation of Classical Data on Quantum Computers</title>
      <link>https://arxiv.org/abs/2410.00742</link>
      <description>arXiv:2410.00742v1 Announce Type: cross 
Abstract: Quantum computing is currently gaining significant attention, not only from the academic community but also from industry, due to its potential applications across several fields for addressing complex problems. For any practical problem which may be tackled using quantum computing, it is imperative to represent the data used onto a quantum computing system. Depending on the application, many different types of data and data structures occur, including regular numbers, higher-dimensional data structures, e.g., n-dimensional images, up to graphs. This report aims to provide an overview of existing methods for representing these data types on gate-based quantum computers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.00742v1</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Thomas Lang, Anja Heim, Kilian Dremel, Dimitri Prjamkov, Martin Blaimer, Markus Firsching, Anastasia Papadaki, Stefan Kasperl, Theobald OJ Fuchs</dc:creator>
    </item>
    <item>
      <title>Better Boosting of Communication Oracles, or Not</title>
      <link>https://arxiv.org/abs/2410.00838</link>
      <description>arXiv:2410.00838v1 Announce Type: cross 
Abstract: Suppose we have a two-party communication protocol for $f$ which allows the parties to make queries to an oracle computing $g$; for example, they may query an Equality oracle. To translate this protocol into a randomized protocol, we must replace the oracle with a randomized subroutine for solving $g$. If $q$ queries are made, the standard technique requires that we boost the error of each subroutine down to $O(1/q)$, leading to communication complexity which grows as $q \log q$. For which oracles $g$ can this naive boosting technique be improved?
  We focus on the oracles which can be computed by constant-cost randomized protocols, and show that the naive boosting strategy can be improved for the Equality oracle but not the 1-Hamming Distance oracle. Two surprising consequences are (1) a new example of a problem where the cost of computing $k$ independent copies grows superlinear in $k$, drastically simplifying the only previous example due to Blais &amp; Brody (CCC 2019); and (2) a new proof that Equality is not complete for the class of constant-cost randomized communication (Harms, Wild, &amp; Zamaraev, STOC 2022; Hambardzumyan, Hatami, &amp; Hatami, Israel Journal of Mathematics 2022).</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.00838v1</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Nathaniel Harms, Artur Riazanov</dc:creator>
    </item>
    <item>
      <title>Cache-Oblivious Representation of B-Tree Structures</title>
      <link>https://arxiv.org/abs/2209.09166</link>
      <description>arXiv:2209.09166v2 Announce Type: replace 
Abstract: We propose a general data structure CORoBTS for storing B-tree-like search trees dynamically in a cache-oblivious way combining the van Emde Boas memory layout with packed memory array.
  In the use of the vEB layout mostly search complexity was considered, so far. We show the complexity of depth-first search of a subtree and contiguous memory area and provide better insight into the relationship between positions of vertices in tree and in memory. We describe how to build an arbitrary tree in vEB layout if we can simulate its depth-first search. Similarly, we examine batch updates of packed memory array.
  In CORoBTS, the stored search tree has to satisfy that all leaves are at the same depth and vertices have arity between the chosen constants $a$ and $b$. The data structure allows searching with an optimal I/O complexity $\mathcal{O}(\log_B{N})$ and is stored in linear space. It provides operations for inserting and removing a subtree; both have an amortized I/O complexity $\mathcal{O}(S\cdot(\log^2 N)/B + \log_B N\cdot\log\log S + 1)$ and amortized time complexity $\mathcal{O}(S\cdot\log^2 N)$, where $S$ is the size of the subtree and $N$ the size of the whole stored tree. Rebuilding an existing subtree saves the multiplicative $\mathcal{O}(\log^2 N)$ in both complexities if the number of vertices on individual tree levels is not changed; it is paid only for the inserted/removed vertices otherwise.
  Modifying cache-oblivious partially persistent array proposed by Davoodi et al. [ESA, pages 296-308. Springer, 2014] to use CORoBTS improves its space complexity from $\mathcal{O}(U^{\log_2 3} + V \log U)$ to $\mathcal{O}(U + V \log U)$, where $U$ is the maximal size of the array and $V$ is the number of versions; the data locality and I/O complexity of both present and persistent reads are kept unchanged; I/O complexity of writes is worsened by a polylogarithmic factor.</description>
      <guid isPermaLink="false">oai:arXiv.org:2209.09166v2</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Luk\'a\v{s} Ondr\'a\v{c}ek, Ond\v{r}ej Mi\v{c}ka</dc:creator>
    </item>
    <item>
      <title>On the Space Usage of Approximate Distance Oracles with Sub-2 Stretch</title>
      <link>https://arxiv.org/abs/2310.12239</link>
      <description>arXiv:2310.12239v2 Announce Type: replace 
Abstract: For an undirected unweighted graph G = (V, E) with n vertices and m edges, let d(u, v) denote the distance from u in V to v in V in G. An (alpha, beta)-stretch approximate distance oracle (ADO) for G is a data structure that, given u, v in V, returns in constant time a value d-hat (u, v) such that d(u, v) &lt;= d-hat (u, v) &lt;= alpha * d(u, v) + beta, for some reals alpha &gt; 1, beta. If beta = 0, we say that the ADO has stretch alpha.
  Thorup and Zwick (2005) showed that one cannot beat stretch 3 with subquadratic space (in terms of n) for general graphs. Patrascu and Roditty (2010) showed that one can obtain stretch 2 using O(m^(1/3)n^(4/3)) space, and so if m is subquadratic in n, then the space usage is also subquadratic. Moreover, Patrascu and Roditty (2010) showed that one cannot beat stretch 2 with subquadratic space even for graphs where m = O-tilde(n), based on the set-intersection hypothesis.
  In this paper, we investigate the minimum possible stretch achievable by an ADO as a function of the graph's maximum degree, a study motivated by the question of identifying the conditions under which an ADO can be stored with subquadratic space while still ensuring a sub-2 stretch. In particular, we show that if the maximum degree in G is Delta_G &lt;= O(n^(1/k - epsilon)) for some 0 &lt; epsilon &lt;= 1/k, then there exists a (2, 1 - k)-stretch ADO for G that uses O-tilde(n^(2 - (k * epsilon) / 3)) space. For k = 2, this result implies a subquadratic sub-2 stretch ADO for graphs with Delta_G &lt;= O(n^(1/2 - epsilon)). We provide tight lower bounds for the upper bound under the same set intersection hypothesis, showing that if Delta_G = Theta(n^(1/k)), a (2, 1 - k)-stretch ADO requires Omega-tilde(n^2) space. Moreover, we show that for constants epsilon, c &gt; 0, a (2 - epsilon, c)-stretch ADO requires Omega-tilde(n^2) space even for graphs with Delta_G = Theta-tilde(1).</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.12239v2</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tsvi Kopelowitz, Ariel Korin, Liam Roditty</dc:creator>
    </item>
    <item>
      <title>O(1) Insertion for Random Walk d-ary Cuckoo Hashing up to the Load Threshold</title>
      <link>https://arxiv.org/abs/2401.14394</link>
      <description>arXiv:2401.14394v3 Announce Type: replace 
Abstract: The random walk $d$-ary cuckoo hashing algorithm was defined by Fotakis, Pagh, Sanders, and Spirakis to generalize and improve upon the standard cuckoo hashing algorithm of Pagh and Rodler. Random walk $d$-ary cuckoo hashing has low space overhead, guaranteed fast access, and fast in practice insertion time. In this paper, we give a theoretical insertion time bound for this algorithm. More precisely, for every $d\ge 3$ hashes, let $c_d^*$ be the sharp threshold for the load factor at which a valid assignment of $cm$ objects to a hash table of size $m$ likely exists. We show that for any $d\ge 4$ hashes and load factor $c&lt;c_d^*$, the expectation of the random walk insertion time is $O(1)$, that is, a constant depending only on $d$ and $c$ but not $m$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.14394v3</guid>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tolson Bell, Alan Frieze</dc:creator>
    </item>
    <item>
      <title>An FPRAS for Model Counting for Non-Deterministic Read-Once Branching Programs</title>
      <link>https://arxiv.org/abs/2406.16515</link>
      <description>arXiv:2406.16515v2 Announce Type: replace 
Abstract: Non-deterministic read-once branching programs, also known as non-deterministic free binary decision diagrams (nFBDD), are a fundamental data structure in computer science for representing Boolean functions. In this paper, we focus on #nFBDD, the problem of model counting for non-deterministic read-once branching programs. The #nFBDD problem is #P-hard, and it is known that there exists a quasi-polynomial randomized approximation scheme for #nFBDD. In this paper, we provide the first FPRAS for #nFBDD. Our result relies on the introduction of new analysis techniques that focus on bounding the dependence of samples.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.16515v2</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kuldeep S. Meel, Alexis de Colnet</dc:creator>
    </item>
    <item>
      <title>Two Results on LPT: A Near-Linear Time Algorithm and Parcel Delivery using Drones</title>
      <link>https://arxiv.org/abs/2407.16323</link>
      <description>arXiv:2407.16323v2 Announce Type: replace 
Abstract: The focus of this paper is to increase our understanding of the Longest Processing Time First (LPT) heuristic. LPT is a classical heuristic for the fundamental problem of uniform machine scheduling. For different machine speeds, LPT was first considered by Gonzalez et al (SIAM J. Computing, 1977). Since then, extensive work has been done to improve the approximation factor of the LPT heuristic. However, all known implementations of the LPT heuristic take $O(mn)$ time, where $m$ is the number of machines and $n$ is the number of jobs. In this work, we come up with the first near-linear time implementation for LPT. Specifically, the running time is $O((n+m)(\log^2{m}+\log{n}))$. Somewhat surprisingly, the result is obtained by mapping the problem to dynamic maintenance of lower envelope of lines, which has been well studied in the computational geometry community.
  Our second contribution is to analyze the performance of LPT for the Drones Warehouse Problem (DWP), which is a natural generalization of the uniform machine scheduling problem motivated by drone-based parcel delivery from a warehouse. In this problem, a warehouse has multiple drones and wants to deliver parcels to several customers. Each drone picks a parcel from the warehouse, delivers it, and returns to the warehouse (where it can also get charged). The speeds and battery lives of the drones could be different, and due to the limited battery life, each drone has a bounded range in which it can deliver parcels. The goal is to assign parcels to the drones so that the time taken to deliver all the parcels is minimized. We prove that the natural approach of solving this problem via the LPT heuristic has an approximation factor of $\phi$, where $\phi \approx 1.62$ is the golden ratio.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.16323v2</guid>
      <category>cs.DS</category>
      <category>cs.CG</category>
      <category>cs.RO</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>L. Sunil Chandran, Rishikesh Gajjala, Shravan Mehra, Saladi Rahul</dc:creator>
    </item>
    <item>
      <title>Efficient Online Sensitivity Analysis For The Injective Bottleneck Path Problem</title>
      <link>https://arxiv.org/abs/2408.09443</link>
      <description>arXiv:2408.09443v3 Announce Type: replace 
Abstract: The tolerance of an element of a combinatorial optimization problem with respect to a given optimal solution is the maximum change, i.e., decrease or increase, of its cost, such that this solution remains optimal. The bottleneck path problem, for given an edge-capacitated graph, a source, and a target, is to find the $\max$-$\min$ value of edge capacities on paths between the source and the target. For any given sample of this problem with $n$ vertices and $m$ edges, there is known the Ramaswamy-Orlin-Chakravarty's algorithm to compute an optimal path and all tolerances with respect to it in $O(m+n\log n)$ time. In this paper, for any in advance given $(n,m)$-network with distinct edge capacities and $k$ source-target pairs, we propose an $O\Big(m \alpha(m,n)+\min\big((n+k)\log n,km\big)\Big)$-time preprocessing, where $\alpha(\cdot,\cdot)$ is the inverse Ackermann function, to find in $O(k)$ time all $2k$ tolerances of an arbitrary edge with respect to some $\max\min$ paths between the paired sources and targets. To find both tolerances of all edges with respect to those optimal paths, it asymptotically improves, for some $n,m,k$, the Ramaswamy-Orlin-Chakravarty's complexity $O\big(k(m+n\log n)\big)$ up to $O(m\alpha(n,m)+km)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.09443v3</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kirill V. Kaymakov, Dmitry S. Malyshev</dc:creator>
    </item>
    <item>
      <title>On the Maximum Distance Sublattice Problem and Closest Vector Problem</title>
      <link>https://arxiv.org/abs/1811.03019</link>
      <description>arXiv:1811.03019v2 Announce Type: replace-cross 
Abstract: In this paper, we introduce the Maximum Distance Sublattice Problem (MDSP). We observed that the problem of solving an instance of the Closest Vector Problem (CVP) in a lattice $\mathcal{L}$ is the same as solving an instance of MDSP in the dual lattice of $\mathcal{L}$. We give an alternate reduction between the CVP and MDSP. This alternate reduction does not use the concept of dual lattice.</description>
      <guid isPermaLink="false">oai:arXiv.org:1811.03019v2</guid>
      <category>cs.CC</category>
      <category>cs.CR</category>
      <category>cs.DS</category>
      <pubDate>Wed, 02 Oct 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Rajendra Kumar, Shashank K Mehta, Mahesh Sreekumar Rajasree</dc:creator>
    </item>
  </channel>
</rss>
