<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Jul 2025 02:18:14 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Dependent Multiplicities in Dependent Linear Type Theory</title>
      <link>https://arxiv.org/abs/2507.08759</link>
      <description>arXiv:2507.08759v1 Announce Type: new 
Abstract: We present a novel dependent linear type theory in which the multiplicity of some variable - i.e., the number of times the variable can be used in a program - can depend on other variables. This allows us to give precise resource annotations to many higher-order functions that cannot be adequately typed in any other system. Inspired by the Dialectica translation, our typing discipline is obtained by embedding linear logic into dependent type theory and specifying how the embedded logic interacts with the host theory. We can then use a standard natural numbers type to obtain a quantitative typing system with dependent multiplicities. We characterise the semantics for our theory as a combination of standard models of dependent type theory and linear logic. Our system can be added to any dependently typed language, which we demonstrate with an implementation in Agda.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.08759v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Maximilian Dor\'e</dc:creator>
    </item>
    <item>
      <title>Filter Equivariant Functions: A symmetric account of length-general extrapolation on lists</title>
      <link>https://arxiv.org/abs/2507.08796</link>
      <description>arXiv:2507.08796v1 Announce Type: new 
Abstract: What should a function that extrapolates beyond known input/output examples look like? This is a tricky question to answer in general, as any function matching the outputs on those examples can in principle be a correct extrapolant. We argue that a "good" extrapolant should follow certain kinds of rules, and here we study a particularly appealing criterion for rule-following in list functions: that the function should behave predictably even when certain elements are removed. In functional programming, a standard way to express such removal operations is by using a filter function. Accordingly, our paper introduces a new semantic class of functions -- the filter equivariant functions. We show that this class contains interesting examples, prove some basic theorems about it, and relate it to the well-known class of map equivariant functions. We also present a geometric account of filter equivariants, showing how they correspond naturally to certain simplicial structures. Our highlight result is the amalgamation algorithm, which constructs any filter-equivariant function's output by first studying how it behaves on sublists of the input, in a way that extrapolates perfectly.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.08796v1</guid>
      <category>cs.PL</category>
      <category>cs.LG</category>
      <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Owen Lewis, Neil Ghani, Andrew Dudzik, Christos Perivolaropoulos, Razvan Pascanu, Petar Veli\v{c}kovi\'c</dc:creator>
    </item>
    <item>
      <title>Heterogeneous Dynamic Logic: Provability Modulo Program Theories</title>
      <link>https://arxiv.org/abs/2507.08581</link>
      <description>arXiv:2507.08581v1 Announce Type: cross 
Abstract: Formally specifying, let alone verifying, properties of systems involving multiple programming languages is inherently challenging. We introduce Heterogeneous Dynamic Logic (HDL), a framework for combining reasoning principles from distinct (dynamic) program logics in a modular and compositional way. HDL mirrors the architecture of satisfiability modulo theories (SMT): Individual dynamic logics, along with their calculi, are treated as dynamic theories that can be flexibly combined to reason about heterogeneous systems whose components are verified using different program logics. HDL provides two key operations: Lifting extends an individual dynamic theory with new program constructs (e.g., the havoc operation or regular programs) and automatically augments its calculus with sound reasoning principles for the new constructs; and Combination enables cross-language reasoning in a single modality via Heterogeneous Dynamic Theories, facilitating the reuse of existing proof infrastructure. We formalize dynamic theories, their lifting and combination in Isabelle, and prove the soundness of all proof rules. We also prove relative completeness theorems for lifting and combination: Under common assumptions, reasoning about lifted or combined theories is no harder than reasoning about the constituent dynamic theories and their common first-order structure (i.e., the "data theory"). We demonstrate HDL's utility by verifying an automotive case study in which a Java controller (formalized in Java dynamic logic) steers a plant model (formalized in differential dynamic logic).</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.08581v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Samuel Teuber, Mattias Ulbrich, Andr\'e Platzer, Bernhard Beckert</dc:creator>
    </item>
    <item>
      <title>Denotational Semantics of Gradual Typing using Synthetic Guarded Domain Theory (Extended Version)</title>
      <link>https://arxiv.org/abs/2411.12822</link>
      <description>arXiv:2411.12822v2 Announce Type: replace 
Abstract: Gradually typed programming languages, which allow for soundly mixing static and dynamically typed programming styles, present a strong challenge for metatheorists. Even the simplest sound gradually typed languages feature at least recursion and errors, with realistic languages featuring furthermore runtime allocation of memory locations and dynamic type tags. Further, the desired metatheoretic properties of gradually typed languages have become increasingly sophisticated: validity of type-based equational reasoning as well as the relational property known as graduality. Many recent works have tackled verifying these properties, but the resulting mathematical developments are highly repetitive and tedious, with few reusable theorems persisting across different developments.
  In this work, we present a new denotational semantics for gradual typing developed using guarded domain theory. Guarded domain theory combines the generality of step-indexed logical relations for modeling advanced programming features with the modularity and reusability of denotational semantics. We demonstrate the feasibility of this approach with a model of a simple gradually typed lambda calculus and prove the validity of beta-eta equality and the graduality theorem for the denotational model. This model should provide the basis for a reusable mathematical theory of gradually typed program semantics. Finally, we have mechanized most of the core theorems of our development in Guarded Cubical Agda, a recent extension of Agda with support for the guarded recursive constructions we use.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.12822v2</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3704863</arxiv:DOI>
      <dc:creator>Eric Giovannini, Tingting Ding, Max S. New</dc:creator>
    </item>
    <item>
      <title>Abstraction Functions as Types</title>
      <link>https://arxiv.org/abs/2502.20496</link>
      <description>arXiv:2502.20496v2 Announce Type: replace 
Abstract: Software development depends on the use of libraries whose specifications constrain the client's code and impose obligations on the implementation. It follows that any approach to verification at scale must also be modular, while permitting specification of both behavior and cost. Hoare's notion of an abstraction function provides an elegant and effective methodology for such verifications, separating the implementation from the abstraction, and using an abstraction function to demonstrate the behavioral correctness of the former relative to the latter.
  For all of its influence, much of the Hoare methodology remains informal in that it relies on conventional separation between implementation and abstraction, and provides no linguistic support for ensuring that these conventions are obeyed. The purpose of this paper is to propose a synthetic account of Hoare's methodology within univalent dependent type theory based on the principle that all types have abstract and concrete aspects by regarding abstraction functions as types, and thus enjoy the full range of typing constructs found in dependent type theory. Achieving this relies crucially on the notion of a phase distinction in type theory which gives rise to modalities that isolate, or fracture, a type into its concrete and abstract parts, and that permit the definition of a type given these aspects using a technique called gluing. Moreover, this approach scales to permit the specification and verification of the cost of programs, as well as their behavior, allowing clients to verify their own cost relative to these specifications and permit the implementor to realize them with tighter bounds. The resulting theory supports modular development of programs and proofs in a manner that hides technical details of no concern to clients while permitting precise specifications of both the cost and behavior of programs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.20496v2</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Harrison Grodin (Carnegie Mellon University), Runming Li (Carnegie Mellon University), Robert Harper (Carnegie Mellon University)</dc:creator>
    </item>
    <item>
      <title>SecRef*: Securely Sharing Mutable References Between Verified and Unverified Code in F*</title>
      <link>https://arxiv.org/abs/2503.00404</link>
      <description>arXiv:2503.00404v2 Announce Type: replace 
Abstract: We introduce SecRef*, a secure compilation framework protecting stateful programs verified in F* against linked unverified code, with which the program dynamically shares ML-style mutable references. To ease program verification in this setting, we propose a way of tracking which references are shareable with the unverified code, and which ones are not shareable and whose contents are thus guaranteed to be unchanged after calling into unverified code. This universal property of non-shareable references is exposed in the interface on which the verified program can rely when calling into unverified code. The remaining refinement types and pre- and post-conditions that the verified code expects from the unverified code are converted into dynamic checks about the shared references by using higher-order contracts. We prove formally in F* that this strategy ensures sound and secure interoperability with unverified code. Since SecRef* is built on top of the Monotonic State effect of F*, these proofs rely on the first monadic representation for this effect, which is a contribution of our work that can be of independent interest. Finally, we use SecRef* to build a simple cooperative multi-threading scheduler that is verified and that securely interacts with unverified threads.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.00404v2</guid>
      <category>cs.PL</category>
      <category>cs.CR</category>
      <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Cezar-Constantin Andrici, Danel Ahman, Catalin Hritcu, Ruxandra Icleanu, Guido Mart\'inez, Exequiel Rivas, Th\'eo Winterhalter</dc:creator>
    </item>
    <item>
      <title>CCR 2.0: High-level Reasoning for Conditional Refinements</title>
      <link>https://arxiv.org/abs/2507.04298</link>
      <description>arXiv:2507.04298v2 Announce Type: replace 
Abstract: In recent years, great progress has been made in the field of formal verification for low-level systems. Many of them are based on one of two popular approaches: refinement or unary separation logic. These two approaches are very different in nature and offer complementary benefits in compositionality.
  Recently, to fuse these benefits into a single unified mechanism, a new approach called Conditional Contextual Refinement (CCR 1.0 for short) was proposed. In this paper, we advance CCR 1.0 and provide novel and intuitive reasoning principles, resulting in CCR 2.0. Achieving this goal was challenging due to non-trivial counterexamples which necessitated elegant changes to the model of CCR 1.0. On top of CCR 2.0, we show how to fuse the benefits of refinement, unary separation logic, and also relational separation logic.
  Our results are formalized in Rocq.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.04298v2</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 14 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Youngju Song, Minki Cho</dc:creator>
    </item>
  </channel>
</rss>
