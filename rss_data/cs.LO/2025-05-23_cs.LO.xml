<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 May 2025 04:00:48 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>HornStr: A string Theory Solver for Constrained Horn Clauses</title>
      <link>https://arxiv.org/abs/2505.15959</link>
      <description>arXiv:2505.15959v1 Announce Type: new 
Abstract: We present HornStr, the first solver for invariant synthesis for Regular Model Checking (RMC) with the specification provided in the SMT-LIB 2.6 theory of strings. It is well-known that invariant synthesis for RMC subsumes various important verification problems, including safety verification for parameterized systems. To achieve a simple and standardized file format, we treat the invariant synthesis problem as a problem of solving Constrained Horn Clauses (CHCs) over strings. Two strategies for synthesizing invariants in terms of regular constraints are supported: (1) L* automata learning, and (2) SAT-based automata learning. HornStr implements these strategies with the help of existing SMT solvers for strings, which are interfaced through SMT-LIB. HornStr provides an easy-to-use interface for string solver developers to apply their techniques to verification and at the same time verification researchers to painlessly tap into the wealth of modern string solving techniques. To assess the effectiveness of HornStr, we conducted a comprehensive evaluation using benchmarks derived from applications including parameterized verification and string rewriting tasks. Our experiments highlight HornStr's capacity to effectively handle these benchmarks, e.g., as the first solver to verify the challenging MU puzzle automatically. Finally, HornStr can be used to automatically generate a new class of interesting SMT-LIB 2.6 string constraint benchmarks, which might in the future be used in the SMT-COMP strings track. In particular, our experiments on the above invariant synthesis benchmarks produce more than 30000 new QF_S constraints. We also detail the performance of various integrated string solvers, providing insights into their effectiveness on our new benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15959v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hongjian Jiang, Anthony W. Lin, Oliver Markgraf, Philipp R\"ummer, Daniel Stan</dc:creator>
    </item>
    <item>
      <title>Monitoring in the Dark: Privacy-Preserving Runtime Verification of Cyber-Physical Systems</title>
      <link>https://arxiv.org/abs/2505.16059</link>
      <description>arXiv:2505.16059v1 Announce Type: new 
Abstract: In distributed Cyber-Physical Systems and Internet-of-Things applications, the nodes of the system send measurements to a monitor that checks whether these measurements satisfy given formal specifications. For instance in Urban Air Mobility, a local traffic authority will be monitoring drone traffic to evaluate its flow and detect emerging problematic patterns. Certain applications require both the specification and the measurements to be private -- i.e. known only to their owners. Examples include traffic monitoring, testing of integrated circuit designs, and medical monitoring by wearable or implanted devices. In this paper we propose a protocol that enables privacy-preserving robustness monitoring. By following our protocol, both system (e.g. drone) and monitor (e.g. traffic authority) only learn the robustness of the measured trace w.r.t. the specification. But the system learns nothing about the formula, and the monitor learns nothing about the signal monitored. We do this using garbled circuits, for specifications in Signal Temporal Logic interpreted over timed state sequences. We analyze the runtime and memory overhead of privacy preservation, the size of the circuits, and their practicality for three different usage scenarios: design testing, offline monitoring, and online monitoring of Cyber-Physical Systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16059v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Charles Koll, Preston Tan Hang, Mike Rosulek, Houssam Abbas</dc:creator>
    </item>
    <item>
      <title>A Game for Counting Logic Formula Size and an Application to Linear Orders</title>
      <link>https://arxiv.org/abs/2505.16185</link>
      <description>arXiv:2505.16185v1 Announce Type: new 
Abstract: Ehrenfeucht-Fra\"iss\'e (EF) games are a basic tool in finite model theory for proving definability lower bounds, with many applications in complexity theory and related areas. They have been applied to study various logics, giving insights on quantifier rank and other logical complexity measures. In this paper, we present an EF game to capture formula size in counting logic with a bounded number of variables. The game combines games introduced previously for counting logic quantifier rank due to Immerman and Lander, and for first-order formula size due to Adler and Immerman, and Hella and V\"a\"an\"anen. The game is used to prove the main result of the paper, an extension of a formula size lower bound of Grohe and Schweikardt for distinguishing linear orders, from 3-variable first-order logic to 3-variable counting logic. As far as we know, this is the first formula size lower bound for counting logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16185v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gregoire Fournier, Gy\"orgy Tur\'an</dc:creator>
    </item>
    <item>
      <title>Efficient Probabilistic Model Checking for Relational Reachability (Extended Version)</title>
      <link>https://arxiv.org/abs/2505.16357</link>
      <description>arXiv:2505.16357v1 Announce Type: new 
Abstract: Markov decision processes model systems subject to nondeterministic and probabilistic uncertainty. A plethora of verification techniques addresses variations of reachability properties, such as: Is there a scheduler resolving the nondeterminism such that the probability to reach an error state is above a threshold? We consider an understudied extension that relates different reachability probabilities, such as: Is there a scheduler such that two sets of states are reached with different probabilities? These questions appear naturally in the design of randomized algorithms and in various security applications. We provide a tractable algorithm for many variations of this problem, while proving computational hardness of some others. An implementation of our algorithm beats solvers for more general probabilistic hyperlogics by orders of magnitude, on the subset of their benchmarks that are within our fragment.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16357v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Lina Gerlach (RWTH Aachen University, Aachen, Germany), Tobias Winkler (RWTH Aachen University, Aachen, Germany), Erika \'Abrah\'am (RWTH Aachen University, Aachen, Germany), Borzoo Bonakdarpour (Michigan State University, East Lansing, MI, USA), Sebastian Junges (Radboud University, Nijmegen, the Netherlands)</dc:creator>
    </item>
    <item>
      <title>Restricted Chase Termination: You Want More than Fairness</title>
      <link>https://arxiv.org/abs/2505.16551</link>
      <description>arXiv:2505.16551v1 Announce Type: new 
Abstract: The chase is a fundamental algorithm with ubiquitous uses in database theory. Given a database and a set of existential rules (aka tuple-generating dependencies), it iteratively extends the database to ensure that the rules are satisfied in a most general way. This process may not terminate, and a major problem is to decide whether it does. This problem has been studied for a large number of chase variants, which differ by the conditions under which a rule is applied to extend the database. Surprisingly, the complexity of the universal termination of the restricted (aka standard) chase is not fully understood. We close this gap by placing universal restricted chase termination in the analytical hierarchy. This higher hardness is due to the fairness condition, and we propose an alternative condition to reduce the hardness of universal termination.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16551v1</guid>
      <category>cs.LO</category>
      <category>cs.DB</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3725246</arxiv:DOI>
      <dc:creator>David Carral, Lukas Gerlach, Lucas Larroque, Micha\"el Thomazo</dc:creator>
    </item>
    <item>
      <title>Flipping and Forking</title>
      <link>https://arxiv.org/abs/2505.16745</link>
      <description>arXiv:2505.16745v1 Announce Type: new 
Abstract: Monadic stability and the more general monadic dependence (or NIP) are tameness conditions for classes of logical structures, studied in the 80's in Shelah's classification program in model theory. They recently emerged in algorithmic and structural graph theory and finite model theory as central notions in relation with the model checking problem for first-order logic: the problem was shown to be fixed-parameter tractable for inputs which come from a fixed class of graphs which is monadically stable, and is conjectured to be tractable in all monadically dependent classes. Several combinatorial characterizations of such graph classes turned out to be essential in their algorithmic treatment; they are all based on the fundamental operation of "flipping" a graph.
  We introduce the notions of $\textit{flips}$ and $\textit{flip independence}$ in arbitrary relational structures. We lift prior combinatorial characterizations of monadically stable graph classes to monadically stable classes of relational structures. We show the equivalence of flip independence with $\textit{forking independence}$ (over models) -- a logical notion of paramount importance in stability theory -- in monadically stable structures, shedding new light on the relevance of flips, also characterizing forking independence (over models) combinatorially. We give more precise descriptions of forking independence in the case of monadically stable graphs, and relational structures with a nowhere dense Gaifman graph.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16745v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Wojciech Przybyszewski, Szymon Toru\'nczyk</dc:creator>
    </item>
    <item>
      <title>Number theory combination: natural density and SMT</title>
      <link>https://arxiv.org/abs/2505.16840</link>
      <description>arXiv:2505.16840v1 Announce Type: new 
Abstract: The study of theory combination in Satisfiability Modulo Theories (SMT) involves various model theoretic properties (e.g., stable infiniteness, smoothness, etc.). We show that such properties can be partly captured by the natural density of the spectrum of the studied theories, which is the set of sizes of their finite models. This enriches the toolbox of the theory combination researcher, by providing new tools to determine the possibility of combining theories. It also reveals interesting and surprising connections between theory combination and number theory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16840v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guilherme V. Toledo, Yoni Zohar</dc:creator>
    </item>
    <item>
      <title>A Formal Proof of Complexity Bounds on Diophantine Equations</title>
      <link>https://arxiv.org/abs/2505.16963</link>
      <description>arXiv:2505.16963v1 Announce Type: new 
Abstract: We present a universal construction of Diophantine equations with bounded complexity in Isabelle/HOL. This is a formalization of our own work in number theory.
  Hilbert's Tenth Problem was answered negatively by Yuri Matiyasevich, who showed that there is no general algorithm to decide whether an arbitrary Diophantine equation has a solution. However, the problem remains open when generalized to the field of rational numbers, or contrarily, when restricted to Diophantine equations with bounded complexity, characterized by the number of variables $\nu$ and the degree $\delta$. If every Diophantine set can be represented within the bounds $(\nu, \delta)$, we say that this pair is universal, and it follows that the corresponding class of equations is undecidable. In a separate mathematics article, we have determined the first non-trivial universal pair for the case of integer unknowns.
  In this paper, we contribute a formal verification of the main construction required to establish said universal pair. In doing so, we markedly extend the Isabelle AFP entry on multivariate polynomials, formalize parts of a number theory textbook, and develop classical theory on Diophantine equations in Isabelle. Additionally, our work includes metaprogramming infrastructure designed to efficiently handle complex definitions of multivariate polynomials. Our mathematical draft has been formalized while the mathematical research was ongoing, and benefitted largely from the help of the theorem prover. We reflect how the close collaboration between mathematician and computer is an uncommon but promising modus operandi.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16963v1</guid>
      <category>cs.LO</category>
      <category>math.NT</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jonas Bayer, Marco David</dc:creator>
    </item>
    <item>
      <title>Language-based Security and Time-inserting Supervisor</title>
      <link>https://arxiv.org/abs/2505.16503</link>
      <description>arXiv:2505.16503v1 Announce Type: cross 
Abstract: Algebraic methods are employed in order to define language-based security properties of processes. A supervisor is introduced that can disable unwanted behavior of an insecure process by controlling some of its actions or by inserting timed actions to make an insecure process secure. We assume a situation where neither the supervisor nor the attacker has complete information about the ongoing systems behavior. We study the conditions under which such a supervisor exists, as well as its properties and limitations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.16503v1</guid>
      <category>cs.CR</category>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Damas P. Gruska</dc:creator>
    </item>
    <item>
      <title>Intersection Types for a Computational Lambda-Calculus with Global State</title>
      <link>https://arxiv.org/abs/2104.01358</link>
      <description>arXiv:2104.01358v4 Announce Type: replace 
Abstract: We study the semantics of an untyped lambda-calculus equipped with operators representing read and write operations from and to a global store. We adopt the monadic approach to model side-effects and treat read and write as algebraic operations over a monad. We introduce operational and denotational semantics and a type assignment system of intersection types and prove that types are invariant under the reduction and expansion of term and state configurations. Finally, we characterize convergent terms via their typings.</description>
      <guid isPermaLink="false">oai:arXiv.org:2104.01358v4</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ugo de'Liguoro, Riccardo Treglia</dc:creator>
    </item>
    <item>
      <title>A categorical account of composition methods in logic (extended version)</title>
      <link>https://arxiv.org/abs/2405.06664</link>
      <description>arXiv:2405.06664v2 Announce Type: replace 
Abstract: We present a categorical theory of the composition methods in finite model theory -- a key technique enabling modular reasoning about complex structures by building them out of simpler components. The crucial results required by the composition methods are Feferman--Vaught--Mostowski (FVM) type theorems, which characterize how logical equivalence behaves under composition and transformation of models.
  Our results are developed by extending the recently introduced game comonad semantics for model comparison games. This level of abstraction allow us to give conditions yielding FVM type results in a uniform way. Our theorems are parametric in the classes of models, logics and operations involved. Furthermore, they naturally account for the existential and positive existential fragments, and extensions with counting quantifiers of these logics. We also reveal surprising connections between FVM type theorems, and classical concepts in the theory of monads.
  We illustrate our methods by recovering many classical theorems of practical interest, including a refinement of a previous result by Dawar, Severini, and Zapata concerning the 3-variable counting logic and cospectrality. To highlight the importance of our techniques being parametric in the logic of interest, we prove a family of FVM theorems for products of structures, uniformly in the logic in question, which cannot be done using specific game arguments.
  This is an extended version of the LiCS 2023 conference paper of the same name.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.06664v2</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Tom\'a\v{s} Jakl, Dan Marsden, Nihil Shah</dc:creator>
    </item>
    <item>
      <title>ESBMC v7.6: Enhanced Model Checking of C++ Programs with Clang AST</title>
      <link>https://arxiv.org/abs/2406.17862</link>
      <description>arXiv:2406.17862v2 Announce Type: replace 
Abstract: This paper presents Efficient SMT-Based Context-Bounded Model Checker (ESBMC) v7.6, an extended version based on previous work on ESBMC v7.3 by K. Song et al. The v7.3 introduced a new Clang-based C++ front-end to address the challenges posed by modern C++ programs. Although the new front-end has demonstrated significant potential in previous studies, it remains in the developmental stage and lacks several essential features. ESBMC v7.6 further enhanced this foundation by adding and extending features based on the Clang AST, such as 1) exception handling, 2) extended memory management and memory safety verification, including dangling pointers, duplicate deallocation, memory leaks and rvalue references and 3) new operational models for STL updating the outdated C++ operational models. Our extensive experiments demonstrate that ESBMC v7.6 can handle a significantly broader range of C++ features introduced in recent versions of the C++ standard.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.17862v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Xianzhiyu Li, Kunjian Song, Mikhail R. Gadelha, Franz Brau{\ss}e, Rafael S. Menezes, Konstantin Korovin, Lucas C. Cordeiro</dc:creator>
    </item>
    <item>
      <title>Small Decision Trees for MDPs with Deductive Synthesis</title>
      <link>https://arxiv.org/abs/2501.10126</link>
      <description>arXiv:2501.10126v2 Announce Type: replace 
Abstract: Markov decision processes (MDPs) describe sequential decision-making processes; MDP policies return for every state in that process an advised action. Classical algorithms can efficiently compute policies that are optimal with respect to, e.g., reachability probabilities. However, these policies are then given in a tabular format. A longstanding challenge is to represent optimal or almost-optimal policies concisely, e.g., as decision trees. This paper makes two contributions towards this challenge: first, an SMT-based approach to encode a given (optimal) policy as a small decision tree, and second, an abstraction-refinement loop that searches for policies that are optimal within the set of policies that can be represented with a small tree. Technically, the latter combines the SMT encoding with verification approaches for families of Markov chains. The empirical evaluation demonstrates the feasibility of these approaches and shows how they can outperform the state-of-the-art on various benchmarks, yielding up to 20 times smaller trees representing (almost) optimal policies for models with up to 10k states and 19 variables.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.10126v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Roman Andriushchenko, Milan \v{C}e\v{s}ka, Sebastian Junges, Filip Mac\'ak</dc:creator>
    </item>
    <item>
      <title>Infinite State Model Checking by Learning Transitive Relations</title>
      <link>https://arxiv.org/abs/2502.04761</link>
      <description>arXiv:2502.04761v2 Announce Type: replace 
Abstract: We propose a new approach for proving safety of infinite state systems. It extends the analyzed system by transitive relations until its diameter D becomes finite, i.e., until constantly many steps suffice to cover all reachable states, irrespective of the initial state. Then we can prove safety by checking that no error state is reachable in D steps. To deduce transitive relations, we use recurrence analysis. While recurrence analyses can usually find conjunctive relations only, our approach also discovers disjunctive relations by combining recurrence analysis with projections. An empirical evaluation of the implementation of our approach in our tool LoAT shows that it is highly competitive with the state of the art.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.04761v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Florian Frohn, J\"urgen Giesl</dc:creator>
    </item>
    <item>
      <title>Compositional Taylor expansion in cartesian differential categories</title>
      <link>https://arxiv.org/abs/2502.09066</link>
      <description>arXiv:2502.09066v2 Announce Type: replace 
Abstract: This paper provides a compositional approach to Taylor expansion, in the setting of cartesian differential categories. Taylor expansion is captured here by a functor that generalizes the tangent bundle functor to higher order derivatives. The fundamental properties of Taylor expansion then boils down to naturality equations that turns this functor into a monad. This monad provides a categorical approach to higher order dual numbers and the jet bundle construction used in automated differentiation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.09066v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Aymeric Walch (IRIF)</dc:creator>
    </item>
    <item>
      <title>Infinitary Refinement Types for Temporal Properties in Scott Domains</title>
      <link>https://arxiv.org/abs/2502.11917</link>
      <description>arXiv:2502.11917v3 Announce Type: replace 
Abstract: We discuss an infinitary refinement type system for input-output temporal specifications of functions that handle infinite objects like streams or infinite trees. Our system is based on a reformulation of Bonsangue and Kok's infinitary extension of Abramsky's Domain Theory in Logical Form to saturated properties. We show that in an interesting range of cases, our system is complete without the need of an infinitary rule introduced by Bonsangue and Kok to reflect the well-filteredness of Scott domains.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.11917v3</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Colin Riba, Alexandre Kejikian</dc:creator>
    </item>
    <item>
      <title>Branching Bisimulation Learning</title>
      <link>https://arxiv.org/abs/2504.12246</link>
      <description>arXiv:2504.12246v2 Announce Type: replace 
Abstract: We introduce a bisimulation learning algorithm for non-deterministic transition systems. We generalise bisimulation learning to systems with bounded branching and extend its applicability to model checking branching-time temporal logic, while previously it was limited to deterministic systems and model checking linear-time properties. Our method computes a finite stutter-insensitive bisimulation quotient of the system under analysis, represented as a decision tree. We adapt the proof rule for well-founded bisimulations to an iterative procedure that trains candidate decision trees from sample transitions of the system, and checks their validity over the entire transition relation using SMT solving. This results in a new technology for model checking CTL* without the next-time operator. Our technique is sound, entirely automated, and yields abstractions that are succinct and effective for formal verification and system diagnostics. We demonstrate the efficacy of our method on diverse benchmarks comprising concurrent software, communication protocols and robotic scenarios. Our method performs comparably to mature tools in the special case of LTL model checking, and outperforms the state of the art in CTL and CTL* model checking for systems with very large and countably infinite state space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.12246v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alessandro Abate, Mirco Giacobbe, Christian Micheletti, Yannik Schnitzer</dc:creator>
    </item>
    <item>
      <title>Approximate Probabilistic Bisimulation for Continuous-Time Markov Chains</title>
      <link>https://arxiv.org/abs/2505.15587</link>
      <description>arXiv:2505.15587v2 Announce Type: replace 
Abstract: We introduce $(\varepsilon, \delta)$-bisimulation, a novel type of approximate probabilistic bisimulation for continuous-time Markov chains. In contrast to related notions, $(\varepsilon, \delta)$-bisimulation allows the use of different tolerances for the transition probabilities ($\varepsilon$, additive) and total exit rates ($\delta$, multiplicative) of states. Fundamental properties of the notion, as well as bounds on the absolute difference of time- and reward-bounded reachability probabilities for $(\varepsilon,\delta)$-bisimilar states, are established.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15587v2</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Timm Spork, Christel Baier, Joost-Pieter Katoen, Sascha Kl\"uppelholz, Jakob Piribauer</dc:creator>
    </item>
    <item>
      <title>OSVAuto: automatic proofs about functional specifications in OS verification</title>
      <link>https://arxiv.org/abs/2403.13457</link>
      <description>arXiv:2403.13457v2 Announce Type: replace-cross 
Abstract: We present OSVAuto for automatic proofs about functional specifications that commonly arise when verifying operating system kernels. The algorithm behind OSVAuto is designed to support natively those data types that commonly occur in OS verification, including sequences, maps, structures and enumerations. Propositions about these data are encoded into a form that is suitable for SMT solving. For quantifier instantiation, we propose an extension of recent work for automatic proofs about sequences. We evaluate the algorithm on proof obligations adapted from existing verification of the uC-OS/II kernel in Coq, demonstrating that a large number of proof obligations can be solved automatically, significantly reducing the proof effort on the functional side.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.13457v2</guid>
      <category>cs.SC</category>
      <category>cs.LO</category>
      <pubDate>Fri, 23 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yulun Wu, Bican Xia, Jiale Xu, Bohua Zhan, Tianqi Zhao</dc:creator>
    </item>
  </channel>
</rss>
