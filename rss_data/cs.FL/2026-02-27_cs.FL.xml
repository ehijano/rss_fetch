<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Feb 2026 05:00:12 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Efficient Constructions of Finite-State Independent Normal Pairs</title>
      <link>https://arxiv.org/abs/2602.23030</link>
      <description>arXiv:2602.23030v1 Announce Type: new 
Abstract: Finite-state independence is a robust notion of algorithmic independence for infinite words. It was introduced for general infinite words by Becher, Carton, and Heiber via deterministic asynchronous two-tape finite automata. \'Alvarez, Becher, and Carton then studied the normal case and characterized finite-state independence in terms of deterministic finite-state shufflers. A shuffler is a finite automaton that reads from two input tapes $x,y\in\Sigma^\infty$ and, at each step, chooses one tape to read next, outputs the symbol read, and updates its state based only on that output symbol. In terms of this characterization, two normal sources are finite-state independent if every deterministic finite-state way of shuffling (interleaving) them still produces a normal sequence. \'Alvarez, Becher, and Carton posed the following questions: (1) can one compute finite-state independent normal pairs efficiently, improving their doubly-exponential procedure; and (2) given a normal word $x$, can one effectively construct a normal word $y$ that is finite-state independent from $x$?
  We answer both questions by explicit deterministic constructions. First, we give a deterministic polynomial-time algorithm that, on input $N$, outputs the first $N$ symbols of two normal words $x$ and $y$ such that for every shuffler $S$, the shuffled output $S(x,y)$ is normal; hence $(x,y)$ is finite-state independent.
  Second, we solve the one-sided companion problem effectively. Given any computable normal word $x\in\Sigma^\infty$, we give an explicit deterministic construction of a computable normal word $y\in\Sigma^\infty$ such that for every shuffler $S$, the shuffled output $S(x,y)$ is normal. In particular, $x$ and $y$ are finite-state independent by the shuffler characterization theorem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.23030v1</guid>
      <category>cs.FL</category>
      <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Subin Pulari</dc:creator>
    </item>
    <item>
      <title>Opacity in Discrete Event Systems: A Perspective and Overview</title>
      <link>https://arxiv.org/abs/2602.22713</link>
      <description>arXiv:2602.22713v1 Announce Type: cross 
Abstract: Opacity has emerged as a central confidentiality notion for information-flow security in discrete event systems (DES), capturing the requirement that an external observer (intruder) should never be able to determine with certainty whether the system is, was, or will be in a secret state. This article provides a concise, newcomer-friendly overview of opacity in DES, emphasizing core definitions and the unifying estimation viewpoint behind major opacity notions,. We summarize representative verification techniques and highlight how different observation models reshape both the problem formulation and algorithmic structure. We then review principal enforcement paradigms, ranging from opacity-enforcing supervisory control to sensor activation/information release optimization and obfuscation/editing mechanisms. Beyond finite automata, we outline how opacity has been studied in richer models such as stochastic systems, timed systems, Petri nets, and continuous/hybrid dynamics, and we briefly survey applications in robotics, location privacy, and information services. Finally, we discuss selected open challenges, including solvability under incomparable information, scalable methods beyond worst-case complexity, and opacity under intelligent or data-driven adversaries.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.22713v1</guid>
      <category>eess.SY</category>
      <category>cs.FL</category>
      <category>cs.SY</category>
      <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Xiang Yin</dc:creator>
    </item>
    <item>
      <title>Uniform Membership for Hyperedge Replacement Grammars and Related Decision Problems</title>
      <link>https://arxiv.org/abs/2501.08082</link>
      <description>arXiv:2501.08082v3 Announce Type: replace 
Abstract: This paper investigates complexity of the uniform membership problem for hyperedge replacement grammars in comparison with other mildly context-sensitive grammar formalisms. It turns out that the complexity of this problem depends on how one defines a hypergraph. There are two commonly used definitions in the field, which differ in whether repetitions of attachment nodes of a hyperedge are allowed in a hypergraph or not. We show that, in general, the problem under consideration is EXPTIME-complete, even for string-generating hyperedge replacement grammars, but it is NP-complete if repetitions are not allowed.
  We extend the developed proof techniques in order prove a general meta-theorem: checking whether a given hyperedge replacement grammar generates a hypergraph satisfying a non-Parikh property is EXPTIME-hard. Non-Parikh properties are those that are not preimages of properties on Parikh vectors of hypergraphs. This includes any graph property relying significantly on structure of graphs, e.g. connectivity, Eulerianity, Hamiltonianity, acyclicity. A tight upper bound is established for EXPTIME-compatible properties via Filter Theorem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.08082v3</guid>
      <category>cs.FL</category>
      <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Tikhon Pshenitsyn</dc:creator>
    </item>
    <item>
      <title>Generalised M\"obius Categories and Convolution Kleene Algebras</title>
      <link>https://arxiv.org/abs/2509.00168</link>
      <description>arXiv:2509.00168v3 Announce Type: replace 
Abstract: Convolution algebras on maps from structures such as monoids, groups or categories into semirings, rings or fields abound in mathematics and the sciences. Of special interest in computing are convolution algebras based on variants of Kleene algebras, which are additively idempotent semirings equipped with a Kleene star. Yet an obstacle to the construction of convolution Kleene algebras on a wide class of structures has so far been the definition of a suitable star. We show that a generalisation of M\"obius categories combined with a generalisation of a classical definition of a star for formal power series allow such a construction. We discuss several instances of this construction on generalised M\"obius categories: convolution Kleene algebras with tests, modal convolution Kleene algebras, concurrent convolution Kleene algebras and higher convolution Kleene algebras (e.g. on strict higher categories and higher relational monoids). These are relevant to the verification of weighted and probabilistic sequential and concurrent programs, using quantitative Hoare logics or predicate transformer algebras, as well as for algebraic reasoning in higher-dimensional rewriting. We also adapt the convolution Kleene algebra construction to Conway semirings, which is widely studied in the context of weighted automata. Finally, we compare the convolution Kleene algebra construction with a previous construction of convolution quantales and present concrete example structures in preparation for future applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.00168v3</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>James Cranch, Georg Struth, Jana Wagemaker</dc:creator>
    </item>
    <item>
      <title>On the order of lazy cellular automata</title>
      <link>https://arxiv.org/abs/2510.14841</link>
      <description>arXiv:2510.14841v3 Announce Type: replace 
Abstract: We study the most elementary family of cellular automata defined over an arbitrary group universe $G$ and an alphabet $A$: the lazy cellular automata, which act as the identity on configurations in $A^G$, except when they read a unique active transition $p \in A^S$, in which case they write a fixed symbol $a \in A$. As expected, the dynamical behavior of lazy cellular automata is relatively simple, yet subtle questions arise since they completely depend on the choice of $p$ and $a$. In this paper, we investigate the order of a lazy cellular automaton $\tau : A^G \to A^G$, defined as the cardinality of the set $\{ \tau^k : k \in \mathbb{N} \}$. In particular, we establish a general upper bound for the order of $\tau$ in terms of the fibers of $p$, and we prove that this bound is attained when $p$ is a quasi-constant pattern.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.14841v3</guid>
      <category>cs.FL</category>
      <category>math.DS</category>
      <category>math.GR</category>
      <category>nlin.CG</category>
      <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Edgar Alcal\'a-Arroyo, Alonso Castillo-Ramirez</dc:creator>
    </item>
    <item>
      <title>Arbitrary-arity Tree Automata and QCTL</title>
      <link>https://arxiv.org/abs/2410.18799</link>
      <description>arXiv:2410.18799v4 Announce Type: replace-cross 
Abstract: We introduce a new class of automata (which we coin EU-automata) running on infininte trees of arbitrary (finite) arity. We develop and study several algorithms to perform classical operations (union, intersection, complement, projection, alternation removal) for those automata, and precisely characterise their complexities. We also develop algorithms for solving membership and emptiness for the languages of trees accepted by EU-automata.
  We then use EU-automata to obtain several algorithmic and expressiveness results for the temporal logic QCTL (which extends CTL with quantification over atomic propositions) and for MSO. On the one hand, we obtain decision procedures with optimal complexity for QCTL satisfiability and model checking; on the other hand, we obtain an algorithm for translating any QCTL formula with k quantifier alternations to formulas with at most one quantifier alternation, at the expense of a $(k + 1)$-exponential blow-up in the size of the formulas. Using the same techniques, we prove that any MSO formula can be translated into a formula with at most four quantifier alternations (and only one second-order-quantifier alternation), this time with a $(k + 2)$-exponential blow-up in the size of the formula.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.18799v4</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Fran\c{c}ois Laroussinie, Nicolas Markey</dc:creator>
    </item>
    <item>
      <title>LeanCat: A Benchmark Suite for Formal Category Theory in Lean (Part I: 1-Categories)</title>
      <link>https://arxiv.org/abs/2512.24796</link>
      <description>arXiv:2512.24796v2 Announce Type: replace-cross 
Abstract: While large language models (LLMs) have demonstrated impressive capabilities in formal theorem proving, current benchmarks fail to adequately measure library-grounded abstraction -- the ability to reason with high-level interfaces and reusable structures central to modern mathematics and software engineering. We introduce LeanCat, a challenging benchmark comprising 100 fully formalized category-theory tasks in Lean. Unlike algebra or arithmetic, category theory serves as a rigorous stress test for structural, interface-level reasoning. Our evaluation reveals a severe abstraction gap: the best state-of-the-art model solves only 12.0% of tasks at pass@4, with performance collapsing from 55.0% on Easy tasks to 0.0% on High-difficulty tasks, highlighting a failure in compositional generalization. To overcome this, we evaluate LeanBridge, a retrieval-augmented agent that employs a retrieve-generate-verify loop. LeanBridge achieves a peak success rate of 24.0% -- doubling the performance of the best static baseline. These results empirically demonstrate that iterative refinement and dynamic library retrieval are not merely optimizations but strict necessities for neuro-symbolic reasoning in abstract domains. LeanCat offers a compact, reusable testbed for tracking progress toward reliable, research-level formalization.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.24796v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <category>math.CT</category>
      <pubDate>Fri, 27 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Rongge Xu, Hui Dai, Yiming Fu, Jiedong Jiang, Tianjiao Nie, Junkai Wang, Holiverse Yang, Zhi-Hao Zhang</dc:creator>
    </item>
  </channel>
</rss>
