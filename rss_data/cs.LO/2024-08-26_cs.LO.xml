<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Aug 2024 04:00:13 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 26 Aug 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>On Woolhouse's Cotton-Spinning Problem</title>
      <link>https://arxiv.org/abs/2408.12623</link>
      <description>arXiv:2408.12623v1 Announce Type: new 
Abstract: In 1864 W.S.B. Woolhouse formulated the Cotton-Spinning problem. This problem boils down to the following. A piecer works at a spinning mule and walks back and forth to repair broken threads. The question is how far the piecer is expected to walk when the threads break at random. This problem can neatly be solved using process modelling and quantitative model checking, showing that Woolhouse's model led to an overestimation of the walking distance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.12623v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jan Friso Groote, Tim A. C. Willemse</dc:creator>
    </item>
    <item>
      <title>Input-based Framework for Three-valued Abstraction Refinement</title>
      <link>https://arxiv.org/abs/2408.12668</link>
      <description>arXiv:2408.12668v1 Announce Type: new 
Abstract: We present a novel algorithmic framework for Three-valued Abstraction Refinement, which extends Counterexample-guided Abstraction Refinement with the ability to verify all properties of mu-calculus including recovery (the ability of the system to always return to a certain state). The framework performs refinement on abstract system inputs rather than abstract states, avoiding problems of previous frameworks. We formalise input-based refinement by introducing the concept of generating automata, and prove that our framework is sound, monotone, and complete. We evaluate the usefulness of the framework on its implementation in our free and open-source formal verification tool.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.12668v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jan Onderka</dc:creator>
    </item>
    <item>
      <title>Complexity of Weighted First-Order Model Counting in the Two-Variable Fragment with Counting Quantifiers: A Bound to Beat</title>
      <link>https://arxiv.org/abs/2404.12905</link>
      <description>arXiv:2404.12905v2 Announce Type: replace 
Abstract: We study the time complexity of the weighted first-order model counting (WFOMC) over the logical language with two variables and counting quantifiers. The problem is known to be solvable in time polynomial in the domain size. However, the degree of the polynomial, which turns out to be relatively high for most practical applications, has never been properly addressed. First, we formulate a time complexity bound for the existing techniques for solving WFOMC with counting quantifiers. The bound is already known to be a polynomial with its degree depending on the number of cells of the input formula. We observe that the number of cells depends, in turn, exponentially on the parameter of the counting quantifiers appearing in the formula. Second, we propose a new approach to dealing with counting quantifiers, reducing the exponential dependency to a quadratic one, therefore obtaining a tighter upper bound. It remains an open question whether the dependency of the polynomial degree on the counting quantifiers can be reduced further, thus making our new bound a bound to beat.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.12905v2</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jan T\'oth, Ond\v{r}ej Ku\v{z}elka</dc:creator>
    </item>
    <item>
      <title>The complexity of deciding characteristic formulae in van Glabbeek's branching-time spectrum</title>
      <link>https://arxiv.org/abs/2405.13697</link>
      <description>arXiv:2405.13697v3 Announce Type: replace 
Abstract: Characteristic formulae give a complete logical description of the behaviour of processes modulo some chosen notion of behavioural semantics. They allow one to reduce equivalence or preorder checking to model checking, and are exactly the formulae in the modal logics characterizing classic behavioural equivalences and preorders for which model checking can be reduced to equivalence or preorder checking.
  This paper studies the complexity of determining whether a formula is characteristic for some finite, loop-free process in each of the logics providing modal characterizations of the simulation-based semantics in van Glabbeek's branching-time spectrum. Since characteristic formulae in each of those logics are exactly the consistent and prime ones, it presents complexity results for the satisfiability and primality problems, and investigates the boundary between modal logics for which those problems can be solved in polynomial time and those for which they become computationally hard.
  Amongst other contributions, this article also studies the complexity of constructing characteristic formulae in the modal logics characterizing simulation-based semantics, both when such formulae are presented in explicit form and via systems of equations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.13697v3</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Luca Aceto, Antonis Achilleos, Aggeliki Chalki, Anna Ingolfsdottir</dc:creator>
    </item>
    <item>
      <title>Abductive Reasoning in a Paraconsistent Framework</title>
      <link>https://arxiv.org/abs/2408.07287</link>
      <description>arXiv:2408.07287v2 Announce Type: replace 
Abstract: We explore the problem of explaining observations starting from a classically inconsistent theory by adopting a paraconsistent framework. We consider two expansions of the well-known Belnap--Dunn paraconsistent four-valued logic $\mathsf{BD}$: $\mathsf{BD}_\circ$ introduces formulas of the form $\circ\phi$ (the information on $\phi$ is reliable), while $\mathsf{BD}_\triangle$ augments the language with $\triangle\phi$'s (there is information that $\phi$ is true). We define and motivate the notions of abduction problems and explanations in $\mathsf{BD}_\circ$ and $\mathsf{BD}_\triangle$ and show that they are not reducible to one another. We analyse the complexity of standard abductive reasoning tasks (solution recognition, solution existence, and relevance / necessity of hypotheses) in both logics. Finally, we show how to reduce abduction in $\mathsf{BD}_\circ$ and $\mathsf{BD}_\triangle$ to abduction in classical propositional logic, thereby enabling the reuse of existing abductive reasoning procedures.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.07287v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>math.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Meghyn Bienvenu, Katsumi Inoue, Daniil Kozhemiachenko</dc:creator>
    </item>
  </channel>
</rss>
