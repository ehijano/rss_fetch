<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Aug 2025 15:51:17 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Competitive Bundle Trading</title>
      <link>https://arxiv.org/abs/2507.23047</link>
      <description>arXiv:2507.23047v1 Announce Type: new 
Abstract: A retailer is purchasing goods in bundles from suppliers and then selling these goods in bundles to customers; her goal is to maximize profit, which is the revenue obtained from selling goods minus the cost of purchasing those goods. In this paper, we study this general trading problem from the retailer's perspective, where both suppliers and customers arrive online. The retailer has inventory constraints on the number of goods from each type that she can store, and she must decide upon arrival of each supplier/customer which goods to buy/sell in order to maximize profit.
  We design an algorithm with logarithmic competitive ratio compared to an optimal offline solution. We achieve this via an exponential-weight-update dynamic pricing scheme, and our analysis dual fits the retailer's profit with respect to a linear programming formulation upper bounding the optimal offline profit. We prove (almost) matching lower bounds, and we also extend our result to an incentive compatible mechanism. Prior to our work, algorithms for trading bundles were known only for the special case of selling an initial inventory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23047v1</guid>
      <category>cs.DS</category>
      <category>cs.GT</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yossi Azar, Niv Buchbinder, Roie Levin, Or Vardi</dc:creator>
    </item>
    <item>
      <title>Efficient algorithm for linear diophantine equations in two variables</title>
      <link>https://arxiv.org/abs/2507.23216</link>
      <description>arXiv:2507.23216v1 Announce Type: new 
Abstract: Solving linear diophantine equations in two variables have applications in computer science and mathematics. In this paper, we revisit an algorithm for solving linear diophantine equations in two variables, which we refer as DEA-R algorithm. The DEA-R algorithm always incurs equal or less number of recursions or recursive calls as compared to extended euclidean algorithm. With the objective of taking advantage of the less number of recursive calls , we propose an optimized version of the DEA-R algorithm as DEA-OPTD. In the recursive function calls in DEA-OPTD, we propose a sequence of more efficient computations. We do a theoretical comparison of the execution times of DEA-OPTD algorithm and DEA-R algorithm to find any possible bound on the value of $c$ for DEA-OPTD being better than DEA-R. We implement and compare an iterative version of DEA-OPTD (DEA-OPTDI) with two versions of a widely used algorithm on an specific input setting. In this comparison, we find out that our algorithm outperforms on the other algorithm against atleast 96% of the inputs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23216v1</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mayank Deora, Pinakpani Pal</dc:creator>
    </item>
    <item>
      <title>Scalable contribution bounding to achieve privacy</title>
      <link>https://arxiv.org/abs/2507.23432</link>
      <description>arXiv:2507.23432v1 Announce Type: new 
Abstract: In modern datasets, where single records can have multiple owners, enforcing user-level differential privacy requires capping each user's total contribution. This "contribution bounding" becomes a significant combinatorial challenge. Existing sequential algorithms for this task are computationally intensive and do not scale to the massive datasets prevalent today. To address this scalability bottleneck, we propose a novel and efficient distributed algorithm. Our approach models the complex ownership structure as a hypergraph, where users are vertices and records are hyperedges. The algorithm proceeds in rounds, allowing users to propose records in parallel. A record is added to the final dataset only if all its owners unanimously agree, thereby ensuring that no user's predefined contribution limit is violated. This method aims to maximize the size of the resulting dataset for high utility while providing a practical, scalable solution for implementing user-level privacy in large, real-world systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23432v1</guid>
      <category>cs.DS</category>
      <category>cs.CR</category>
      <category>cs.DC</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vincent Cohen-Addad, Alessandro Epasto, Jason Lee, Morteza Zadimoghaddam</dc:creator>
    </item>
    <item>
      <title>Nyldon Factorization of Thue-Morse Words and Fibonacci Words</title>
      <link>https://arxiv.org/abs/2507.23659</link>
      <description>arXiv:2507.23659v1 Announce Type: new 
Abstract: The Nyldon factorization is a string factorization that is a non-decreasing product of Nyldon words. Nyldon words and Nyldon factorizations are recently defined combinatorial objects inspired by the well-known Lyndon words and Lyndon factorizations. In this paper, we investigate the Nyldon factorization of several words. First, we fully characterize the Nyldon factorizations of the (finite) Fibonacci and the (finite) Thue-Morse words. Moreover, we show that there exists a non-decreasing product of Nyldon words that is a factorization of the infinite Thue-Morse word.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23659v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kaisei Kishi, Kazuki Kai, Yuto Nakashima, Shunsuke Inenaga, Hideo Bannai</dc:creator>
    </item>
    <item>
      <title>The Squishy Grid Problem</title>
      <link>https://arxiv.org/abs/2507.23105</link>
      <description>arXiv:2507.23105v1 Announce Type: cross 
Abstract: In this paper we consider the problem of approximating Euclidean distances by the infinite integer grid graph. Although the topology of the graph is fixed, we have control over the edge-weight assignment $w:E\to \mathbb{R}_{\ge 0}$, and hope to have grid distances be asymptotically isometric to Euclidean distances, that is, for all grid points $u,v$, $\mathrm{dist}_w(u,v) = (1\pm o(1))\|u-v\|_2$. We give three methods for solving this problem, each attractive in its own way.
  * Our first construction is based on an embedding of the recursive, non-periodic pinwheel tiling of Radin and Conway into the integer grid. Distances in the pinwheel graph are asymptotically isometric to Euclidean distances, but no explicit bound on the rate of convergence was known. We prove that the multiplicative distortion of the pinwheel graph is $(1+1/\Theta(\log^\xi \log D))$, where $D$ is the Euclidean distance and $\xi=\Theta(1)$. The pinwheel tiling approach is conceptually simple, but can be improved quantitatively.
  * Our second construction is based on a hierarchical arrangement of "highways." It is simple, achieving stretch $(1 + 1/\Theta(D^{1/9}))$, which converges doubly exponentially faster than the pinwheel tiling approach.
  * The first two methods are deterministic. An even simpler approach is to sample the edge weights independently from a common distribution $\mathscr{D}$. Whether there exists a distribution $\mathscr{D}^*$ that makes grid distances Euclidean, asymptotically and in expectation, is major open problem in the theory of first passage percolation. Previous experiments show that when $\mathscr{D}$ is a Fisher distribution, grid distances are within 1\% of Euclidean. We demonstrate experimentally that this level of accuracy can be achieved by a simple 2-point distribution that assigns weights 0.41 or 4.75 with probability 44\% and 56\%, respectively.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23105v1</guid>
      <category>cs.CG</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <category>math.PR</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Zixi Cai, Kuowen Chen, Shengquan Du, Arnold Filtser, Seth Pettie, Daniel Skora</dc:creator>
    </item>
    <item>
      <title>Online Combinatorial Allocation with Interdependent Values</title>
      <link>https://arxiv.org/abs/2507.23500</link>
      <description>arXiv:2507.23500v1 Announce Type: cross 
Abstract: We study online combinatorial allocation problems in the secretary setting, under interdependent values. In the interdependent model, introduced by Milgrom and Weber (1982), each agent possesses a private signal that captures her information about an item for sale, and the value of every agent depends on the signals held by all agents. Mauras, Mohan, and Reiffenh\"auser (2024) were the first to study interdependent values in online settings, providing constant-approximation guarantees for secretary settings, where agents arrive online along with their signals and values, and the goal is to select the agent with the highest value.
  In this work, we extend this framework to {\em combinatorial} secretary problems, where agents have interdependent valuations over {\em bundles} of items, introducing additional challenges due to both combinatorial structure and interdependence. We provide $2e$-competitive algorithms for a broad class of valuation functions, including submodular and XOS functions, matching the approximation guarantees in the single-choice secretary setting. Furthermore, our results cover the same range of valuation classes for which constant-factor algorithms exist in classical (non-interdependent) secretary settings, while incurring only an additional factor of $2$ due to interdependence. Finally, we extend our study to strategic settings, and provide a $4e$-competitive truthful mechanism for online bipartite matching with interdependent valuations, again meeting the frontier of what is known, even without interdependence.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23500v1</guid>
      <category>cs.GT</category>
      <category>cs.DS</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3736252.3742518</arxiv:DOI>
      <dc:creator>Michal Feldman, Simon Mauras, Divyarthi Mohan, Rebecca Reiffenh\"auser</dc:creator>
    </item>
    <item>
      <title>Improved Algorithms for Kernel Matrix-Vector Multiplication Under Sparsity Assumptions</title>
      <link>https://arxiv.org/abs/2507.23539</link>
      <description>arXiv:2507.23539v1 Announce Type: cross 
Abstract: Motivated by the problem of fast processing of attention matrices, we study fast algorithms for computing matrix-vector products for asymmetric Gaussian Kernel matrices $K\in \mathbb{R}^{n\times n}$. $K$'s columns are indexed by a set of $n$ keys $k_1,k_2\ldots, k_n\in \mathbb{R}^d$, rows by a set of $n$ queries $q_1,q_2,\ldots,q_n\in \mathbb{R}^d $, and its $i,j$ entry is $K_{ij} = e^{-\|q_i-k_j\|_2^2/2\sigma^2}$ for some bandwidth parameter $\sigma&gt;0$. Given a vector $x\in \mathbb{R}^n$ and error parameter $\epsilon&gt;0$, our task is to output a $y\in \mathbb{R}^n$ such that $\|Kx-y\|_2\leq \epsilon \|x\|_2$ in time subquadratic in $n$ and linear in $d$. Our algorithms rely on the following modelling assumption about the matrices $K$: the sum of the entries of $K$ scales linearly in $n$, as opposed to worst case quadratic growth. We validate this assumption experimentally, for Gaussian kernel matrices encountered in various settings such as fast attention computation in LLMs. We obtain the first subquadratic-time algorithm that works under this assumption, for unrestricted vectors.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23539v1</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Piotr Indyk, Michael Kapralov, Kshiteej Sheth, Tal Wagner</dc:creator>
    </item>
    <item>
      <title>Amplitude amplification and estimation require inverses</title>
      <link>https://arxiv.org/abs/2507.23787</link>
      <description>arXiv:2507.23787v1 Announce Type: cross 
Abstract: We prove that the generic quantum speedups for brute-force search and counting only hold when the process we apply them to can be efficiently inverted. The algorithms speeding up these problems, amplitude amplification and amplitude estimation, assume the ability to apply a state preparation unitary $U$ and its inverse $U^\dagger$; we give problem instances based on trace estimation where no algorithm which uses only $U$ beats the naive, quadratically slower approach. Our proof of this is simple and goes through the compressed oracle method introduced by Zhandry. Since these two subroutines are responsible for the ubiquity of the quadratic "Grover" speedup in quantum algorithms, our result explains why such speedups are far harder to come by in the settings of quantum learning, metrology, and sensing. In these settings, $U$ models the evolution of an experimental system, so implementing $U^\dagger$ can be much harder -- tantamount to reversing time within the system. Our result suggests a dichotomy: without inverse access, quantum speedups are scarce; with it, quantum speedups abound.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.23787v1</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ewin Tang, John Wright</dc:creator>
    </item>
    <item>
      <title>A Simple $(1-\epsilon)$-Approximation Semi-Streaming Algorithm for Maximum (Weighted) Matching</title>
      <link>https://arxiv.org/abs/2307.02968</link>
      <description>arXiv:2307.02968v4 Announce Type: replace 
Abstract: We present a simple semi-streaming algorithm for $(1-\epsilon)$-approximation of bipartite matching in $O(\log{\!(n)}/\epsilon)$ passes. This matches the performance of state-of-the-art "$\epsilon$-efficient" algorithms -- the ones with much better dependence on $\epsilon$ albeit with some mild dependence on $n$ -- while being considerably simpler.
  The algorithm relies on a direct application of the multiplicative weight update method with a self-contained primal-dual analysis that can be of independent interest. To show case this, we use the same ideas, alongside standard tools from matching theory, to present an equally simple semi-streaming algorithm for $(1-\epsilon)$-approximation of weighted matchings in general (not necessarily bipartite) graphs, again in $O(\log{\!(n)}/\epsilon)$ passes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.02968v4</guid>
      <category>cs.DS</category>
      <category>cs.DC</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.46298/theoretics.25.16</arxiv:DOI>
      <arxiv:journal_reference>TheoretiCS, Volume 4 (2025), Article 16, 1-25</arxiv:journal_reference>
      <dc:creator>Sepehr Assadi</dc:creator>
    </item>
    <item>
      <title>Advancing Quantum State Preparation Using Decision Diagram with Local Invertible Maps</title>
      <link>https://arxiv.org/abs/2507.17170</link>
      <description>arXiv:2507.17170v2 Announce Type: replace 
Abstract: Quantum state preparation (QSP) is a fundamental task in quantum computing and quantum information processing. It is critical to the execution of many quantum algorithms, including those in quantum machine learning. In this paper, we propose a family of efficient QSP algorithms tailored to different numbers of available ancilla qubits - ranging from no ancilla qubits, to a single ancilla qubit, to a sufficiently large number of ancilla qubits. Our approach exploits the power of Local Invertible Map Tensor Decision Diagrams (LimTDDs) - a highly compact representation of quantum states that combines tensor networks and decision diagrams to reduce quantum circuit complexity. Extensive experiments demonstrate that our methods significantly outperform existing approaches and exhibit better scalability for large-scale quantum states, both in terms of runtime and gate complexity. Furthermore, our method shows exponential improvement in best-case scenarios.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.17170v2</guid>
      <category>cs.DS</category>
      <category>quant-ph</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Xin Hong, Aochu Dai, Chenjian Li, Sanjiang Li, Shenggang Ying, Mingsheng Ying</dc:creator>
    </item>
    <item>
      <title>Settling Weighted Token Swapping up to Algorithmic Barriers</title>
      <link>https://arxiv.org/abs/2507.22450</link>
      <description>arXiv:2507.22450v2 Announce Type: replace 
Abstract: We study the weighted token swapping problem, in which we are given a graph on $n$ vertices, $n$ weighted tokens, an initial assignment of one token to each vertex, and a final assignment of one token to each vertex. The goal is to find a minimum-cost sequence of swaps of adjacent tokens to reach the final assignment from the initial assignment, where the cost is the sum over all swaps of the sum of the weights of the two swapped tokens. Unweighted token swapping has been extensively studied: it is NP-hard to approximate to a factor better than $14/13$, and there is a polynomial-time 4-approximation, along with a tight "barrier" result showing that the class of locally optimal algorithms cannot achieve a ratio better than 4. For trees, the problem remains NP-hard to solve exactly, and there is a polynomial-time 2-approximation, along with a tight barrier result showing that the class of $\ell$-straying algorithms cannot achieve a ratio better than 2. Weighted token swapping with $\{0,1\}$ weights is much harder to approximation: it is NP-hard to approximate even to a factor of $(1-\varepsilon) \cdot \ln n$ for any constant $\varepsilon&gt;0$. Restricting to positive weights, no approximation algorithms are known, and the only known lower bounds are those inherited directly from the unweighted version. We provide the first approximation algorithms for weighted token swapping on both trees and general graphs, along with tight barrier results. Letting $w$ and $W$ be the minimum and maximum token weights, our approximation ratio is $2+2W/w$ for general graphs and $1+W/w$ for trees.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.22450v2</guid>
      <category>cs.DS</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Nicole Wein, Guanyu Tony Zhang</dc:creator>
    </item>
    <item>
      <title>Optimal and Near-Optimal Adaptive Vector Quantization</title>
      <link>https://arxiv.org/abs/2402.03158</link>
      <description>arXiv:2402.03158v2 Announce Type: replace-cross 
Abstract: Quantization is a fundamental optimization for many machine-learning use cases, including compressing gradients, model weights and activations, and datasets. The most accurate form of quantization is \emph{adaptive}, where the error is minimized with respect to a given input, rather than optimizing for the worst case. However, optimal adaptive quantization methods are considered infeasible in terms of both their runtime and memory requirements.
  We revisit the Adaptive Vector Quantization (AVQ) problem and present algorithms that find optimal solutions with asymptotically improved time and space complexity. We also present an even faster near-optimal algorithm for large inputs. Our experiments show our algorithms may open the door to using AVQ more extensively in a variety of machine learning applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.03158v2</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <category>cs.IT</category>
      <category>cs.NI</category>
      <category>math.IT</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ran Ben-Basat, Yaniv Ben-Itzhak, Michael Mitzenmacher, Shay Vargaftik</dc:creator>
    </item>
    <item>
      <title>Graph Reconstruction from Noisy Random Subgraphs</title>
      <link>https://arxiv.org/abs/2405.04261</link>
      <description>arXiv:2405.04261v2 Announce Type: replace-cross 
Abstract: We consider the problem of reconstructing an undirected graph $G$ on $n$ vertices given multiple random noisy subgraphs or "traces". Specifically, a trace is generated by sampling each vertex with probability $p_v$, then taking the resulting induced subgraph on the sampled vertices, and then adding noise in the form of either (a) deleting each edge in the subgraph with probability $1-p_e$, or (b) deleting each edge with probability $f_e$ and transforming a non-edge into an edge with probability $f_e$. We show that, under mild assumptions on $p_v$, $p_e$ and $f_e$, if $G$ is selected uniformly at random, then $O(p_e^{-1} p_v^{-2} \log n)$ or $O((f_e-1/2)^{-2} p_v^{-2} \log n)$ traces suffice to reconstruct $G$ with high probability. In contrast, if $G$ is arbitrary, then $\exp(\Omega(n))$ traces are necessary even when $p_v=1, p_e=1/2$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.04261v2</guid>
      <category>cs.IT</category>
      <category>cs.DS</category>
      <category>math.IT</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1109/ISIT57864.2024.10619491</arxiv:DOI>
      <arxiv:journal_reference>2024 IEEE International Symposium on Information Theory (ISIT), Athens, Greece, 2024, pp. 3462-3467</arxiv:journal_reference>
      <dc:creator>Andrew McGregor, Rik Sengupta</dc:creator>
    </item>
    <item>
      <title>Computational Verification of the Buratti--Horak--Rosa Conjecture for Small Integers and Inductive Approaches</title>
      <link>https://arxiv.org/abs/2507.00059</link>
      <description>arXiv:2507.00059v4 Announce Type: replace-cross 
Abstract: This paper presents a comprehensive computational approach to verify and inductively construct Hamiltonian paths for the Buratti--Horak--Rosa (BHR) Conjecture. The conjecture posits that for any multiset $L$ of $p-1$ positive integers not exceeding $\lfloor p/2 \rfloor$, there exists a Hamiltonian path in the complete graph $K_p$ with vertex-set $\{0, 1, \dots, p-1\}$ whose edge lengths (under the cyclic metric) match $L$, if and only if for every divisor $d$ of $p$, the number of multiples of $d$ appearing in $L$ is at most $p - d$.
  Building upon prior computational work by Mariusz Meszka, which verified the conjecture for all primes up to $p=23$, our Python program extends this verification significantly. We approach the problem by systematically generating frequency partitions (FPs) of edge lengths and employing a recursive backtracking algorithm. We report successful computational verification for all frequency partitions for integers $p &lt; 32$, specifically presenting results for $p=31$ and a composite $p=26$. For the composite number $p=30$, the Python code took approximately 11 hours to verify on a Lenovo laptop. For $p=16$, $167,898$ valid multisets were processed, taking around 20 hours on Google Colab Pro+.
  Furthermore, we introduce and implement two constructive, inductive strategies for building Hamiltonian paths: (1) increasing the multiplicity of an existing edge length, and (2) adding a new edge length. These methods, supported by a reuse-insertion heuristic and backtracking search, demonstrate successful constructions for evolving FPs up to $p=40$. Through these empirical tests and performance metrics, we provide strong computational evidence for the validity of the BHR conjecture within the scope tested, and outline the scalability of our approach for higher integer values.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.00059v4</guid>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ranjan N Naik</dc:creator>
    </item>
  </channel>
</rss>
