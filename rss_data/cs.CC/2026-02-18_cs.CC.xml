<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CC</link>
    <description>cs.CC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Feb 2026 05:00:22 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Efficient quantum circuits for high-dimensional representations of SU(n) and Ramanujan quantum expanders</title>
      <link>https://arxiv.org/abs/2602.15180</link>
      <description>arXiv:2602.15180v1 Announce Type: cross 
Abstract: We present efficient quantum circuits that implement high-dimensional unitary irreducible representations (irreps) of $SU(n)$, where $n \ge 2$ is constant. For dimension $N$ and error $\epsilon$, the number of quantum gates in our circuits is polynomial in $\log(N)$ and $\log(1/\epsilon)$. Our construction relies on the Jordan-Schwinger representation, which allows us to realize irreps of $SU(n)$ in the Hilbert space of $n$ quantum harmonic oscillators. Together with a recent efficient quantum Hermite transform, which allows us to map the computational basis states to the eigenstates of the quantum harmonic oscillator, this allows us to implement these irreps efficiently. Our quantum circuits can be used to construct explicit Ramanujan quantum expanders, a longstanding open problem. They can also be used to fast-forward the evolution of certain quantum systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.15180v1</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Vishnu Iyer, Siddhartha Jain, Stephen Jordan, Rolando Somma</dc:creator>
    </item>
    <item>
      <title>Polynomial-time isomorphism test for $k$-generated extensions of abelian groups</title>
      <link>https://arxiv.org/abs/2602.15497</link>
      <description>arXiv:2602.15497v1 Announce Type: cross 
Abstract: The group isomorphism problem asks whether two finite groups given by their Cayley tables are isomorphic or not. Although there are polynomial-time algorithms for some specific group classes, the best known algorithm for testing isomorphism of arbitrary groups of order $ n $ has time complexity $ n^{O(\log n)} $. We consider the group isomorphism problem for some extensions of abelian groups by $ k $-generated groups for bounded $ k $. In particular, we prove that one can decide isomorphism of abelian-by-cyclic extensions in polynomial time, generalizing a 2009 result of Le Gall for coprime extensions. As another application, we give a polynomial-time isomorphism test for abelian-by-simple group extensions, generalizing a 2017 result of Grochow and Qiao for central extensions. The main novelty of the proof is a polynomial-time algorithm for computing the unit group of a finite ring, which might be of independent interest.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.15497v1</guid>
      <category>math.GR</category>
      <category>cs.CC</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Saveliy V. Skresanov</dc:creator>
    </item>
    <item>
      <title>How Global Calibration Strengthens Multiaccuracy</title>
      <link>https://arxiv.org/abs/2504.15206</link>
      <description>arXiv:2504.15206v2 Announce Type: replace-cross 
Abstract: Multiaccuracy and multicalibration are multigroup fairness notions for prediction that have found numerous applications in learning and computational complexity. They can be achieved from a single learning primitive: weak agnostic learning. Here we investigate the power of multiaccuracy as a learning primitive, both with and without the additional assumption of calibration. We find that multiaccuracy in itself is rather weak, but that the addition of global calibration (this notion is called calibrated multiaccuracy) boosts its power substantially, enough to recover implications that were previously known only assuming the stronger notion of multicalibration.
  We give evidence that multiaccuracy might not be as powerful as standard weak agnostic learning, by showing that there is no way to post-process a multiaccurate predictor to get a weak learner, even assuming the best hypothesis has correlation $1/2$. Rather, we show that it yields a restricted form of weak agnostic learning, which requires some concept in the class to have correlation greater than $1/2$ with the labels. However, by also requiring the predictor to be calibrated, we recover not just weak, but strong agnostic learning.
  A similar picture emerges when we consider the derivation of hardcore measures from predictors satisfying multigroup fairness notions. On the one hand, while multiaccuracy only yields hardcore measures of density half the optimal, we show that (a weighted version of) calibrated multiaccuracy achieves optimal density.
  Our results yield new insights into the complementary roles played by multiaccuracy and calibration in each setting. They shed light on why multiaccuracy and global calibration, although not particularly powerful by themselves, together yield considerably stronger notions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.15206v2</guid>
      <category>cs.LG</category>
      <category>cs.CC</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>S\'ilvia Casacuberta, Parikshit Gopalan, Varun Kanade, Omer Reingold</dc:creator>
    </item>
    <item>
      <title>Learning depth-3 circuits via quantum agnostic boosting</title>
      <link>https://arxiv.org/abs/2509.14461</link>
      <description>arXiv:2509.14461v3 Announce Type: replace-cross 
Abstract: We initiate the study of quantum agnostic learning of phase states with respect to a function class $\mathsf{C}\subseteq \{c:\{0,1\}^n\rightarrow \{0,1\}\}$: given copies of an unknown $n$-qubit state $|\psi\rangle$ which has fidelity $\textsf{opt}$ with a phase state $|\phi_c\rangle=\frac{1}{\sqrt{2^n}}\sum_{x\in \{0,1\}^n}(-1)^{c(x)}|x\rangle$ for some $c\in \mathsf{C}$, output $|\phi\rangle$ which has fidelity $|\langle \phi | \psi \rangle|^2 \geq \textsf{opt}-\varepsilon$. To this end, we give agnostic learning protocols for the following classes: (i) Size-$t$ decision trees which runs in time $\textsf{poly}(n,t,1/\varepsilon)$. This also implies $k$-juntas can be agnostically learned in time $\textsf{poly}(n,2^k,1/\varepsilon)$. (ii) $s$-term DNF formulas in time $\textsf{poly}(n,(s/\varepsilon)^{\log \log (s/\varepsilon) \cdot \log(1/\varepsilon)})$.
  Our main technical contribution is a quantum agnostic boosting protocol which converts a weak agnostic learner, which outputs a parity state $|\phi\rangle$ such that $|\langle \phi|\psi\rangle|^2\geq \textsf{opt}/\textsf{poly}(n)$, into a strong learner which outputs a superposition of parity states $|\phi'\rangle$ such that $|\langle \phi'|\psi\rangle|^2\geq \textsf{opt} - \varepsilon$.
  Using quantum agnostic boosting, we obtain a $n^{O(\log(n/\varepsilon) \cdot \log \log n)}$-time algorithm for $\varepsilon$-learning $\textsf{poly}(n)$-sized depth-$3$ circuits (consisting of $\textsf{AND}$, $\textsf{OR}$, $\textsf{NOT}$ gates) in the uniform $\textsf{PAC}$ model given quantum examples. Classically, obtaining an algorithm with a similar complexity has been an open question in the $\textsf{PAC}$ model and our work answers this given quantum examples.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.14461v3</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <category>cs.LG</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Srinivasan Arunachalam, Arkopal Dutt, Alexandru Gheorghiu, Michael de Oliveira</dc:creator>
    </item>
    <item>
      <title>On the $\Sigma^0_1$-Completeness of Cubic Diophantine Systems and their Consequences for Equations</title>
      <link>https://arxiv.org/abs/2510.00759</link>
      <description>arXiv:2510.00759v5 Announce Type: replace-cross 
Abstract: We prove that $\mathrm{H}\mathbb{N}(3,n)=\mathrm{U}$ for some fixed $n$. The core result is a uniform primitive recursive compiler from sentence codes to finite cubic Diophantine systems over $\mathbb{N}$, such that arithmetic theoremhood is equivalent to cubic solvability on the compiler image. The translation is explicit: finite proof traces are arithmetized, local syntactic and inference checks are compiled to quadratic constraints, and one guard gadget $u = 1+v^2, u\cdot E = 0$ provides the unique degree escalation from $2$ to $3$ while preserving solvability. The construction is mechanized in $\textsf{Rocq}$ and certified in the Calculus of Inductive Constructions, including uniform computability, checker--constraint equivalence, and a global degree-$3$ bound for emitted systems. From this certified core, undecidability is obtained by a classical fixed-point Diagonal Argument: any total correct decider for cubic satisfiability computes a mirror cubic instance on which it fails. Consequently cubic satisfiability is $\Sigma^0_1$-complete, and in particular there is no total correct procedure deciding all degree-$3$ Diophantine instances.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.00759v5</guid>
      <category>math.LO</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Milan Rosko</dc:creator>
    </item>
    <item>
      <title>On Minimal Achievable Quotas in Multiwinner Voting</title>
      <link>https://arxiv.org/abs/2510.19620</link>
      <description>arXiv:2510.19620v2 Announce Type: replace-cross 
Abstract: Justified representation (JR) and extended justified representation (EJR) are well-established proportionality axioms in approval-based multiwinner voting. Both axioms are always satisfiable, but they rely on a fixed quota (typically Hare or Droop), with the Droop quota being the smallest one that guarantees existence across all instances. With this in mind, we take a step beyond the fixed-quota paradigm by studying instance-dependent proportionality notions. More specifically, we minimize the quota requirements for JR and EJR using the parameter $\alpha$. We demonstrate that all commonly studied voting rules can have an additive gap to the optimum of $\frac{k^2}{(k+1)^2}$. Moreover, we examine the computational aspects of our instance-dependent quota and prove that determining the optimal value of $\alpha$ for a given approval profile that allows some committee to satisfy $\alpha$-JR is NP-complete. To address this, we introduce an integer linear programming (ILP) formulation for computing committees that satisfy $\alpha$-JR, and we provide positive computational results in the voter interval (VI) and candidate interval (CI) domains.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.19620v2</guid>
      <category>cs.GT</category>
      <category>cs.CC</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Patrick Becker, Fabian Frank</dc:creator>
    </item>
    <item>
      <title>Is nasty noise actually harder than malicious noise?</title>
      <link>https://arxiv.org/abs/2511.09763</link>
      <description>arXiv:2511.09763v2 Announce Type: replace-cross 
Abstract: We consider the relative abilities and limitations of computationally efficient algorithms for learning in the presence of noise, under two well-studied and challenging adversarial noise models for learning Boolean functions: malicious noise, in which an adversary can arbitrarily corrupt a random subset of examples given to the learner; and nasty noise, in which an adversary can arbitrarily corrupt an adversarially chosen subset of examples given to the learner.
  We consider both the distribution-independent and fixed-distribution settings. Our main results highlight a dramatic difference between these two settings: For distribution-independent learning, we prove a strong equivalence between the two noise models: If a class ${\cal C}$ of functions is efficiently learnable in the presence of $\eta$-rate malicious noise, then it is also efficiently learnable in the presence of $\eta$-rate nasty noise. In sharp contrast, for the fixed-distribution setting we show an arbitrarily large separation: Under a standard cryptographic assumption, for any arbitrarily large value $r$ there exists a concept class for which there is a ratio of $r$ between the rate $\eta_{malicious}$ of malicious noise that polynomial-time learning algorithms can tolerate, versus the rate $\eta_{nasty}$ of nasty noise that such learning algorithms can tolerate.
  To offset the negative result for the fixed-distribution setting, we define a broad and natural class of algorithms, namely those that ignore contradictory examples (ICE). We show that for these algorithms, malicious noise and nasty noise are equivalent up to a factor of two in the noise rate: Any efficient ICE learner that succeeds with $\eta$-rate malicious noise can be converted to an efficient learner that succeeds with $\eta/2$-rate nasty noise. We further show that the above factor of two is necessary, again under a standard cryptographic assumption.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.09763v2</guid>
      <category>cs.LG</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Guy Blanc, Yizhi Huang, Tal Malkin, Rocco A. Servedio</dc:creator>
    </item>
  </channel>
</rss>
