<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Feb 2026 05:00:38 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>A Formal Framework for the Explanation of Finite Automata Decisions</title>
      <link>https://arxiv.org/abs/2602.13351</link>
      <description>arXiv:2602.13351v1 Announce Type: new 
Abstract: Finite automata (FA) are a fundamental computational abstraction that is widely used in practice for various tasks in computer science, linguistics, biology, electrical engineering, and artificial intelligence. Given an input word, an FA maps the word to a result, in the simple case "accept" or "reject", but in general to one of a finite set of results. A question that then arises is: why? Another question is: how can we modify the input word so that it is no longer accepted? One may think that the automaton itself is an adequate explanation of its behaviour, but automata can be very complex and difficult to make sense of directly. In this work, we investigate how to explain the behaviour of an FA on an input word in terms of the word's characters. In particular, we are interested in minimal explanations: what is the minimal set of input characters that explains the result, and what are the minimal changes needed to alter the result? In this paper, we propose an efficient method to determine all minimal explanations for the behaviour of an FA on a particular word. This allows us to give unbiased explanations about which input features are responsible for the result. Experiments show that our approach scales well, even when the underlying problem is challenging.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.13351v1</guid>
      <category>cs.FL</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jaime Cuartas Granada, Alexey Ignatiev, Peter J. Stuckey</dc:creator>
    </item>
    <item>
      <title>Geometric Characterization of Context-Free Intersections via the Inner Segment Dichotomy</title>
      <link>https://arxiv.org/abs/2602.14722</link>
      <description>arXiv:2602.14722v1 Announce Type: new 
Abstract: The intersection of two context-free languages is not generally context-free, but no geometric criterion has characterized when it remains so. The crossing gap (max(i'-i, j'-j) for two crossing push-pop arcs) is the natural candidate. We refute this: we exhibit CFLs whose intersection is CFL despite unbounded-gap crossings. The governing quantity is the inner segment measure: for crossing arcs inducing a decomposition w = P1 P2 P3 P4, it is max(|P2|,|P3|), the length of the longer inner segment between interleaved crossing endpoints. We prove a dichotomy for this measure: bounded inner segments imply context-freeness via a finite buffer construction; growing inner segments with pump-sensitive linkages imply non-context-freeness. The inner segment concept applies to all CFL intersections; the strictness of the resulting characterization depends on the language class. For block-counting CFLs (languages requiring equality among designated pairs of block lengths), the dichotomy is complete: the intersection is CFL if and only if the combined arcs are jointly well-nested. For general CFLs, the CFL direction is unconditional; the non-CFL direction requires pump-sensitive linkages whose necessity is the main open problem, reducing the general CFL intersection problem to a specific property of pump-sensitive decompositions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.14722v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jorge Miguel Silva</dc:creator>
    </item>
    <item>
      <title>Constant-Time Dynamic Enumeration of Word Infixes in a Regular Language</title>
      <link>https://arxiv.org/abs/2602.14748</link>
      <description>arXiv:2602.14748v1 Announce Type: new 
Abstract: For a fixed regular language $L$, the enumeration of $L$-infixes is the following task: we are given an input word $w = a_1 \cdots a_n$ and we must enumerate the infixes of $w$ that belong to $L$, i.e., the pairs $i \leq j$ such that $a_i \cdots a_j \in L$. We are interested in dynamic enumeration of $L$-infixes, where we must additionally support letter substitution updates on $w$ (e.g., "replace the $i$-th letter of $w$ by a letter $a$"). Each update changes the set of infixes to enumerate, and resets the enumeration state.
  We study for which regular languages $L$ we can perform dynamic enumeration of $L$-infixes in constant delay (i.e., the next infix is always produced in constant time) and constant additional memory throughout the enumeration, while supporting each update in constant time.
  We show that, for languages $L$ with a neutral letter, if the language $L$ belongs to the class ZG and is extensible (i.e., if $u \in L$ and $u$ is a factor of $v$ then $v \in L$), then dynamic enumeration of $L$-infixes can be achieved with a simple algorithm that ensures constant-time updates and constant delay, but not constant additional memory. Our main contribution is then to show an algorithm that additionally uses only constant additional memory, and applies to a more general class of semi-extensible ZG languages for which we give several equivalent characterizations. We further discuss whether our results can be generalized to larger language classes and show some (conditional) lower bounds.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.14748v1</guid>
      <category>cs.FL</category>
      <category>cs.DS</category>
      <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Antoine Amarilli, Sven Dziadek, Luc Segoufin</dc:creator>
    </item>
    <item>
      <title>Computability of Agentic Systems</title>
      <link>https://arxiv.org/abs/2602.13222</link>
      <description>arXiv:2602.13222v1 Announce Type: cross 
Abstract: This paper introduces the Quest Graph, a formal framework for analyzing the capabilities of agentic systems with finite context. We define abstractions that model common reasoning techniques and establish their computational power: the base Quest Graph is equivalent to an unrestricted Turing machine; the forward-only Finite Quest Decision Process (FQDP), despite its wide use, is only equivalent to a pushdown automaton (context-free); and the Reference-Augmented QDP (RQDP) regains Turing completeness only when stateful queries are allowed.
  Since computability affects efficiency, we then analyze the theoretical efficiency of each model by simulating task dependencies in computation graphs. We show that this computational hierarchy translates to concrete performance trade-offs: reference-augmented (Turing-complete) systems can be exponentially more efficient at simulating complex graphs than their non-augmented (context-free) counterparts. This work provides a formal methodology for classifying and understanding the fundamental capabilities of agentic systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.13222v1</guid>
      <category>cs.CC</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Chatavut Viriyasuthee</dc:creator>
    </item>
    <item>
      <title>Automaticity of spacetime diagrams generated by cellular automata on commutative monoids</title>
      <link>https://arxiv.org/abs/2207.13062</link>
      <description>arXiv:2207.13062v4 Announce Type: replace-cross 
Abstract: It is well-known that the spacetime diagrams of some cellular automata have a fractal structure: for instance Pascal's triangle modulo 2 generates a Sierpinski triangle. It has been shown that such patterns can occur when the alphabet is endowed with the structure of an Abelian group, provided the cellular automaton is a morphism with respect to this structure and the initial configuration has finite support. The spacetime diagram then has a property related to k-automaticity. We show that these conditions can be relaxed: the Abelian group can be a commutative monoid, the initial configuration can be k-automatic, and the spacetime diagrams still exhibit the same regularity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2207.13062v4</guid>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <category>math.DS</category>
      <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Vincent Nesme</dc:creator>
    </item>
    <item>
      <title>Formalization of Harder-Narasimhan theory</title>
      <link>https://arxiv.org/abs/2509.19632</link>
      <description>arXiv:2509.19632v3 Announce Type: replace-cross 
Abstract: The Harder-Narasimhan theory provides a canonical filtration of a vector bundle on a projective curve whose successive quotients are semistable with strictly decreasing slopes. In this article, we present the formalization of Harder-Narasimhan theory in the proof assistant Lean 4 with Mathlib. This formalization is based on a recent approach of Harder-Narasimhan theory by Chen and Jeannin, which reinterprets the theory in order-theoretic terms and avoids the classical dependence on algebraic geometry. As an application, we formalize the uniqueness of coprimary filtration of a finitely generated module over a noetherian ring, and the existence of the Jordan-H\"older filtration of a semistable Harder-Narasimhan game.
  Code available at: https://github.com/YijunYuan/HarderNarasimhan</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.19632v3</guid>
      <category>math.AG</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>math.NT</category>
      <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yijun Yuan</dc:creator>
    </item>
    <item>
      <title>Implementation of Polynomial NP-Complete Algorithms Based on the NP Verifier Simulation Framework</title>
      <link>https://arxiv.org/abs/2602.10991</link>
      <description>arXiv:2602.10991v2 Announce Type: replace-cross 
Abstract: While prior work established a verifier-based polynomial-time framework for NP, explicit deterministic machines for concrete NP-complete problems have remained elusive. In this paper, we construct fully specified deterministic Turing Machines (DTMs) for \textsc{SAT} and \textsc{Subset-Sum} within an improved NP verifier simulation framework. A key contribution of this work is the development of a functional implementation that bridges the gap between theoretical proofs and executable software. Our improved feasible-graph construction yields a genuine reduction in the asymptotic polynomial degree, while optimized edge-extension mechanisms significantly improve practical execution speed. We show that these machines generate valid witnesses, extending the framework to deterministic \textsc{FNP} computation without increasing complexity. The complete Python implementation behaves in accordance with the predicted polynomial-time bounds, and the source code along with sample instances are available in a public online repository.</description>
      <guid isPermaLink="false">oai:arXiv.org:2602.10991v2</guid>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <pubDate>Tue, 17 Feb 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Changryeol Lee</dc:creator>
    </item>
  </channel>
</rss>
