<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 29 Mar 2024 04:00:11 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 29 Mar 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Modelling the Raft Distributed Consensus Protocol in mCRL2</title>
      <link>https://arxiv.org/abs/2403.18916</link>
      <description>arXiv:2403.18916v1 Announce Type: new 
Abstract: The consensus problem is a fundamental problem in distributed systems. It involves a set of actors, or entities, that need to agree on some values or decisions. The Raft algorithm is a solution to the consensus problem that has gained widespread popularity as an easy-to-understand and implement alternative to Lamport's Paxos algorithm. In this paper we discuss a formalisation of the Raft algorithm and its associated correctness properties in the mCRL2 specification language.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.18916v1</guid>
      <category>cs.LO</category>
      <category>cs.DC</category>
      <category>cs.SE</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.399.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 399, 2024, pp. 7-20</arxiv:journal_reference>
      <dc:creator>Parth Bora (Eindhoven University of Technology), Pham Duc Minh (Eindhoven University of Technology), Tim A. C. Willemse (Eindhoven University of Technology)</dc:creator>
    </item>
    <item>
      <title>Algebraic Reasoning Meets Automata in Solving Linear Integer Arithmetic</title>
      <link>https://arxiv.org/abs/2403.18995</link>
      <description>arXiv:2403.18995v1 Announce Type: new 
Abstract: We present a new angle on solving quantified linear integer arithmetic based on combining the automata-based approach, where numbers are understood as bitvectors, with ideas from (nowadays prevalent) algebraic approaches, which work directly with numbers. This combination is enabled by a fine-grained version of the duality between automata and arithmetic formulae. In particular, we employ a construction where states of automaton are obtained as derivatives of arithmetic formulae: then every state corresponds to a formula. Optimizations based on techniques and ideas transferred from the world of algebraic methods are used on thousands of automata states, which dramatically amplifies their effect. The merit of this combination of automata with algebraic methods is demonstrated by our prototype implementation being competitive to and even superior to state-of-the-art SMT solvers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.18995v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Peter Habermehl, Michal He\v{c}ko, Vojt\v{e}ch Havlena, Luk\'a\v{s} Hol\'ik, Ond\v{r}ej Leng\'al</dc:creator>
    </item>
    <item>
      <title>Deciding Boolean Separation Logic via Small Models (Technical Report)</title>
      <link>https://arxiv.org/abs/2403.18999</link>
      <description>arXiv:2403.18999v1 Announce Type: new 
Abstract: We present a novel decision procedure for a fragment of separation logic (SL) with arbitrary nesting of separating conjunctions with boolean conjunctions, disjunctions, and guarded negations together with a support for the most common variants of linked lists. Our method is based on a model-based translation to SMT for which we introduce several optimisations$\unicode{x2013}$the most important of them is based on bounding the size of predicate instantiations within models of larger formulae, which leads to a much more efficient translation of SL formulae to SMT. Through a series of experiments, we show that, on the frequently used symbolic heap fragment, our decision procedure is competitive with other existing approaches, and it can outperform them outside the symbolic heap fragment. Moreover, our decision procedure can also handle some formulae for which no decision procedure has been implemented so far.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.18999v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tom\'a\v{s} Dac\'ik, Adam Rogalewicz, Tom\'a\v{s} Vojnar, Florian Zuleger</dc:creator>
    </item>
    <item>
      <title>EDA-Driven Preprocessing for SAT Solving</title>
      <link>https://arxiv.org/abs/2403.19446</link>
      <description>arXiv:2403.19446v1 Announce Type: new 
Abstract: Effective formulation of problems into Conjunctive Normal Form (CNF) is critical in modern Boolean Satisfiability (SAT) solving for optimizing solver performance. Addressing the limitations of existing methods, our Electronic Design Automation (EDA)-driven preprocessing framework introduces a novel methodology for preparing SAT instances, leveraging both circuit and CNF formats for enhanced flexibility and efficiency. Central to our approach is the integration of a new logic synthesis technique, guided by a reinforcement learning agent, and a novel cost-customized LUT mapping strategy, enabling efficient handling of diverse SAT challenges. By transforming the SAT competition benchmarks into circuit instances, our framework demonstrates substantial performance improvements, as evidenced by a 52.42% reduction on average compared to solving directly. Moreover, our framework achieves a remarkable 96.14% runtime reduction on average for a set of logic equivalence checking problems that exhibit inherent circuit structures. These results highlight the effectiveness and versatility of our approach in handling both CNF and circuit instances. The code is available at https://github.com/cure-lab/EDA4SAT.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.19446v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Zhengyuan Shi, Tiebing Tang, Sadaf Khan, Hui-Ling Zhen, Mingxuan Yuan, Zhufei Chu, Qiang Xu</dc:creator>
    </item>
    <item>
      <title>Linear Programming in Isabelle/HOL</title>
      <link>https://arxiv.org/abs/2403.19639</link>
      <description>arXiv:2403.19639v1 Announce Type: new 
Abstract: Linear programming describes the problem of optimising a linear objective function over a set of constraints on its variables. In this paper we present a solver for linear programs implemented in the proof assistant Isabelle/HOL. This allows formally proving its soundness, termination, and other properties. We base these results on a previous formalisation of the simplex algorithm which does not take optimisation problems into account. Using the weak duality theorem of linear programming we obtain an algorithm for solving linear programs. Using Isabelle's code generation mechanism we can generate an external solver for linear programs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.19639v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Julian Parsert</dc:creator>
    </item>
    <item>
      <title>Logic and Languages of Higher-Dimensional Automata</title>
      <link>https://arxiv.org/abs/2403.19526</link>
      <description>arXiv:2403.19526v1 Announce Type: cross 
Abstract: In this paper we study finite higher-dimensional automata (HDAs) from the logical point of view. Languages of HDAs are sets of finite bounded-width interval pomsets with interfaces (iiPoms&lt;=k) closed under order extension. We prove that languages of HDAs are MSO-definable. For the converse, we show that the order extensions of MSO-definable sets of iiPoms&lt;=k are languages of HDAs. As a consequence, unlike the case of all pomsets, order extension of MSO-definable sets of iiPoms&lt;=k is also MSO-definable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.19526v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Amazigh Amrane, Hugo Bazille, Uli Fahrenberg, Marie Fortin</dc:creator>
    </item>
    <item>
      <title>Dependence Logics in Temporal Settings</title>
      <link>https://arxiv.org/abs/2204.07839</link>
      <description>arXiv:2204.07839v2 Announce Type: replace 
Abstract: Many forms of dependence manifest themselves over time, with behavior of variables in dynamical systems as a paradigmatic example. This paper studies temporal dependence in dynamical systems from a logical perspective, by enriching a minimal modal base logic of static functional dependencies. We first introduce a logic for dynamical systems featuring temporalized variables, provide a complete axiomatic proof calculus, and show that its satisfiability problem is decidable. Then, to capture explicit reasoning about dynamic transition functions, we enhance the framework with function symbols and term identity. Next we combine temporalized variables with a modality for next-time truth from standard temporal logic, where modal correspondence analysis reveals the principles needed for a complete and decidable logic of timed dynamical systems supporting reductions between the two ways of referring to time. Our final result is an axiomatization of a general decidable logic of dependencies in arbitrary dynamical systems. We conclude with a brief outlook on how the systems introduced here mesh with richer temporal logics of system behavior, and with dynamic topological logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2204.07839v2</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Alexandru Baltag, Johan van Benthem, Dazhu Li</dc:creator>
    </item>
    <item>
      <title>Can Language Models Pretend Solvers? Logic Code Simulation with LLMs</title>
      <link>https://arxiv.org/abs/2403.16097</link>
      <description>arXiv:2403.16097v2 Announce Type: replace-cross 
Abstract: Transformer-based large language models (LLMs) have demonstrated significant potential in addressing logic problems. capitalizing on the great capabilities of LLMs for code-related activities, several frameworks leveraging logical solvers for logic reasoning have been proposed recently. While existing research predominantly focuses on viewing LLMs as natural language logic solvers or translators, their roles as logic code interpreters and executors have received limited attention. This study delves into a novel aspect, namely logic code simulation, which forces LLMs to emulate logical solvers in predicting the results of logical programs. To further investigate this novel task, we formulate our three research questions: Can LLMs efficiently simulate the outputs of logic codes? What strength arises along with logic code simulation? And what pitfalls? To address these inquiries, we curate three novel datasets tailored for the logic code simulation task and undertake thorough experiments to establish the baseline performance of LLMs in code simulation. Subsequently, we introduce a pioneering LLM-based code simulation technique, Dual Chains of Logic (DCoL). This technique advocates a dual-path thinking approach for LLMs, which has demonstrated state-of-the-art performance compared to other LLM prompt strategies, achieving a notable improvement in accuracy by 7.06% with GPT-4-Turbo.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.16097v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Minyu Chen, Guoqiang Li, Ling-I Wu, Ruibang Liu, Yuxin Su, Xi Chang, Jianxin Xue</dc:creator>
    </item>
    <item>
      <title>Chase Termination Beyond Polynomial Time</title>
      <link>https://arxiv.org/abs/2403.16712</link>
      <description>arXiv:2403.16712v2 Announce Type: replace-cross 
Abstract: The chase is a widely implemented approach to reason with tuple-generating dependencies (tgds), used in data exchange, data integration, and ontology-based query answering. However, it is merely a semi-decision procedure, which may fail to terminate. Many decidable conditions have been proposed for tgds to ensure chase termination, typically by forbidding some kind of "cycle" in the chase process. We propose a new criterion that explicitly allows some such cycles, and yet ensures termination of the standard chase under reasonable conditions. This leads to new decidable fragments of tgds that are not only syntactically more general but also strictly more expressive than the fragments defined by prior acyclicity conditions. Indeed, while known terminating fragments are restricted to PTime data complexity, our conditions yield decidable languages for any k-ExpTime. We further refine our syntactic conditions to obtain fragments of tgds for which an optimised chase procedure decides query entailment in PSpace or k-ExpSpace, respectively.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.16712v2</guid>
      <category>cs.DB</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Philipp Hanisch, Markus Kr\"otzsch</dc:creator>
    </item>
  </channel>
</rss>
