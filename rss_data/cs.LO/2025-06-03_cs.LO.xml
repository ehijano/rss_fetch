<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Jun 2025 01:54:03 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Computing Witnesses Using the SCAN Algorithm (Extended Preprint)</title>
      <link>https://arxiv.org/abs/2506.00163</link>
      <description>arXiv:2506.00163v1 Announce Type: new 
Abstract: Second-order quantifier-elimination is the problem of finding, given a formula with second-order quantifiers, a logically equivalent first-order formula. While such formulas are not computable in general, there are practical algorithms and subclasses with applications throughout computational logic. One of the most prominent algorithms for second-order quantifier elimination is the SCAN algorithm which is based on saturation theorem proving. In this paper we show how the SCAN algorithm on clause sets can be extended to solve a more general problem: namely, finding an instance of the second-order quantifiers that results in a logically equivalent first-order formula. In addition we provide a prototype implementation of the proposed method. This work paves the way for applying the SCAN algorithm to new problems in application domains such as modal correspondence theory, knowledge representation, and verification.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.00163v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Fabian Achammer, Stefan Hetzl, Renate A. Schmidt</dc:creator>
    </item>
    <item>
      <title>A Topological Semantics of Dialogue: Nerve Structures and Logical Extraction</title>
      <link>https://arxiv.org/abs/2506.00615</link>
      <description>arXiv:2506.00615v1 Announce Type: new 
Abstract: We introduce a concise, topologically-motivated semantics for finite dialogues by mapping each utterance to an open set in a fixed semantic space, building the corresponding nerve complex of joint satisfiability, and extracting fundamental combinatorial invariants:
  1. The negative nerve, which enumerates all finite collections of utterances whose
  opens have empty intersection, providing a straightforward criterion for merging
  separate transcripts without contradiction.
  2. The global interpretation subspace, the unique minimal open in which all asserted
  utterances hold simultaneously, enabling effective enumeration of all logical
  consequences of the entire dialogue.
  3. A practical demonstration in the Wolfram Language, with algorithms for constructing
  nerves, detecting inconsistencies, and computing the global interpretation, thereby
  illustrating computational feasibility.
  Our framework is grounded in classical duality and topological semantics (Stone duality, Priestley duality, Tarski's semantics, coherence-space methods, Scott domains, topos semantics, and homotopy type theory) while drawing on recent advances in topological data analysis and dialogue-based semantics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.00615v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>math.AT</category>
      <category>math.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andreu Ballus Santacana</dc:creator>
    </item>
    <item>
      <title>Thinking Out of the Box: Hybrid SAT Solving by Unconstrained Continuous Optimization</title>
      <link>https://arxiv.org/abs/2506.00674</link>
      <description>arXiv:2506.00674v1 Announce Type: new 
Abstract: The Boolean satisfiability (SAT) problem lies at the core of many applications in combinatorial optimization, software verification, cryptography, and machine learning. While state-of-the-art solvers have demonstrated high efficiency in handling conjunctive normal form (CNF) formulas, numerous applications require non-CNF (hybrid) constraints, such as XOR, cardinality, and Not-All-Equal constraints. Recent work leverages polynomial representations to represent such hybrid constraints, but it relies on box constraints that can limit the use of powerful unconstrained optimizers. In this paper, we propose unconstrained continuous optimization formulations for hybrid SAT solving by penalty terms. We provide theoretical insights into when these penalty terms are necessary and demonstrate empirically that unconstrained optimizers (e.g., Adam) can enhance SAT solving on hybrid benchmarks. Our results highlight the potential of combining continuous optimization and machine-learning-based methods for effective hybrid SAT solving.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.00674v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>math.OC</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Zhiwei Zhang, Samy Wu Fung, Anastasios Kyrillidis, Stanley Osher, Moshe Y. Vardi</dc:creator>
    </item>
    <item>
      <title>Efficient Model Checking for the Alternating-Time {\mu}-Calculus via Effectivity Frames</title>
      <link>https://arxiv.org/abs/2506.01010</link>
      <description>arXiv:2506.01010v1 Announce Type: new 
Abstract: The semantics of alternating-time temporal logic (ATL) and the more expressive alternating-time {\mu}-calculus (AMC) is standardly given in terms of concurrent game frames (CGF). The information required to interpret AMC formulas is equivalently represented in terms of effectivity frames in the sense of Pauly; in many cases, this representation is more compact than the corresponding CGF, and in principle allows for faster evaluation of coalitional modalities. In the present work, we investigate whether implementing a model checker based on effectivity frames leads to better performance in practice. We implement the translation from concurrent game frames to effectivity frames and analyse performance gains in model checking based on corresponding instantiations of a generic model checker for coalgebraic {\mu}-calculi, using dedicated benchmark series as well as random systems and formulas. In the process, we also compare performance to the state-of-the-art ATL model checkerMCMAS. Our results indicate that on large systems, the overhead involved in converting a CGF to an effectivity frame is often outweighed by the benefits in subsequent model checking.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.01010v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Hausmann, Merlin Humml, Simon Prucker, Lutz Schr\"oder</dc:creator>
    </item>
    <item>
      <title>Big Steps in Higher-Order Mathematical Operational Semantics</title>
      <link>https://arxiv.org/abs/2506.01076</link>
      <description>arXiv:2506.01076v1 Announce Type: new 
Abstract: Small-step and big-step operational semantics are two fundamental styles of structural operational semantics (SOS), extensively used in practice. The former one is more fine-grained and is usually regarded as primitive, as it only defines a one-step reduction relation between a given program and its direct descendant under an ambient evaluation strategy. The latter one implements, in a self-contained manner, such a strategy directly by relating a program to the net result of the evaluation process. The agreement between these two styles of semantics is one of the key pillars in operational reasoning on programs; however, such agreement is typically proven from scratch every time on a case-by-case basis. A general, abstract mathematical argument behind this agreement is up till now missing. We cope with this issue within the framework of higher-order mathematical operational semantics by providing an abstract categorical notion of big-step SOS, complementing the existing notion of abstract higher-order GSOS. Moreover, we introduce a general construction for deriving the former from the latter, and prove an abstract equivalence result between the two.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.01076v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sergey Goncharov, Pouya Partow, Stelios Tsampas</dc:creator>
    </item>
    <item>
      <title>A Decidable Bundled Fragment of First-Order Modal Logic Without Finite Model Property</title>
      <link>https://arxiv.org/abs/2506.01421</link>
      <description>arXiv:2506.01421v1 Announce Type: new 
Abstract: The satisfiability problem for First-order Modal Logic (\FOML) is undecidable even for simple fragments like having only unary predicates, two variables etc. Recently a new way to identify decidable fragments of \FOML has been introduced called the "bundled fragments", where the quantifiers and modalities are restricted to appear together. Since there are many ways to bundle the quantifiers together, some of them lead to (un)decidable fragments. In (Liu et.al, 2023) the authors prove a `trichotomy', where they show that every bundled fragment falls into one of the following three categories: (1) Those that satisfy "finite model property" (and hence decidable), (2) Those that are undecidable, and (3) Those that do not satisfy "finite model property" (whose decidability is left open).
  In this paper we collapse the trichotomy into a dichotomy over "increasing domain models" by proving that the one combination that falls into the last category is indeed decidable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.01421v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Varad Joshi, Anantha Padmanabha</dc:creator>
    </item>
    <item>
      <title>Safety, Relative Tightness and the Probabilistic Frame Rule</title>
      <link>https://arxiv.org/abs/2506.01626</link>
      <description>arXiv:2506.01626v2 Announce Type: new 
Abstract: Probabilistic separation logic offers an approach to reasoning about imperative probabilistic programs in which a separating conjunction is used as a mechanism for expressing independence properties. Crucial to the effectiveness of the formalism is the frame rule, which enables modular reasoning about independent probabilistic state. We explore a semantic formulation of probabilistic separation logic, in which the frame rule has the same simple formulation as in separation logic, without further side conditions. This is achieved by building a notion of safety into specifications, using which we establish a crucial property of specifications, called relative tightness, from which the soundness of the frame rule follows.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.01626v2</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Janez Ignacij Jereb, Alex Simpson</dc:creator>
    </item>
    <item>
      <title>On Symbol Elimination and Uniform Interpolation in Theory Extensions</title>
      <link>https://arxiv.org/abs/2506.01664</link>
      <description>arXiv:2506.01664v1 Announce Type: new 
Abstract: We define a notion of general uniform interpolant, generalizing the notions of cover and of uniform interpolant and identify situations in which symbol elimination can be used for computing general uniform interpolants. We investigate the limitations of the method we propose, and identify theory extensions for which the computation of general uniform interpolants can be reduced to symbol elimination followed by the computation of uniform quantifier-free interpolants in extensions with uninterpreted function symbols of theories allowing uniform quantifier-free interpolation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.01664v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Viorica Sofronie-Stokkermans</dc:creator>
    </item>
    <item>
      <title>Modal Verification Patterns for Systems</title>
      <link>https://arxiv.org/abs/2506.01719</link>
      <description>arXiv:2506.01719v1 Announce Type: new 
Abstract: Although they differ in the functionality they offer, low-level systems exhibit certain patterns of design and utilization of computing resources. In this paper, we argue the position that modalities, in the sense of modal logic, should be a go-to approach when specifying and verifying low-level systems code. We explain how the concept of a resource context helps guide the design of new modalities for verification of systems code, and we justify our perspective by discussing prior systems that have used modalities for systems verification successfully, arguing that they fit into the verification design pattern we articulate, and explaining how this approach might apply to other systems verification challenges.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.01719v1</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Ismail Kuru, Colin S. Gordon</dc:creator>
    </item>
    <item>
      <title>Faithful Logic Embeddings in HOL -- Deep and Shallow</title>
      <link>https://arxiv.org/abs/2502.19311</link>
      <description>arXiv:2502.19311v3 Announce Type: replace 
Abstract: Deep and shallow embeddings of non-classical logics in classical higher-order logic have been explored, implemented, and used in various reasoning tools in recent years. This paper presents a method for the simultaneous deployment of deep and shallow embeddings of various degrees in classical higher-order logic. This enables flexible, interactive and automated theorem proving and counterexample finding at meta and object level, as well as automated faithfulness proofs between these logic embeddings. The method is beneficial for logic education, research and application and is illustrated here using a simple propositional modal logic. However, this approach is conceptual in nature and not limited to this simple logic context.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.19311v3</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>math.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christoph Benzm\"uller</dc:creator>
    </item>
    <item>
      <title>A framework for computing upper bounds in passive learning settings</title>
      <link>https://arxiv.org/abs/2504.03517</link>
      <description>arXiv:2504.03517v4 Announce Type: replace 
Abstract: The task of inferring logical formulas from examples has garnered significant attention as a means to assist engineers in creating formal specifications used in the design, synthesis, and verification of computing systems. Among various approaches, enumeration algorithms have emerged as some of the most effective techniques for this task. These algorithms employ advanced strategies to systematically enumerate candidate formulas while minimizing redundancies by avoiding the generation of syntactically different but semantically equivalent formulas. However, a notable drawback is that these algorithms typically do not provide guarantees of termination, which poses challenges for their use in real-world applications.
  This paper develops an abstract framework to bound the size of possible solutions for a logic inference task, thereby providing a termination guarantee for enumeration algorithms through the introduction of a sufficient stopping criterion. The proposed framework is designed with flexibility in mind and is applicable to a broad spectrum of practically relevant logical formalisms, including Modal Logic, Linear Temporal Logic, Computation Tree Logic, Alternating-time Temporal Logic, and even selected inference task for finite automata. In addition, our approach enabled us to develop a new class of algorithms that enumerate over the semantics of formulas rather than their syntactic representations, offering new possibilities for reducing redundancy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.03517v4</guid>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Benjamin Bordais, Daniel Neider</dc:creator>
    </item>
    <item>
      <title>INTERLEAVE: A Faster Symbolic Algorithm for Maximal End Component Decomposition</title>
      <link>https://arxiv.org/abs/2505.20748</link>
      <description>arXiv:2505.20748v2 Announce Type: replace 
Abstract: This paper presents a novel symbolic algorithm for the Maximal End Component (MEC) decomposition of a Markov Decision Process (MDP). The key idea behind our algorithm INTERLEAVE is to interleave the computation of Strongly Connected Components (SCCs) with eager elimination of redundant state-action pairs, rather than performing these computations sequentially as done by existing state-of-the-art algorithms. Even though our approach has the same complexity as prior works, an empirical evaluation of INTERLEAVE on the standardized Quantitative Verification Benchmark Set demonstrates that it solves 19 more benchmarks (out of 379) than the closest previous algorithm. On the 149 benchmarks that prior approaches can solve, we demonstrate a 3.81x average speedup in runtime.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.20748v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Suguman Bansal, Ramneet Singh</dc:creator>
    </item>
    <item>
      <title>Towards a Neural Lambda Calculus: Neurosymbolic AI Applied to the Foundations of Functional Programming</title>
      <link>https://arxiv.org/abs/2304.09276</link>
      <description>arXiv:2304.09276v2 Announce Type: replace-cross 
Abstract: Over the last decades, deep neural networks based-models became the dominant paradigm in machine learning. Further, the use of artificial neural networks in symbolic learning has been seen as increasingly relevant recently. To study the capabilities of neural networks in the symbolic AI domain, researchers have explored the ability of deep neural networks to learn mathematical constructions, such as addition and multiplication, logic inference, such as theorem provers, and even the execution of computer programs. The latter is known to be too complex a task for neural networks. Therefore, the results were not always successful, and often required the introduction of biased elements in the learning process, in addition to restricting the scope of possible programs to be executed. In this work, we will analyze the ability of neural networks to learn how to execute programs as a whole. To do so, we propose a different approach. Instead of using an imperative programming language, with complex structures, we use the Lambda Calculus ({\lambda}-Calculus), a simple, but Turing-Complete mathematical formalism, which serves as the basis for modern functional programming languages and is at the heart of computability theory. We will introduce the use of integrated neural learning and lambda calculi formalization. Finally, we explore execution of a program in {\lambda}-Calculus is based on reductions, we will show that it is enough to learn how to perform these reductions so that we can execute any program. Keywords: Machine Learning, Lambda Calculus, Neurosymbolic AI, Neural Networks, Transformer Model, Sequence-to-Sequence Models, Computational Models</description>
      <guid isPermaLink="false">oai:arXiv.org:2304.09276v2</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jo\~ao Flach, Alvaro F. Moreira, Luis C. Lamb</dc:creator>
    </item>
    <item>
      <title>The equivariant model structure on cartesian cubical sets</title>
      <link>https://arxiv.org/abs/2406.18497</link>
      <description>arXiv:2406.18497v2 Announce Type: replace-cross 
Abstract: We develop a constructive model of homotopy type theory in a Quillen model category that classically presents the usual homotopy theory of spaces. Our model is based on presheaves over the cartesian cube category, a well-behaved Eilenberg-Zilber category. The key innovation is an additional equivariance condition in the specification of the cubical Kan fibrations, which can be described as the pullback of an interval-based class of uniform fibrations in the category of symmetric sequences of cubical sets. The main technical results in the development of our model have been formalized in a computer proof assistant.</description>
      <guid isPermaLink="false">oai:arXiv.org:2406.18497v2</guid>
      <category>math.AT</category>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Steve Awodey, Evan Cavallo, Thierry Coquand, Emily Riehl, Christian Sattler</dc:creator>
    </item>
    <item>
      <title>Efficient Neural Clause-Selection Reinforcement</title>
      <link>https://arxiv.org/abs/2503.07792</link>
      <description>arXiv:2503.07792v2 Announce Type: replace-cross 
Abstract: Clause selection is arguably the most important choice point in saturation-based theorem proving. Framing it as a reinforcement learning (RL) task is a way to challenge the human-designed heuristics of state-of-the-art provers and to instead automatically evolve -- just from prover experiences -- their potentially optimal replacement. In this work, we present a neural network architecture for scoring clauses for clause selection that is powerful yet efficient to evaluate. Following RL principles to make design decisions, we integrate the network into the Vampire theorem prover and train it from successful proof attempts. An experiment on the diverse TPTP benchmark finds the neurally guided prover improve over a baseline strategy, from which it initially learns -- in terms of the number of in-training-unseen problems solved under a practically relevant, short CPU instruction limit -- by 20%.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.07792v2</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Martin Suda</dc:creator>
    </item>
    <item>
      <title>Further Comments on Yablo's Construction</title>
      <link>https://arxiv.org/abs/2504.10370</link>
      <description>arXiv:2504.10370v3 Announce Type: replace-cross 
Abstract: We continue our analysis of Yablo's coding of the liar paradox by infinite acyclic graphs. The present notes are based on and continue the author's previous results on the problem. In particular, our approach is often more systematic than before.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.10370v3</guid>
      <category>math.CO</category>
      <category>cs.LO</category>
      <pubDate>Tue, 03 Jun 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Karl Schlechta</dc:creator>
    </item>
  </channel>
</rss>
