<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Oct 2025 04:00:17 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 27 Oct 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Simplifying explicit subtyping coercions in a polymorphic calculus with effects</title>
      <link>https://arxiv.org/abs/2404.04218</link>
      <description>arXiv:2404.04218v3 Announce Type: replace 
Abstract: Algebraic effect handlers are becoming an increasingly popular way of structuring effectful computations, and their performance is often a concern. One of the proposed approaches towards efficient compilation is tracking effect information through explicit subtyping coercions. However, in the presence of polymorphism, these coercions are compiled into additional arguments of compiled functions, incurring significant overhead. In this paper, we present a polymorphic effectful calculus, identify simplification phases needed to reduce the number of unnecessary constraints, and prove that they preserve semantics. In addition, we implement the simplification algorithm in the Eff language and evaluate its performance on a number of benchmarks. Though we do not prove the optimality of the presented simplifications, the results show that the algorithm eliminates all coercions, resulting in code as efficient as manually monomorphised one.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.04218v3</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 27 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Filip Koprivec, Matija Pretnar</dc:creator>
    </item>
    <item>
      <title>Bean: A Language for Backward Error Analysis</title>
      <link>https://arxiv.org/abs/2501.14550</link>
      <description>arXiv:2501.14550v2 Announce Type: replace 
Abstract: Backward error analysis offers a method for assessing the quality of numerical programs in the presence of floating-point rounding errors. However, techniques from the numerical analysis literature for quantifying backward error require substantial human effort, and there are currently no tools or automated methods for statically deriving sound backward error bounds. To address this gap, we propose Bean, a typed first-order programming language designed to express quantitative bounds on backward error. Bean's type system combines a graded coeffect system with strict linearity to soundly track the flow of backward error through programs. We prove the soundness of our system using a novel categorical semantics, where every Bean program denotes a triple of related transformations that together satisfy a backward error guarantee.
  To illustrate Bean's potential as a practical tool for automated backward error analysis, we implement a variety of standard algorithms from numerical linear algebra in Bean, establishing fine-grained backward error bounds via typing in a compositional style. We also develop a prototype implementation of Bean that infers backward error bounds automatically. Our evaluation shows that these inferred bounds match worst-case theoretical relative backward error bounds from the literature, underscoring Bean's utility in validating a key property of numerical programs: numerical stability.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.14550v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>cs.NA</category>
      <category>math.NA</category>
      <pubDate>Mon, 27 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3729324</arxiv:DOI>
      <arxiv:journal_reference>Michael Hicks (Ed.). 2025. Proc. ACM Program. Lang. 9, PLDI (June 2025)</arxiv:journal_reference>
      <dc:creator>Ariel E. Kellison, Laura Zielinski, David Bindel, Justin Hsu</dc:creator>
    </item>
    <item>
      <title>Abstraction Functions as Types</title>
      <link>https://arxiv.org/abs/2502.20496</link>
      <description>arXiv:2502.20496v3 Announce Type: replace 
Abstract: Software development depends on the use of libraries whose specifications constrain the client's code and impose obligations on the implementation. It follows that any approach to verification at scale must also be modular, while permitting specification of both behavior and cost. Hoare's influential notion of an abstraction function provides an elegant and effective methodology for such verifications, separating the implementation from the specification, and using an abstraction function to demonstrate the behavioral correctness of the former relative to the latter.
  For all of its influence, much of the Hoare methodology relies on conventional separation between implementation and specification, providing no linguistic support for ensuring that these conventions are obeyed. The purpose of this paper is to propose a synthetic account of Hoare's methodology within univalent dependent type theory based on the principle that all types have abstract and concrete aspects by regarding abstraction functions as types. Achieving this relies crucially on the notion of a phase distinction in type theory, which gives rise to modalities that fracture a type into its concrete and abstract parts and that permit the definition of a type given these aspects using a technique called gluing. A noninterference theorem governing the phase distinction characterizes the modularity guarantees provided by the theory. Moreover, this approach scales to permit the specification and verification of the cost of programs, allowing clients to verify their own cost relative to a specification and permitting the implementation to be upper-bounded by the specification using a monadic sealing effect. The resulting theory supports modular development of programs and proofs in a manner that hides private details of no concern to clients while permitting precise specifications of both the cost and behavior of programs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.20496v3</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 27 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Harrison Grodin (Carnegie Mellon University), Runming Li (Carnegie Mellon University), Robert Harper (Carnegie Mellon University)</dc:creator>
    </item>
    <item>
      <title>Semantically Separating Nominal Wyvern for Usability and Decidability</title>
      <link>https://arxiv.org/abs/2507.03867</link>
      <description>arXiv:2507.03867v2 Announce Type: replace 
Abstract: The Dependent Object Types (DOT) calculus incorporates concepts from functional languages (e.g. modules) with traditional object-oriented features (e.g. objects, subtyping) to achieve greater expressivity (e.g. F-bounded polymorphism). However, this merger of paradigms comes at the cost of subtype decidability. Recent work on bringing decidability to DOT has either sacrificed expressiveness or ease of use. The unrestricted construction of recursive types and type bounds has made subtype decidability a much harder problem than in traditional object-oriented programming.
  Recognizing this, our paper introduces Nominal Wyvern, a DOT-like dependent type system that takes an alternative approach: instead of having a uniform structural syntax like DOT, Nominal Wyvern is designed around a "semantic separation" between the nominal declaration of recursive types on the one hand, and the structural refinement of those types when they are used on the other. This design naturally guides the user to avoid writing undecidably recursive structural types.
  From a technical standpoint, this separation also makes guaranteeing decidability possible by allowing for an intuitive adaptation of material/shape separation, a technique for achieving subtype decidability by separating types responsible for subtyping constraints from types that represent concrete data. The result is a type system with syntax and structure familiar to OOP users that achieves decidability without compromising the expressiveness of F-bounded polymorphism and module systems as they are used in practice.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.03867v2</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 27 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yu Xiang Zhu, Amos Robinson, Sophia Roshal, Timothy Mou, Julian Mackay, Jonathan Aldrich, Alex Potanin</dc:creator>
    </item>
    <item>
      <title>Dependent Session Types for Verified Concurrent Programming</title>
      <link>https://arxiv.org/abs/2510.19129</link>
      <description>arXiv:2510.19129v2 Announce Type: replace 
Abstract: We present TLLC which extends the Two-Level Linear dependent type theory (TLL) with session-based concurrency. Equipped with Martin-L\"{o}f style dependency, the session types of TLLC allow protocols to specify properties of communicated messages. When used in conjunction with the dependent type machinery already present in TLL, dependent session types facilitate a form of relational verification by relating concurrent programs with their idealized sequential counterparts. Correctness properties proven for sequential programs can be easily lifted to their corresponding concurrent implementations. TLLC makes session types a powerful tool for intrinsically verifying the correctness of data structures such as queues and concurrent algorithms such as map-reduce. To extend TLL with session types, we develop a novel formulation of intuitionistic session type which we believe to be widely applicable for integrating session types into other type systems beyond the context of TLLC. We study the meta-theory of our language, proving its soundness as both a term calculus and a process calculus. To demonstrate the practicality of TLLC, we have implemented a prototype compiler that translates TLLC programs into concurrent C code, which has been extensively evaluated.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.19129v2</guid>
      <category>cs.PL</category>
      <pubDate>Mon, 27 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Qiancheng Fu, Hongwei Xi, Ankush Das</dc:creator>
    </item>
  </channel>
</rss>
