<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Jan 2026 02:35:34 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>S4 modal sequent calculus as intermediate logic and intermediate language</title>
      <link>https://arxiv.org/abs/2601.08071</link>
      <description>arXiv:2601.08071v1 Announce Type: new 
Abstract: In this short paper, we advocate for the idea that continuation-based intermediate languages correspond to intermediate logics. The goal of intermediate languages is to serve as a basis for compiler intermediate representations, allowing to represent expressive program transformations for optimisation and compilation, while preserving the properties that make programs compilable efficiently in the first place, such as the "stackability" of continuations. Intermediate logics are logics between intuitionistic and classical logic in terms of provability. Second-class continuations used in CPS-based intermediate languages correspond to a classical modal logic S4 with the added restriction that implications may only return modal types. This indeed corresponds to an intermediate logic, owing to the G\"odel-McKinsey-Tarski theorem which states the intuitionistic nature of the modal fragment of S4. We introduce a three-kinded polarised sequent calculus for S4, together with an operational machine model that separates a heap from a stack. With this model we study a stackability property for the modal fragment of S4.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08071v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Jean Caspar, Guillaume Munch-Maccagnoni</dc:creator>
    </item>
    <item>
      <title>Forcing and Interpolation in First-Order Hybrid Logic with rigid symbols</title>
      <link>https://arxiv.org/abs/2601.08432</link>
      <description>arXiv:2601.08432v1 Announce Type: new 
Abstract: In this paper, we establish an analogue of Craig Interpolation Property for a many-sorted variant of first-order hybrid logic. We develop a forcing technique that dynamically adds new constants to the underlying signature in a way that preserves consistency, even in the presence of models with possibly empty domains. Using this forcing method, we derive general criteria that are sufficient for a signature square to satisfy both Robinson's consistency and Craig interpolation properties.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08432v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Daniel G\u{a}in\u{a}, Go Hashimoto</dc:creator>
    </item>
    <item>
      <title>Degree-preserving Godel logics with an involution: intermediate logics and (ideal) paraconsistency</title>
      <link>https://arxiv.org/abs/2601.08474</link>
      <description>arXiv:2601.08474v1 Announce Type: new 
Abstract: In this paper we study intermediate logics between the degree preserving companion of Godel fuzzy logic with an involution and classical propositional logic CPL, as well as the intermediate logics of their finite-valued counterparts. Although these degree-preserving Godel logics are explosive with respect to Godel negation, they are paraconsistent with respect to the involutive negation. We introduce the notion of saturated paraconsistency, a weaker notion than ideal paraconsistency, and we fully characterize the ideal and the saturated paraconsistent logics between the degree-preserving n-valued Godel fuzzy logic with an involution and CPL. We also identify a large family of saturated paraconsistent logics in the family of intermediate logics for degree-preserving finite-valued Lukasiewicz logics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08474v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-030-71258-7_6</arxiv:DOI>
      <arxiv:journal_reference>Arieli, O., Zamansky, A. (eds), Arnon Avron on Semantics and Proof Theory of Non-Classical Logics, pp. 107-139. 2021. Cham: Springer</arxiv:journal_reference>
      <dc:creator>M. E. Coniglio, F. Esteva, J. Gispert, L. Godo</dc:creator>
    </item>
    <item>
      <title>On Deciding Constant Runtime of Linear Loops</title>
      <link>https://arxiv.org/abs/2601.08492</link>
      <description>arXiv:2601.08492v1 Announce Type: new 
Abstract: We consider linear single-path loops of the form \[
  \textbf{while} \quad \varphi \quad \textbf{do} \quad \vec{x} \gets A \vec{x} + \vec{b} \quad \textbf{end} \] where $\vec{x}$ is a vector of variables, the loop guard $\varphi$ is a conjunction of linear inequations over the variables $\vec{x}$, and the update of the loop is represented by the matrix $A$ and the vector $\vec{b}$. It is already known that termination of such loops is decidable. In this work, we consider loops where $A$ has real eigenvalues, and prove that it is decidable whether the loop's runtime (for all inputs) is bounded by a constant if the variables range over $\mathbb R$ or $\mathbb Q$. This is an important problem in automatic program verification, since safety of linear while-programs is decidable if all loops have constant runtime, and it is closely connected to the existence of multiphase-linear ranking functions, which are often used for termination and complexity analysis. To evaluate its practical applicability, we also present an implementation of our decision procedure.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08492v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Florian Frohn, J\"urgen Giesl, Peter Giesl, Nils Lommen</dc:creator>
    </item>
    <item>
      <title>The Unification Type of an Equational Theory May Depend on the Instantiation Preorder: From Results for Single Theories to Results for Classes of Theories</title>
      <link>https://arxiv.org/abs/2601.08710</link>
      <description>arXiv:2601.08710v1 Announce Type: new 
Abstract: The unification type of an equational theory is defined using a preorder on substitutions, called the instantiation preorder, whose scope is either restricted to the variables occurring in the unification problem, or unrestricted such that all variables are considered. It has been known for more than three decades that the unification type of an equational theory may vary, depending on which instantiation preorder is used. More precisely, it was shown in 1991 that the theory ACUI of an associative, commutative, and idempotent binary function symbol with a unit is unitary w.r.t. the restricted instantiation preorder, but not unitary w.r.t. the unrestricted one. In 2016 this result was strengthened by showing that the unrestricted type of this theory also cannot be finitary. In the conference version of this article, we considerably improved on this result by proving that ACUI is infinitary w.r.t. the unrestricted instantiation preorder, thus precluding type zero. We also showed that, w.r.t. this preorder, the unification type of ACU (where idempotency is removed from the axioms) and of AC (where additionally the unit is removed) is infinitary, though it is respectively unitary and finitary in the restricted case. In the other direction, we proved (using the example of unification in the description logic EL) that the unification type may actually improve from type zero to infinitary when switching from the restricted instantiation preorder to the unrestricted one. In the present article, we not only determine the unrestricted unification type of considerably more equational theories, but we also prove general results for whole classes of theories. In particular, we show that theories that are regular and finite, regular and locally finite, or regular, monoidal, and satisfy an additional condition are Noetherian, and thus cannot have unrestricted unification type zero.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08710v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Franz Baader, Oliver Fern\'andez Gil</dc:creator>
    </item>
    <item>
      <title>Evaluating Implicit Regulatory Compliance in LLM Tool Invocation via Logic-Guided Synthesis</title>
      <link>https://arxiv.org/abs/2601.08196</link>
      <description>arXiv:2601.08196v1 Announce Type: cross 
Abstract: The integration of large language models (LLMs) into autonomous agents has enabled complex tool use, yet in high-stakes domains, these systems must strictly adhere to regulatory standards beyond simple functional correctness. However, existing benchmarks often overlook implicit regulatory compliance, thus failing to evaluate whether LLMs can autonomously enforce mandatory safety constraints. To fill this gap, we introduce LogiSafetyGen, a framework that converts unstructured regulations into Linear Temporal Logic oracles and employs logic-guided fuzzing to synthesize valid, safety-critical traces. Building on this framework, we construct LogiSafetyBench, a benchmark comprising 240 human-verified tasks that require LLMs to generate Python programs that satisfy both functional objectives and latent compliance rules. Evaluations of 13 state-of-the-art (SOTA) LLMs reveal that larger models, despite achieving better functional correctness, frequently prioritize task completion over safety, which results in non-compliant behavior.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.08196v1</guid>
      <category>cs.CL</category>
      <category>cs.AI</category>
      <category>cs.CR</category>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Da Song, Yuheng Huang, Boqi Chen, Tianshuo Cong, Randy Goebel, Lei Ma, Foutse Khomh</dc:creator>
    </item>
    <item>
      <title>List types for resource aware languages: an implicit name approach</title>
      <link>https://arxiv.org/abs/2112.11062</link>
      <description>arXiv:2112.11062v3 Announce Type: replace 
Abstract: A novel formalisation of variable control in languages with implicit names based on de Bruijn indices is presented. We design and implement three languages: first, a restricted language with implicit names; then, a restricted calculus with implicit names and explicit substitution, and finally, an extended calculus with implicit names, implicit substitution and resource control. We propose a novel concept of list types, which are used to give a simple and manageable definition of linearity. We develop an implementation in Haskell.</description>
      <guid isPermaLink="false">oai:arXiv.org:2112.11062v3</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Silvia Ghilezan (MISANU), Jelena Iveti\'c (LIP, PLUME), Pierre Lescanne (LIP, PLUME), Simona Ka\v{s}terovi\'c</dc:creator>
    </item>
    <item>
      <title>Subgraph Isomorphism: Prolog vs. Conventional</title>
      <link>https://arxiv.org/abs/2511.13600</link>
      <description>arXiv:2511.13600v2 Announce Type: replace 
Abstract: Subgraph Isomorphism uses a small graph as a pattern to identify within a larger graph a set of vertices that have matching edges. This paper addresses a logic program written in Prolog for a specific relatively complex graph pattern for which multiple conventional implementations (including parallel) exist. The goal is to understand the complexity differences between programming logically and programming conventionally. Discussion includes the process of converting the graph pattern into logic statements in Prolog, and the resulting characteristics as the size of the graph increased. The analysis shows that using a logic paradigm is an efficient way to attack complex graph problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.13600v2</guid>
      <category>cs.LO</category>
      <category>cs.DS</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Claire Y. Yin, Peter M. Kogge</dc:creator>
    </item>
    <item>
      <title>The Modal Logic of Abstraction Refinement</title>
      <link>https://arxiv.org/abs/2601.05897</link>
      <description>arXiv:2601.05897v2 Announce Type: replace 
Abstract: Iterative abstraction refinement techniques are one of the most prominent paradigms for the analysis and verification of systems with large or infinite state spaces. This paper investigates the changes of truth values of system properties expressible in computation tree logic (CTL) when abstractions of transition systems are refined. To this end, the paper utilizes modal logic by defining alethic modalities expressing possibility and necessity on top of CTL: The modal operator $\lozenge$ is interpreted as "there is a refinement, in which ..." and $\Box$ is interpreted as "in all refinements, ...".
  Upper and lower bounds for the resulting modal logics of abstraction refinement are provided for three scenarios: 1) when considering all finite abstractions of a transition system, 2) when considering all abstractions of a transition system, and 3) when considering the class of all transition systems. Furthermore, to prove these results, generic techniques to obtain upper bounds of modal logics using novel types of so-called control statements are developed.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.05897v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jakob Piribauer, Vinzent Zschuppe</dc:creator>
    </item>
    <item>
      <title>LTL$_f$ Learning Meets Boolean Set Cover</title>
      <link>https://arxiv.org/abs/2509.24616</link>
      <description>arXiv:2509.24616v2 Announce Type: replace-cross 
Abstract: Learning formulas in Linear Temporal Logic (LTLf) from finite traces is a fundamental research problem which has found applications in artificial intelligence, software engineering, programming languages, formal methods, control of cyber-physical systems, and robotics. We implement a new CPU tool called Bolt improving over the state of the art by learning formulas more than 100x faster over 70% of the benchmarks, with smaller or equal formulas in 98% of the cases. Our key insight is to leverage a problem called Boolean Set Cover as a subroutine to combine existing formulas using Boolean connectives. Thanks to the Boolean Set Cover component, our approach offers a novel trade-off between efficiency and formula size.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.24616v2</guid>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Gabriel Bathie, Nathana\"el Fijalkow, Th\'eo Matricon, Baptiste Mouillon, Pierre Vandenhove</dc:creator>
    </item>
    <item>
      <title>Rule Rewriting Revisited: A Fresh Look at Static Filtering for Datalog and ASP</title>
      <link>https://arxiv.org/abs/2601.05108</link>
      <description>arXiv:2601.05108v2 Announce Type: replace-cross 
Abstract: Static filtering is a data-independent optimisation method for Datalog, which generalises algebraic query rewriting techniques from relational databases. In spite of its early discovery by Kifer and Lozinskii in 1986, the method has been overlooked in recent research and system development, and special cases are being rediscovered independently. We therefore recall the original approach, using updated terminology and more general filter predicates that capture features of modern systems, and we show how to extend its applicability to answer set programming (ASP). The outcome is strictly more general but also more complex than the classical approach: double exponential in general and single exponential even for predicates of bounded arity. As a solution, we propose tractable approximations of the algorithm that can still yield much improved logic programs in typical cases, e.g., it can improve the performance of rule systems over real-world data in the order of magnitude.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.05108v2</guid>
      <category>cs.DB</category>
      <category>cs.LO</category>
      <pubDate>Wed, 14 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Philipp Hanisch, Markus Kr\"otzsch</dc:creator>
    </item>
  </channel>
</rss>
