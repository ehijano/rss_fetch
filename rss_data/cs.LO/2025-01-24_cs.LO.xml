<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Jan 2025 05:00:07 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>The Yoneda embedding in simplicial type theory</title>
      <link>https://arxiv.org/abs/2501.13229</link>
      <description>arXiv:2501.13229v1 Announce Type: new 
Abstract: Riehl and Shulman introduced simplicial type theory (STT), a variant of homotopy type theory which aimed to study not just homotopy theory, but its fusion with category theory: $(\infty,1)$-category theory. While notoriously technical, manipulating $\infty$-categories in simplicial type theory is often easier than working with ordinary categories, with the type theory handling infinite stacks of coherences in the background. We capitalize on recent work by Gratzer et al. defining the $(\infty,1)$-category of $\infty$-groupoids in STT to define presheaf categories within STT and systematically develop their theory. In particular, we construct the Yoneda embedding, prove the universal property of presheaf categories, refine the theory of adjunctions in STT, introduce the theory of Kan extensions, and prove Quillen's Theorem A. In addition to a large amount of category theory in STT, we offer substantial evidence that STT can be used to produce difficult results in $\infty$-category theory at a fraction of the complexity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13229v1</guid>
      <category>cs.LO</category>
      <category>math.AT</category>
      <category>math.CT</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Gratzer, Jonathan Weinberger, Ulrik Buchholtz</dc:creator>
    </item>
    <item>
      <title>Overview and Roadmap of Team Automata</title>
      <link>https://arxiv.org/abs/2501.13589</link>
      <description>arXiv:2501.13589v1 Announce Type: new 
Abstract: Team Automata is a formalism for interacting component-based systems proposed in 1997, whereby multiple sending and receiving actions from concurrent automata can synchronise. During the past 25+ years, team automata have been studied and applied in many different contexts, involving 25+ researchers and resulting in 25+ publications. In this paper, we first revisit the specific notion of synchronisation and composition of team automata, relating it to other relevant coordination models, such as Reo, BIP, Contract Automata, Choreography Automata, and Multi-Party Session Types. We then identify several aspects that have recently been investigated for team automata and related models. These include communication properties (which are the properties of interest?), realisability (how to decompose a global model into local components?), tool support (what has been automatised or implemented?), and Variability (can a family of concrete product (automata) models be captured concisely?). Our presentation of these aspects provides a snapshot of the most recent trends in research on team automata, and delineates a roadmap for future research, both for team automata and for related formalisms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13589v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Maurice H. ter Beek, Rolf Hennicker, Jos\'e Proen\c{c}a</dc:creator>
    </item>
    <item>
      <title>Verifying Graph Algorithms in Separation Logic: A Case for an Algebraic Approach (Extended Version)</title>
      <link>https://arxiv.org/abs/2501.13603</link>
      <description>arXiv:2501.13603v1 Announce Type: new 
Abstract: Specifying and verifying graph-manipulating programs is a well-known and persistent challenge in separation logic. We show that the obstacles in dealing with graphs are removed if one represents graphs as partial commutative monoids, and admits applying over them structure-preserving functions (i.e., morphisms), including higher-order ones (i.e., combinators).
  By distributing over the monoid operations, morphisms work in tandem with framing to propagate the low-level pointer manipulation to the more abstract level of mathematical graphs, and to reduce the reasoning about the whole graph to reasoning about sub-components. We illustrate the approach with a novel and concise proof of a well-known graph benchmark, the Schorr-Waite graph marking algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13603v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marcos Grandury, Aleksandar Nanevski, Alexander Gryzlov</dc:creator>
    </item>
    <item>
      <title>Algebraic and algorithmic synergies between promise and infinite-domain CSPs</title>
      <link>https://arxiv.org/abs/2501.13740</link>
      <description>arXiv:2501.13740v1 Announce Type: new 
Abstract: We establish a framework that allows us to transfer results between some constraint satisfaction problems with infinite templates and promise constraint satisfaction problems. On the one hand, we obtain new algebraic results for infinite-domain CSPs giving new criteria for NP-hardness. On the other hand, we show the existence of promise CSPs with finite templates that reduce naturally to tractable infinite-domain CSPs, but that are not finitely tractable, thereby showing a non-trivial connection between those two fields of research. In an important part of our proof, we also obtain uniform polynomial-time algorithms solving temporal constraint satisfaction problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13740v1</guid>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Antoine Mottet</dc:creator>
    </item>
    <item>
      <title>Forbidden Induced Subgraphs for Bounded Shrub-Depth and the Expressive Power of MSO</title>
      <link>https://arxiv.org/abs/2501.13903</link>
      <description>arXiv:2501.13903v1 Announce Type: new 
Abstract: The graph parameter shrub-depth is a dense analog of tree-depth. We characterize classes of bounded shrub-depth by forbidden induced subgraphs. The obstructions are well-controlled flips of large half-graphs and of disjoint unions of many long paths. Applying this characterization, we show that on every hereditary class of unbounded shrub-depth, MSO is more expressive than FO. This confirms a conjecture of [Gajarsk\'y and Hlin\v{e}n\'y; LMCS 2015] who proved that on classes of bounded shrub-depth FO and MSO have the same expressive power. Combined, the two results fully characterize the hereditary classes on which FO and MSO coincide, answering an open question by [Elberfeld, Grohe, and Tantau; LICS 2012].
  Our work is inspired by the notion of stability from model theory. A graph class C is MSO-stable, if no MSO-formula can define arbitrarily long linear orders in graphs from C. We show that a hereditary graph class is MSO-stable if and only if it has bounded shrub-depth. As a key ingredient, we prove that every hereditary class of unbounded shrub-depth FO-interprets the class of all paths. This improves upon a result of [Ossona de Mendez, Pilipczuk, and Siebertz; Eur. J. Comb. 2025] who showed the same statement for FO-transductions instead of FO-interpretations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13903v1</guid>
      <category>cs.LO</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <category>math.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Nikolas M\"ahlmann</dc:creator>
    </item>
    <item>
      <title>Formally Verified Neurosymbolic Trajectory Learning via Tensor-based Linear Temporal Logic on Finite Traces</title>
      <link>https://arxiv.org/abs/2501.13712</link>
      <description>arXiv:2501.13712v1 Announce Type: cross 
Abstract: We present a novel formalisation of tensor semantics for linear temporal logic on finite traces (LTLf), with formal proofs of correctness carried out in the theorem prover Isabelle/HOL. We demonstrate that this formalisation can be integrated into a neurosymbolic learning process by defining and verifying a differentiable loss function for the LTLf constraints, and automatically generating an implementation that integrates with PyTorch. We show that, by using this loss, the process learns to satisfy pre-specified logical constraints. Our approach offers a fully rigorous framework for constrained training, eliminating many of the inherent risks of ad-hoc, manual implementations of logical aspects directly in an "unsafe" programming language such as Python, while retaining efficiency in implementation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13712v1</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Mark Chevallier, Filip Smola, Richard Schmoetten, Jacques D. Fleuriot</dc:creator>
    </item>
    <item>
      <title>On Deciding the Data Complexity of Answering Linear Monadic Datalog Queries with LTL Operators(Extended Version)</title>
      <link>https://arxiv.org/abs/2501.13762</link>
      <description>arXiv:2501.13762v1 Announce Type: cross 
Abstract: Our concern is the data complexity of answering linear monadic datalog queries whose atoms in the rule bodies can be prefixed by operators of linear temporal logic LTL. We first observe that, for data complexity, answering any connected query with operators $\bigcirc/\bigcirc^-$ (at the next/previous moment) is either in AC0, or in $ACC0\!\setminus\!AC0$, or $NC^1$-complete, or LogSpace-hard and in NLogSpace. Then we show that the problem of deciding LogSpace-hardness of answering such queries is PSpace-complete, while checking membership in the classes AC0 and ACC0 as well as $NC^1$-completeness can be done in ExpSpace. Finally, we prove that membership in AC0 or in ACC0, $NC^1$-completeness, and LogSpace-hardness are undecidable for queries with operators $\Diamond_f/\Diamond_p$ (sometime in the future/past) provided that $NC^1 \ne NLogSpace$, and $LogSpace \ne NLogSpace$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13762v1</guid>
      <category>cs.AI</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alessandro Artale, Anton Gnatenko, Vladislav Ryzhikov, Michael Zakharyaschev</dc:creator>
    </item>
    <item>
      <title>A beginner guide to Iris, Coq and separation logic</title>
      <link>https://arxiv.org/abs/2105.12077</link>
      <description>arXiv:2105.12077v2 Announce Type: replace 
Abstract: Creating safe concurrent algorithms is challenging and error-prone. For this reason, a formal verification framework is necessary especially when those concurrent algorithms are used in safety-critical systems. The goal of this guide is to provide resources for beginners to get started in their journey of formal verification using the powerful tool Iris. The difference between this guide and many others is that it provides (i) an in-depth explanation of examples and tactics, (ii) an explicit discussion of separation logic, and (iii) a thorough coverage of Iris and Coq. References to other guides and to papers are included throughout to provide readers with resources through which to continue their learning.</description>
      <guid isPermaLink="false">oai:arXiv.org:2105.12077v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Elizabeth Dietrich</dc:creator>
    </item>
    <item>
      <title>On The Axioms Of $\mathcal{M},\mathcal{N}$-Adhesive Categories</title>
      <link>https://arxiv.org/abs/2401.12638</link>
      <description>arXiv:2401.12638v5 Announce Type: replace 
Abstract: Adhesive and quasiadhesive categories provide a general framework for the study of algebraic graph rewriting systems. In a quasiadhesive category any two regular subobjects have a join which is again a regular subobject. Vice versa, if regular monos are adhesive, then the existence of a regular join for any pair of regular subobjects entails quasiadhesivity. It is also known (quasi)adhesive categories can be embedded in a Grothendieck topos via a functor preserving pullbacks and pushouts along (regular) monomorphisms. In this paper we extend these results to $\mathcal{M}, \mathcal{N}$-adhesive categories, a concept recently introduced to generalize the notion of (quasi)adhesivity. We introduce the notion of $\mathcal{N}$-adhesive morphism, which allows us to express $\mathcal{M}, \mathcal{N}$-adhesivity as a condition on the subobjects's posets. Moreover, $\mathcal{N}$-adhesive morphisms allows us to show how an $\mathcal{M},\mathcal{N}$-adhesive category can be embedded into a Grothendieck topos, preserving pullbacks and $\mathcal{M}, \mathcal{N}$-pushouts.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.12638v5</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Davide Castelnovo, Marino Miculan</dc:creator>
    </item>
    <item>
      <title>Boolean basis, formula size, and number of modal operators</title>
      <link>https://arxiv.org/abs/2408.11651</link>
      <description>arXiv:2408.11651v2 Announce Type: replace 
Abstract: Is it possible to write significantly smaller formulae when using Boolean operators other than those of the De Morgan basis (and, or, not, and the constants)? For propositional logic, a negative answer was given by Pratt: formulae over one set of operators can always be translated into an equivalent formula over any other complete set of operators with only polynomial increase in size. Surprisingly, for modal logic the picture is different: we show that elimination of bi-implication is only possible at the cost of an exponential number of occurrences of the modal operator $\lozenge$ and therefore of an exponential increase in formula size, i.e., the De Morgan basis and its extension by bi-implication differ in succinctness. Moreover, we prove that any complete set of Boolean operators agrees in succinctness with the De Morgan basis or with its extension by bi-implication. More precisely, these results are shown for the modal logic $\mathrm{T}$ (and therefore for $\mathrm{K}$). We complement them showing that the modal logic $\mathrm{S5}$ behaves as propositional logic: the choice of Boolean operators has no significant impact on the size of formulae.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.11651v2</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christoph Berkholz, Dietrich Kuske, Christian Schwarz</dc:creator>
    </item>
    <item>
      <title>Quantitative Monoidal Algebra: Axiomatising Distance with String Diagrams</title>
      <link>https://arxiv.org/abs/2410.09229</link>
      <description>arXiv:2410.09229v2 Announce Type: replace 
Abstract: String diagrammatic calculi have become increasingly popular in fields such as quantum theory, circuit theory, probabilistic programming, and machine learning, where they enable resource-sensitive and compositional algebraic analysis. Traditionally, the equations of diagrammatic calculi only axiomatise exact semantic equality. However, reasoning in these domains often involves approximations rather than strict equivalences. In this work, we develop a quantitative framework for diagrammatic calculi, where one may axiomatise notions of distance between string diagrams. Unlike similar approaches, such as the quantitative theories introduced by Mardare et al., this requires us to work in a monoidal rather than a cartesian setting. We define a suitable notion of monoidal theory, the syntactic category it freely generates, and its models, where the concept of distance is established via enrichment over a quantale. To illustrate the framework, we provide examples from probabilistic and linear systems analysis.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.09229v2</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gabriele Lobbia, Wojciech R\'o\.zowski, Ralph Sarkis, Fabio Zanasi</dc:creator>
    </item>
    <item>
      <title>Languages of Higher-Dimensional Timed Automata</title>
      <link>https://arxiv.org/abs/2401.17444</link>
      <description>arXiv:2401.17444v3 Announce Type: replace-cross 
Abstract: We present a new language semantics for real-time concurrency. Its operational models are higher-dimensional timed automata (HDTAs), a generalization of both higher-dimensional automata and timed automata. In real-time concurrent systems, both concurrency of events and timing and duration of events are of interest. Thus, HDTAs combine the non-interleaving concurrency model of higher-dimensional automata with the real-time modeling, using clocks, of timed automata. We define languages of HDTAs as sets of interval-timed pomsets with interfaces.
  We show that language inclusion of HDTAs is undecidable. On the other hand, using a region construction we can show that untimings of HDTA languages have enough regularity so that untimed language inclusion is decidable. On a more practical note, we give new insights on when practical applications, like checking reachability, might benefit from using HDTAs instead of classical timed automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.17444v3</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Amazigh Amrane, Hugo Bazille, Emily Clement, Uli Fahrenberg, Philipp Schlehuber-Caissier</dc:creator>
    </item>
    <item>
      <title>An Internal Logic of Virtual Double Categories</title>
      <link>https://arxiv.org/abs/2410.06792</link>
      <description>arXiv:2410.06792v2 Announce Type: replace-cross 
Abstract: We present a type theory called fibrational virtual double type theory (FVDblTT) designed specifically for formal category theory, which is a succinct reformulation of New and Licata's Virtual Equipment Type Theory (VETT). FVDblTT formalizes reasoning on isomorphisms that are commonly employed in category theory. Virtual double categories are one of the most successful frameworks for developing formal category theory, and FVDblTT has them as a theoretical foundation. We validate its worth as an internal language of virtual double categories by providing a syntax-semantics duality between virtual double categories and specifications in FVDblTT as a biadjunction.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.06792v2</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hayato Nasu</dc:creator>
    </item>
    <item>
      <title>Abstract Operational Methods for Call-by-Push-Value</title>
      <link>https://arxiv.org/abs/2410.17045</link>
      <description>arXiv:2410.17045v3 Announce Type: replace-cross 
Abstract: Levy's call-by-push-value is a comprehensive programming paradigm that combines elements from functional and imperative programming, supports computational effects and subsumes both call-by-value and call-by-name evaluation strategies. In the present work, we develop modular methods to reason about program equivalence in call-by-push-value, and in fine-grain call-by-value, which is a popular lightweight call-by-value sublanguage of the former. Our approach is based on the fundamental observation that presheaf categories of sorted sets are suitable universes to model call-by-(push)-value languages, and that natural, coalgebraic notions of program equivalence such as applicative similarity and logical relations can be developed within. Starting from this observation, we formalize fine-grain call-by-value and call-by-push-value in the higher-order abstract GSOS framework, reduce their key congruence properties to simple syntactic conditions by leveraging existing theory and argue that introducing changes to either language incurs minimal proof overhead.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.17045v3</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1145/3704871</arxiv:DOI>
      <dc:creator>Sergey Goncharov, Stelios Tsampas, Henning Urbat</dc:creator>
    </item>
    <item>
      <title>Pushing the Limit: Verified Performance-Optimal Causally-Consistent Database Transactions</title>
      <link>https://arxiv.org/abs/2411.07049</link>
      <description>arXiv:2411.07049v2 Announce Type: replace-cross 
Abstract: Modern web services crucially rely on high-performance distributed databases, where concurrent transactions are isolated from each other using concurrency control protocols. Relaxed isolation levels, which permit more complex concurrent behaviors than strong levels like serializability, are used in practice for higher performance and availability.
  In this paper, we present Eiger-PORT+, a concurrency control protocol that achieves a strong form of causal consistency, called TCCv (Transactional Causal Consistency with convergence). We show that Eiger-PORT+ also provides performance-optimal read transactions in the presence of transactional writes, thus refuting an open conjecture that this is impossible for TCCv. We also deductively verify that Eiger-PORT+ satisfies this isolation level by refining an abstract model of transactions. This yields the first deductive verification of a complex concurrency control protocol. Furthermore, we conduct a performance evaluation showing Eiger-PORT+'s superior performance over the state-of-the-art.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.07049v2</guid>
      <category>cs.DB</category>
      <category>cs.DC</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shabnam Ghasemirad, Christoph Sprenger, Si Liu, Luca Multazzu, David Basin</dc:creator>
    </item>
    <item>
      <title>Modular Counting CSP: Reductions and Algorithms</title>
      <link>https://arxiv.org/abs/2501.04224</link>
      <description>arXiv:2501.04224v3 Announce Type: replace-cross 
Abstract: The Constraint Satisfaction Problem (CSP) is ubiquitous in various areas of mathematics and computer science. Many of its variations have been studied including the Counting CSP, where the goal is to find the number of solutions to a CSP instance. The complexity of finding the exact number of solutions of a CSP is well understood (Bulatov, 2013, and Dyer and Richerby, 2013) and the focus has shifted to other variations of the Counting CSP such as counting the number of solutions modulo an integer. This problem has attracted considerable attention recently. In the case of CSPs based on undirected graphs Bulatov and Kazeminia (STOC 2022) obtained a complexity classification for the problem of counting solutions modulo p for arbitrary prime p. In this paper we report on the progress made towards a similar classification for the general CSP, not necessarily based on graphs.
  We identify several features that make the general case very different from the graph case such as a stronger form of rigidity and the structure of automorphisms of powers of relational structures. We provide a solution algorithm in the case p=2 that works under some additional conditions and prove the hardness of the problem under some assumptions about automorphisms of the powers of the relational structure. We also reduce the general CSP to the case that only uses binary relations satisfying strong additional conditions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.04224v3</guid>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Amirhossein Kazeminia, Andrei A. Bulatov</dc:creator>
    </item>
  </channel>
</rss>
