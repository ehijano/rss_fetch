<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Mar 2025 04:00:18 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Simplifier: A New Tool for Boolean Circuit Simplification</title>
      <link>https://arxiv.org/abs/2503.19103</link>
      <description>arXiv:2503.19103v1 Announce Type: new 
Abstract: The Boolean circuit simplification problem involves finding a smaller circuit that computes the same function as a given Boolean circuit. This problem is closely related to several key areas with both theoretical and practical applications, such as logic synthesis, satisfiability, and verification.
  In this paper, we present Simplifier, a new open source tool for simplifying Boolean circuits. The tool optimizes subcircuits with three inputs and at most three outputs, seeking to improve each one. It is designed as a low-effort method that runs in just a few seconds for circuits of reasonable size. This efficiency is achieved by combining two key strategies. First, the tool utilizes a precomputed database of optimized circuits, generated with SAT solvers after carefully clustering Boolean functions with three inputs and up to three outputs. Second, we demonstrate that it is sufficient to check a linear number of subcircuits, relative to the size of the original circuit. This allows a single iteration of the tool to be executed in linear time.
  We evaluated the tool on a wide range of Boolean circuits, including both industrial and hand-crafted examples, in two popular formats: AIG and BENCH. For AIG circuits, after applying the state-of-the-art ABC framework, our tool achieved an additional 4% average reduction in size. For BENCH circuits, the tool reduced their size by an average of 30%.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19103v1</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniil Averkov, Gregory Emdin, Viktoriia Krivogornitsyna, Alexander S. Kulikov, Fedor Kurmazov, Alexander Smal, Vsevolod Vaskin</dc:creator>
    </item>
    <item>
      <title>Proceedings of the Fourteenth and Fifteenth International Workshop on Graph Computation Models</title>
      <link>https://arxiv.org/abs/2503.19632</link>
      <description>arXiv:2503.19632v1 Announce Type: new 
Abstract: This volume contains the post-proceedings of the Fourteenth and the Fifteenth International Workshops on Graph Computation Models (GCM 2023 and 2024). The workshops took place in Leicester, UK on 18th July 2023 and Enschede, the Netherlands on 9th July 2024, in each case as part of STAF (Software Technologies: Applications and Foundations). 
  Graphs are common mathematical structures that are visual and intuitive. They constitute a natural and seamless way for system modeling in science, engineering, and beyond, including computer science, biology, and business process modeling. Graph computation models constitute a class of very high-level models where graphs are first-class citizens. The aim of the International GCM Workshop series is to bring together researchers interested in all aspects of computation models based on graphs and graph transformation. It promotes the cross-fertilizing exchange of ideas and experiences among senior and young researchers from the different communities interested in the foundations, applications, and implementations of graph computation models and related areas. </description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19632v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.417</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 417, 2025</arxiv:journal_reference>
      <dc:creator>J\"org Endrullis, Dominik Grzelak, Tobias Heindel, Jens Kosiol</dc:creator>
    </item>
    <item>
      <title>On the number of asynchronous attractors in AND-NOT Boolean networks</title>
      <link>https://arxiv.org/abs/2503.19147</link>
      <description>arXiv:2503.19147v1 Announce Type: cross 
Abstract: Boolean Networks (BNs) describe the time evolution of binary states using logic functions on the nodes of a network. They are fundamental models for complex discrete dynamical systems, with applications in various areas of science and engineering, and especially in systems biology. A key aspect of the dynamical behavior of BNs is the number of attractors, which determines the diversity of long-term system trajectories. Due to the noisy nature and incomplete characterization of biological systems, a stochastic asynchronous update scheme is often more appropriate than the deterministic synchronous one. AND-NOT BNs, whose logic functions are the conjunction of literals, are an important subclass of BNs because of their structural simplicity and their usefulness in analyzing biological systems for which the only information available is a collection of interactions among components. In this paper, we establish new theoretical results regarding asynchronous attractors in AND-NOT BNs. We derive two new upper bounds for the number of asynchronous attractors in an AND-NOT BN based on structural properties (strong even cycles and dominating sets, respectively) of the AND-NOT BN. These findings contribute to a more comprehensive understanding of asynchronous dynamics in AND-NOT BNs, with implications for attractor enumeration and counting, as well as for network design and control.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19147v1</guid>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Van-Giang Trinh, Samuel Pastva, Jordan Rozum, Kyu Hyong Park, R\'eka Albert</dc:creator>
    </item>
    <item>
      <title>Splitting Answer Set Programs with respect to Intensionality Statements (Extended Version)</title>
      <link>https://arxiv.org/abs/2503.19762</link>
      <description>arXiv:2503.19762v1 Announce Type: cross 
Abstract: Splitting a logic program allows us to reduce the task of computing its stable models to similar tasks for its subprograms. This can be used to increase solving performance and prove program correctness. We generalize the conditions under which this technique is applicable, by considering not only dependencies between predicates but also their arguments and context. This allows splitting programs commonly used in practice to which previous results were not applicable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19762v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1609/aaai.v37i5.25780</arxiv:DOI>
      <arxiv:journal_reference>Jorge Fandinno, Yuliya Lierler: Splitting Answer Set Programs with Respect to Intensionality Statements. AAAI 2023: 6338-6345</arxiv:journal_reference>
      <dc:creator>Jorge Fandinno, Yuliya Lierler</dc:creator>
    </item>
    <item>
      <title>Limits with Signed Digit Streams</title>
      <link>https://arxiv.org/abs/1807.10492</link>
      <description>arXiv:1807.10492v2 Announce Type: replace 
Abstract: We work with the signed digit representation of abstract real numbers, which roughly is the binary representation enriched by the additional digit -1. The main objective of this paper is an algorithm which takes a sequence of signed digit representations of reals and returns the signed digit representation of their limit, if the sequence converges. As a first application we use this algorithm together with Heron's method to build up an algorithm which converts the signed digit representation of a non-negative real number into the signed digit representation of its square root. Instead of writing the algorithms first and proving their correctness afterwards, we work the other way round, in the tradition of program extraction from proofs. In fact we first give constructive proofs, and from these proofs we then compute the extracted terms, which is the desired algorithm. The correctness of the extracted term follows directly by the Soundness Theorem of program extraction. In order to get the extracted term from some proofs which are often quite long, we use the proof assistant Minlog. However, to apply the extracted terms, the programming language Haskell is useful. Therefore after each proof we show a notation of the extracted term, which can be easily rewritten as a definition in Haskell.</description>
      <guid isPermaLink="false">oai:arXiv.org:1807.10492v2</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Franziskus Wiesnet</dc:creator>
    </item>
    <item>
      <title>Univalent Enriched Categories and the Enriched Rezk Completion</title>
      <link>https://arxiv.org/abs/2401.11752</link>
      <description>arXiv:2401.11752v3 Announce Type: replace 
Abstract: Enriched categories are categories whose sets of morphisms are enriched with extra structure. Such categories play a prominent role in the study of higher categories, homotopy theory, and the semantics of programming languages. In this paper, we study univalent enriched categories. We prove that all essentially surjective and fully faithful functors between univalent enriched categories are equivalences, and we show that every enriched category admits a Rezk completion. Finally, we use the Rezk completion for enriched categories to construct univalent enriched Kleisli categories.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.11752v3</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Niels van der Weide</dc:creator>
    </item>
    <item>
      <title>Derandomization with Pseudorandomness</title>
      <link>https://arxiv.org/abs/2404.16614</link>
      <description>arXiv:2404.16614v2 Announce Type: replace 
Abstract: Derandomization techniques are often used within advanced randomized algorithms. In particular, pseudorandom objects, such as hash families and expander graphs, are key components of such algorithms, but their verification presents a challenge. This work shows how such algorithms can be expressed and verified in Isabelle and presents a pseudorandom objects library that abstracts away the deep algebraic/analytic results involved. Moreover, it presents examples that show how the library eases and enables the verification of advanced randomized algorithms. Highlighting the value of this framework is that it was recently used to verify the space-optimal distinct elements algorithm by Blasiok from 2018, which relies on the combination of many derandomization techniques to achieve its optimality.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.16614v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Emin Karayel</dc:creator>
    </item>
    <item>
      <title>On Qualitative Preference in Alternating-time Temporal Logic with Strategy Contexts</title>
      <link>https://arxiv.org/abs/2502.13436</link>
      <description>arXiv:2502.13436v2 Announce Type: replace 
Abstract: We show how to add and eliminate binary preference on plays in Alternating-time Temporal Logic (ATL) with strategy contexts on Concurrent Game Models (CGMs) by means of a translation which preserves satisfaction in models where preference-indiscernibility between plays is an equivalence relation of finite index. The elimination technique also works for a companion second-order path quantifier, which makes quantified path variables range over sets of plays that are closed under preference-indiscernibility. We argue that the preference operator and the specialized quantifier facilitate formulating interesting solution concepts such as Nash equilibrium and secure equilibrium in a straightforward way. We also present a novel translation from ATL with strategy contexts to Quantified Computation Tree Logic (QCTL). Together with the translation which eliminates preference and the specialized form of quantification, this translation allows reasoning about infinite multiplayer synchronous games on CGMs to be translated from the proposed extension of ATL with strategy contexts into QCTL. The setting is related to that of ordered objectives in the works of Bouyer, Brenguier, Markey and Ummels, except that our focus is on the use of the temporal logic languages mentioned above, and we rely on translations into QCTL for the algorithmic solutions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.13436v2</guid>
      <category>cs.LO</category>
      <category>cs.MA</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dimitar P. Guelev</dc:creator>
    </item>
    <item>
      <title>Linearization via Rewriting (Long Version)</title>
      <link>https://arxiv.org/abs/2503.04408</link>
      <description>arXiv:2503.04408v2 Announce Type: replace 
Abstract: We introduce the structural resource lambda-calculus, a new formalism in which strongly normalizing terms of the lambda-calculus can naturally be represented, and at the same time any type derivation can be internally rewritten to its linearization. The calculus is shown to be normalizing and confluent. Noticeably, every strongly normalizable lambda-term can be represented by a type derivation. This is the first example of a system where the linearization process takes place internally, while remaining purely finitary and rewrite-based.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04408v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ugo Dal Lago, Federico Olimpieri</dc:creator>
    </item>
    <item>
      <title>Verification and External Parameter Inference for Stochastic World Models</title>
      <link>https://arxiv.org/abs/2503.16034</link>
      <description>arXiv:2503.16034v2 Announce Type: replace 
Abstract: Given its ability to analyse stochastic models ranging from discrete and continuous-time Markov chains to Markov decision processes and stochastic games, probabilistic model checking (PMC) is widely used to verify system dependability and performance properties. However, modelling the behaviour of, and verifying these properties for many software-intensive systems requires the joint analysis of multiple interdependent stochastic models of different types, which existing PMC techniques and tools cannot handle. To address this limitation, we introduce a tool-supported UniversaL stochasTIc Modelling, verificAtion and synThEsis (ULTIMATE) framework that supports the representation, verification and synthesis of heterogeneous multi-model stochastic systems with complex model interdependencies. Through its unique integration of multiple PMC paradigms, and underpinned by a novel verification method for handling model interdependencies, ULTIMATE unifies-for the first time-the modelling of probabilistic and nondeterministic uncertainty, discrete and continuous time, partial observability, and the use of both Bayesian and frequentist inference to exploit domain knowledge and data about the modelled system and its context. A comprehensive suite of case studies and experiments confirm the generality and effectiveness of our novel verification framework.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.16034v2</guid>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Radu Calinescu, Sinem Getir Yaman, Simos Gerasimou, Gricel V\'azquez, Micah Bassett</dc:creator>
    </item>
    <item>
      <title>Reasoning Around Paradox with Grounded Deduction</title>
      <link>https://arxiv.org/abs/2409.08243</link>
      <description>arXiv:2409.08243v3 Announce Type: replace-cross 
Abstract: How can we reason around logical paradoxes without falling into them? This paper introduces grounded deduction or GD, a Kripke-inspired approach to first-order logic and arithmetic that is neither classical nor intuitionistic, but nevertheless appears both pragmatically usable and intuitively justifiable. GD permits the direct expression of unrestricted recursive definitions - including paradoxical ones such as 'L := not L' - while adding dynamic typing premises to certain inference rules so that such paradoxes do not lead to inconsistency. This paper constitutes a preliminary development and investigation of grounded deduction, to be extended with further elaboration and deeper analysis of its intriguing properties.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.08243v3</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Bryan Ford</dc:creator>
    </item>
    <item>
      <title>Structural temporal logic for mechanized program verification</title>
      <link>https://arxiv.org/abs/2410.14906</link>
      <description>arXiv:2410.14906v5 Announce Type: replace-cross 
Abstract: Mechanized verification of liveness properties for infinite programs with effects and nondeterminism is challenging. Existing temporal reasoning frameworks operate at the level of models such as traces and automata. Reasoning happens at a very low-level, requiring complex nested (co-)inductive proof techniques and familiarity with proof assistant mechanics (e.g., the guardedness checker). Further, reasoning at the level of models instead of program constructs creates a verification gap that loses the benefits of modularity and composition enjoyed by structural program logics such as Hoare Logic. To address this verification gap, and the lack of compositional proof techniques for temporal specifications, we propose Ticl, a new structural temporal logic. Using ticl, we encode complex (co-)inductive proof techniques as structural lemmas and focus our reasoning on variants and invariants. We show that it is possible to perform compositional proofs of general temporal properties in a proof assistant, while working at a high level of abstraction. We demonstrate the benefits of Ticl by giving mechanized proofs of safety and liveness properties for programs with scheduling, concurrent shared memory, and distributed consensus, demonstrating a low proof-to-code ratio.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.14906v5</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Eleftherios Ioannidis, Yannick Zakowski, Steve Zdancewic, Sebastian Angel</dc:creator>
    </item>
  </channel>
</rss>
