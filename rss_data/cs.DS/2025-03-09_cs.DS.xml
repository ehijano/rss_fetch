<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 10 Mar 2025 04:00:07 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Efficient Algorithms for Verifying Kruskal Rank in Sparse Linear Regression and Related Applications</title>
      <link>https://arxiv.org/abs/2503.04986</link>
      <description>arXiv:2503.04986v1 Announce Type: new 
Abstract: We present novel algorithmic techniques to efficiently verify the Kruskal rank of matrices that arise in sparse linear regression, tensor decomposition, and latent variable models. Our unified framework combines randomized hashing techniques with dynamic programming strategies, and is applicable in various settings, including binary fields, general finite fields, and integer matrices. In particular, our algorithms achieve a runtime of $\mathcal{O}\left(dk \cdot \left(nM\right)^{\lceil k / 2 \rceil}\right)$ while ensuring high-probability correctness. Our contributions include: A unified framework for verifying Kruskal rank across different algebraic settings; Rigorous runtime and high-probability guarantees that nearly match known lower bounds; Practical implications for identifiability in tensor decompositions and deep learning, particularly for the estimation of noise transition matrices.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04986v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Fengqin Zhou</dc:creator>
    </item>
    <item>
      <title>Faster Global Minimum Cut with Predictions</title>
      <link>https://arxiv.org/abs/2503.05004</link>
      <description>arXiv:2503.05004v1 Announce Type: new 
Abstract: Global minimum cut is a fundamental combinatorial optimization problem with wide-ranging applications. Often in practice, these problems are solved repeatedly on families of similar or related instances. However, the de facto algorithmic approach is to solve each instance of the problem from scratch discarding information from prior instances.
  In this paper, we consider how predictions informed by prior instances can be used to warm-start practical minimum cut algorithms. The paper considers the widely used Karger's algorithm and its counterpart, the Karger-Stein algorithm. Given good predictions, we show these algorithms become near-linear time and have robust performance to erroneous predictions. Both of these algorithms are randomized edge-contraction algorithms. Our natural idea is to probabilistically prioritize the contraction of edges that are unlikely to be in the minimum cut.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05004v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Benjamin Moseley, Helia Niaparast, Karan Singh</dc:creator>
    </item>
    <item>
      <title>Fair Clustering in the Sliding Window Model</title>
      <link>https://arxiv.org/abs/2503.05173</link>
      <description>arXiv:2503.05173v1 Announce Type: new 
Abstract: We study streaming algorithms for proportionally fair clustering, a notion originally suggested by Chierichetti et. al. (2017), in the sliding window model. We show that although there exist efficient streaming algorithms in the insertion-only model, surprisingly no algorithm can achieve finite multiplicative ratio without violating the fairness constraint in the sliding window. Hence, the problem of fair clustering is a rare separation between the insertion-only streaming model and the sliding window model. On the other hand, we show that if the fairness constraint is relaxed by a multiplicative $(1+\varepsilon)$ factor, there exists a $(1 + \varepsilon)$-approximate sliding window algorithm that uses $\text{poly}(k\varepsilon^{-1}\log n)$ space. This achieves essentially the best parameters (up to degree in the polynomial) provided the aforementioned lower bound. We also implement a number of empirical evaluations on real datasets to complement our theoretical results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05173v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vincent Cohen-Addad, Shaofeng H. -C. Jiang, Qiaoyuan Yang, Yubo Zhang, Samson Zhou</dc:creator>
    </item>
    <item>
      <title>Fair Center Clustering in Sliding Windows</title>
      <link>https://arxiv.org/abs/2503.05260</link>
      <description>arXiv:2503.05260v1 Announce Type: new 
Abstract: The $k$-center problem requires the selection of $k$ points (centers) from a given metric pointset $W$ so to minimize the maximum distance of any point of $W$ from the closest center. This paper focuses on a fair variant of the problem, known as \emph {fair center}, where each input point belongs to some category and each category may contribute a limited number of points to the center set. We present the first space-efficient streaming algorithm for fair center in general metrics, under the sliding window model. At any time $t$, the algorithm is able to provide a solution for the current window whose quality is almost as good as the one guaranteed by the best, polynomial-time sequential algorithms run on the entire window, and exhibits space and time requirements independent of the window size. Our theoretical results are backed by an extensive set of experiments on both real-world and synthetic datasets, which provide evidence of the practical viability of the algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05260v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Matteo Ceccarello, Andrea Pietracaprina, Geppino Pucci, Francesco Vison\`a</dc:creator>
    </item>
    <item>
      <title>On the Parameterized Complexity of Odd Coloring</title>
      <link>https://arxiv.org/abs/2503.05312</link>
      <description>arXiv:2503.05312v1 Announce Type: new 
Abstract: A proper vertex coloring of a connected graph $G$ is called an odd coloring if, for every vertex $v$ in $G$, there exists a color that appears odd number of times in the open neighborhood of $v$. The minimum number of colors required to obtain an odd coloring of $G$ is called the \emph{odd chromatic number} of $G$, denoted by $\chi_{o}(G)$. Determining $\chi_o(G)$ known to be ${\sf NP}$-hard. Given a graph $G$ and an integer $k$, the \odc{} problem is to decide whether $\chi_o(G)$ is at most $k$. In this paper, we study the parameterized complexity of the problem, particularly with respect to structural graph parameters. We obtain the following results: \begin{itemize}
  \item We prove that the problem admits a polynomial kernel when parameterized by the distance to clique.
  \item We show that the problem cannot have a polynomial kernel when parameterized by the vertex cover number unless ${\sf NP} \subseteq {\sf Co {\text -} NP/poly}$.
  \item We show that the problem is fixed-parameter tractable when parameterized by distance to cluster, distance to co-cluster, or neighborhood diversity.
  \item We show that the problem is ${\sf W[1]}$-hard parameterized by clique-width. \end{itemize}
  Finally, we study the complexity of the problem on restricted graph classes. We show that it can be solved in polynomial time on cographs and split graphs but remains NP-complete on certain subclasses of bipartite graphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05312v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sriram Bhyravarapu, Swati Kumari, I. Vinod Reddy</dc:creator>
    </item>
    <item>
      <title>Strassen's algorithm via orbit flip graphs</title>
      <link>https://arxiv.org/abs/2503.05467</link>
      <description>arXiv:2503.05467v1 Announce Type: new 
Abstract: We give a short proof for Strassen's result that the rank of the 2 by 2 matrix multiplication tensor is at most 7. The proof requires no calculations and also no pattern matching or other type of nontrivial verification, and is based solely on properties of a specific order 6 group action. Our proof is based on the recent combination of flip graph algorithms and symmetries.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05467v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christian Ikenmeyer, Jakob Moosbauer</dc:creator>
    </item>
    <item>
      <title>Time-Optimal $k$-Server</title>
      <link>https://arxiv.org/abs/2503.05589</link>
      <description>arXiv:2503.05589v1 Announce Type: new 
Abstract: The time-optimal $k$-server problem minimizes the time spent serving all requests instead of the distances traveled. We give a lower bound of $2k-1$ on the competitive ratio of any deterministic online algorithm for this problem, which coincides with the best known upper bound on the competitive ratio achieved by the work-function algorithm for the classical $k$-server problem. We provide further lower bounds of $k+1$ for all Euclidean spaces and $k$ for uniform metric spaces. For the latter, we give a matching $k$-competitive deterministic algorithm. Our most technical result, proven by applying Yao's principle to a suitable instance distribution on a specifically constructed metric space, is a lower bound of $k+\mathcal{O}(\log k)$ that holds even for randomized algorithms, which contrasts with the best known lower bound for the classical problem that remains polylogarithmic.
  With this paper, we hope to initiate a further study of this natural yet neglected problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05589v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Fabian Frei, Dennis Komm, Moritz Stocker, Philip Whittington</dc:creator>
    </item>
    <item>
      <title>Bridging Classical and Quantum String Matching: A Computational Reformulation of Bit-Parallelism</title>
      <link>https://arxiv.org/abs/2503.05596</link>
      <description>arXiv:2503.05596v1 Announce Type: new 
Abstract: String matching is a fundamental problem in computer science, with critical applications in text retrieval, bioinformatics, and data analysis. Among the numerous solutions that have emerged for this problem in recent decades, bit-parallelism has significantly enhanced their practical efficiency, leading to the development of several optimized approaches for both exact and approximate string matching. However, their potential in quantum computing remains largely unexplored. This paper presents a novel pathway that not only translates bit-parallel string matching algorithms into the quantum framework but also enhances their performance to achieve a quadratic speedup through Grover's search. By embedding quantum search within a bit-parallel model, we reduce the time complexity of string matching, establishing a structured pathway for transforming classical algorithms into quantum solutions with provable computational advantages. Beyond exact matching, this technique offers a foundation for tackling a wide range of non-standard string matching problems, opening new avenues for efficient text searching in the quantum era. To demonstrate the simplicity and adaptability of the technique presented in this paper, we apply this translation and adaptation process to two landmark bit-parallel algorithms: Shift-And for exact pattern matching and Shift-Add for approximate string matching with up to k errors.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05596v1</guid>
      <category>cs.DS</category>
      <category>cs.IR</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Simone Faro, Arianna Pavone, Caterina Viola</dc:creator>
    </item>
    <item>
      <title>Dynamic Indexing Through Learned Indices with Worst-case Guarantees</title>
      <link>https://arxiv.org/abs/2503.05007</link>
      <description>arXiv:2503.05007v1 Announce Type: cross 
Abstract: Indexing data is a fundamental problem in computer science. Recently, various papers apply machine learning to this problem.
  For a fixed integer $\varepsilon$, a \emph{learned index} is a function $h : \mathcal{U} \rightarrow [0, n]$ where $\forall q \in \mathcal{U}$, $h(q) \in [\text{rank}(q) - \varepsilon, \text{rank}(q) + \varepsilon]$. These works use machine learning to compute $h$. Then, they store $S$ in a sorted array $A$ and access $A[\lfloor h(q) \rfloor]$ to answer queries in $O(k + \varepsilon + \log |h|)$ time. Here, $k$ denotes the output size and $|h|$ the complexity of $h$. Ferragina and Vinciguerra (VLDB 2020) observe that creating a learned index is a geometric problem. They define the PGM index by restricting $h$ to a piecewise linear function and show a linear-time algorithm to compute a PGM index of approximate minimum complexity.
  Since indexing queries are decomposable, the PGM index may be made dynamic through the logarithmic method. When allowing deletions, range query times deteriorate to worst-case $O(N + \sum\limits_i^{\lceil \log n \rceil } (\varepsilon + \log |h_i|))$ time (where $N$ is the largest size of $S$ seen so far).
  This paper offers a combination of theoretical insights and experiments as we apply techniques from computational geometry to dynamically maintain an approximately minimum-complexity learned index $h : \mathcal{U} \rightarrow [0, n]$ with $O(\log^2 n)$ update time.
  We also prove that if we restrict $h$ to lie in a specific subclass of piecewise-linear functions, then we can combine $h$ and hash maps to support queries in $O(k + \varepsilon + \log |h|)$ time (at the cost of increasing $|h|$). We implement our algorithm and compare it to the existing implementation. Our empirical analysis shows that our solution supports more efficient range queries whenever the update sequence contains many deletions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05007v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Emil Toftegaard G{\ae}de, Ivor van der Hoog, Eva Rotenberg, Tord Stordalen</dc:creator>
    </item>
    <item>
      <title>Graph parameters that are coarsely equivalent to path-length</title>
      <link>https://arxiv.org/abs/2503.05661</link>
      <description>arXiv:2503.05661v1 Announce Type: cross 
Abstract: Two graph parameters are said to be coarsely equivalent if they are within constant factors from each other for every graph $G$. Recently, several graph parameters were shown to be coarsely equivalent to tree-length. Recall that the length of a tree-decomposition ${\cal T}(G)$ of a graph $G$ is the largest diameter of a bag in ${\cal T}(G)$, and the tree-length $tl(G)$ of $G$ is the minimum of the length, over all tree-decompositions of $G$. Similarly, the length of a path-decomposition ${\cal P}(G)$ of a graph $G$ is the largest diameter of a bag in ${\cal P}(G)$, and the path-length $pl(G)$ of $G$ is the minimum of the length, over all path-decompositions of $G$. In this paper, we present several graph parameters that are coarsely equivalent to path-length. Among other results, we show that the path-length of a graph $G$ is small if and only if one of the following equivalent conditions is true: (a) $G$ can be embedded to an unweighted caterpillar tree (equivalently, to a graph of path-width one) with a small additive distortion; (b) there is a constant $r\ge 0$ such that for every triple of vertices $u,v,w$ of $G$, disk of radius $r$ centered at one of them intercepts all paths connecting two others; (c) $G$ has a $k$-dominating shortest path with small $k\ge 0$; (d) $G$ has a $k'$-dominating pair with small $k'\ge 0$; (e) some power $G^\mu$ of $G$ is an AT-free (or even a cocomparability) graph for a small integer $\mu\ge 0$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05661v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Feodor F. Dragan, Ekkehard K\"ohler</dc:creator>
    </item>
    <item>
      <title>On Almost Fair and Equitable Allocations of Indivisible Items for Non-monotone Valuations</title>
      <link>https://arxiv.org/abs/2503.05695</link>
      <description>arXiv:2503.05695v1 Announce Type: cross 
Abstract: In this work, we revisit well-studied problems of fair allocation of indivisible items among agents with general, non-monotone valuations. We explore the existence and efficient computation of allocations that satisfy either fairness or equity constraints. The fairness notions we consider ensure that each agent values her bundle at least as much as others', allowing for (any or some) item removal, while the equity guarantees roughly equal valuations among agents, with similar adjustments. For objective valuations where items are classified as either goods or chores, we present a pseudo-polynomial local-search algorithm computing an ``equitable-up-to-any-good-or-any-chore'' (EQX*) allocation, a weaker version of an ``equitable-up-to-any-item" (EQX) allocation. Additionally, we provide a polynomial-time greedy algorithm that computes an ``equitable-up-to-one-item" (EQ1) allocation, and a similar algorithm returning an EQX* allocation when the valuations are also additive. As a key technical contribution of this work, by leveraging fixed-point theorems (such as Sperner's Lemma and its variants), we establish the existence of ``equitable-up-to-one-good-and-one-chore'' (EQ1*) and ``envy-free-up-to-one-good-and-one-chore'' (EF1*) allocations for non-negative (and possibly non-objective and non-monotone) valuations. This holds even when items are arranged in a path and bundles must form connected sub-paths. Additionally, we present a polynomial-time dynamic-programming algorithm that computes an EQ1* allocation. Finally, we extend the EF1* and EQ1* results to non-positive valuations using a novel multi-coloring variant of Sperner's lemma, a combinatorial result of independent interest. For monotone non-increasing valuations and path-connected bundles, this implies the existence of EF1 and EQ1 allocations, with EQ1 allocations being efficiently computable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05695v1</guid>
      <category>cs.GT</category>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vittorio Bil\`o, Martin Loebl, Cosimo Vinci</dc:creator>
    </item>
    <item>
      <title>A Framework for Algorithm Stability</title>
      <link>https://arxiv.org/abs/1704.08000</link>
      <description>arXiv:1704.08000v3 Announce Type: replace 
Abstract: We say that an algorithm is stable if small changes in the input result in small changes in the output. This kind of algorithm stability is particularly relevant when analyzing and visualizing time-varying data. Stability in general plays an important role in a wide variety of areas, such as numerical analysis, machine learning, and topology, but is poorly understood in the context of (combinatorial) algorithms. In this paper we present a framework for analyzing the stability of algorithms. We focus in particular on the trade-off between the stability of an algorithm and the quality of the solution it computes. Our framework allows for three types of stability analysis with increasing degrees of complexity: event stability, topological stability, and Lipschitz stability. In addition, we need to refine the model of an algorithm based on how it interacts with the time-varying data, for which we consider several options. We demonstrate the use of our stability framework by applying it to kinetic Euclidean minimum spanning trees.</description>
      <guid isPermaLink="false">oai:arXiv.org:1704.08000v3</guid>
      <category>cs.DS</category>
      <category>cs.CG</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Wouter Meulemans, Bettina Speckmann, Kevin Verbeek, Jules Wulms</dc:creator>
    </item>
    <item>
      <title>Learning-Augmented Search Data Structures</title>
      <link>https://arxiv.org/abs/2402.10457</link>
      <description>arXiv:2402.10457v2 Announce Type: replace 
Abstract: We study the integration of machine learning advice to improve upon traditional data structure designed for efficient search queries. Although there has been recent effort in improving the performance of binary search trees using machine learning advice, e.g., Lin et. al. (ICML 2022), the resulting constructions nevertheless suffer from inherent weaknesses of binary search trees, such as complexity of maintaining balance across multiple updates and the inability to handle partially-ordered or high-dimensional datasets. For these reasons, we focus on skip lists and KD trees in this work. Given access to a possibly erroneous oracle that outputs estimated fractional frequencies for search queries on a set of items, we construct skip lists and KD trees that provably provides the optimal expected search time, within nearly a factor of two. In fact, our learning-augmented skip lists and KD trees are still optimal up to a constant factor, even if the oracle is only accurate within a constant factor. We also demonstrate robustness by showing that our data structures achieves an expected search time that is within a constant factor of an oblivious skip list/KD tree construction even when the predictions are arbitrarily incorrect. Finally, we empirically show that our learning-augmented search data structures outperforms their corresponding traditional analogs on both synthetic and real-world datasets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.10457v2</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Chunkai Fu, Brandon G. Nguyen, Jung Hoon Seo, Ryan Zesch, Samson Zhou</dc:creator>
    </item>
    <item>
      <title>Dynamic Range Minimum Queries on the Ultra-Wide Word RAM</title>
      <link>https://arxiv.org/abs/2411.16281</link>
      <description>arXiv:2411.16281v2 Announce Type: replace 
Abstract: We consider the dynamic range minimum problem on the ultra-wide word RAM model of computation. This model extends the classic $w$-bit word RAM model with special ultrawords of length $w^2$ bits that support standard arithmetic and boolean operation and scattered memory access operations that can access $w$ (non-contiguous) locations in memory. The ultra-wide word RAM model captures (and idealizes) modern vector processor architectures.
  Our main result is a linear space data structure that supports range minimum queries and updates in $O(\log \log \log n)$ time. This exponentially improves the time of existing techniques. Our result is based on a simple reduction to prefix minimum computations on sequences $O(\log n)$ words combined with a new parallel, recursive implementation of these.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.16281v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Philip Bille, Inge Li G{\o}rtz, Tord Stordalen, M\'aximo P\'erez L\'opez</dc:creator>
    </item>
    <item>
      <title>The Structural Complexity of Matrix-Vector Multiplication</title>
      <link>https://arxiv.org/abs/2502.21240</link>
      <description>arXiv:2502.21240v2 Announce Type: replace 
Abstract: We consider the problem of preprocessing an $n\times n$ matrix M, and supporting queries that, for any vector v, returns the matrix-vector product Mv. This problem has been extensively studied in both theory and practice: on one side, practitioners have developed algorithms that are highly efficient in practice, whereas theoreticians have proven that the problem cannot be solved faster than naive multiplication in the worst-case. This lower bound holds even in the average-case, implying that existing average-case analyses cannot explain this gap between theory and practice. Therefore, we study the problem for structured matrices. We show that for $n\times n$ matrices of VC-dimension d, the matrix-vector multiplication problem can be solved with $\tilde{O}(n^2)$ preprocessing and $\tilde O(n^{2-1/d})$ query time. Given the low constant VC-dimensions observed in most real-world data, our results posit an explanation for why the problem can be solved so much faster in practice. Moreover, our bounds hold even if the matrix does not have a low VC-dimension, but is obtained by (possibly adversarially) corrupting at most a subquadratic number of entries of any unknown low VC-dimension matrix. Our results yield the first non-trivial upper bounds for many applications. In previous works, the online matrix-vector hypothesis (conjecturing that quadratic time is needed per query) was used to prove many conditional lower bounds, showing that it is impossible to compute and maintain high-accuracy estimates for shortest paths, Laplacian solvers, effective resistance, and triangle detection in graphs subject to node insertions and deletions in subquadratic time. Yet, via a reduction to our matrix-vector-multiplication result, we show we can maintain the aforementioned problems efficiently if the input is structured, providing the first subquadratic upper bounds in the high-accuracy regime.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.21240v2</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>cs.CG</category>
      <category>cs.LG</category>
      <pubDate>Mon, 10 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Emile Anand, Jan van den Brand, Rose McCarty</dc:creator>
    </item>
  </channel>
</rss>
