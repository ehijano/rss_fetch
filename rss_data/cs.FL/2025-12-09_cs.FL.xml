<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Dec 2025 05:23:34 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 09 Dec 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Soft state reduction of fuzzy automata over residuated lattices</title>
      <link>https://arxiv.org/abs/2512.06832</link>
      <description>arXiv:2512.06832v1 Announce Type: new 
Abstract: State reduction of finite automata plays a significant role in improving efficiency in formal verification, pattern recognition, and machine learning, where automata-based models are widely used. While deterministic automata have well-defined minimization procedures, reducing states in nondeterministic fuzzy finite automata (FfAs) remains challenging, especially for FfAs over non-locally finite residuated lattices like the product and Hamacher structures. This work introduces soft state reduction, an approximate method that leverages a small threshold $\varepsilon$ possibly combined with a word length bound $k$ to balance reduction accuracy and computational feasibility. By omitting fuzzy values smaller than $\varepsilon$, the underlying residuated lattice usually becomes locally finite, making computations more tractable. We introduce and study approximate invariances, which are fuzzy relations that allow merging of almost equivalent states of an FfA up to a tolerance level $\varepsilon$ and, optionally, to words of bounded length $k$. We further present an algorithm which iteratively applies such invariances to achieve reduction while preserving approximate language equivalence. Our method effectively reduces FfAs where existing techniques fail.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.06832v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 09 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Linh Anh Nguyen, Son Thanh Cao, Stefan Stanimirovi\'c</dc:creator>
    </item>
    <item>
      <title>An Analysis of Decision Problems for Relational Pattern Languages under Various Constraints</title>
      <link>https://arxiv.org/abs/2512.07476</link>
      <description>arXiv:2512.07476v1 Announce Type: new 
Abstract: Patterns are words with terminals and variables. The language of a pattern is the set of words obtained by uniformly substituting all variables with words that contain only terminals. In their original definition, patterns only allow for multiple distinct occurrences of some variables to be related by the equality relation, represented by using the same variable multiple times. In an extended notion, called relational patterns and relational pattern languages, variables may be related by arbitrary other relations. We extend the ongoing investigation of the main decision problems for patterns (namely, the membership problem, the inclusion problem, and the equivalence problem) to relational pattern languages under a wide range of individual relations. It is shown show that - even for many much simpler or less restrictive relations - the complexity and (un)decidability characteristics of these problems do not change compared to the classical case where variables are related only by equality.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.07476v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <category>math.CO</category>
      <pubDate>Tue, 09 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Klaus Jansen, Dirk Nowotka, Lis Pirotton, Corinna Wambsganz, Max Wiedenh\"oft</dc:creator>
    </item>
    <item>
      <title>Specializing anti-unification for interaction models composition via gate connections</title>
      <link>https://arxiv.org/abs/2512.07595</link>
      <description>arXiv:2512.07595v1 Announce Type: new 
Abstract: Interaction models describe distributed systems as algebraic terms, with gates marking interaction points between local views. Composing local models into a coherent global one requires aligning these gates while respecting the algebraic laws of interaction operators. We specialize anti-unification (or generalization) via a special constant-preserving variant, which preserves designated constants while generalizing the remaining structure. We develop a dedicated rule-based procedure for computing these generalizations, prove its termination, soundness, and completeness, extend it modulo equational theories, and integrate it into a standard anti-unification framework. A prototype tool demonstrates the approach's ability to recompose global interactions from partial views.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.07595v1</guid>
      <category>cs.FL</category>
      <category>cs.SC</category>
      <pubDate>Tue, 09 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Joel Nguetoum (Paris-Saclay University, CEA, List, Palaiseau, France, Paris-Saclay University, CentraleSupelec, MICS, Gif-sur-Yvette, France), Boutheina Bannour (Paris-Saclay University, CEA, List, Palaiseau, France), Pascale Le Gall (Paris-Saclay University, CentraleSupelec, MICS, Gif-sur-Yvette, France), Erwan Mahe (Paris-Saclay University, CEA, List, Palaiseau, France)</dc:creator>
    </item>
    <item>
      <title>A finer reparameterisation theorem for MSO and FO queries on strings</title>
      <link>https://arxiv.org/abs/2512.06466</link>
      <description>arXiv:2512.06466v1 Announce Type: cross 
Abstract: We show a theorem on monadic second-order k-ary queries on finite words. It may be illustrated by the following example: if the number of results of a query on binary strings is O(number of 0s $\times$ number of 1s), then each result can be MSO-definably identified from a 0-position, a 1-position and some finite data.
  Our proofs also handle the case of first-order logic / aperiodic monoids. Thus we can state and prove the folklore theorem that dimension minimisation holds for first-order string-to-string interpretations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.06466v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Tue, 09 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>L\^e Th\`anh D\~ung Nguy\^en, Pawe{\l} Parys</dc:creator>
    </item>
    <item>
      <title>Systematic Evaluation of Black-Box Checking for Fast Bug Detection</title>
      <link>https://arxiv.org/abs/2512.07434</link>
      <description>arXiv:2512.07434v1 Announce Type: cross 
Abstract: Combinations of active automata learning, model-based testing and model checking have been successfully used in numerous applications, e.g., for spotting bugs in implementations of major network protocols and to support refactoring of embedded controllers. However, in the large majority of these applications, model checking is only used at the very end, when no counterexample can be found anymore for the latest hypothesis model. This contrasts with the original proposal of black-box checking (BBC) by Peled, Vardi &amp; Yannakakis, which applies model checking for all hypotheses, also the intermediate ones. In this article, we present the first systematic evaluation of the ability of BBC to find bugs quickly, based on 77 benchmarks models from real protocol implementations and controllers for which specifications of safety properties are available. Our main finding are: (a) In cases where the full model can be learned, BBC detects violations of the specifications with just 3.4% of the queries needed by an approach in which model checking is only used for the full model. (b) Even when the full model cannot be learned, BBC is still able to detect many violations of the specification. In particular, BBC manages to detect 94% of the safety properties violations in the challenging RERS 2019 industrial LTL benchmarks. (c) Our results also confirm that BBC is way more effective than existing MBT algorithms in finding deep bugs in implementations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2512.07434v1</guid>
      <category>cs.SE</category>
      <category>cs.FL</category>
      <pubDate>Tue, 09 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Bram Pellen, Mar\'ia Bel\'en Rodr\'iguez, Frits Vaandrager, Petra van den Bos</dc:creator>
    </item>
    <item>
      <title>Bounded Languages Described by GF(2)-grammars</title>
      <link>https://arxiv.org/abs/1912.13401</link>
      <description>arXiv:1912.13401v5 Announce Type: replace 
Abstract: GF(2)-grammars are a recently introduced grammar family with some unusual algebraic properties. They are closely connected to unambiguous grammars. By using the method of formal power series, we establish strong conditions that are necessary for subsets of a^* b^* and a^* b^* c^* to be described by some GF(2)-grammar. By further applying the established results, we settle the long-standing open question of proving inherent ambiguity of the language {a^n b^m c^k | n != m or m != k}$, as well as give a new purely algebraic proof of the inherent ambiguity of the language {a^n b^m c^k}{n = m or m = k}.</description>
      <guid isPermaLink="false">oai:arXiv.org:1912.13401v5</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 09 Dec 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Vladislav Makarov</dc:creator>
    </item>
  </channel>
</rss>
