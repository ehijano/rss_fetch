<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Dec 2024 02:43:54 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Inversion by Partial Evaluation: A Reversible Interpreter Experiment</title>
      <link>https://arxiv.org/abs/2412.03122</link>
      <description>arXiv:2412.03122v1 Announce Type: new 
Abstract: A computational limit of combining partial evaluation and program inversion is investigated. Using a reversible Turing machine interpreter, we show that the first Futamura and inversion projections can produce not only functionally but also textually equivalent programs. The construction of the interpreter in a reversible flowchart language is shown in full. Insights are provided on the practical interplay between reversible interpreters, program inverters, and partial evaluators. We conclude that both projections must be included in the program transformation toolbox.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.03122v1</guid>
      <category>cs.PL</category>
      <category>cs.FL</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.413.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 413, 2024, pp. 1-14</arxiv:journal_reference>
      <dc:creator>Robert Gl\"uck (DIKU, Dept. of Computer Science, University of Copenhagen), Louis Marott Normann (DIKU, Dept. of Computer Science, University of Copenhagen)</dc:creator>
    </item>
    <item>
      <title>Explicit Weakening</title>
      <link>https://arxiv.org/abs/2412.03124</link>
      <description>arXiv:2412.03124v1 Announce Type: new 
Abstract: I present a novel formulation of substitution, where facts about substitution that previously required tens or hundreds of lines to justify in a proof assistant now follow immediately - they can be justified by writing the four letters "refl". The paper is an executable literate Agda script, and source of the paper is available as an artifact in the file Weaken.lagda.md.
  Not all consequences of the pandemic have been awful. For the last three years, I've had the great pleasure of meeting with Peter Thiemann and Jeremy Siek for a couple of hours every week, via Zoom, exploring topics including core calculi, gradual typing, and formalisation in Agda. The work reported here arose from those discussions, and is dedicated to Peter on the occasion of his 60th birthday.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.03124v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.413.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 413, 2024, pp. 15-26</arxiv:journal_reference>
      <dc:creator>Philip Wadler (University of Edinburgh)</dc:creator>
    </item>
    <item>
      <title>Gradual Guarantee via Step-Indexed Logical Relations in Agda</title>
      <link>https://arxiv.org/abs/2412.03125</link>
      <description>arXiv:2412.03125v1 Announce Type: new 
Abstract: The gradual guarantee is an important litmus test for gradually typed languages, that is, languages that enable a mixture of static and dynamic typing. The gradual guarantee states that changing the precision of a type annotation does not change the behavior of the program, except perhaps to trigger an error if the type annotation is incorrect. Siek et al. (2015) proved that the Gradually Typed Lambda Calculus (GTLC) satisfies the gradual guarantee using a simulation-based proof and mechanized their proof in Isabelle. In the following decade, researchers have proved the gradual guarantee for more sophisticated calculi, using step-indexed logical relations.  However, given the complexity of that style of proof, there has not yet been a mechanized proof of the gradual guarantee using step-indexed logical relations. This paper reports on a mechanized proof of the gradual guarantee for the GTLC carried out in the Agda proof assistant.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.03125v1</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.413.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 413, 2024, pp. 27-42</arxiv:journal_reference>
      <dc:creator>Jeremy G. Siek (Indiana University)</dc:creator>
    </item>
    <item>
      <title>Completing the Functional Approach in Object-Oriented Languages</title>
      <link>https://arxiv.org/abs/2412.03126</link>
      <description>arXiv:2412.03126v1 Announce Type: new 
Abstract: Over the last two decades practically all object-oriented programming languages have introduced features that are well-known from functional programming languages. But many features that were introduced were fragmentary. In Java-TX we address the latter features and propose a completion. Java-TX (i.e. Type eXtended) is a language based on Java. The predominant new features are global type inference and real function types for lambda expressions. Global type inference means that all type annotations can be omitted, and the compiler infers them without losing the static type property. We introduce the function types in a similar fashion as in Scala but additionally integrated them into the Java target-typing as proposed in the so-called strawman approach. In this paper, we provide an integrated presentation of all Java-TX features. The focus is therby on the automatic inference of type parameters for classes and their methods, and on the heterogeneous translation of function types, which permits the preservation of the argument and return types in bytecode.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.03126v1</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.413.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 413, 2024, pp. 43-56</arxiv:journal_reference>
      <dc:creator>Martin Pluemicke</dc:creator>
    </item>
    <item>
      <title>Massimult: A Novel Parallel CPU Architecture Based on Combinator Reduction</title>
      <link>https://arxiv.org/abs/2412.02765</link>
      <description>arXiv:2412.02765v1 Announce Type: cross 
Abstract: The Massimult project aims to design and implement an innovative CPU architecture based on combinator reduction with a novel combinator base and a new abstract machine. The evaluation of programs within this architecture is inherently highly parallel and localized, allowing for faster computation, reduced energy consumption, improved scalability, enhanced reliability, and increased resistance to attacks. In this paper, we introduce the machine language LambdaM, detail its compilation into KVY assembler code, and describe the abstract machine Matrima. The best part of Matrima is its ability to exploit inherent parallelism and locality in combinator reduction, leading to significantly faster computations with lower energy consumption, scalability across multiple processors, and enhanced security against various types of attacks. Matrima can be simulated as a software virtual machine and is intended for future hardware implementation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.02765v1</guid>
      <category>cs.DC</category>
      <category>cs.AR</category>
      <category>cs.PF</category>
      <category>cs.PL</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jurgen Nicklisch-Franken, Ruslan Feizerakhmanov</dc:creator>
    </item>
    <item>
      <title>Summa Summarum: Moessner's Theorem without Dynamic Programming</title>
      <link>https://arxiv.org/abs/2412.03127</link>
      <description>arXiv:2412.03127v1 Announce Type: cross 
Abstract: Seventy years on, Moessner's theorem and Moessner's process -- i.e., the additive computation of integral powers -- continue to fascinate. They have given rise to a variety of elegant proofs, to an implementation in hardware, to generalizations, and now even to a popular video, "The Moessner Miracle.'' The existence of this video, and even more its title, indicate that while the "what'' of Moessner's process is understood, its "how'' and even more its "why'' are still elusive. And indeed all the proofs of Moessner's theorem involve more complicated concepts than both the theorem and the process. This article identifies that Moessner's process implements an additive function with dynamic programming. A version of this implementation without dynamic programming (1) gives rise to a simpler statement of Moessner's theorem and (2) can be abstracted and then instantiated into related additive computations. The simpler statement also suggests a simpler and more efficient implementation to compute integral powers as well as simple additive functions to compute, e.g., Factorial numbers. It also reveals the source of -- to quote John Conway and Richard Guy -- Moessner's magic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.03127v1</guid>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SC</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.413.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 413, 2024, pp. 57-92</arxiv:journal_reference>
      <dc:creator>Olivier Danvy (National University of Singapore)</dc:creator>
    </item>
    <item>
      <title>Grounded Language Design for Lightweight Diagramming for Formal Methods</title>
      <link>https://arxiv.org/abs/2412.03310</link>
      <description>arXiv:2412.03310v1 Announce Type: cross 
Abstract: Model finding, as embodied by SAT solvers and similar tools, is used widely, both in embedding settings and as a tool in its own right. For instance, tools like Alloy target SAT to enable users to incrementally define, explore, verify, and diagnose sophisticated specifications for a large number of complex systems.
  These tools critically include a visualizer that lets users graphically explore these generated models. As we show, however, default visualizers, which know nothing about the domain, are unhelpful and even actively violate presentational and cognitive principles. At the other extreme, full-blown visualizations require significant effort as well as knowledge a specifier might not possess; they can also exhibit bad failure modes (including silent failure). Instead, we need a language to capture essential domain information for lightweight diagramming. We ground our language design in both the cognitive science literature on diagrams and on a large number of example custom visualizations. This identifies the key elements of lightweight diagrams. We distill these into a small set of orthogonal primitives. We extend an Alloy-like tool to support these primitives. We evaluate the effectiveness of the produced diagrams, finding them good for reasoning. We then compare this against many other drawing languages and tools to show that this work defines a new niche that is lightweight, effective, and driven by sound principles.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.03310v1</guid>
      <category>cs.CL</category>
      <category>cs.PL</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Siddhartha Prasad, Ben Greenman, Tim Nelson, Shriram Krishnamurthi</dc:creator>
    </item>
    <item>
      <title>String Diagrams for $\lambda$-calculi and Functional Computation</title>
      <link>https://arxiv.org/abs/2305.18945</link>
      <description>arXiv:2305.18945v3 Announce Type: replace-cross 
Abstract: This tutorial gives an advanced introduction to string diagrams and graph languages for higher-order computation. The subject matter develops in a principled way, starting from the two dimensional syntax of key categorical concepts such as functors, adjunctions, and strictification, and leading up to Cartesian Closed Categories, the core mathematical model of the lambda calculus and of functional programming languages. This methodology inverts the usual approach of proceeding from syntax to a categorical interpretation, by rationally reconstructing a syntax from the categorical model. The result is a graph syntax -- more precisely, a hierarchical hypergraph syntax -- which in many ways is shown to be an improvement over the conventional linear term syntax. The rest of the tutorial focuses on applications of interest to programming languages: operational semantics, general frameworks for type inference, and complex whole-program transformations such as closure conversion and automatic differentiation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.18945v3</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.CT</category>
      <pubDate>Thu, 05 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dan Ghica, Fabio Zanasi</dc:creator>
    </item>
  </channel>
</rss>
