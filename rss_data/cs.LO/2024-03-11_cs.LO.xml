<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Mar 2024 04:00:13 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 12 Mar 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Realizability in Semantics-Guided Synthesis Done Eagerly</title>
      <link>https://arxiv.org/abs/2403.05607</link>
      <description>arXiv:2403.05607v1 Announce Type: new 
Abstract: We present realizability and realization logic, two program logics that jointly address the problem of finding solutions in semantics-guided synthesis. What is new is that we proceed eagerly and not only analyze a single candidate program but a whole set. Realizability logic computes information about the set of candidate programs in a forward fashion. Realization logic uses this information as guidance to identify a suitable candidate in a backward fashion. Realizability logic is able to analyze a set of programs due to a new form of assertions that tracks synthesis alternatives. Realizability logic then picks alternatives to arrive at a program, and we give the guarantee that this process will not need backtracking. We show how to implement the program logics using verification conditions, and report on experiments with a prototype in the context of safe memory reclamation for lock-free data structures.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.05607v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Roland Meyer, Jakob Tepe, Sebastian Wolff</dc:creator>
    </item>
    <item>
      <title>Local Computing By Partial Quantifier Elimination</title>
      <link>https://arxiv.org/abs/2403.05928</link>
      <description>arXiv:2403.05928v1 Announce Type: new 
Abstract: Localization of computations plays a crucial role in solving hard problems efficiently. We will refer to the techniques implementing such localization as ${\mathit local}$ ${\mathit computing}$. We relate local computing with $\mathit{partial}$ $\mathit{quantifier}$ $\mathit{elimination}$ (PQE). The latter is a generalization of regular quantifier elimination where one can take a $\mathit{part}$ of the formula out of the scope of quantifiers. The objective of this paper is to show that PQE can be viewed as a language of local computing and hence building efficient PQE solvers is of great importance. We describe application of local computing by PQE to three different problems of hardware verification: property generation, equivalence checking and model checking. Besides, we discuss using local computing by PQE for SAT solving. Finally, we relate PQE and interpolation, a form of local computing.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.05928v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Eugene Goldberg</dc:creator>
    </item>
    <item>
      <title>mpbn: a simple tool for efficient edition and analysis of elementary properties of Boolean networks</title>
      <link>https://arxiv.org/abs/2403.06255</link>
      <description>arXiv:2403.06255v1 Announce Type: new 
Abstract: The tool mpbn offers a Python programming interface for an easy interactive editing of Boolean networks and the efficient computation of elementary properties of their dynamics, including fixed points, trap spaces, and reachability properties under the Most Permissive update mode. Relying on Answer-Set Programming logical framework, we show that mpbn is scalable to models with several thousands of nodes and is one of the best-performing tool for computing minimal and maximal trap spaces of Boolean networks, a key feature for understanding and controling their stable behaviors. The tool is available at https://github.com/bnediction/mpbn.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.06255v1</guid>
      <category>cs.LO</category>
      <category>math.DS</category>
      <category>q-bio.MN</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Van-Giang Trinh, Belaid Benhamou, Lo\"ic Paulev\'e</dc:creator>
    </item>
    <item>
      <title>Multiple Reachability in Linear Dynamical Systems</title>
      <link>https://arxiv.org/abs/2403.06515</link>
      <description>arXiv:2403.06515v1 Announce Type: new 
Abstract: We consider reachability decision problems for linear dynamical systems: Given a linear map on $\mathbb{R}^d$ , together with source and target sets, determine whether there is a point in the source set whose orbit, obtained by repeatedly applying the linear map, enters the target set. When the source and target sets are semialgebraic, this problem can be reduced to a point-to-polytope reachability question. The latter is generally believed not to be substantially harder than the well-known Skolem and Positivity Problems. The situation is markedly different for multiple reachability, i.e. the question of whether the orbit visits the target set at least m times, for some given positive integer m. In this paper, we prove that when the source set is semialgebraic and the target set consists of a hyperplane, multiple reachability is undecidable; in fact we already obtain undecidability in ambient dimension d = 10 and with fixed m = 9. Moreover, as we observe that procedures for dimensions 3 up to 9 would imply strong results pertaining to effective solutions of Diophantine equations, we mainly focus on the affine plane ($\mathbb{R}^2$). We obtain two main positive results. We show that multiple reachability is decidable for halfplane targets, and that it is also decidable for general semialgebraic targets, provided the linear map is a rotation. The latter result involves a new method, based on intersections of algebraic subgroups with subvarieties, due to Bombieri and Zannier.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.06515v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Toghrul Karimov, Edon Kelmendi, Jo\"el Ouaknine, James Worrell</dc:creator>
    </item>
    <item>
      <title>Local Intuitionistic Modal Logics and Their Calculi</title>
      <link>https://arxiv.org/abs/2403.06772</link>
      <description>arXiv:2403.06772v1 Announce Type: new 
Abstract: We investigate intuitionistic modal logics with locally interpreted $\square$ and $\lozenge$. The basic logic LIK is stronger than constructive modal logic WK and incomparable with intuitionistic modal logic IK. We propose an axiomatization of LIK and some of its extensions. We propose bi-nested calculi for LIK and these extensions, thus providing both a decision procedure and a procedure of finite countermodel extraction.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.06772v1</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Philippe Balbiani, Han Gao, \c{C}i\u{g}dem Gencer, Nicola Olivetti</dc:creator>
    </item>
    <item>
      <title>Are Targeted Messages More Effective?</title>
      <link>https://arxiv.org/abs/2403.06817</link>
      <description>arXiv:2403.06817v1 Announce Type: new 
Abstract: Graph neural networks (GNN) are deep learning architectures for graphs. Essentially, a GNN is a distributed message passing algorithm, which is controlled by parameters learned from data. It operates on the vertices of a graph: in each iteration, vertices receive a message on each incoming edge, aggregate these messages, and then update their state based on their current state and the aggregated messages. The expressivity of GNNs can be characterised in terms of certain fragments of first-order logic with counting and the Weisfeiler-Lehman algorithm.
  The core GNN architecture comes in two different versions. In the first version, a message only depends on the state of the source vertex, whereas in the second version it depends on the states of the source and target vertices. In practice, both of these versions are used, but the theory of GNNs so far mostly focused on the first one. On the logical side, the two versions correspond to two fragments of first-order logic with counting that we call modal and guarded.
  The question whether the two versions differ in their expressivity has been mostly overlooked in the GNN literature and has only been asked recently (Grohe, LICS'23). We answer this question here. It turns out that the answer is not as straightforward as one might expect. By proving that the modal and guarded fragment of first-order logic with counting have the same expressivity over labelled undirected graphs, we show that in a non-uniform setting the two GNN versions have the same expressivity. However, we also prove that in a uniform setting the second version is strictly more expressive.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.06817v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Martin Grohe, Eran Rosenbluth</dc:creator>
    </item>
    <item>
      <title>Measuring Robustness in Cyber-Physical Systems under Sensor Attacks</title>
      <link>https://arxiv.org/abs/2403.05829</link>
      <description>arXiv:2403.05829v1 Announce Type: cross 
Abstract: This paper contributes a formal framework for quantitative analysis of bounded sensor attacks on cyber-physical systems, using the formalism of differential dynamic logic. Given a precondition and postcondition of a system, we formalize two quantitative safety notions, quantitative forward and backward safety, which respectively express (1) how strong the strongest postcondition of the system is with respect to the specified postcondition, and (2) how strong the specified precondition is with respect to the weakest precondition of the system needed to ensure the specified postcondition holds. We introduce two notions, forward and backward robustness, to characterize the robustness of a system against sensor attacks as the loss of safety. To reason about robustness, we introduce two simulation distances, forward and backward simulation distances, which are defined based on the behavioral distances between the original system and the system with compromised sensors. Forward and backward distances, respectively, characterize upper bounds of the degree of forward and backward safety loss caused by the sensor attacks. We verify the two simulation distances by expressing them as modalities, i.e., formulas of differential dynamic logic, and develop an ad-hoc proof system to reason with such formulas. We showcase our formal notions and reasoning techniques on two non-trivial case studies: an autonomous vehicle that needs to avoid collision and a water tank system.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.05829v1</guid>
      <category>eess.SY</category>
      <category>cs.CR</category>
      <category>cs.ET</category>
      <category>cs.LO</category>
      <category>cs.SY</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jian Xiang, Ruggero Lanotte, Simone Tini, Stephen Chong, Massimo Merro</dc:creator>
    </item>
    <item>
      <title>Towards Multiphase Clocking in Single-Flux Quantum Systems</title>
      <link>https://arxiv.org/abs/2403.05884</link>
      <description>arXiv:2403.05884v1 Announce Type: cross 
Abstract: Rapid single-flux quantum (RSFQ) is one of the most advanced superconductive electronics technologies. SFQ systems operate at tens of gigahertz with up to three orders of magnitude smaller power as compared to CMOS. In conventional SFQ systems, most gates require clock signal. Each gate should have the fanins with equal logic depth, necessitating insertion of path-balancing (PB) DFFs, incurring prohibitive area penalty. Multiphase clocking is the effective method for reducing the path-balancing overhead at the cost of reduced throughput. However, existing tools are not directly applicable for technology mapping of multiphase systems. To overcome this limitation, in this work, we propose a technology mapping tool for multiphase systems. Our contribution is threefold. First, we formulate a phase assignment as a Constraint Programming with Satisfiability (CP-SAT) problem, to determine the phase of each element within the network. Second, we formulate the path balancing problem as a CP-SAT to optimize the number of DFFs within an asynchronous datapath. Finally, we integrate these methods into a technology mapping flow to convert a logic network into a multiphase SFQ circuit. In our case studies, by using seven phases, the size of the circuit (expressed as the number of Josephson junctions) is reduced, on average, by 59.94 % as compared to the dual (fast-slow) clocking method, while outperforming the state-of-the-art single-phase SFQ mapping tools.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.05884v1</guid>
      <category>cs.ET</category>
      <category>cs.LO</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Rassul Bairamkulov, Giovanni De Micheli</dc:creator>
    </item>
    <item>
      <title>Provability in BI's Sequent Calculus is Decidable</title>
      <link>https://arxiv.org/abs/2103.02343</link>
      <description>arXiv:2103.02343v5 Announce Type: replace 
Abstract: Warning: This paper contains a mistake, rendering the proof of the main theorem invalid. The logic of Bunched Implications (BI) combines both additive and multiplicative connectives, which include two primitive intuitionistic implications. As a consequence, contexts in the sequent presentation are not lists, nor multisets, but rather tree-like structures called bunches. This additional complexity notwithstanding, the logic has a well-behaved metatheory admitting all the familiar forms of semantics and proof systems. However, the presentation of an effective proof-search procedure has been elusive since the logic's debut. We show that one can reduce the proof-search space for any given sequent to a primitive recursive set, the argument generalizing Gentzen's decidability argument for classical propositional logic and combining key features of Dyckhoff's contraction-elimination argument for intuitionistic logic. An effective proof-search procedure, and hence decidability of provability, follows as a corollary.</description>
      <guid isPermaLink="false">oai:arXiv.org:2103.02343v5</guid>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <category>math.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander Gheorghiu, Simon Docherty, David Pym</dc:creator>
    </item>
    <item>
      <title>From Basic Proof-theoretic Validity to Base-extension Semantics for Intuitionistic Propositional Logic</title>
      <link>https://arxiv.org/abs/2210.05344</link>
      <description>arXiv:2210.05344v3 Announce Type: replace 
Abstract: Proof-theoretic semantics (P-tS) is the approach to meaning in logic based on proof (as opposed to truth). There are two major approaches to P-tS: proof-theor\-etic validity (P-tV) and base-extension semantics (B-eS). The former is a semantics of arguments, and the latter is a semantics of logical constants. This paper demonstrates that the B-eS for intuitionistic propositional logic (IPL) encapsulates the declarative content of a basic version of P-tV. Such relationships have been considered before yielding incompleteness results. This paper diverges from these approaches by accounting for the constructive, hypothetical setup of P-tV. It explicates how the B-eS for IPL works.</description>
      <guid isPermaLink="false">oai:arXiv.org:2210.05344v3</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alexander V. Gheorghiu, David J. Pym</dc:creator>
    </item>
    <item>
      <title>Quantitative Verification with Neural Networks</title>
      <link>https://arxiv.org/abs/2301.06136</link>
      <description>arXiv:2301.06136v3 Announce Type: replace 
Abstract: We present a data-driven approach to the quantitative verification of probabilistic programs and stochastic dynamical models. Our approach leverages neural networks to compute tight and sound bounds for the probability that a stochastic process hits a target condition within finite time. This problem subsumes a variety of quantitative verification questions, from the reachability and safety analysis of discrete-time stochastic dynamical models, to the study of assertion-violation and termination analysis of probabilistic programs. We rely on neural networks to represent supermartingale certificates that yield such probability bounds, which we compute using a counterexample-guided inductive synthesis loop: we train the neural certificate while tightening the probability bound over samples of the state space using stochastic optimisation, and then we formally check the certificate's validity over every possible state using satisfiability modulo theories; if we receive a counterexample, we add it to our set of samples and repeat the loop until validity is confirmed. We demonstrate on a diverse set of benchmarks that, thanks to the expressive power of neural networks, our method yields smaller or comparable probability bounds than existing symbolic methods in all cases, and that our approach succeeds on models that are entirely beyond the reach of such alternative techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2301.06136v3</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.CONCUR.2023.22</arxiv:DOI>
      <dc:creator>Alessandro Abate, Alec Edwards, Mirco Giacobbe, Hashan Punchihewa, Diptarko Roy</dc:creator>
    </item>
    <item>
      <title>Designing Equilibria in Concurrent Games with Social Welfare and Temporal Logic Constraints</title>
      <link>https://arxiv.org/abs/2306.03045</link>
      <description>arXiv:2306.03045v2 Announce Type: replace 
Abstract: In game theory, mechanism design is concerned with the design of incentives so that a desired outcome of the game can be achieved. In this paper, we explore the concept of equilibrium design, where incentives are designed to obtain a desirable equilibrium that satisfies a specific temporal logic property. Our study is based on a framework where system specifications are represented as temporal logic formulae, games as quantitative concurrent game structures, and players' goals as mean-payoff objectives. We consider system specifications given by LTL and GR(1) formulae, and show that designing incentives to ensure that a given temporal logic property is satisfied on some/every Nash equilibrium of the game can be achieved in PSPACE for LTL properties and in NP/{\Sigma}P 2 for GR(1) specifications. We also examine the complexity of related decision and optimisation problems, such as optimality and uniqueness of solutions, as well as considering social welfare, and show that the complexities of these problems lie within the polynomial hierarchy. Equilibrium design can be used as an alternative solution to rational synthesis and verification problems for concurrent games with mean-payoff objectives when no solution exists or as a technique to repair concurrent games with undesirable Nash equilibria in an optimal way.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.03045v2</guid>
      <category>cs.LO</category>
      <category>cs.GT</category>
      <category>cs.MA</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Julian Gutierrez, Muhammad Najib, Giuseppe Perelli, Michael Wooldridge</dc:creator>
    </item>
    <item>
      <title>Partial-order Checking with Unfolding for Linear Temporal Properties</title>
      <link>https://arxiv.org/abs/2306.10707</link>
      <description>arXiv:2306.10707v2 Announce Type: replace 
Abstract: Unfolding can tackle the path-explosion problem caused by concurrency. Traditional unfolding generation faces an NP-complete problem when adding events to the unfolding structure, which also exists in the case of verifying linear temporal logic (LTL). The reason is that it is necessary to enumerate possible concurrent event combinations after adding an event. Many state-of-the-art methods optimally explore unfolding-based structure (called event structure) by a tree-like structure, which should be constructed on the event structure with complete conflict and causal relations. However, a synchronization of a Petri net and the Buchi representation of LTL as a folded net can not represent complete conflict and causal relations. Thus, it is difficult to apply such a tree-like structure directly on the folded net. To resolve this difficulty, we propose a new method, called partial-order checking with unfolding, to verify LTL based on PDNet (program dependence net). We define an exploration tree with a new notion of delayed transitions, which is different from the existing tree-like structure. It improves the unfolding generation by avoiding all possible event combinations. Then, we propose an algorithm to simultaneously construct the exploration tree while generating the unfolding structure, as well as checking LTL. We implement a tool PUPER for concurrent programs with POSIX threads. It improves traditional unfolding generations via our exploration tree-based algorithms and shows better performance than SPIN and DiVine on the used benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.10707v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shuo Li, Liao Zheng, Zhijun Ding</dc:creator>
    </item>
    <item>
      <title>An Approximate Skolem Function Counter</title>
      <link>https://arxiv.org/abs/2312.12026</link>
      <description>arXiv:2312.12026v2 Announce Type: replace 
Abstract: One approach to probabilistic inference involves counting the number of models of a given Boolean formula. Here, we are interested in inferences involving higher-order objects, i.e., functions. We study the following task: Given a Boolean specification between a set of inputs and outputs, count the number of functions of inputs such that the specification is met. Such functions are called Skolem functions.
  We are motivated by the recent development of scalable approaches to Boolean function synthesis. This stands in relation to our problem analogously to the relationship between Boolean satisfiability and the model counting problem. Yet, counting Skolem functions poses considerable new challenges. From the complexity-theoretic standpoint, counting Skolem functions is not only #P-hard; it is quite unlikely to have an FPRAS (Fully Polynomial Randomized Approximation Scheme) as the problem of even synthesizing one Skolem function remains challenging, even given access to an NP oracle.
  The primary contribution of this work is the first algorithm, SkolemFC, that computes an estimate of the number of Skolem functions. SkolemFC relies on technical connections between counting functions and propositional model counting: our algorithm makes a linear number of calls to an approximate model counter and computes an estimate of the number of Skolem functions with theoretical guarantees. Moreover, we show that Skolem function count can be approximated through a polynomial number of calls to a SAT oracle. Our prototype displays impressive scalability, handling benchmarks comparably to state-of-the-art Skolem function synthesis engines, even though counting all such functions ostensibly poses a greater challenge than synthesizing a single function.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.12026v2</guid>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Arijit Shaw, Brendan Juba, Kuldeep S. Meel</dc:creator>
    </item>
    <item>
      <title>Rethinking the notion of oracle: A prequel to Lawvere-Tierney topologies for computability theorists</title>
      <link>https://arxiv.org/abs/2202.00188</link>
      <description>arXiv:2202.00188v4 Announce Type: replace-cross 
Abstract: We present three different perspectives of oracle. First, an oracle is a blackbox; second, an oracle is a tool to change the way we access mathematical objects; and third, an oracle is a factor that causes a change in truth values. Formally, the second perspective advocates that an oracle is an endofunctor on the category of coded sets (preserving underlying sets) -- we associate it with a universal closure operator. The third perspective advocates that an oracle is an operation on the object of truth values -- we associate it with a Lawvere-Tierney topology. These three perspectives create a link between the three fields, computability theory, synthetic descriptive set theory, and effective topos theory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2202.00188v4</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Takayuki Kihara</dc:creator>
    </item>
    <item>
      <title>Internal sums for synthetic fibered $(\infty,1)$-categories</title>
      <link>https://arxiv.org/abs/2205.00386</link>
      <description>arXiv:2205.00386v3 Announce Type: replace-cross 
Abstract: We give structural results about bifibrations of (internal) $(\infty,1)$-categories with internal sums. This includes a higher version of Moens' Theorem, characterizing cartesian bifibrations with extensive aka stable and disjoint internal sums over lex bases as Artin gluings of lex functors.
  We also treat a generalized version of Moens' Theorem due to Streicher which does not require the Beck--Chevalley condition.
  Furthermore, we show that also in this setting the Moens fibrations can be characterized via a condition due to Zawadowski.
  Our account overall follows Streicher's presentation of fibered category theory \`{a} la B\'{e}nabou, generalizing the results to the internal, higher-categorical case, formulated in a synthetic setting.
  Namely, we work inside simplicial homotopy type theory, which has been introduced by Riehl and Shulman as a logical system to reason about internal $(\infty,1)$-categories, interpreted as Rezk objects in any given Grothendieck--Rezk--Lurie $(\infty,1)$-topos.</description>
      <guid isPermaLink="false">oai:arXiv.org:2205.00386v3</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <category>math.AT</category>
      <category>math.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jonathan Weinberger</dc:creator>
    </item>
    <item>
      <title>Homotopy type theory as internal languages of diagrams of $\infty$-logoses</title>
      <link>https://arxiv.org/abs/2212.02444</link>
      <description>arXiv:2212.02444v2 Announce Type: replace-cross 
Abstract: We show that certain diagrams of $\infty$-logoses are reconstructed in internal languages of their oplax limits via lex, accessible modalities, which enables us to use plain homotopy type theory to reason about not only a single $\infty$-logos but also a diagram of $\infty$-logoses. This also provides a higher dimensional version of Sterling's synthetic Tait computability -- a type theory for higher dimensional logical relations. To prove the main result, we establish a precise correspondence between the lex, accessible localizations of an $\infty$-logos and the lex, accessible modalities in the internal language of the $\infty$-logos. To do this, we also partly develop the Kripke-Joyal semantics of homotopy type theory in $\infty$-logoses.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.02444v2</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <category>math.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Taichi Uemura</dc:creator>
    </item>
    <item>
      <title>DeepOnto: A Python Package for Ontology Engineering with Deep Learning</title>
      <link>https://arxiv.org/abs/2307.03067</link>
      <description>arXiv:2307.03067v2 Announce Type: replace-cross 
Abstract: Integrating deep learning techniques, particularly language models (LMs), with knowledge representation techniques like ontologies has raised widespread attention, urging the need of a platform that supports both paradigms. Although packages such as OWL API and Jena offer robust support for basic ontology processing features, they lack the capability to transform various types of information within ontologies into formats suitable for downstream deep learning-based applications. Moreover, widely-used ontology APIs are primarily Java-based while deep learning frameworks like PyTorch and Tensorflow are mainly for Python programming. To address the needs, we present DeepOnto, a Python package designed for ontology engineering with deep learning. The package encompasses a core ontology processing module founded on the widely-recognised and reliable OWL API, encapsulating its fundamental features in a more "Pythonic" manner and extending its capabilities to incorporate other essential components including reasoning, verbalisation, normalisation, taxonomy, projection, and more. Building on this module, DeepOnto offers a suite of tools, resources, and algorithms that support various ontology engineering tasks, such as ontology alignment and completion, by harnessing deep learning methods, primarily pre-trained LMs. In this paper, we also demonstrate the practical utility of DeepOnto through two use-cases: the Digital Health Coaching in Samsung Research UK and the Bio-ML track of the Ontology Alignment Evaluation Initiative (OAEI).</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.03067v2</guid>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yuan He, Jiaoyan Chen, Hang Dong, Ian Horrocks, Carlo Allocca, Taehun Kim, Brahmananda Sapkota</dc:creator>
    </item>
    <item>
      <title>The Weisfeiler-Leman Dimension of Conjunctive Queries</title>
      <link>https://arxiv.org/abs/2310.19006</link>
      <description>arXiv:2310.19006v2 Announce Type: replace-cross 
Abstract: The Weisfeiler-Leman (WL) dimension of a graph parameter $f$ is the minimum $k$ such that, if $G_1$ and $G_2$ are indistinguishable by the $k$-dimensional WL-algorithm then $f(G_1)=f(G_2)$. The WL-dimension of $f$ is $\infty$ if no such $k$ exists. We study the WL-dimension of graph parameters characterised by the number of answers from a fixed conjunctive query to the graph. Given a conjunctive query $\varphi$, we quantify the WL-dimension of the function that maps every graph $G$ to the number of answers of $\varphi$ in $G$.
  The works of Dvor\'ak (J. Graph Theory 2010), Dell, Grohe, and Rattan (ICALP 2018), and Neuen (ArXiv 2023) have answered this question for full conjunctive queries, which are conjunctive queries without existentially quantified variables. For such queries $\varphi$, the WL-dimension is equal to the treewidth of the Gaifman graph of $\varphi$.
  In this work, we give a characterisation that applies to all conjunctive qureies. Given any conjunctive query $\varphi$, we prove that its WL-dimension is equal to the semantic extension width $\mathsf{sew}(\varphi)$, a novel width measure that can be thought of as a combination of the treewidth of $\varphi$ and its quantified star size, an invariant introduced by Durand and Mengel (ICDT 2013) describing how the existentially quantified variables of $\varphi$ are connected with the free variables. Using the recently established equivalence between the WL-algorithm and higher-order Graph Neural Networks (GNNs) due to Morris et al. (AAAI 2019), we obtain as a consequence that the function counting answers to a conjunctive query $\varphi$ cannot be computed by GNNs of order smaller than $\mathsf{sew}(\varphi)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2310.19006v2</guid>
      <category>cs.DM</category>
      <category>cs.DB</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andreas G\"obel, Leslie Ann Goldberg, Marc Roth</dc:creator>
    </item>
    <item>
      <title>Robust Conformal Prediction for STL Runtime Verification under Distribution Shift</title>
      <link>https://arxiv.org/abs/2311.09482</link>
      <description>arXiv:2311.09482v2 Announce Type: replace-cross 
Abstract: Cyber-physical systems (CPS) designed in simulators behave differently in the real-world. Once they are deployed in the real-world, we would hence like to predict system failures during runtime. We propose robust predictive runtime verification (RPRV) algorithms under signal temporal logic (STL) tasks for general stochastic CPS. The RPRV problem faces several challenges: (1) there may not be sufficient data of the behavior of the deployed CPS, (2) predictive models are based on a distribution over system trajectories encountered during the design phase, i.e., there may be a distribution shift during deployment. To address these challenges, we assume to know an upper bound on the statistical distance (in terms of an f-divergence) between the distributions at deployment and design time, and we utilize techniques based on robust conformal prediction. Motivated by our results in [1], we construct an accurate and an interpretable RPRV algorithm. We use a trajectory prediction model to estimate the system behavior at runtime and robust conformal prediction to obtain probabilistic guarantees by accounting for distribution shifts. We precisely quantify the relationship between calibration data, desired confidence, and permissible distribution shift. To the best of our knowledge, these are the first statistically valid algorithms under distribution shift in this setting. We empirically validate our algorithms on a Franka manipulator within the NVIDIA Isaac sim environment.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.09482v2</guid>
      <category>eess.SY</category>
      <category>cs.LO</category>
      <category>cs.RO</category>
      <category>cs.SY</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yiqi Zhao, Bardh Hoxha, Georgios Fainekos, Jyotirmoy V. Deshmukh, Lars Lindemann</dc:creator>
    </item>
    <item>
      <title>Sound and Complete Witnesses for Template-based Verification of LTL Properties on Polynomial Programs</title>
      <link>https://arxiv.org/abs/2403.05386</link>
      <description>arXiv:2403.05386v2 Announce Type: replace-cross 
Abstract: In this work, we study the classical problem of verifying programs with respect to formal specifications given in the linear temporal logic (LTL). LTL is a rich and expressive logic that can specify important properties of programs. This includes, but is not limited to, termination, safety, liveness, progress, recurrence and reach-avoid properties. We first present novel sound and complete witnesses for LTL verification over imperative programs. Our witnesses are applicable to both universal (all runs) and existential (some run) settings. We then consider polynomial arithmetic programs, i.e. programs in which every assignment and guard consists only of polynomial expressions, with specifications as LTL formulas in which atomic propositions are polynomial constraints. For this setting, we provide an efficient algorithm to automatically synthesize such LTL witnesses. Our synthesis procedure is both sound and semi-complete, i.e. complete for any fixed polynomial degree in the templates. In other words, we provide the first template-based approach for polynomial programs that can handle any LTL formula as its specification. Our approach has termination guarantees with sub-exponential time complexity and generalizes and unifies previous methods for termination, safety and reachability, since they are expressible in LTL. Finally, we present experimental results demonstrating the effectiveness of our approach and that it can handle programs which were beyond the reach of previous state-of-the-art tools.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.05386v2</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Krishnendu Chatterjee, Amir Kafshdar Goharshady, Ehsan Kafshdar Goharshady, Mehrdad Karrabi, {\DJ}or{\dj}e \v{Z}ikeli\'c</dc:creator>
    </item>
  </channel>
</rss>
