<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Jul 2025 04:01:12 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Who Wins the Multi-Structural Game?</title>
      <link>https://arxiv.org/abs/2507.18718</link>
      <description>arXiv:2507.18718v1 Announce Type: new 
Abstract: Combinatorial games played between two players, called Spoiler and Duplicator, have often been used to capture syntactic properties of formal logical languages. For instance, the widely used Ehrenfeucht-Fra\"iss\'e (EF) game captures the syntactic measure of quantifier rank of first-order formulas. For every such game, there is an associated natural decision problem: "given an instance of the game, does Spoiler win the game on that instance?" For EF games, this problem was shown to be PSPACE-complete by Pezzoli in 1998. In this present paper, we show that the same problem for the *multi-structural* (MS) games of recent interest is PSPACE-hard, but contained in NEXPTIME. In the process, we also resolve an open problem posed by Pezzoli about the dependence of the hardness results for EF games on the arity of the schema under consideration. Our techniques combine adaptations of Pezzoli's constructions together with insights from the theory of inapproximability of optimization problems, as well as the recently developed technique of parallel play for MS games.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.18718v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ronald Fagin, Neil Immerman, Phokion Kolaitis, Jonathan Lenchner, Rik Sengupta</dc:creator>
    </item>
    <item>
      <title>Higher-order Kripke models for intuitionistic and non-classical modal logics</title>
      <link>https://arxiv.org/abs/2507.18798</link>
      <description>arXiv:2507.18798v1 Announce Type: new 
Abstract: This paper introduces higher-order Kripke models, a generalization of standard Kripke models that is remarkably close to Kripke's original idea - both mathematically and conceptually. Standard Kripke models are now considered $0$-ary models, whereas an $n$-ary model for $n &gt; 0$ is a model whose set of objects (''possible worlds'') contains only $(n-1)$-ary Kripke models. Models with infinitely many layers are also considered. This framework is obtained by promoting a radical change of perspective in how modal semantics for non-classical logics are defined: just like classical modalities are obtained through use of an accessibility relation between classical propositional models, non-classical modalities are now obtained through use of an accessibility relation between non-classical propositional models (even when they are Kripke models already). The paper introduces the new models after dealing specifically with the case of intuitionistic modal logic. It is shown that, depending on which intuitionistic $0$-ary propositional models are allowed, we may obtain $1$-ary models equivalent to either birelational models for $IK$ or for a new logic called $MK$. Those $1$-ary models have an intuitive reading that adds to the interpretation of intuitionistic models in terms of ''timelines'' the concept of ''alternative timelines''. More generally, the $1$-ary models can be read as defining a concept of ''alternative'' for any substantive interpretation of the $0$-ary models. The semantic clauses for necessity and possibility of $MK$ are also modular and can be used to obtain similar modal semantics for every non-classical logic, each of which can be provided with a similar intuitive reading. After intuitionistic modal logic is dealt with, the general structure of High-order Kripke Models and some of its variants are defined, and a series of conjectures about their properties are stated.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.18798v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Victor Barroso-Nascimento</dc:creator>
    </item>
    <item>
      <title>A Proof of the Schr\"oder-Bernstein Theorem in ACL2</title>
      <link>https://arxiv.org/abs/2507.19008</link>
      <description>arXiv:2507.19008v1 Announce Type: new 
Abstract: The Schr\"oder-Bernstein theorem states that, for any two sets P and Q, if there exists an injection from P to Q and an injection from Q to P, then there must exist a bijection between the two sets. Classically, it follows that the ordering of the cardinal numbers is antisymmetric. We describe a formulation and verification of the Schr\"oder-Bernstein theorem in ACL2 following a well-known proof, introducing a theory of chains to define a non-computable witness.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19008v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 36-45</arxiv:journal_reference>
      <dc:creator>Grant Jurgensen (Kestrel Institute)</dc:creator>
    </item>
    <item>
      <title>RV32I in ACL2</title>
      <link>https://arxiv.org/abs/2507.19009</link>
      <description>arXiv:2507.19009v1 Announce Type: new 
Abstract: We present a simple ACL2 simulator for the RISC-V 32-bit base instruction set architecture, written in the operational semantics style. Like many other ISA models, our RISC-V state object is a single-threaded object and we prove read-over-write, write-over-write, writing-the-read, and state well-formedness theorems. Unlike some other models, we separate the instruction decoding functions from their semantic counterparts. Accordingly, we verify encoding / decoding functions for each RV32I instruction, the proofs for which are entirely automatic. </description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19009v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 46-50</arxiv:journal_reference>
      <dc:creator>Carl Kwan (The University of Texas at Austin)</dc:creator>
    </item>
    <item>
      <title>On Automating Proofs of Multiplier Adder Trees using the RTL Books</title>
      <link>https://arxiv.org/abs/2507.19010</link>
      <description>arXiv:2507.19010v1 Announce Type: new 
Abstract: We present an experimental, verified clause processor ctv-cp that fits into the framework used at Arm for formal verification of arithmetic hardware designs. This largely automates the ACL2 proof development effort for integer multiplier modules that exist in designs ranging from floating-point division to matrix multiplication.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19010v1</guid>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 51-55</arxiv:journal_reference>
      <dc:creator>Mayank Manjrekar (Arm Inc.)</dc:creator>
    </item>
    <item>
      <title>A Formalization of the Yul Language and Some Verified Yul Code Transformations</title>
      <link>https://arxiv.org/abs/2507.19012</link>
      <description>arXiv:2507.19012v1 Announce Type: new 
Abstract: Yul is an intermediate language used in the compilation of the Solidity programming language for Ethereum smart contracts. The compiler applies customizable sequences of transformations to Yul code. To help ensure the correctness of these transformations and their sequencing, we used the ACL2 theorem prover to develop a formalization of the syntax and semantics of Yul, proofs relating static and dynamic semantics, a formalization of some Yul code transformations, and correctness proofs for these transformations.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19012v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.8</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 65-83</arxiv:journal_reference>
      <dc:creator>Alessandro Coglio (Kestrel Institute), Eric McCarthy (Kestrel Institute)</dc:creator>
    </item>
    <item>
      <title>A Formalization of the Correctness of the Floodsub Protocol</title>
      <link>https://arxiv.org/abs/2507.19013</link>
      <description>arXiv:2507.19013v1 Announce Type: new 
Abstract: Floodsub is a simple, robust and popular peer-to-peer publish/subscribe (pubsub) protocol, where nodes can arbitrarily leave or join the network, subscribe to or unsubscribe from topics  and forward newly received messages to all of their neighbors, except the sender or the originating peer. To show the correctness of Floodsub, we propose its specification: Broadcastsub, in which implementation details like network connections and neighbor subscriptions are elided. To show that Floodsub does really implement Broadcastsub, one would have to show that the two systems have related infinite computations. We prove this by reasoning locally about states and their successors using Well-Founded Simulation (WFS). In this paper, we focus on the mechanization of a proof which shows that Floodsub is a simulation refinement of Broadcastsub using WFS. To the best of our knowledge, ours is the first mechanized refinement-based verification of a real world pubsub protocol. </description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19013v1</guid>
      <category>cs.LO</category>
      <category>cs.NI</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.9</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 84-103</arxiv:journal_reference>
      <dc:creator>Ankit Kumar (Northeastern University), Panagiotis Manolios (Northeastern University)</dc:creator>
    </item>
    <item>
      <title>An ACL2s Interface to Z3</title>
      <link>https://arxiv.org/abs/2507.19014</link>
      <description>arXiv:2507.19014v1 Announce Type: new 
Abstract: We present Lisp-Z3, an extension to the ACL2s systems programming framework (ASPF) that supports the use of the Z3 satisfiability modulo theories (SMT) solver. Lisp-Z3 allows one to develop tools written using the full feature set of Common Lisp that can use both ACL2/s (either ACL2 or ACL2s) and Z3 as services, combining the power of SMT and interactive theorem proving. Lisp-Z3 is usable by anyone who would like to interact with Z3 from Common Lisp, as it does not depend on the availability of ACL2/s. We discuss the use of Lisp-Z3 in three applications. The first is a Sudoku solver.  The second is SeqSolve, a string solver which solved a larger number of benchmark problems more quickly than any other existing solver at the time of its publishing. Finally, Lisp-Z3 was also used in the context of hardware-in-the-loop fuzzing of wireless routers, where low latency was an important goal. The latter two applications leveraged the ability of Lisp-Z3 to integrate Z3 with ACL2s code. We have further plans to use Lisp-Z3 inside of ACL2s to provide more powerful automated support for dependent types, and in particular more efficient generation of counterexamples to properties involving dependent types.  This paper describes the usage and implementation of Lisp-Z3, as well as an evaluation of its use in the aforementioned applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19014v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.10</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 104-123</arxiv:journal_reference>
      <dc:creator>Andrew T. Walter (Northeastern University), Panagiotis Manolios (Northeastern University)</dc:creator>
    </item>
    <item>
      <title>A CASP-based Solution for Traffic Signal Optimisation</title>
      <link>https://arxiv.org/abs/2507.19061</link>
      <description>arXiv:2507.19061v1 Announce Type: new 
Abstract: In the context of urban traffic control, traffic signal optimisation is the problem of determining the optimal green length for each signal in a set of traffic signals. The literature has effectively tackled such a problem, mostly with automated planning techniques leveraging the PDDL+ language and solvers. However, such language has limitations when it comes to specifying optimisation statements and computing optimal plans. In this paper, we provide an alternative solution to the traffic signal optimisation problem based on Constraint Answer Set Programming (CASP). We devise an encoding in a CASP language, which is then solved by means of clingcon 3, a system extending the well-known ASP solver clingo. We performed experiments on real historical data from the town of Huddersfield in the UK, comparing our approach to the PDDL+ model that obtained the best results for the considered benchmark. The results showed the potential of our approach for tackling the traffic signal optimisation problem and improving the solution quality of the PDDL+ plans.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19061v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alice Tarzariol, Marco Maratea, Mauro Vallati</dc:creator>
    </item>
    <item>
      <title>Transfinite Fixed Points in Alpay Algebra as Ordinal Game Equilibria in Dependent Type Theory</title>
      <link>https://arxiv.org/abs/2507.19245</link>
      <description>arXiv:2507.19245v1 Announce Type: new 
Abstract: This paper contributes to the Alpay Algebra by demonstrating that the stable outcome of a self referential process, obtained by iterating a transformation through all ordinal stages, is identical to the unique equilibrium of an unbounded revision dialogue between a system and its environment. The analysis initially elucidates how classical fixed point theorems guarantee such convergence in finite settings and subsequently extends the argument to the transfinite domain, relying upon well founded induction and principles of order theoretic continuity.
  Furthermore, the resulting transordinal fixed point operator is embedded into dependent type theory, a formalization which permits every step of the transfinite iteration and its limit to be verified within a modern proof assistant. This procedure yields a machine checked proof that the iterative dialogue necessarily stabilizes and that its limit is unique. The result provides a foundation for Alpay's philosophical claim of semantic convergence within the framework of constructive logic. By unifying concepts from fixed point theory, game semantics, ordinal analysis, and type theory, this research establishes a broadly accessible yet formally rigorous foundation for reasoning about infinite self referential systems and offers practical tools for certifying their convergence within computational environments.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19245v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Faruk Alpay, Bugra Kilictas, Taylan Alpay</dc:creator>
    </item>
    <item>
      <title>Order in Partial Markov Categories</title>
      <link>https://arxiv.org/abs/2507.19424</link>
      <description>arXiv:2507.19424v1 Announce Type: new 
Abstract: Partial Markov categories are a recent framework for categorical probability theory, providing an abstract account of partial probabilistic computation. In this article, we discuss two order relations on the morphisms of a partial Markov category. In particular, we prove that every partial Markov category is canonically enriched over the category of preordered sets and monotone maps. We show that our construction recovers several well-known order enrichments. We also demonstrate that the existence of codiagonal maps (comparators) is closely related to order properties of partial Markov categories. We propose a synthetic version of the Cauchy-Schwarz inequality to facilitate inequational reasoning in partial Markov categories. We apply this new axiom to prove that updating a prior distribution with an evidence predicate increases the likelihood of the evidence in the posterior.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19424v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Elena Di Lavore, Mario Rom\'an, Pawe{\l} Soboci\'nski, M\'ark Sz\'eles</dc:creator>
    </item>
    <item>
      <title>An Enumerative Embedding of the Python Type System in ACL2s</title>
      <link>https://arxiv.org/abs/2507.19015</link>
      <description>arXiv:2507.19015v1 Announce Type: cross 
Abstract: Python is a high-level interpreted language that has become an industry standard in a wide variety of applications. In this paper, we take a first step towards using ACL2s to reason about Python code by developing an embedding of a subset of the Python type system in ACL2s. The subset of Python types we support includes many of the most commonly used type annotations as well as user-defined types comprised of supported types. We provide ACL2s definitions of these types, as well as defdata enumerators that are customized to provide code coverage and identify errors in Python programs. Using the ACL2s embedding, we can generate instances of types that can then be used as inputs to fuzz Python programs, which allows us to identify bugs in Python code that are not detected by state-of-the-art Python type checkers. We evaluate our work against four open-source repositories, extracting their type information and generating inputs for fuzzing functions with type signatures that are in the supported subset of Python types. Note that we only use the type signatures of functions to generate inputs and treat the bodies of functions as black boxes. We measure code coverage, which ranges from about 68% to more than 80%, and identify code patterns that hinder coverage such as complex branch conditions and external file system dependencies. We conclude with a discussion of the results and recommendations for future work.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19015v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.11</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 124-144</arxiv:journal_reference>
      <dc:creator>Samuel Xifaras (Northeastern University), Panagiotis Manolios (Northeastern University), Andrew T. Walter (Northeastern University), William Robertson (Northeastern University)</dc:creator>
    </item>
    <item>
      <title>Faster Lifting for Ordered Domains with Predecessor Relations</title>
      <link>https://arxiv.org/abs/2507.19182</link>
      <description>arXiv:2507.19182v1 Announce Type: cross 
Abstract: We investigate lifted inference on ordered domains with predecessor relations, where the elements of the domain respect a total (cyclic) order, and every element has a distinct (clockwise) predecessor. Previous work has explored this problem through weighted first-order model counting (WFOMC), which computes the weighted sum of models for a given first-order logic sentence over a finite domain. In WFOMC, the order constraint is typically encoded by the linear order axiom introducing a binary predicate in the sentence to impose a linear ordering on the domain elements. The immediate and second predecessor relations are then encoded by the linear order predicate. Although WFOMC with the linear order axiom is theoretically tractable, existing algorithms struggle with practical applications, particularly when the predecessor relations are involved. In this paper, we treat predecessor relations as a native part of the axiom and devise a novel algorithm that inherently supports these relations. The proposed algorithm not only provides an exponential speedup for the immediate and second predecessor relations, which are known to be tractable, but also handles the general k-th predecessor relations. The extensive experiments on lifted inference tasks and combinatorics math problems demonstrate the efficiency of our algorithm, achieving speedups of a full order of magnitude.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.19182v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Kuncheng Zou, Jiahao Mai, Yonggang Zhang, Yuyi Wang, Ond\v{r}ej Ku\v{z}elka, Yuanhong Wang, Yi Chang</dc:creator>
    </item>
    <item>
      <title>Boolean basis, formula size, and number of modal operators</title>
      <link>https://arxiv.org/abs/2408.11651</link>
      <description>arXiv:2408.11651v4 Announce Type: replace 
Abstract: Is it possible to write significantly smaller formulae when using Boolean operators other than those of the De Morgan basis (and, or, not, and the constants)? For propositional logic, a negative answer was given by Pratt: formulae over one set of operators can always be translated into an equivalent formula over any other complete set of operators with only polynomial increase in size. Surprisingly, for modal logic the picture is different: we show that elimination of bi-implication is only possible at the cost of an exponential number of occurrences of the modal operator $\lozenge$ and therefore of an exponential increase in formula size, i.e., the De Morgan basis and its extension by bi-implication differ in succinctness. Moreover, we prove that any complete set of Boolean operators agrees in succinctness with the De Morgan basis or with its extension by bi-implication. More precisely, these results are shown for the modal logic $\mathrm{T}$ (and therefore for $\mathrm{K}$). We complement them showing that the modal logic $\mathrm{S5}$ behaves as propositional logic: the choice of Boolean operators has no significant impact on the size of formulae.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.11651v4</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christoph Berkholz, Dietrich Kuske, Christian Schwarz</dc:creator>
    </item>
    <item>
      <title>Optimally Rewriting Formulas and Database Queries: A Confluence of Term Rewriting, Structural Decomposition, and Complexity</title>
      <link>https://arxiv.org/abs/2411.10229</link>
      <description>arXiv:2411.10229v2 Announce Type: replace 
Abstract: A central computational task in database theory, finite model theory, and computer science at large is the evaluation of a first-order sentence on a finite structure. In the context of this task, the \emph{width} of a sentence, defined as the maximum number of free variables over all subformulas, has been established as a crucial measure, where minimizing width of a sentence (while retaining logical equivalence) is considered highly desirable. An undecidability result rules out the possibility of an algorithm that, given a first-order sentence, returns a logically equivalent sentence of minimum width; this result motivates the study of width minimization via syntactic rewriting rules, which is this article's focus. For a number of common rewriting rules (which are known to preserve logical equivalence), including rules that allow for the movement of quantifiers, we present an algorithm that, given a positive first-order sentence $\phi$, outputs the minimum-width sentence obtainable from $\phi$ via application of these rules. We thus obtain a complete algorithmic understanding of width minimization up to the studied rules; this result is the first one -- of which we are aware -- that establishes this type of understanding in such a general setting. Our result builds on the theory of term rewriting and establishes an interface among this theory, query evaluation, and structural decomposition theory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.10229v2</guid>
      <category>cs.LO</category>
      <category>cs.DB</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hubie Chen, Stefan Mengel</dc:creator>
    </item>
    <item>
      <title>Towards Bug-Free Distributed Go Programs</title>
      <link>https://arxiv.org/abs/2506.15135</link>
      <description>arXiv:2506.15135v2 Announce Type: replace-cross 
Abstract: Programmers of distributed systems need to reason about concurrency to avoid races. However, reasoning about concurrency is difficult, and unexpected races show up as bugs. Data race detection in shared memory systems is well-studied (dynamic data race detection [13], behavioral types [15], dynamic race detection [31]). Similar to how a data race consists of reads and writes not related by happens-before at a shared memory location, a communication race consists of receives and sends not related by happens-before on a shared channel. Communication races are problematic: a receiver expects a specific message from a specific sender, but with a communication race, the receiver can receive a message meant for another receiver, or not receive anything at all. In this work, we describe a verification framework that can prove the absence of communication races for distributed programs that use a subset of the Go programming language, where synchronization is mainly achieved via message passing. We statically reason about how a distributed program executes, using a happens-before order, extended to buffered and unbuffered channels.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.15135v2</guid>
      <category>cs.SE</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Mon, 28 Jul 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Zhengqun Koo</dc:creator>
    </item>
  </channel>
</rss>
