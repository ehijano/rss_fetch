<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Aug 2025 04:03:04 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>CASP: An evaluation dataset for formal verification of C code</title>
      <link>https://arxiv.org/abs/2508.18798</link>
      <description>arXiv:2508.18798v1 Announce Type: new 
Abstract: Recent developments in Large Language Models (LLMs) have shown promise in automating code generation, yet the generated programs lack rigorous correctness guarantees. Formal verification can address this shortcoming, but requires expertise and is time-consuming to apply. Currently, there is no dataset of verified C code paired with formal specifications that enables systematic benchmarking in this space. To fill this gap, we present a curated evaluation dataset of C code paired with formal specifications written in ANSI/ISO C Specification Language (ACSL). We develop a multi-stage filtering process to carefully extract 506 pairs of C code and formal specifications from The Stack 1 and The Stack 2. We first identify C files annotated with formal languages. Then, we ensure that the annotated C files formally verify, and employ LLMs to improve non-verifying files. Furthermore, we post-process the remaining files into pairs of C code and ACSL specifications, where each specification-implementation pair is formally verified using Frama-C. To ensure the quality of the pairs, a manual inspection is conducted to confirm the correctness of every pair. The resulting dataset of C-ACSL specification pairs (CASP) provides a foundation for benchmarking and further research on integrating automated code generation with verified correctness.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.18798v1</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Niclas Hertzberg, Merlijn Sevenhuijsen, Liv K{\aa}reborn, Anna Lokrantz</dc:creator>
    </item>
    <item>
      <title>AS2FM: Enabling Statistical Model Checking of ROS 2 Systems for Robust Autonomy</title>
      <link>https://arxiv.org/abs/2508.18820</link>
      <description>arXiv:2508.18820v1 Announce Type: cross 
Abstract: Designing robotic systems to act autonomously in unforeseen environments is a challenging task. This work presents a novel approach to use formal verification, specifically Statistical Model Checking (SMC), to verify system properties of autonomous robots at design-time. We introduce an extension of the SCXML format, designed to model system components including both Robot Operating System 2 (ROS 2) and Behavior Tree (BT) features. Further, we contribute Autonomous Systems to Formal Models (AS2FM), a tool to translate the full system model into JANI. The use of JANI, a standard format for quantitative model checking, enables verification of system properties with off-the-shelf SMC tools. We demonstrate the practical usability of AS2FM both in terms of applicability to real-world autonomous robotic control systems, and in terms of verification runtime scaling. We provide a case study, where we successfully identify problems in a ROS 2-based robotic manipulation use case that is verifiable in less than one second using consumer hardware. Additionally, we compare to the state of the art and demonstrate that our method is more comprehensive in system feature support, and that the verification runtime scales linearly with the size of the model, instead of exponentially.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.18820v1</guid>
      <category>cs.RO</category>
      <category>cs.FL</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Christian Henkel, Marco Lampacrescia, Michaela Klauck, Matteo Morelli</dc:creator>
    </item>
    <item>
      <title>Real-Time Model Checking for Closed-Loop Robot Reactive Planning</title>
      <link>https://arxiv.org/abs/2508.19186</link>
      <description>arXiv:2508.19186v1 Announce Type: cross 
Abstract: We present a new application of model checking which achieves real-time multi-step planning and obstacle avoidance on a real autonomous robot. We have developed a small, purpose-built model checking algorithm which generates plans in situ based on "core" knowledge and attention as found in biological agents. This is achieved in real-time using no pre-computed data on a low-powered device. Our approach is based on chaining temporary control systems which are spawned to counteract disturbances in the local environment that disrupt an autonomous agent from its preferred action (or resting state). A novel discretization of 2D LiDAR data sensitive to bounded variations in the local environment is used. Multi-step planning using model checking by forward depth-first search is applied to cul-de-sac and playground scenarios. Both empirical results and informal proofs of two fundamental properties of our approach demonstrate that model checking can be used to create efficient multi-step plans for local obstacle avoidance, improving on the performance of a reactive agent which can only plan one step. Our approach is an instructional case study for the development of safe, reliable and explainable planning in the context of autonomous vehicles.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.19186v1</guid>
      <category>cs.RO</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christopher Chandler, Bernd Porr, Giulia Lafratta, Alice Miller</dc:creator>
    </item>
    <item>
      <title>Enumeration for MSO-Queries on Compressed Trees</title>
      <link>https://arxiv.org/abs/2403.03067</link>
      <description>arXiv:2403.03067v2 Announce Type: replace 
Abstract: We study the problem of enumerating the answers to a query formulated in monadic second order logic (MSO) over an unranked forest F that is compressed by a straight-line program (SLP) D. Our main result states that this can be done after O(|D|) preprocessing and with output-linear delay (in data complexity). This is a substantial improvement over the previously known algorithms for MSO-evaluation over trees, since the compressed size |D| might be much smaller than (or even logarithmic in) the actual data size |F|, and there are linear time SLP-compressors that yield very good compressions on practical inputs. In particular, this also constitutes a meta-theorem in the field of algorithmics on SLP-compressed inputs: all enumeration problems on trees or strings that can be formulated in MSO-logic can be solved with linear preprocessing and output-linear delay, even if the inputs are compressed by SLPs. We also show that our approach can support vertex relabelling updates in time that is logarithmic in the uncompressed data. Our result extends previous work on the enumeration of MSO-queries over uncompressed trees and on the enumeration of document spanners over compressed text documents.</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.03067v2</guid>
      <category>cs.FL</category>
      <category>cs.DB</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Markus Lohrey, Markus L. Schmid</dc:creator>
    </item>
    <item>
      <title>From LTL to COCOA without Detours</title>
      <link>https://arxiv.org/abs/2410.01021</link>
      <description>arXiv:2410.01021v3 Announce Type: replace 
Abstract: Chains of co-Buechi automata (COCOA) have recently been introduced as a new canonical representation of omega-regular languages. The co-Buechi automata in a chain assign to each omega-word its natural color, which depends only on the language itself and not on its automaton representation. The automata in such a chain can be minimized in polynomial time and are good-for-games, making the representation attractive for verification and reactive synthesis applications. However, since in such applications, a specification is usually given in linear temporal logic (LTL), to make COCOA useful, the specification first has to be translated into such a chain of automata. Currently, the only known translation procedure involves a detour through deterministic parity automata (LTL to DPW to COCOA), where the first step neglects the natural colors and requires intricate constructions by Safra or Esparza et al. This observation raises the question whether, by leveraging the definition of the natural color of words, these complex constructions can be avoided, leading to a more direct translation from LTL to COCOA.
  This paper presents a surprisingly simple yet optimal translation from LTL to COCOA. Our procedure relies on standard operations on weak alternating automata, Miyano-Hayashi's breakpoint construction, an augmented subset construction, and simple graph algorithms. With weak alternating automata as a starting point, the procedure can also handle specifications in linear dynamic logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.01021v3</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>R\"udiger Ehlers, Ayrat Khalimov</dc:creator>
    </item>
    <item>
      <title>Synthesizing DSLs for Few-Shot Learning</title>
      <link>https://arxiv.org/abs/2508.16063</link>
      <description>arXiv:2508.16063v2 Announce Type: replace-cross 
Abstract: We study the problem of synthesizing domain-specific languages (DSLs) for few-shot learning in symbolic domains. Given a base language and instances of few-shot learning problems, where each instance is split into training and testing samples, the DSL synthesis problem asks for a grammar over the base language that guarantees that small expressions solving training samples also solve corresponding testing samples. We prove that the problem is decidable for a class of languages whose semantics over fixed structures can be evaluated by tree automata and when expression size corresponds to parse tree depth in the grammar, and, furthermore, the grammars solving the problem correspond to a regular set of trees. We also prove decidability results for variants of the problem where DSLs are only required to express solutions for input learning problems and where DSLs are defined using macro grammars.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.16063v2</guid>
      <category>cs.PL</category>
      <category>cs.FL</category>
      <pubDate>Wed, 27 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1145/3763073</arxiv:DOI>
      <dc:creator>Paul Krogmeier, P. Madhusudan</dc:creator>
    </item>
  </channel>
</rss>
