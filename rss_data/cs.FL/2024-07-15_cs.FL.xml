<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Jul 2024 04:01:19 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 16 Jul 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Learning Weighted Finite Automata over the Max-Plus Semiring and its Termination</title>
      <link>https://arxiv.org/abs/2407.09775</link>
      <description>arXiv:2407.09775v1 Announce Type: new 
Abstract: Active learning of finite automata has been vigorously pursued for the purposes of analysis and explanation of black-box systems. In this paper, we study an L*-style learning algorithm for weighted automata over the max-plus semiring. The max-plus setting exposes a "consistency" issue in the previously studied semiring-generic extension of L*: we show that it can fail to maintain consistency of tables, and can thus make equivalence queries on obviously wrong hypothesis automata. We present a theoretical fix by a mathematically clean notion of column-closedness. We also present a nontrivial and reasonably broad class of weighted languages over the max-plus semiring in which our algorithm terminates.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.09775v1</guid>
      <category>cs.FL</category>
      <category>cs.LG</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Takamasa Okudono, Masaki Waga, Taro Sekiyama, Ichiro Hasuo</dc:creator>
    </item>
    <item>
      <title>Blow-up in Non-Deterministic Automata</title>
      <link>https://arxiv.org/abs/2407.09891</link>
      <description>arXiv:2407.09891v1 Announce Type: new 
Abstract: In this paper we examine the difficulty of finding an equivalent deterministic automaton when confronted with a non-deterministic one. While for some automata the exponential blow-up in their number of states is unavoidable, we show that in general, any approximation of state complexity with polynomial precision remains PSPACE-hard. The same is true when using the subset construction to determinize the NFA, meaning that it is PSPACE-hard to predict whether subset construction will produce an exponential ''blow-up'' in the number of states or not. To give an explanation for its behaviour, we propose the notion of subset complexity, which serves as an upper bound on the size of subset construction. Due to it simple and intuitive nature it allows to identify large classes of automata which can have limited non-determinism and completely avoid the ''blow-up''. Subset complexity also remains invariant under NFA reversal and allows to predict how the introduction or removal of transitions from the NFA will affect its size.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.09891v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Ivan Baburin, Ryan Cotterell</dc:creator>
    </item>
    <item>
      <title>On state complexity for subword-closed languages</title>
      <link>https://arxiv.org/abs/2407.10355</link>
      <description>arXiv:2407.10355v1 Announce Type: new 
Abstract: This paper investigates the state complexities of subword-closed and superword-closed languages, comparing them to regular languages. We focus on the square root operator and the substitution operator. We establish an exponential lower bound for superword-closed languages for the k-th root. For subword-closed languages we analyze in detail a specific instance of the square root problem for which a quadratic complexity is proven. For the substitution operator, we show an exponential lower bound for the general substitution. We then find some conditions for which we prove a quadratic upper bound.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.10355v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>J\'er\^ome Guyot</dc:creator>
    </item>
    <item>
      <title>Some Remarks on Palindromic Periodicities</title>
      <link>https://arxiv.org/abs/2407.10564</link>
      <description>arXiv:2407.10564v1 Announce Type: cross 
Abstract: We say a finite word $x$ is a palindromic periodicity if there exist two palindromes $p$ and $s$ such that $|x| \geq |ps|$ and $x$ is a prefix of the word $(ps)^\omega = pspsps\cdots$. In this paper we examine the palindromic periodicities occurring in some classical infinite words, such as Sturmian words, episturmian words, the Thue-Morse word, the period-doubling word, the Rudin-Shapiro word, the paperfolding word, and the Tribonacci word, and prove a number of results about them.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.10564v1</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gabriele Fici, Jeffrey Shallit, Jamie Simpson</dc:creator>
    </item>
    <item>
      <title>Decision Problems on Copying and Shuffling</title>
      <link>https://arxiv.org/abs/2302.06248</link>
      <description>arXiv:2302.06248v4 Announce Type: replace 
Abstract: We study decision problems of the form: given a regular or linear context-free language $L$, is there a word of a given fixed form in $L$, where given fixed forms are based on word operations copy, marked copy, shuffle and their combinations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.06248v4</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vesa Halava, Tero Harju, Dirk Nowotka, Esa Sahla</dc:creator>
    </item>
    <item>
      <title>SynCode: LLM Generation with Grammar Augmentation</title>
      <link>https://arxiv.org/abs/2403.01632</link>
      <description>arXiv:2403.01632v3 Announce Type: replace-cross 
Abstract: LLMs are widely used in complex AI applications. These applications underscore the need for LLM outputs to adhere to a specific format, for their integration with other components in the systems. Typically the format rules e.g., for data serialization formats such as JSON, YAML, or Code in Programming Language are expressed as context-free grammar (CFG). Due to the hallucinations and unreliability of LLMs, instructing LLMs to adhere to specified syntax becomes an increasingly important challenge.
  We present SynCode, a novel framework for efficient and general syntactical decoding with LLMs, to address this challenge. SynCode ensures soundness and completeness with respect to the CFG of a formal language, effectively retaining valid tokens while filtering out invalid ones. SynCode uses an offline-constructed, efficient lookup table, the DFA mask store, derived from the DFA of the language's grammar for efficient generation. SynCode seamlessly integrates with any language defined by CFG, as evidenced by experiments focusing on generating JSON, Python, and Go outputs. Our experiments evaluating the effectiveness of SynCode for JSON generation demonstrate that SynCode eliminates all syntax errors and significantly outperforms state-of-the-art baselines. Furthermore, our results underscore how SynCode significantly reduces 96.07% of syntax errors in generated Python and Go code, showcasing its substantial impact on enhancing syntactical precision in LLM generation. Our code is available at https://github.com/uiuc-focal-lab/syncode</description>
      <guid isPermaLink="false">oai:arXiv.org:2403.01632v3</guid>
      <category>cs.LG</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Shubham Ugare, Tarun Suresh, Hangoo Kang, Sasa Misailovic, Gagandeep Singh</dc:creator>
    </item>
  </channel>
</rss>
