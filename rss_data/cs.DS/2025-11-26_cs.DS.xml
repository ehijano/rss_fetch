<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Nov 2025 05:00:09 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>The Buffer Minimization Problem for Scheduling Flow Jobs with Conflicts</title>
      <link>https://arxiv.org/abs/2511.19690</link>
      <description>arXiv:2511.19690v1 Announce Type: new 
Abstract: We consider the online buffer minimization in multiprocessor systems with conflicts problem (in short, the buffer minimization problem) in the recently introduced flow model. In an online fashion, workloads arrive on some of the $n$ processors and are stored in an input buffer. Processors can run and reduce these workloads, but conflicts between pairs of processors restrict simultaneous task execution. Conflicts are represented by a graph, where vertices correspond to processors and edges indicate conflicting pairs. An online algorithm must decide which processors are run at a time; so provide a valid schedule respecting the conflict constraints.
  The objective is to minimize the maximal workload observed across all processors during the schedule. Unlike the original model, where workloads arrive as discrete blocks at specific time points, the flow model assumes workloads arrive continuously over intervals or not at all. We present tight bounds for all graphs with four vertices (except the path, which has been solved previously) and for the families of general complete graphs and complete bipartite graphs. We also recover almost tight bounds for complete $k$-partite graphs.
  For the original model, we narrow the gap for the graph consisting of a triangle and an additional edge to a fourth vertex.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.19690v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Niklas Haas, S\"oren Schmitt, Rob van Stee</dc:creator>
    </item>
    <item>
      <title>Greedy Algorithms for Shortcut Sets and Hopsets</title>
      <link>https://arxiv.org/abs/2511.20111</link>
      <description>arXiv:2511.20111v1 Announce Type: new 
Abstract: We explore the power of greedy algorithms for hopsets and shortcut sets. In particular, we propose simple greedy algorithms that, given an input graph $G$ and a parameter $\beta$, compute a shortcut set or an exact hopset $H$ of hopbound at most $\beta$, and we prove the following guarantees about the size $|H|$ of the output:
  For shortcut sets, we prove the bound $$|H| \le \tilde{O}\left( \frac{n^2}{\beta^3} + \frac{n^{3/2}}{\beta^{3/2}} \right).$$ This matches the current state-of-the-art upper bound by Kogan and Parter [SODA '22].
  For exact hopsets of $n$-node, $m$-edge weighted graphs, the size of the output hopset is existentially optimal up to subpolynomial factors, under some technical assumptions.
  Despite their simplicity and conceptual implications, these greedy algorithms are slower than existing sampling-based approaches. Our second set of results focus on faster deterministic algorithms that are based on a certain greedy set cover approximation algorithm on paths in the transitive closure. One consequence is a deterministic algorithm that takes $O(mn^{2/3})$ time to compute a shortcut set of size $\tilde{O}(n)$ and hopbound $O(n^{1/3})$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.20111v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ben Bals, Joakim Blikstad, Greg Bodwin, Daniel Dadush, Sebastian Forster, Yasamin Nazari</dc:creator>
    </item>
    <item>
      <title>Maintaining Bipartite Colourings on Temporal Graphs on a Budget</title>
      <link>https://arxiv.org/abs/2511.20338</link>
      <description>arXiv:2511.20338v1 Announce Type: new 
Abstract: Graph colouring is a fundamental problem for networks, serving as a tool for avoiding conflicts via symmetry breaking, for example, avoiding multiple computer processes simultaneously updating the same resource. This paper considers a generalisation of this problem to \emph{temporal graphs}, i.e., to graphs whose structure changes according to an ordered sequence of edge sets. In the simultaneous resource updating problem on temporal graphs, the resources which can be accessed will change, however, the necessity of symmetry breaking to avoid conflicts remains.
  In this paper, we focus on the problem of \emph{maintaining proper colourings} on temporal graphs in general, with a particular focus on bipartite colourings. Our aim is to minimise the total number of times that the vertices change colour, or, in the form of a decision problem, whether we can maintain a proper colouring by allowing not more colour changes than some given \emph{budget}. On the negative side, we show that, despite bipartite colouring being easy on static graphs, the problem of maintaining such a colouring on graphs that are bipartite in each snapshot is NP-Hard to even approximate within \emph{any} constant factor unless the Unique Games Conjecture fails. On the positive side, we provide an exact algorithm for a temporal graph with $n$ vertices, a lifetime $T$ and at most $k$ components in any given snapshot in $O(T \vert E \vert 2^{k} + n T 2^{2k})$ time, and an $O\left(\sqrt{\log(nT)}\right)$-factor approximation algorithm running in $\tilde{O}((nT)^3)$ time.
  Our results contribute to the structural complexity of networks that change with time with respect to a fundamental computational problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.20338v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Duncan Adamson, George B. Mertzios, Paul G. Spirakis</dc:creator>
    </item>
    <item>
      <title>Robust Algorithms for Finding Cliques in Random Intersection Graphs via Sum-of-Squares</title>
      <link>https://arxiv.org/abs/2511.20376</link>
      <description>arXiv:2511.20376v1 Announce Type: new 
Abstract: We study efficient algorithms for recovering cliques in dense random intersection graphs (RIGs). In this model, $d = n^{\Omega(1)}$ cliques of size approximately $k$ are randomly planted by choosing the vertices to participate in each clique independently with probability $\delta$. While there has been extensive work on recovering one, or multiple disjointly planted cliques in random graphs, the natural extension of this question to recovering overlapping cliques has been, surprisingly, largely unexplored. Moreover, because every vertex can be part of polynomially many cliques, this task is significantly harder than in case of disjointly planted cliques (as recently studied by Kothari, Vempala, Wein and Xu [COLT'23]) and manifests in the failure of simple combinatorial and even spectral algorithms.
  In this work we obtain the first efficient algorithms for recovering the community structure of RIGs both from the perspective of exact and approximate recovery. Our algorithms are further robust to noise, monotone adversaries, a certain, optimal number of edge corruptions, and work whenever $k \gg \sqrt{n \log(n)}$. Our techniques follow the proofs-to-algorithms framework utilizing the sum-of-squares hierarchy.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.20376v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Andreas G\"obel, Janosch Ruff, Leon Schiller</dc:creator>
    </item>
    <item>
      <title>Counting large patterns in degenerate graphs</title>
      <link>https://arxiv.org/abs/2511.20385</link>
      <description>arXiv:2511.20385v1 Announce Type: new 
Abstract: The problem of subgraph counting asks for the number of occurrences of a pattern graph $H$ as a subgraph of a host graph $G$ and is known to be computationally challenging: it is $\#W[1]$-hard even when $H$ is restricted to simple structures such as cliques or paths. Curticapean and Marx (FOCS'14) show that if the graph $H$ has vertex cover number $\tau$, subgraph counting has time complexity $O(|H|^{2^{O(\tau)}} |G|^{\tau + O(1)})$. This raises the question of whether this upper bound can be improved for input graphs $G$ from a restricted family of graphs. Earlier work by Eppstein~(IPL'94) shows that this is indeed possible, by proving that when $G$ is a $d$-degenerate graph and $H$ is a biclique of arbitrary size, subgraph counting has time complexity $O(d 3^{d/3} |G|)$. We show that if the input is restricted to $d$-degenerate graphs, the upper bound of Curticapean and Marx can be improved for a family of graphs $H$ that includes all bicliques and satisfies a property we call $(c,d)$-locatable. Importantly, our algorithm's running time only has a polynomial dependence on the size of~$H$. A key feature of $(c,d)$-locatable graphs $H$ is that they admit a vertex cover of size at most $cd$. We further characterize $(1,d)$-locatable graphs, for which our algorithms achieve a linear running time dependence on $|G|$, and we establish a lower bound showing that counting graphs which are barely not $(1,d)$-locatable is already $\#\text{W}[1]$-hard. We note that the restriction to $d$-degenerate graphs has been a fruitful line of research leading to two very general results (FOCS'21, SODA'25) and this creates the impression that we largely understand the complexity of counting substructures in degenerate graphs. However, all aforementioned results have an exponential dependency on the size of the pattern graph $H$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.20385v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Christine Awofeso, Patrick Greaves, Oded Lachish, Felix Reidl</dc:creator>
    </item>
    <item>
      <title>Polynomial Algorithms for Simultaneous Unitary Similarity and Equivalence</title>
      <link>https://arxiv.org/abs/2511.19439</link>
      <description>arXiv:2511.19439v1 Announce Type: cross 
Abstract: We present an algorithm to solve the Simultaneous Unitary Similarity(S.U.S) problem which is to check if there exists a Similarity transformation determined by a Unitary $U$ s.t $UA_lU^*=B_l$, $l \in \{1,...,p\}$, where $A_l$ and $B_l$ are $nxn$ complex matrices. We observe that the problem is simplest when $U$ is diagonal, where we see that the `paths' in the graph defined by non-zero elements of $A_l$ and $B_l$ determine the solution. Inspired by this we generalize this to the case when $U$ is block-diagonal to identify a form refered to as the `Solution-form' using `paths' determined by non-zero sub-matrices of $A_l,B_l$ which are non-zero multiples of Unitary. When not in Solution form we find an equivalent problem to solve by diagonalizing a Hermitian or a Normal matrix related to the sub-matrices. The problem is solved in a maximum of $n$ steps. The same idea can be extended to solve the Simultaneous Unitary Equivalence(S.U.Eq) problem where we solve for $U,V$ in $UA_lV^*=B_l$, $A_l,B_l$ being $mxn$ Complex rectangular matrices. Here we work with the 'paths' in the related bi-graph to define the Solution-form. The algorithms have a complexity of $O(pn^4)$. This work finds application in Quantum Evolution, Quantum gate design and Simulation.The salient features of each step of the algorithm can be retained as Canonical features to classify a given collection of complex matrices up to Unitary Similarity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.19439v1</guid>
      <category>math.RA</category>
      <category>cs.DS</category>
      <category>quant-ph</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Harikrishna VJ, Vittal Rao, Ramakrishnan K. R</dc:creator>
    </item>
    <item>
      <title>Improved Linear-Time Construction of Minimal Dominating Set via Mobile Agents</title>
      <link>https://arxiv.org/abs/2511.19880</link>
      <description>arXiv:2511.19880v1 Announce Type: cross 
Abstract: Mobile agents have emerged as a powerful framework for solving fundamental graph problems in distributed settings in recent times. These agents, modelled as autonomous physical or software entities, possess local computation power, finite memory and have the ability to traverse a graph, offering efficient solutions to a range of classical problems. In this work, we focus on the problem of computing a \emph{minimal dominating set} (mDS) in anonymous graphs using mobile agents. Building on the recently proposed optimal dispersion algorithm on the synchronous mobile agent model, we design two new algorithms that achieve a \emph{linear-time} solution for this problem in the synchronous setting. Specifically, given a connected $n$-node graph with $n$ agents initially placed in either rooted or arbitrary configurations, we show that an mDS can be computed in $O(n)$ rounds using only $O(\log n)$ bits of memory per agent, without using any prior knowledge of any global parameters. This improves upon the best-known complexity results in the literature over the same model. In addition, as natural by-products of our methodology, our algorithms also construct a spanning tree and elect a unique leader in $O(n)$ rounds, which are also important results of independent interest in the mobile-agent framework.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.19880v1</guid>
      <category>cs.DC</category>
      <category>cs.DS</category>
      <category>cs.MA</category>
      <category>cs.RO</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Prabhat Kumar Chand, Anisur Rahaman Molla</dc:creator>
    </item>
    <item>
      <title>REWA: Witness-Overlap Theory -- Foundations for Composable Binary Similarity Systems</title>
      <link>https://arxiv.org/abs/2511.19998</link>
      <description>arXiv:2511.19998v1 Announce Type: cross 
Abstract: REWA introduces a general theory of similarity based on witness-overlap structures. We show that whenever similarity between concepts can be expressed as monotone witness overlap -- whether arising from graph neighborhoods, causal relations, temporal structure, topological features, symbolic patterns, or embedding-based neighborhoods -- it admits a reduction to compact encodings with provable ranking preservation guarantees. REWA systems consist of: (1) finite witness sets $W(v)$, (2) semi-random bit assignments generated from each witness, and (3) monotonicity of expected similarity in the overlap $\Delta(u, v) = |W(u) \cap W(v)|$. We prove that under an overlap-gap condition on the final witness sets -- independent of how they were constructed -- top-$k$ rankings are preserved using $m = O(\log(|V|/\delta))$ bits. The witness-set formulation is compositional: any sequence of structural, temporal, causal, topological, information-theoretic, or learned transformations can be combined into pipelines that terminate in discrete witness sets. The theory applies to the final witness overlap, enabling modular construction of similarity systems from reusable primitives. This yields a vast design space: millions of composable similarity definitions inherit logarithmic encoding complexity. REWA subsumes and unifies Bloom filters, minhash, LSH bitmaps, random projections, sketches, and hierarchical filters as special cases. It provides a principled foundation for similarity systems whose behavior is governed by witness overlap rather than hash-function engineering. This manuscript presents the axioms, the main reducibility theorem, complete proofs with explicit constants, and a detailed discussion of compositional design, limitations, and future extensions including multi-bit encodings, weighted witnesses, and non-set representations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.19998v1</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <category>cs.IR</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nikit Phadke</dc:creator>
    </item>
    <item>
      <title>Fast Matrix Multiplication via Ternary Meta Flip Graphs</title>
      <link>https://arxiv.org/abs/2511.20317</link>
      <description>arXiv:2511.20317v1 Announce Type: cross 
Abstract: Matrix multiplication optimization remains a fundamental challenge in computational mathematics. This work introduces a novel approach that discovers matrix multiplication schemes in the ternary field ($Z_T$), where coefficients are restricted to $\{-1, 0, 1\}$ to minimize naive additive complexity. The core of the method is a GPU-accelerated meta flip graph algorithm that maintains ternary safety through specialized arithmetic operations and sign symmetry breaking. Key results include new best ranks for the formats $4 \times 5 \times 12$, $5 \times 6 \times 10$, and $6 \times 7 \times 9$, the independent discovery of 32 schemes in $Z_T$ that match known optimal ranks (including 8 previously known only with rational coefficients), and 30 rank improvements in the binary field. The analysis of 164 known schemes shows that 92 can be implemented in $Z_T$, while 72 could not be found in the ternary field with current methods, defining the current boundaries of this approach. All software, results, and discovered schemes are provided as open-source.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.20317v1</guid>
      <category>cs.SC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>A. I. Perminov</dc:creator>
    </item>
    <item>
      <title>Model-Based Learning of Whittle indices</title>
      <link>https://arxiv.org/abs/2511.20397</link>
      <description>arXiv:2511.20397v1 Announce Type: cross 
Abstract: We present BLINQ, a new model-based algorithm that learns the Whittle indices of an indexable, communicating and unichain Markov Decision Process (MDP). Our approach relies on building an empirical estimate of the MDP and then computing its Whittle indices using an extended version of a state-of-the-art existing algorithm. We provide a proof of convergence to the Whittle indices we want to learn as well as a bound on the time needed to learn them with arbitrary precision. Moreover, we investigate its computational complexity. Our numerical experiments suggest that BLINQ significantly outperforms existing Q-learning approaches in terms of the number of samples needed to get an accurate approximation. In addition, it has a total computational cost even lower than Q-learning for any reasonably high number of samples. These observations persist even when the Q-learning algorithms are speeded up using pre-trained neural networks to predict Q-values.</description>
      <guid isPermaLink="false">oai:arXiv.org:2511.20397v1</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <category>cs.NA</category>
      <category>math.NA</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Jo\"el Charles-Rebuff\'e, Nicolas Gast, Bruno Gaujal</dc:creator>
    </item>
    <item>
      <title>Smallest Suffixient Sets: Effectiveness, Resilience, and Calculation</title>
      <link>https://arxiv.org/abs/2506.05638</link>
      <description>arXiv:2506.05638v4 Announce Type: replace-cross 
Abstract: A suffixient set is a novel combinatorial object that captures the essential information of repetitive strings in a way that, provided with a random access mechanism, supports various forms of pattern matching. In this paper, we study the size $\chi$ of the smallest suffixient set as a repetitiveness measure: we place it between known measures and study its sensitivity to various string operations. As a corollary of our results, we give simple online algorithms to compute smallest suffixient sets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.05638v4</guid>
      <category>cs.FL</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Wed, 26 Nov 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Gonzalo Navarro, Giuseppe Romana, Cristian Urbina</dc:creator>
    </item>
  </channel>
</rss>
