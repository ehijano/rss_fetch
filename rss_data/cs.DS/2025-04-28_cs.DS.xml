<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Apr 2025 04:00:02 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Geodetic Set on Graphs of Constant Pathwidth and Feedback Vertex Set Number</title>
      <link>https://arxiv.org/abs/2504.17862</link>
      <description>arXiv:2504.17862v1 Announce Type: new 
Abstract: In the \textsc{Geodetic Set} problem, the input consists of a graph $G$ and a positive integer $k$. The goal is to determine whether there exists a subset $S$ of vertices of size $k$ such that every vertex in the graph is included in a shortest path between two vertices in $S$. Kellerhals and Koana [IPEC 2020; J. Graph Algorithms Appl 2022] proved that the problem is $\W[1]$-hard when parameterized by the pathwidth and the feedback vertex set number of the input graph. They posed the question of whether the problem admits an $\XP$ algorithm when parameterized by the combination of these two parameters. We answer this in negative by proving that the problem remains \NP-hard on graphs of constant pathwidth and feedback vertex set number.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17862v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Prafullkumar Tale</dc:creator>
    </item>
    <item>
      <title>Preserving Distances in Faulty Colored Graphs</title>
      <link>https://arxiv.org/abs/2504.17868</link>
      <description>arXiv:2504.17868v1 Announce Type: new 
Abstract: We study color fault-tolerant (CFT) network design problems: Given an $n$-vertex graph $G$ whose edges are arbitrarily colored (with no ``legality'' restrictions), the goal is to find a sparse subgraph $H$ such that, when any color fault causes all edges of some color $c$ to crash, the surviving subgraph $H-c$ remains ``similar'' to the surviving graph $G-c$. The similarity is problem-dependent, usually pertaining to distance preserving. If each color class has size $\Delta$ or less, a brute-force approach can disregard the colors and take $H$ to be $\Delta$-edge fault-tolerant ($\Delta$-EFT), so that $H-F$ is similar to $G-F$ for every set $F$ of $\leq \Delta$ edges. We ask if the colors can be utilized to provide a sparser $H$.
  Our main results concern CFT sourcewise distance preservers, where there is a given set $S \subseteq V$ of $\sigma$ sources, and all $S \times V$ distances should be exactly equal in $H-c$ and in $G-c$. We give nearly-tight upper and lower bounds of $\tilde{\Theta} (n^{2-1/(\Delta+1)} \cdot \sigma^{1/(\Delta+1)})$ on the worst-case size of such preservers. The corresponding $\Delta$-EFT problem admits the same lower bound, but the state-of-the-art upper bound for $\Delta\geq 3$ is $\tilde{O}(n^{2-1/2^\Delta} \cdot \sigma^{1/2^\Delta})$. Our approach also leads to new and arguably simpler constructions that recover these $\Delta$-EFT bounds and shed some light on their current gaps.
  We provide additional results along these lines, showcasing problems where the color structure helps or does not help sparsification. For preserving the distance between a single pair of vertices after a color fault, the brute-force approach via $\Delta$-EFT is shown to be suboptimal. In contrast, for preserving reachability from a single source in a directed graph, it is (worst-case) optimal.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17868v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Merav Parter, Asaf Petruschka</dc:creator>
    </item>
    <item>
      <title>Searching in trees with heavy group sets of fixed size</title>
      <link>https://arxiv.org/abs/2504.17887</link>
      <description>arXiv:2504.17887v1 Announce Type: new 
Abstract: We consider the following generalization of the binary search problem: A searcher is required to find a hidden element $x$ in a tree $T$. To do so, they iteratively perform queries to an oracle about a chosen vertex $v$. After each such call, the oracle responds whether the target was found and if not, the searcher receives as a reply the neighbor of $v$ that lays on the shortest path towards $x$. Additionally, each vertex $v$ may have a different query cost $w(v)$. The goal is to find the optimal querying strategy for the searcher which minimizes the worst case query cost required to find $x$. The problem is known to be NP-hard even in restricted classes of trees such as bounded diameter spiders [Cicalese et al. 2016] and no constant factor approximation algorithm is known for the general case. Inspired by recent studies [Dereniowski et al. 2022, Dereniowski et al. 2024], instead of restricted classes of trees, we explore restrictions on the weight function. We introduce the concept of a heavy group set of a vertex $HG(v,w)$. We show that if for every $v\in T$: $|HG(v,w)|\leq k$ an $O(\log\log n)$-approximation can be found within $2^{O(\log^2k)}\cdot\text{poly}(n)$ time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17887v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Micha{\l} Szyfelbein</dc:creator>
    </item>
    <item>
      <title>PHast -- Perfect Hashing with fast evaluation</title>
      <link>https://arxiv.org/abs/2504.17918</link>
      <description>arXiv:2504.17918v1 Announce Type: new 
Abstract: Perfect hash functions give unique "names" to arbitrary keys requiring only a few bits per key. This is an essential building block in applications like static hash tables, databases, or bioinformatics. This paper introduces the PHast approach that has the currently fastest query time with competitive construction time and space consumption. PHast improves bucket-placement which first hashes each key k to a bucket, and then looks for the bucket seed s such that a secondary hash function maps pairs (s,k) in a collision-free way. PHast can use small-range primary hash functions with linear mapping, fixed-width encoding of seeds, and parallel construction. This is achieved using small overlapping slices of allowed values and bumping to handle unsuccessful seed assignment.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17918v1</guid>
      <category>cs.DS</category>
      <category>cs.DB</category>
      <category>cs.PF</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Piotr Beling, Peter Sanders</dc:creator>
    </item>
    <item>
      <title>An Optimal $3$-Fault-Tolerant Connectivity Oracle</title>
      <link>https://arxiv.org/abs/2504.17937</link>
      <description>arXiv:2504.17937v1 Announce Type: new 
Abstract: We present an optimal oracle for answering connectivity queries in undirected graphs in the presence of at most three vertex failures. Specifically, we show that we can process a graph $G$ in $O(n+m)$ time, in order to build a data structure that occupies $O(n)$ space, which can be used in order to answer queries of the form "given a set $F$ of at most three vertices, and two vertices $x$ and $y$ not in $F$, are $x$ and $y$ connected in $G\setminus F$?" in constant time, where $n$ and $m$ denote the number of vertices and edges, respectively, of $G$. The idea is to rely on the DFS-based framework introduced by Kosinas [ESA'23], for handling connectivity queries in the presence of multiple vertex failures. Our technical contribution is to show how to appropriately extend the toolkit of the DFS-based parameters, in order to optimally handle up to three vertex failures. Our approach has the interesting property that it does not rely on a compact representation of vertex cuts, and has the potential to provide optimal solutions for more vertex failures. Furthermore, we show that the DFS-based framework can be easily extended in order to answer vertex-cut queries, and the number of connected components in the presence of multiple vertex failures. In the case of three vertex failures, we can answer such queries in $O(\log n)$ time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17937v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Evangelos Kosinas</dc:creator>
    </item>
    <item>
      <title>Improving the Threshold for Finding Rank-1 Matrices in a Subspace</title>
      <link>https://arxiv.org/abs/2504.17947</link>
      <description>arXiv:2504.17947v1 Announce Type: new 
Abstract: We consider a basic computational task of finding $s$ planted rank-1 $m \times n$ matrices in a linear subspace $\mathcal{U} \subseteq \mathbb{R}^{m \times n}$ where $\dim(\mathcal{U}) = R \ge s$. The work of Johnston-Lovitz-Vijayaraghavan (FOCS 2023) gave a polynomial-time algorithm for this task and proved that it succeeds when ${R \le (1-o(1))mn/4}$, under minimal genericity assumptions on the input. Aiming to precisely characterize the performance of this algorithm, we improve the bound to ${R \le (1-o(1))mn/2}$ and also prove that the algorithm fails when ${R \ge (1+o(1))mn/\sqrt{2}}$. Numerical experiments indicate that the true breaking point is $R = (1+o(1))mn/\sqrt{2}$. Our work implies new algorithmic results for tensor decomposition, for instance, decomposing order-4 tensors with twice as many components as before.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17947v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jeshu Dastidar, Tait Weicht, Alexander S. Wein</dc:creator>
    </item>
    <item>
      <title>Complexity and Approximation Algorithms for Fixed Charge Transportation Problems</title>
      <link>https://arxiv.org/abs/2504.18037</link>
      <description>arXiv:2504.18037v1 Announce Type: new 
Abstract: The Fixed Charge Transportation (FCT) problem models transportation scenarios where we need to send a commodity from $n$ sources to $m$ sinks, and the cost of sending a commodity from a source to a sink consists of a linear component and a fixed component. Despite extensive research on exponential time exact algorithms and heuristic algorithms for FCT and its variants, their approximability and computational complexity are not well understood.
  In this work, we initiate a systematic study of the approximability and complexity of these problems. When there are no linear costs, we call the problem the Pure Fixed Charge Transportation (PFCT) problem. We also distinguish between cases with general, sink-independent, and uniform fixed costs; we use the suffixes ``-S'' and ``-U'' to denote the latter two cases, respectively. This gives us six variants of the FCT problem.
  We give a complete characterization of the existence of $O(1)$-approximation algorithms for these variants. In particular, we give $2$-approximation algorithms for FCT-U and PFCT-S, and a $(6/5 + \epsilon)$-approximation for PFCT-U. On the negative side, we prove that FCT and PFCT are NP-hard to approximate within a factor of $O(\log^{2-\epsilon} (\max\{n, m\}))$ for any constant $\epsilon &gt; 0$, FCT-S is NP-hard to approximate within a factor of $c\log (\max\{n, m\})$ for some constant $c&gt; 0$, and PFCT-U is APX-hard. Additionally, we design an Efficient Parameterized Approximation Scheme (EPAS) for PFCT when parameterized by the number $n$ of sources, and an $O(1/\epsilon)$-bicriteria approximation for the FCT problem, when we are allowed to violate the demand constraints for sinks by a factor of $1\pm \epsilon$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18037v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yong Chen, Shi Li, Zihao Liang</dc:creator>
    </item>
    <item>
      <title>Fully Dynamic Algorithms for Transitive Reduction</title>
      <link>https://arxiv.org/abs/2504.18161</link>
      <description>arXiv:2504.18161v1 Announce Type: new 
Abstract: Given a directed graph $G$, a transitive reduction $G^t$ of $G$ (first studied by Aho, Garey, Ullman [SICOMP `72]) is a minimal subgraph of $G$ that preserves the reachability relation between every two vertices in $G$.
  In this paper, we study the computational complexity of transitive reduction in the dynamic setting. We obtain the first fully dynamic algorithms for maintaining a transitive reduction of a general directed graph undergoing updates such as edge insertions or deletions. Our first algorithm achieves $O(m+n \log n)$ amortized update time, which is near-optimal for sparse directed graphs, and can even support extended update operations such as inserting a set of edges all incident to the same vertex, or deleting an arbitrary set of edges. Our second algorithm relies on fast matrix multiplication and achieves $O(m+ n^{1.585})$ \emph{worst-case} update time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18161v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gramoz Goranci, Adam Karczmarz, Ali Momeni, Nikos Parotsidis</dc:creator>
    </item>
    <item>
      <title>Solving Partial Dominating Set and Related Problems Using Twin-Width</title>
      <link>https://arxiv.org/abs/2504.18218</link>
      <description>arXiv:2504.18218v1 Announce Type: new 
Abstract: Partial vertex cover and partial dominating set are two well-investigated optimization problems. While they are $\rm W[1]$-hard on general graphs, they have been shown to be fixed-parameter tractable on many sparse graph classes, including nowhere-dense classes. In this paper, we demonstrate that these problems are also fixed-parameter tractable with respect to the twin-width of a graph. Indeed, we establish a more general result: every graph property that can be expressed by a logical formula of the form $\phi\equiv\exists x_1\ldots \exists x_k \#y\,\psi(x_1,\ldots,x_k,y)\ge t$, where $\psi$ is a quantifier-free formula, $t$ is an arbitrary number, and $\#y$ is a counting quantifier, can be evaluated in time $f(d,k)n$, where $n$ is the number of vertices and $d$ is the width of a contraction sequence that is part of the input. Notably, this includes problems such as connected partial dominating set and independent partial dominating set.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18218v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>cs.LO</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jakub Balab\'an, Daniel Mock, Peter Rossmanith</dc:creator>
    </item>
    <item>
      <title>Treewidth Parameterized by Feedback Vertex Number</title>
      <link>https://arxiv.org/abs/2504.18302</link>
      <description>arXiv:2504.18302v1 Announce Type: new 
Abstract: We provide the first algorithm for computing an optimal tree decomposition for a given graph $G$ that runs in single exponential time in the feedback vertex number of $G$, that is, in time $2^{O(\text{fvn}(G))}\cdot n^{O(1)}$, where $\text{fvn}(G)$ is the feedback vertex number of $G$ and $n$ is the number of vertices of $G$. On a classification level, this improves the previously known results by Chapelle et al. [Discrete Applied Mathematics '17] and Fomin et al. [Algorithmica '18], who independently showed that an optimal tree decomposition can be computed in single exponential time in the vertex cover number of $G$.
  One of the biggest open problems in the area of parameterized complexity is whether we can compute an optimal tree decomposition in single exponential time in the treewidth of the input graph. The currently best known algorithm by Korhonen and Lokshtanov [STOC '23] runs in $2^{O(\text{tw}(G)^2)}\cdot n^4$ time, where $\text{tw}(G)$ is the treewidth of $G$. Our algorithm improves upon this result on graphs $G$ where $\text{fvn}(G)\in o(\text{tw}(G)^2)$. On a different note, since $\text{fvn}(G)$ is an upper bound on $\text{tw}(G)$, our algorithm can also be seen either as an important step towards a positive resolution of the above-mentioned open problem, or, if its answer is negative, then a mark of the tractability border of single exponential time algorithms for the computation of treewidth.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18302v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hendrik Molter, Meirav Zehavi, Amit Zivan</dc:creator>
    </item>
    <item>
      <title>Computing Distances on Graph Associahedra is Fixed-parameter Tractable</title>
      <link>https://arxiv.org/abs/2504.18338</link>
      <description>arXiv:2504.18338v1 Announce Type: new 
Abstract: An elimination tree of a connected graph $G$ is a rooted tree on the vertices of $G$ obtained by choosing a root $v$ and recursing on the connected components of $G-v$ to obtain the subtrees of $v$. The graph associahedron of $G$ is a polytope whose vertices correspond to elimination trees of $G$ and whose edges correspond to tree rotations, a natural operation between elimination trees. These objects generalize associahedra, which correspond to the case where $G$ is a path. Ito et al. [ICALP 2023] recently proved that the problem of computing distances on graph associahedra is NP-hard. In this paper we prove that the problem, for a general graph $G$, is fixed-parameter tractable parameterized by the distance $k$. Prior to our work, only the case where $G$ is a path was known to be fixed-parameter tractable. To prove our result, we use a novel approach based on a marking scheme that restricts the search to a set of vertices whose size is bounded by a (large) function of $k$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18338v1</guid>
      <category>cs.DS</category>
      <category>cs.CG</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Lu\'is Felipe I. Cunha, Ignasi Sau, U\'everton S. Souza, Mario Valencia-Pabon</dc:creator>
    </item>
    <item>
      <title>Maximum Coverage in Turnstile Streams with Applications to Fingerprinting Measures</title>
      <link>https://arxiv.org/abs/2504.18394</link>
      <description>arXiv:2504.18394v1 Announce Type: new 
Abstract: In the maximum coverage problem we are given $d$ subsets from a universe $[n]$, and the goal is to output $k$ subsets such that their union covers the largest possible number of distinct items. We present the first algorithm for maximum coverage in the turnstile streaming model, where updates which insert or delete an item from a subset come one-by-one. Notably our algorithm only uses $poly\log n$ update time. We also present turnstile streaming algorithms for targeted and general fingerprinting for risk management where the goal is to determine which features pose the greatest re-identification risk in a dataset. As part of our work, we give a result of independent interest: an algorithm to estimate the complement of the $p^{\text{th}}$ frequency moment of a vector for $p \geq 2$. Empirical evaluation confirms the practicality of our fingerprinting algorithms demonstrating a speedup of up to $210$x over prior work.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18394v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alina Ene, Alessandro Epasto, Vahab Mirrokni, Hoai-An Nguyen, Huy L. Nguyen, David P. Woodruff, Peilin Zhong</dc:creator>
    </item>
    <item>
      <title>Subexponential and Parameterized Mixing Times of Glauber Dynamics on Independent Sets</title>
      <link>https://arxiv.org/abs/2504.18427</link>
      <description>arXiv:2504.18427v1 Announce Type: new 
Abstract: Given a graph $G$, the hard-core model defines a probability distribution over its independent sets, assigning to each set of size $k$ a probability of $\frac{\lambda^k}{Z}$, where $\lambda&gt;0$ is a parameter known as the fugacity and $Z$ is a normalization constant. The Glauber dynamics is a simple Markov chain that converges to this distribution and enables efficient sampling. Its mixing time--the number of steps needed to approach the stationary distribution--has been widely studied across various graph classes, with most previous work emphasizing the dichotomy between polynomial and exponential mixing times, with a particular focus on sparse classes of graphs.
  Inspired by the modern fine-grained approach to computational complexity, we investigate subexponential mixing times of the Glauber dynamics on geometric intersection graphs, such as disk graphs. We also study parameterized mixing times by focusing on two structural parameters that can remain small even in dense graphs: the tree independence number and the path independence number. We show that Glauber dynamics mixes in polynomial time on graphs with bounded path independence number and in quasi-polynomial time when the tree independence number is bounded. Moreover, we prove both bounds are tight, revealing a clear separation between the two parameters.
  This work provides a simple and efficient algorithm for sampling from the hard-core model. Unlike classical approaches that rely explicitly on geometric representations or on constructing decompositions such as tree decompositions or separator trees, our analysis only requires their existence to establish mixing time bounds--these structures are not used directly by the algorithm itself.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18427v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Malory Marin</dc:creator>
    </item>
    <item>
      <title>Boundaried Kernelization</title>
      <link>https://arxiv.org/abs/2504.18476</link>
      <description>arXiv:2504.18476v1 Announce Type: new 
Abstract: The notion of a (polynomial) kernelization from parameterized complexity is a well-studied model for efficient preprocessing for hard computational problems. By now, it is quite well understood which parameterized problems do or (conditionally) do not admit a polynomial kernelization. Unfortunately, polynomial kernelizations seem to require strong restrictions on the global structure of inputs.
  To avoid this restriction, we propose a model for efficient local preprocessing that is aimed at local structure in inputs. Our notion, dubbed boundaried kernelization, is inspired by protrusions and protrusion replacement, which are tools in meta-kernelization [Bodlaender et al. J'ACM 2016]. Unlike previous work, we study the preprocessing of suitable boundaried graphs in their own right, in significantly more general settings, and aiming for polynomial rather than exponential bounds. We establish polynomial boundaried kernelizations for a number of problems, while unconditionally ruling out such results for others. We also show that boundaried kernelization can be a tool for regular kernelization by using it to obtain an improved kernelization for Vertex Cover parameterized by the vertex-deletion distance to a graph of bounded treedepth.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18476v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Leonid Antipov, Stefan Kratsch</dc:creator>
    </item>
    <item>
      <title>Online Distributed Queue Length Estimation</title>
      <link>https://arxiv.org/abs/2504.18503</link>
      <description>arXiv:2504.18503v1 Announce Type: new 
Abstract: Queue length monitoring is a commonly arising problem in numerous applications such as queue management systems, scheduling, and traffic monitoring. Motivated by such applications, we formulate a queue monitoring problem, where there is a FIFO queue with arbitrary arrivals and departures, and a server needs to monitor the length of a queue by using decentralized pings from packets in the queue. Packets can send pings informing the server about the number of packets ahead of them in the queue. Via novel online policies and lower bounds, we tightly characterize the trade-off between the number of pings sent and the accuracy of the server's real time estimates. Our work studies the trade-off under various arrival and departure processes, including constant-rate, Poisson, and adversarial processes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18503v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Aditya Bhaskara, Sreenivas Gollapudi, Sungjin Im, Kostas Kollias, Kamesh Munagala</dc:creator>
    </item>
    <item>
      <title>Combinatorial Drone Searching</title>
      <link>https://arxiv.org/abs/2504.17955</link>
      <description>arXiv:2504.17955v1 Announce Type: cross 
Abstract: We introduce and study the combinatorial drone searching problem, which we describe in terms of search strategies for finding one or more hikers lost in a forest. An aerial drone can issue a probe to send a signal a given distance such that if there is a lost hiker within this distance, then the drone will learn this. But the drone does not learn the direction or distance to the lost hiker. The optimization problem is to minimize the number of probes and/or hiker responses, as well as possibly minimizing the flight distance for the drone. We describe a number of efficient combinatorial drone searching strategies and we analyze each one in terms of the size, $n$, of the search domain. Moreover, we derive strong bounds for the constant factors for the search costs for our algorithms, which in some cases involve computer-assisted proofs. We also show how to extend these strategies to find all lost hikers using a simple, memoryless drone search, traveling a distance that is $\mathcal{O}(\log{k})$-competitive with the optimal traveling salesperson (TSP) tour for $k$ lost hikers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17955v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ofek Gila (University of California, Irvine), Michael T. Goodrich (University of California, Irvine), Zahra Hadizadeh (University of Rochester), Daniel S. Hirschberg (University of California, Irvine), Shayan Taherijam (University of California, Irvine)</dc:creator>
    </item>
    <item>
      <title>Efficient Tree Generation for Globally Optimal Decisions under Probabilistic Outcomes</title>
      <link>https://arxiv.org/abs/2504.17983</link>
      <description>arXiv:2504.17983v1 Announce Type: cross 
Abstract: Many real-world problems require making sequences of decisions where the outcomes of each decision are probabilistic and uncertain, and the availability of different actions is constrained by the outcomes of previous actions. There is a need to generate policies that are adaptive to uncertainty, globally optimal, and yet scalable as the state space grows. In this paper, we propose the generation of optimal decision trees, which dictate which actions should be implemented in different outcome scenarios, while maximizing the expected reward of the strategy. Using a combination of dynamic programming and mixed-integer linear optimization, the proposed methods scale to problems with large but finite state spaces, using problem-specific information to prune away large subsets of the state space that do not yield progress towards rewards. We demonstrate that the presented approach is able to find the globally optimal decision tree in linear time with respect to the number states explored.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.17983v1</guid>
      <category>math.OC</category>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Berk Ozturk, She'ifa Punla-Green, Les Servi</dc:creator>
    </item>
    <item>
      <title>Optimal Secure Coded Distributed Computation over all Fields</title>
      <link>https://arxiv.org/abs/2504.18038</link>
      <description>arXiv:2504.18038v1 Announce Type: cross 
Abstract: We construct optimal secure coded distributed schemes that extend the known optimal constructions over fields of characteristic 0 to all fields. A serendipitous result is that we can encode \emph{all} functions over finite fields with a recovery threshold proportional to the complexity (tensor rank or multiplicative); this is due to the well-known result that all functions over a finite field can be represented as multivariate polynomials (or symmetric tensors). We get that a tensor of order $\ell$ (or a multivariate polynomial of degree $\ell$) can be computed in the faulty network of $N$ nodes setting within a factor of $\ell$ and an additive term depending on the genus of a code with $N$ rational points and distance covering the number of faulty servers; in particular, we present a coding scheme for general matrix multiplication of two $m \times m $ matrices with a recovery threshold of $2 m^{\omega } -1+g$ where $\omega $ is the exponent of matrix multiplication which is optimal for coding schemes using AG codes. Moreover, we give sufficient conditions for which the Hadamard-Shur product of general linear codes gives a similar recovery threshold, which we call \textit{log-additive codes}. Finally, we show that evaluation codes with a \textit{curve degree} function (first defined in [Ben-Sasson et al. (STOC '13)]) that have well-behaved zero sets are log-additive.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18038v1</guid>
      <category>cs.IT</category>
      <category>cs.DC</category>
      <category>cs.DS</category>
      <category>cs.SC</category>
      <category>math.AG</category>
      <category>math.IT</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Pedro Soto</dc:creator>
    </item>
    <item>
      <title>Efficient Matching of Some Fundamental Regular Expressions with Backreferences</title>
      <link>https://arxiv.org/abs/2504.18247</link>
      <description>arXiv:2504.18247v1 Announce Type: cross 
Abstract: Regular expression matching is of practical importance due to its widespread use in real-world applications. In practical use, regular expressions are often used with real-world extensions. Accordingly, the matching problem of regular expressions with real-world extensions has been actively studied in recent years, yielding steady progress. However, backreference, a popular extension supported by most modern programming languages such as Java, Python, JavaScript and others in their standard libraries for string processing, is an exception to this positive trend. In fact, it is known that the matching problem of regular expressions with backreferences (rewbs) is theoretically hard and the existence of an asymptotically fast matching algorithm for arbitrary rewbs seems unlikely. Even among currently known partial solutions, the balance between efficiency and generality remains unsatisfactory. To bridge this gap, we present an efficient matching algorithm for rewbs of the form $e_0 (e)_1 e_1 \backslash 1 e_2$ where $e_0, e, e_1, e_2$ are pure regular expressions, which are fundamental and frequently used in practical applications. It runs in quadratic time with respect to the input string length, substantially improving the best-known cubic time complexity for these rewbs. Our algorithm combines ideas from both stringology and automata theory in a novel way. We leverage two techniques from automata theory, injection and summarization, to simultaneously examine matches whose backreferenced substrings are either a fixed right-maximal repeat or its extendable prefixes, which are concepts from stringology. By further utilizing a subtle property of extendable prefixes, our algorithm correctly decides the matching problem while achieving the quadratic-time complexity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18247v1</guid>
      <category>cs.FL</category>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Taisei Nogami, Tachio Terauchi</dc:creator>
    </item>
    <item>
      <title>On constrained intersection representations of graphs and digraphs</title>
      <link>https://arxiv.org/abs/2504.18365</link>
      <description>arXiv:2504.18365v1 Announce Type: cross 
Abstract: We study the problem of determining optimal directed intersection representations of DAGs in a model introduced by Kostochka, Liu, Machado, and Milenkovic [ISIT2019]: vertices are assigned color sets so that there is an arc from a vertex $u$ to a vertex $v$ if and only if their color sets have nonempty intersection and $v$ gets assigned strictly more colors than $u$, and the goal is to minimize the total number of colors. We show that the problem is polynomially solvable in the class of triangle-free and Hamiltonian DAGs and also disclose the relationship of this problem with several other models of intersection representations of graphs and digraphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18365v1</guid>
      <category>cs.DM</category>
      <category>cs.DS</category>
      <category>cs.IT</category>
      <category>math.CO</category>
      <category>math.IT</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ferdinando Cicalese, Cl\'ement Dallard, Martin Milani\v{c}</dc:creator>
    </item>
    <item>
      <title>Heavy-Tailed Privacy: The Symmetric alpha-Stable Privacy Mechanism</title>
      <link>https://arxiv.org/abs/2504.18411</link>
      <description>arXiv:2504.18411v1 Announce Type: cross 
Abstract: With the rapid growth of digital platforms, there is increasing apprehension about how personal data is collected, stored, and used by various entities. These concerns arise from the increasing frequency of data breaches, cyber-attacks, and misuse of personal information for targeted advertising and surveillance. To address these matters, Differential Privacy (DP) has emerged as a prominent tool for quantifying a digital system's level of protection. The Gaussian mechanism is commonly used because the Gaussian density is closed under convolution, and is a common method utilized when aggregating datasets. However, the Gaussian mechanism only satisfies an approximate form of Differential Privacy. In this work, we present and analyze of the Symmetric alpha-Stable (SaS) mechanism. We prove that the mechanism achieves pure differential privacy while remaining closed under convolution. Additionally, we study the nuanced relationship between the level of privacy achieved and the parameters of the density. Lastly, we compare the expected error introduced to dataset queries by the Gaussian and SaS mechanisms. From our analysis, we believe the SaS Mechanism is an appealing choice for privacy-focused applications.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18411v1</guid>
      <category>cs.CR</category>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christopher C. Zawacki, Eyad H. Abed</dc:creator>
    </item>
    <item>
      <title>Lower bounds on collective additive spanners</title>
      <link>https://arxiv.org/abs/2504.18508</link>
      <description>arXiv:2504.18508v1 Announce Type: cross 
Abstract: In this paper we present various lower bound results on collective tree spanners and on spanners of bounded treewidth. A graph $G$ is said to admit a system of $\mu$ collective additive tree $c$-spanners if there is a system $\cal{T}$$(G)$ of at most $\mu$ spanning trees of $G$ such that for any two vertices $u,v$ of $G$ a tree $T\in \cal{T}$$(G)$ exists such that the distance in $T$ between $u$ and $v$ is at most $c$ plus their distance in $G$. A graph $G$ is said to admit an additive $k$-treewidth $c$-spanner if there is a spanning subgraph $H$ of $G$ with treewidth $k$ such that for any pair of vertices $u$ and $v$ their distance in $H$ is at most $c$ plus their distance in $G$. Among other results, we show that:
  $\bullet$ Any system of collective additive tree $1$ -- spanners must have $\Omega(\sqrt[3]{\log n})$ spanning trees for some unit interval graphs;
  $\bullet$ No system of a constant number of collective additive tree $2$-spanners can exist for strongly chordal graphs;
  $\bullet$ No system of a constant number of collective additive tree $3$-spanners can exist for chordal graphs;
  $\bullet$ No system of a constant number of collective additive tree $c$-spanners can exist for weakly chordal graphs as well as for outerplanar graphs for any constant $c\geq 0$;
  $\bullet$ For any constants $k \ge 2$ and $c \ge 1$ there are graphs of treewidth $k$ such that no spanning subgraph of treewidth $k-1$ can be an additive $c$-spanner of such a graph.
  All these lower bound results apply also to general graphs. Furthermore, they %results complement known upper bound results with tight lower bound results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.18508v1</guid>
      <category>math.CO</category>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Derek G. Corneil, Feodor F. Dragan, Ekkehard K\"ohler, Yang Xiang</dc:creator>
    </item>
    <item>
      <title>Light Edge Fault Tolerant Graph Spanners</title>
      <link>https://arxiv.org/abs/2502.10890</link>
      <description>arXiv:2502.10890v2 Announce Type: replace 
Abstract: There has recently been significant interest in fault tolerant spanners, which are spanners that still maintain their stretch guarantees after some nodes or edges fail. This work has culminated in an almost complete understanding of the three-way tradeoff between stretch, sparsity, and number of faults tolerated. However, despite some progress in metric settings, there have been no results to date on the tradeoff in general graphs between stretch, lightness, and number of faults tolerated.
  We initiate the study of light edge fault tolerant (EFT) graph spanners, obtaining the first such results. First, we observe that lightness can be unbounded if we use the traditional definition (normalizing by the MST). We then argue that a natural definition of fault-tolerant lightness is to instead normalize by a min-weight fault tolerant connectivity preserver; essentially, a fault-tolerant version of the MST. However, even with this, we show that it is still not generally possible to construct $f$-EFT spanners whose weight compares reasonably to the weight of a min-weight $f$-EFT connectivity preserver.
  In light of this lower bound, it is natural to then consider bicriteria notions of lightness, where we compare the weight of an $f$-EFT spanner to a min-weight $(f' &gt; f)$-EFT connectivity preserver. The most interesting question is to determine the minimum value of $f'$ that allows for reasonable lightness upper bounds. Our main result is a precise answer to this question: $f' = 2f$. In particular, we show that the lightness can be untenably large (roughly $n/k$ for a $k$-spanner) if one normalizes by the min-weight $(2f-1)$-EFT connectivity preserver. But if one normalizes by the min-weight $2f$-EFT connectivity preserver, then we show that the lightness is bounded by just $O(f^{1/2})$ times the non-fault tolerant lightness (roughly $n^{1/k}$, for a $(1+\epsilon)(2k-1)$-spanner).</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.10890v2</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Greg Bodwin, Michael Dinitz, Ama Koranteng, Lily Wang</dc:creator>
    </item>
    <item>
      <title>Coreset Strikes Back: Improved Parameterized Approximation Schemes for (Constrained) k-Median/Means</title>
      <link>https://arxiv.org/abs/2504.06980</link>
      <description>arXiv:2504.06980v2 Announce Type: replace 
Abstract: Algorithmic scatter dimension is a notion of metric spaces introduced recently by Abbasi et al. (FOCS 2023), which unifies many well-known metric spaces, including continuous Euclidean space, bounded doubling space, planar and bounded treewidth metrics. Recently, Bourneuf and Pilipczuk (SODA 2025) showed that metrics induced by graphs from any fixed proper minor closed graph class have bounded scatter dimension. Abbasi et al. presented a unified approach to obtain EPASes (i.e., $(1+\epsilon)$-approximations running in time FPT in $k$ and $\epsilon$) for $k$-Clustering in metrics of bounded scatter dimension. However, a seemingly inherent limitation of their approach was that it could only handle clustering objectives where each point was assigned to the closest chosen center. They explicitly asked, if there exist EPASes for constrained $k$-Clustering in metrics of bounded scatter dimension.
  We present a unified framework which yields EPASes capacitated and fair $k$-Median/Means in metrics of bounded algorithmic scatter dimension. Our framework exploits coresets for such constrained clustering problems in a novel manner, and notably requires only coresets of size $(k\log n/\epsilon)^{O(1)}$, which are usually constuctible even in general metrics. Note that due to existing lower bounds it is impossible to obtain such an EPAS for Capacitated $k$-Center, thus essentially answering the complete spectrum of the question.
  Our results on capacitated and fair $k$-Median/Means provide the first EPASes for these problems in broad families of metric spaces. Earlier such results were only known in continuous Euclidean spaces due to Cohen-Addad &amp; Li, (ICALP 2019), and Bandyapadhyay, Fomin &amp; Simonov, (ICALP 2021; JCSS 2024), respectively. Along the way, we obtain faster EPASes for uncapacitated $k$-Median/Means, improving upon the running time of the algorithm by Abbasi et al.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.06980v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sujoy Bhore, Ameet Gadekar, Tanmay Inamdar</dc:creator>
    </item>
    <item>
      <title>Fully Scalable MPC Algorithms for Euclidean k-Center</title>
      <link>https://arxiv.org/abs/2504.16382</link>
      <description>arXiv:2504.16382v2 Announce Type: replace 
Abstract: The $k$-center problem is a fundamental optimization problem with numerous applications in machine learning, data analysis, data mining, and communication networks. The $k$-center problem has been extensively studied in the classical sequential setting for several decades, and more recently there have been some efforts in understanding the problem in parallel computing, on the Massively Parallel Computation (MPC) model. For now, we have a good understanding of $k$-center in the case where each local MPC machine has sufficient local memory to store some representatives from each cluster, that is, when one has $\Omega(k)$ local memory per machine. While this setting covers the case of small values of $k$, for a large number of clusters these algorithms require undesirably large local memory, making them poorly scalable. The case of large $k$ has been considered only recently for the fully scalable low-local-memory MPC model for the Euclidean instances of the $k$-center problem. However, the earlier works have been considering only the constant dimensional Euclidean space, required a super-constant number of rounds, and produced only $k(1+o(1))$ centers whose cost is a super-constant approximation of $k$-center.
  In this work, we significantly improve upon the earlier results for the $k$-center problem for the fully scalable low-local-memory MPC model. In the low dimensional Euclidean case in $\mathbb{R}^d$, we present the first constant-round fully scalable MPC algorithm for $(2+\varepsilon)$-approximation. We push the ratio further to $(1 + \varepsilon)$-approximation albeit using slightly more $(1 + \varepsilon)k$ centers. All these results naturally extends to slightly super-constant values of $d$. In the high-dimensional regime, we provide the first fully scalable MPC algorithm that in a constant number of rounds achieves an $O(\log n/ \log \log n)$-approximation for $k$-center.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.16382v2</guid>
      <category>cs.DS</category>
      <category>cs.DC</category>
      <pubDate>Mon, 28 Apr 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Artur Czumaj, Guichen Gao, Mohsen Ghaffari, Shaofeng H. -C. Jiang</dc:creator>
    </item>
  </channel>
</rss>
