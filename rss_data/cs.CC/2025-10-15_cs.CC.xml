<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CC</link>
    <description>cs.CC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Oct 2025 01:54:17 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>The Structure of In-Place Space-Bounded Computation</title>
      <link>https://arxiv.org/abs/2510.12005</link>
      <description>arXiv:2510.12005v1 Announce Type: new 
Abstract: In the standard model of computing multi-output functions in logspace ($\mathsf{FL}$), we are given a read-only tape holding $x$ and a logarithmic length worktape, and must print $f(x)$ to a dedicated write-only tape. However, there has been extensive work (both in theory and in practice) on algorithms that transform $x$ into $f(x)$ in-place on a single read-write tape with limited (in our case $O(\log n)$) additional workspace. We say $f\in \mathsf{inplaceFL}$ if $f$ can be computed in this model. We initiate the study of in-place computation from a structural complexity perspective, proving upper and lower bounds on the power of $\mathsf{inplaceFL}$. We show the following:
  i) Unconditionally, $\mathsf{FL}\not\subseteq \mathsf{inplaceFL}$.
  ii) The problems of integer multiplication and evaluating $\mathsf{NC}^0_4$ circuits lie outside $\mathsf{inplaceFL}$ under cryptographic assumptions. However, evaluating $\mathsf{NC}^0_2$ circuits can be done in $\mathsf{inplaceFL}$.
  iii) We have $\mathsf{FL} \subseteq \mathsf{inplaceFL}^{\mathsf{STP}}.$ Consequently, proving $\mathsf{inplaceFL} \not\subseteq \mathsf{FL}$ would imply $\mathsf{SAT} \not\in \mathsf{L}$.
  We also consider the analogous catalytic class ($\mathsf{inplaceFCL}$), where the in-place algorithm has a large additional worktape tape that it must reset at the end of the computation. We give $\mathsf{inplaceFCL}$ algorithms for matrix multiplication and inversion over polynomial-sized finite fields. We furthermore use our results and techniques to show two novel barriers to proving $\mathsf{CL} \subseteq \mathsf{P}$. First, we show that any proof of $\mathsf{CL}\subseteq \mathsf{P}$ must be non-relativizing, by giving an oracle relative to which $\mathsf{CL}^O=\mathsf{EXP}^O$. Second, we identify a search problem in $\mathsf{searchCL}$ but not known to be in $\mathsf{P}$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.12005v1</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>James Cook, Surendra Ghentiyala, Ian Mertz, Edward Pyne, Nathan S. Sheffield</dc:creator>
    </item>
    <item>
      <title>Tight Quantum Time-Space Tradeoffs for Permutation Inversion</title>
      <link>https://arxiv.org/abs/2510.12112</link>
      <description>arXiv:2510.12112v1 Announce Type: new 
Abstract: In permutation inversion, we are given a permutation $\pi : [N] \rightarrow [N]$, and want to prepare some advice of size $S$, such that we can efficiently invert any image in time $T$. This is a fundamental cryptographic problem with profound connections to communication complexity and circuit lower bounds.
  In the classical setting, a tight $ST = \tilde{\Theta}(N)$ bound has been established since the seminal work of Hellman (1980) and Yao (1990). In the quantum setting, a lower bound of $ST^2 = \tilde{\Omega}(N)$ is proved by Nayebi, Aaronson, Belovs, and Trevisan (2015) against classical advice, and by Hhan, Xagawa and Yamakawa (2019) against quantum advice. It left open an intriguing possibility that Grover's search can be sped up to time $\tilde{O}(\sqrt{N / S})$.
  In this work, we prove an $ST + T^2 = \Omega(N)$ lower bound for permutation inversion with even quantum advice. This bound matches the best known attacks and shows that Grover's search and the classical Hellman's algorithm cannot be further sped up.
  Our proof combines recent techniques by Liu (2023) and by Rosmanis (2022). Specifically, we first reduce the permutation inversion problem against quantum advice to a variant by Liu's technique, then we analyze this variant via representation theory inspired by Rosmanis (2022).</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.12112v1</guid>
      <category>cs.CC</category>
      <category>cs.IT</category>
      <category>math.IT</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator> Akshima, Tyler Besselman, Kai-Min Chung, Siyao Guo, Tzu-Yi Yang</dc:creator>
    </item>
    <item>
      <title>On the Complexity of Nucleolus Computation for Bipartite b-Matching Games</title>
      <link>https://arxiv.org/abs/2105.07161</link>
      <description>arXiv:2105.07161v3 Announce Type: cross 
Abstract: We explore the complexity of nucleolus computation in b-matching games on bipartite graphs. We show that computing the nucleolus of a simple b-matching game is NP-hard even on bipartite graphs of maximum degree 7. We complement this with partial positive results in the special case where b values are bounded by 2. In particular, we describe an efficient algorithm when a constant number of vertices satisfy b(v) = 2 as well as an efficient algorithm for computing the non-simple b-matching nucleolus when b = 2.</description>
      <guid isPermaLink="false">oai:arXiv.org:2105.07161v3</guid>
      <category>cs.GT</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1016/j.tcs.2024.114476</arxiv:DOI>
      <dc:creator>Jochen Koenemann, Justin Toth, Felix Zhou</dc:creator>
    </item>
    <item>
      <title>Exact Matching and Top-k Perfect Matching Parameterized by Neighborhood Diversity or Bandwidth</title>
      <link>https://arxiv.org/abs/2510.12552</link>
      <description>arXiv:2510.12552v1 Announce Type: cross 
Abstract: The Exact Matching (EM) problem asks whether there exists a perfect matching which uses a prescribed number of red edges in a red/blue edge-colored graph. While there exists a randomized polynomial-time algorithm for the problem, only some special cases admit a deterministic one so far, making it a natural candidate for testing the P=RP hypothesis. A polynomial-time equivalent problem, Top-k Perfect Matching (TkPM), asks for a perfect matching maximizing the weight of the $k$ heaviest edges.
  We study the above problems, mainly the latter, in the scenario where the input is a blown-up graph, meaning a graph which had its vertices replaced by cliques or independent sets. We describe an FPT algorithm for TkPM parameterized by $k$ and the neighborhood diversity of the input graph, which is essentially the size of the graph before the blow-up; this graph is also called the prototype. We extend this algorithm into an approximation scheme with a much softer dependency on the aforementioned parameters, time-complexity wise. Moreover, for prototypes with bounded bandwidth but unbounded size, we develop a recursive algorithm that runs in subexponential time. Utilizing another algorithm for EM on bounded neighborhood diversity graphs, we adapt this recursive subexponential algorithm to EM.
  Our approach is similar to the use of dynamic programming on e.g. bounded treewidth instances for various problems. The main point is that the existence of many disjoint separators is utilized to avoid including in the separator any of a set of ``bad'' vertices during the split phase.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.12552v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nicolas El Maalouly, Kostas Lakis</dc:creator>
    </item>
    <item>
      <title>Performance of Gaussian Boson Sampling on Planted Bipartite Clique Detection</title>
      <link>https://arxiv.org/abs/2510.12774</link>
      <description>arXiv:2510.12774v1 Announce Type: cross 
Abstract: We investigate whether Gaussian Boson Sampling (GBS) can provide a computational advantage for solving the planted biclique problem, which is a graph problem widely believed to be classically hard when the planted structure is small. Although GBS has been heuristically and experimentally observed to favor sampling dense subgraphs, its theoretical performance on this classically hard problem remains largely unexplored. We focus on a natural statistic derived from GBS output: the frequency with which a node appears in GBS samples, referred to as the node weight. We rigorously analyze whether this signal is strong enough to distinguish planted biclique nodes from background nodes. Our analysis characterizes the distribution of node weights under GBS and quantifies the bias introduced by the planted structure. The results reveal a sharp limitation: when the planted biclique size falls within the conjectured hard regime, the natural fluctuations in node weights dominate the bias signal, making detection unreliable using simple ranking strategies. These findings provide the first rigorous evidence that planted biclique detection may remain computationally hard even under GBS-based quantum computing, and they motivate further investigation into more advanced GBS-based algorithms or other quantum approaches for this problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.12774v1</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Yu-Zhen Janice Chen, Laurent Massouli\'e, Don Towsley</dc:creator>
    </item>
    <item>
      <title>The Complexity of Contracting Bipartite Graphs into Small Cycles</title>
      <link>https://arxiv.org/abs/2206.07358</link>
      <description>arXiv:2206.07358v2 Announce Type: replace 
Abstract: For a positive integer $\ell \geq 3$, the $C_\ell$-Contractibility problem takes as input an undirected simple graph $G$ and determines whether $G$ can be transformed into a graph isomorphic to $C_\ell$ (the induced cycle on $\ell$ vertices) using only edge contractions. Brouwer and Veldman [JGT 1987] showed that $C_4$-Contractibility is NP-complete in general graphs. It is easy to verify that $C_3$-Contractibility is polynomial-time solvable. Dabrowski and Paulusma [IPL 2017] showed that $C_{\ell}$-Contractibility is \NP-complete\ on bipartite graphs for $\ell = 6$ and posed as open problems the status of the problem when $\ell$ is 4 or 5. In this paper, we show that both $C_5$-Contractibility and $C_4$-Contractibility are NP-complete on bipartite graphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2206.07358v2</guid>
      <category>cs.CC</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>R. Krithika, Roohani Sharma, Prafullkumar Tale</dc:creator>
    </item>
    <item>
      <title>The Algorithmic Regulator</title>
      <link>https://arxiv.org/abs/2510.10300</link>
      <description>arXiv:2510.10300v3 Announce Type: replace 
Abstract: The regulator theorem states that, under certain conditions, any optimal controller must embody a model of the system it regulates, grounding the idea that controllers embed, explicitly or implicitly, internal models of the controlled. This principle underpins neuroscience and predictive brain theories like the Free-Energy Principle or Kolmogorov/Algorithmic Agent theory. However, the theorem is only proven in limited settings. Here, we treat the deterministic, closed, coupled world-regulator system $(W,R)$ as a single self-delimiting program $p$ via a constant-size wrapper that produces the world output string~$x$ fed to the regulator. We analyze regulation from the viewpoint of the algorithmic complexity of the output, $K(x)$. We define $R$ to be a \emph{good algorithmic regulator} if it \emph{reduces} the algorithmic complexity of the readout relative to a null (unregulated) baseline $\varnothing$, i.e., \[ \Delta = K\big(O_{W,\varnothing}\big) - K\big(O_{W,R}\big) &gt; 0. \] We then prove that the larger $\Delta$ is, the more world-regulator pairs with high mutual algorithmic information are favored. More precisely, a complexity gap $\Delta &gt; 0$ yields \[ \Pr\big((W,R)\mid x\big) \le C\,2^{\,M(W{:}R)}\,2^{-\Delta}, \] making low $M(W{:}R)$ exponentially unlikely as $\Delta$ grows. This is an AIT version of the idea that ``the regulator contains a model of the world.'' The framework is distribution-free, applies to individual sequences, and complements the Internal Model Principle. Beyond this necessity claim, the same coding-theorem calculus singles out a \emph{canonical scalar objective} and implicates a \emph{planner}. On the realized episode, a regulator behaves \emph{as if} it minimized the conditional description length of the readout.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.10300v3</guid>
      <category>cs.CC</category>
      <category>cs.AI</category>
      <category>cs.IT</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <category>math.IT</category>
      <category>q-bio.NC</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Giulio Ruffini</dc:creator>
    </item>
    <item>
      <title>The NPA hierarchy does not always attain the commuting operator value</title>
      <link>https://arxiv.org/abs/2510.04943</link>
      <description>arXiv:2510.04943v2 Announce Type: replace-cross 
Abstract: We show that it is undecidable to determine whether the commuting operator value of a nonlocal game is strictly greater than 1/2. As a corollary, there is a boolean constraint system (BCS) game for which the value of the Navascu\'es-Pironio-Ac\'in (NPA) hierarchy does not attain the commuting operator value at any finite level. Our contribution involves establishing a computable mapping from Turing machines to BCS nonlocal games in which the halting property of the machine is encoded as a decision problem for the commuting operator value of the game. Our techniques are algebraic and distinct from those used to establish MIP*=RE.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.04943v2</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Marco Fanizza, Larissa Kroell, Arthur Mehta, Connor Paddock, Denis Rochette, William Slofstra, Yuming Zhao</dc:creator>
    </item>
    <item>
      <title>How hard is it to verify a classical shadow?</title>
      <link>https://arxiv.org/abs/2510.08515</link>
      <description>arXiv:2510.08515v2 Announce Type: replace-cross 
Abstract: Classical shadows are succinct classical representations of quantum states which allow one to encode a set of properties P of a quantum state rho, while only requiring measurements on logarithmically many copies of rho in the size of P. In this work, we initiate the study of verification of classical shadows, denoted classical shadow validity (CSV), from the perspective of computational complexity, which asks: Given a classical shadow S, how hard is it to verify that S predicts the measurement statistics of a quantum state? We first show that even for the elegantly simple classical shadow protocol of [Huang, Kueng, Preskill, Nature Physics 2020] utilizing local Clifford measurements, CSV is QMA-complete. This hardness continues to hold for the high-dimensional extension of said protocol due to [Mao, Yi, and Zhu, PRL 2025]. In contrast, we show that for the HKP and MYZ protocols utilizing global Clifford measurements, CSV can be "dequantized" for low-rank observables, i.e., solved in randomized poly-time with standard sampling assumptions. Among other results, we also show that CSV for exponentially many observables is complete for a quantum generalization of the second level of the polynomial hierarchy, yielding the first natural complete problem for such a class.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.08515v2</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <pubDate>Wed, 15 Oct 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Georgios Karaiskos, Dorian Rudolph, Johannes Jakob Meyer, Jens Eisert, Sevag Gharibian</dc:creator>
    </item>
  </channel>
</rss>
