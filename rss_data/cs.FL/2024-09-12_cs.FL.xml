<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Sep 2024 04:00:19 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>A GLR-like Parsing Algorithm for Three-Valued Interpretations of Boolean Grammars with Strong Negation</title>
      <link>https://arxiv.org/abs/2409.06966</link>
      <description>arXiv:2409.06966v1 Announce Type: new 
Abstract: Boolean grammars generalize context-free rewriting by extending the possibilities when dealing with different rules for the same nonterminal symbol. By allowing not only disjunction (as in the case of usual context-free grammars), but also conjunction and negation as possible connections between different rules with the same left-hand side, they are able to simplify the description of context-free languages and characterize languages that are not context-free. The use of negation, however, leads to the possibility of introducing rules that interplay in such a way which is problematic to handle in the classical, two-valued logical setting. Here we define a three valued interpretation to deal with such contradictory grammars using a method introduced originally in the context of logic programming, and present an algorithm to determine the membership status of strings with respect to the resulting three valued languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06966v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 27-43</arxiv:journal_reference>
      <dc:creator>Patrik Adri\'an (University of Debrecen, Faculty of Informatics), Gy\"orgy Vaszil (University of Debrecen, Faculty of Informatics)</dc:creator>
    </item>
    <item>
      <title>Complexity of Unary Exclusive Nondeterministic Finite Automata</title>
      <link>https://arxiv.org/abs/2409.06967</link>
      <description>arXiv:2409.06967v1 Announce Type: new 
Abstract: Exclusive nondeterministic finite automata (XNFA) are nondeterministic finite automata with a special acceptance condition. An input is accepted if there is exactly one accepting path in its computation tree. If there are none or more than one accepting paths, the input is rejected. We study the descriptional complexity of XNFA accepting unary languages. While the state costs for mutual simulations with DFA and NFA over general alphabets differ significantly from the known types of finite automata, it turns out that the state costs for the simulations in the unary case are in the order of magnitude of the general case. In particular, the state costs for the simulation of an XNFA by a DFA or an NFA are $e^{\theta(\sqrt{n \cdot ln{n}})}$. Conversely, converting an NFA to an equivalent XNFA may cost $e^{\theta(\sqrt{n \cdot ln{n}})}$ states as well. All bounds obtained are also tight in the order of magnitude. Finally, we investigate the computational complexity of different decision problems for unary XNFA and it is shown that the problems of emptiness, universality, inclusion, and equivalence are coNP-complete, whereas the general membership problem is NL-complete.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06967v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.10</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 136-149</arxiv:journal_reference>
      <dc:creator>Martin Kutrib (Institut f\"ur Informatik, Universit\"at Giessen), Andreas Malcher (Institut f\"ur Informatik, Universit\"at Giessen), Matthias Wendlandt (Institut f\"ur Informatik, Universit\"at Giessen)</dc:creator>
    </item>
    <item>
      <title>A New Notion of Regularity: Finite State Automata Accepting Graphs</title>
      <link>https://arxiv.org/abs/2409.06968</link>
      <description>arXiv:2409.06968v1 Announce Type: new 
Abstract: Analogous to regular string and tree languages, regular languages of directed acyclic graphs (DAGs) are defined in the literature. Although called regular, those DAG-languages are more powerful and, consequently, standard problems have a higher complexity than in the string case. Top-down as well as bottom-up deterministic DAG languages are subclasses of the regular DAG languages. We refine this hierarchy by providing a weaker subclass of the deterministic DAG languages. For a DAG grammar generating a language in this new DAG language class, or, equivalently, a DAG-automaton recognizing it, a classical deterministic finite state automaton (DFA) can be constructed. As the main result, we provide a characterization of this class.
  The motivation behind this is the transfer of techniques for regular string languages to graphs. Trivially, our restricted DAG language class is closed under union and intersection. This permits the application of minimization and hyper-minimization algorithms known for DFAs. This alternative notion of regularity coins at the existence of a DFA for recognizing a DAG language.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06968v1</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 5-26</arxiv:journal_reference>
      <dc:creator>Yvo Ad Meeres (University of Bremen, Germany)</dc:creator>
    </item>
    <item>
      <title>Determinism in Multi-Soliton Automata</title>
      <link>https://arxiv.org/abs/2409.06969</link>
      <description>arXiv:2409.06969v1 Announce Type: new 
Abstract: Soliton automata are mathematical models of soliton switching in chemical molecules. Several concepts of determinism for soliton automata have been defined. The concept of strong determinism has been investigated for the case in which only a single soliton can be present in a molecule. In the present paper, several different concepts of determinism are explored for the multi-soliton case. It is shown that the degree of non-determinism is a connected measure of descriptional complexity for multi-soliton automata. A characterization of the class of strongly deterministic multi-soliton automata is presented. Finally, the concept of perfect determinism, forming a natural extension of strong determinism, is introduced and considered for multi-soliton automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06969v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 44-58</arxiv:journal_reference>
      <dc:creator>Henning Bordihn (University of Potsdam, Institute of Computer Science), Helena Schulz</dc:creator>
    </item>
    <item>
      <title>Operational State Complexity of Block Languages</title>
      <link>https://arxiv.org/abs/2409.06970</link>
      <description>arXiv:2409.06970v1 Announce Type: new 
Abstract: In this paper we consider block languages, namely sets of words having the same length, and study the deterministic and nondeterministic state complexity of several operations on these languages. Being a subclass of finite languages, the upper bounds of operational state complexity known for finite languages apply for block languages as well. However, in several cases, smaller values were found. Block languages can be represented as bitmaps, which are a good tool to study their minimal finite automata and their operations, as we  illustrate here.
</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06970v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.5</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 59-76</arxiv:journal_reference>
      <dc:creator>Guilherme Duarte (CMUP,FCUP), Nelma Moreira (CMUP,FCUP), Luca Prigioniero (University of Loughborough), Rog\'erio Reis (CMUP,FCUP)</dc:creator>
    </item>
    <item>
      <title>Winning Strategies for the Synchronization Game on Subclasses of Finite Automata</title>
      <link>https://arxiv.org/abs/2409.06971</link>
      <description>arXiv:2409.06971v1 Announce Type: new 
Abstract: We exhibit a winning strategy for Synchronizer in the synchronization game on every synchronizing automaton in whose transition monoid the regular D-classes form subsemigroups</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06971v1</guid>
      <category>cs.FL</category>
      <category>cs.GT</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 77-85</arxiv:journal_reference>
      <dc:creator>Henning Fernau (Universit\"at Trier, Fachbereich IV, Informatikwissenschaften, Trier, Germany), Carolina Haase (Universit\"at Trier, Fachbereich IV, Informatikwissenschaften, Trier, Germany), Stefan Hoffmann (Institute of Natural Sciences,Mathematics, Ural Federal University, Ekaterinburg, Russia), Mikhail Volkov (Institute of Natural Sciences,Mathematics, Ural Federal University, Ekaterinburg, Russia)</dc:creator>
    </item>
    <item>
      <title>How to Demonstrate Metalinearness and Regularity by Tree-Restricted General Grammars</title>
      <link>https://arxiv.org/abs/2409.06972</link>
      <description>arXiv:2409.06972v1 Announce Type: new 
Abstract: This paper introduces derivation trees for general grammars. Within these trees, it defines context-dependent pairs of nodes, corresponding to rewriting two neighboring symbols using a non context-free rule. It proves that the language generated by a linear core general grammar with a slow-branching derivation tree is k-linear if there is a constant u such that every sentence w in the generated language is the frontier of a derivation tree in which any pair of neighboring paths contains u or fewer context-dependent pairs of nodes. Next, it proves that the language generated by a general grammar with a regular core is regular if there is a constant u such that every sentence w in the generated language is the frontier of a derivation tree in which any pair of neighboring paths contains u or fewer context-dependent pairs of nodes. The paper explains that this result is a powerful tool for showing that certain languages are k-linear or regular.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06972v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.7</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 86-99</arxiv:journal_reference>
      <dc:creator>Martin Havel (Brno University of Technology, Faculty of Information Technology), Zbyn\v{e}k K\v{r}ivka (Brno University of Technology, Faculty of Information Technology), Alexander Meduna (Brno University of Technology, Faculty of Information Technology)</dc:creator>
    </item>
    <item>
      <title>Non-Global Parikh Tree Automata</title>
      <link>https://arxiv.org/abs/2409.06973</link>
      <description>arXiv:2409.06973v1 Announce Type: new 
Abstract: Parikh (tree) automata are an expressive and yet computationally well-behaved extension of finite automata -- they allow to increment a number of counters during their computations, which are finally tested by a semilinear constraint. In this work, we introduce and investigate a new perspective on Parikh tree automata (PTA): instead of testing one counter configuration that results from the whole input tree, we implement a non-global automaton model. Here, we copy and distribute the current configuration at each node to all its children, incrementing the counters pathwise, and check the arithmetic constraint at each leaf. We obtain that the classes of tree languages recognizable by global PTA and non-global PTA are incomparable. In contrast to global PTA, the non-emptiness problem is undecidable for non-global PTA if we allow the automata to work with at least three counters, whereas the membership problem stays decidable. However, for a restriction of the model, where counter configurations are passed in a linear fashion to at most one child node, we can prove decidability of the non-emptiness problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06973v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.8</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 100-117</arxiv:journal_reference>
      <dc:creator>Luisa Herrmann (TU Dresden), Johannes Osterholzer</dc:creator>
    </item>
    <item>
      <title>Various Types of Comet Languages and their Application in External Contextual Grammars</title>
      <link>https://arxiv.org/abs/2409.06974</link>
      <description>arXiv:2409.06974v1 Announce Type: new 
Abstract: In this paper, we continue the research on the power of contextual grammars with selection languages from subfamilies of the family of regular languages. We investigate various comet-like types of languages and compare such language families to some other subregular families of languages (finite, monoidal, nilpotent, combinational, (symmetric) definite, ordered, non-counting,  power-separating, suffix-closed, commutative, circular, or union-free languages). Further, we compare the language families defined by these types for the selection with each other and with the families of the hierarchy obtained for external contextual grammars. In this way, we extend the existing hierarchy by new language families.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06974v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.9</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 118-135</arxiv:journal_reference>
      <dc:creator>Marvin K\"odding, Bianca Truthe</dc:creator>
    </item>
    <item>
      <title>Repetitive Finite Automata With Translucent Letters</title>
      <link>https://arxiv.org/abs/2409.06975</link>
      <description>arXiv:2409.06975v1 Announce Type: new 
Abstract: Here we propose an extension of the (deterministic and the nondeterministic) finite automaton with translucent letters (DFAwtl and NFAwtl), which lies between these automata and their non-returning variants (that is, the nr-DFAwtl and the nr-NFAwtl). This new model works like a DFAwtl or an NFAwtl, but on seeing the end-of-tape marker, it may change its internal state and continue with its computation instead of just ending it, accepting or rejecting. This new type of automaton is called a repetitive deterministic or nondeterministic finite automaton with translucent letters (RDFAwtl or RNFAwtl). In the deterministic case, the new model is strictly more expressive than the DFAwtl, but less expressive than the nr-DFAwtl, while in the nondeterministic case, the new model is equivalent to the NFAwtl.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06975v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.11</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 150-167</arxiv:journal_reference>
      <dc:creator>Franti\v{s}ek Mr\'az (Charles University at Prague), Friedrich Otto (University of Kassel)</dc:creator>
    </item>
    <item>
      <title>5' -&gt; 3' Watson-Crick Automata accepting Necklaces</title>
      <link>https://arxiv.org/abs/2409.06976</link>
      <description>arXiv:2409.06976v1 Announce Type: new 
Abstract: Watson-Crick (WK) finite automata work on a Watson-Crick tape representing a DNA molecule. They have two reading heads. In 5'-&gt;3'  WK automata, the heads move and read the input in opposite physical directions. In this paper, we consider such inputs which are necklaces, i.e., they represent circular DNA molecules. In sensing  5'-&gt;3'  WK automata, the computation on the input is finished when the heads meet. As the original model is capable of accepting the linear context-free languages, the necklace languages we are investigating here have strong relations to that class. Here, we use these automata in two different acceptance modes. On the one hand, in weak acceptance mode the heads are starting nondeterministically at any point of the input, like the necklace is cut at a nondeterministically chosen point), and if the input is accepted, it is in the accepted necklace language. These languages can be seen as the languages obtained from the linear context-free languages by taking their closure under cyclic shift operation. On the other hand, in strong acceptance mode, it is required that the input is accepted starting the heads in the computation from every point of the cycle. These languages can be seen as the maximal cyclic shift closed languages included in a linear language. On the other hand, as  it will be shown, they have a kind of locally testable property. We present some hierarchy results based on restricted variants of the WK automata, such as stateless or all-final variants.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06976v1</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.12</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 168-185</arxiv:journal_reference>
      <dc:creator>Benedek Nagy (Eastern Mediterranean University, Famagusta,Eszterh\'azy K\'aroly Catholic University, Eger)</dc:creator>
    </item>
    <item>
      <title>Complexity Aspects of the Extension of Wagner's Hierarchy to $k$-Partitions</title>
      <link>https://arxiv.org/abs/2409.06977</link>
      <description>arXiv:2409.06977v1 Announce Type: new 
Abstract: It is known that the Wadge reducibility of regular $\omega$-languages is efficiently decidable (Krishnan et al., 1995), (Wilke, Yoo, 1995). In this paper we study analogous problem for regular k-partitions of $\omega$-languages. In the series of previous papers (Selivanov, 2011), (Alaev, Selivanov, 2021), (Selivanov, 2012) there was a partial progress towards obtaining an efficient algorithm for deciding the Wadge reducibility in this setting as well. In this paper we finalize this line of research providing a quadratic algorithm (in RAM model). For this we construct a quadratic algorithm to decide a preorder relation on iterated posets. Additionally, we discuss the size of the representation of regular $\omega$-languages and suggest a more compact way to represent them. The algorithm we provide is efficient for the more compact representation as well.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06977v1</guid>
      <category>cs.FL</category>
      <category>cs.CC</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.13</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 186-197</arxiv:journal_reference>
      <dc:creator>Vladimir Podolskii, Victor Selivanov</dc:creator>
    </item>
    <item>
      <title>Large Language Models and the Extended Church-Turing Thesis</title>
      <link>https://arxiv.org/abs/2409.06978</link>
      <description>arXiv:2409.06978v1 Announce Type: new 
Abstract: The Extended Church-Turing Thesis (ECTT) posits that all effective information processing, including unbounded and non-uniform interactive computations, can be described in terms of interactive Turing machines with advice. Does this assertion also apply to the abilities of contemporary large language models (LLMs)? From a broader perspective, this question calls for an investigation of the computational power of LLMs by the classical means of computability and computational complexity theory, especially the theory of automata. Along these lines, we establish a number of fundamental results. Firstly, we argue that any fixed (non-adaptive) LLM is computationally equivalent to a, possibly very large, deterministic finite-state transducer. This characterizes the base level of LLMs. We extend this to a key result concerning the simulation of space-bounded Turing machines by LLMs. Secondly, we show that lineages of evolving LLMs are computationally equivalent to interactive Turing machines with advice. The latter finding confirms the validity of the ECTT for lineages of LLMs. From a computability viewpoint, it also suggests that lineages of LLMs possess super-Turing computational power. Consequently, in our computational model knowledge generation is in general a non-algorithmic process realized by lineages of LLMs.  Finally, we discuss the merits of our findings in the broader context of several related disciplines and philosophies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.06978v1</guid>
      <category>cs.FL</category>
      <category>cs.AI</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.407.14</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 407, 2024, pp. 198-213</arxiv:journal_reference>
      <dc:creator>Ji\v{r}\'i Wiedermann, Jan van Leeuwen</dc:creator>
    </item>
    <item>
      <title>Submonoid Membership in n-dimensional lamplighter groups and S-unit equations</title>
      <link>https://arxiv.org/abs/2409.07077</link>
      <description>arXiv:2409.07077v1 Announce Type: cross 
Abstract: We show that Submonoid Membership is decidable in n-dimensional lamplighter groups $(\mathbb{Z}/p\mathbb{Z}) \wr \mathbb{Z}^n$ for any prime $p$ and integer $n$. More generally, we show decidability of Submonoid Membership in semidirect products of the form $\mathcal{Y} \rtimes \mathbb{Z}^n$, where $\mathcal{Y}$ is any finitely presented module over the Laurent polynomial ring $\mathbb{F}_p[X_1^{\pm}, \ldots, X_n^{\pm}]$. Combined with a result of Shafrir (2024), this gives the first example of a group $G$ and a finite index subgroup $\widetilde{G} \leq G$, such that Submonoid Membership is decidable in $\widetilde{G}$ but undecidable in $G$.
  To obtain our decidability result, we reduce Submonoid Membership in $\mathcal{Y} \rtimes \mathbb{Z}^n$ to solving S-unit equations over $\mathbb{F}_p[X_1^{\pm}, \ldots, X_n^{\pm}]$-modules. We show that the solution set of such equations is effectively $p$-automatic, extending a result of Adamczewski and Bell (2012). As an intermediate result, we also obtain that the solution set of the Knapsack Problem in $\mathcal{Y} \rtimes \mathbb{Z}^n$ is effectively $p$-automatic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.07077v1</guid>
      <category>math.GR</category>
      <category>cs.FL</category>
      <category>math.NT</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ruiwen Dong</dc:creator>
    </item>
    <item>
      <title>Myhill-Nerode Theorem for Higher-Dimensional Automata</title>
      <link>https://arxiv.org/abs/2210.08298</link>
      <description>arXiv:2210.08298v5 Announce Type: replace 
Abstract: We establish a Myhill-Nerode type theorem for higher-dimensional automata (HDAs), stating that a language is regular if and only if it has finite prefix quotient. HDAs extend standard automata with additional structure, making it possible to distinguish between interleavings and concurrency. We also introduce deterministic HDAs and show that not all HDAs are determinizable, that is, there exist regular languages that cannot be recognised by a deterministic HDA. Using our theorem, we develop an internal characterisation of deterministic languages. Lastly, we develop analogues of the Myhill-Nerode construction and of determinacy for HDAs with interfaces.</description>
      <guid isPermaLink="false">oai:arXiv.org:2210.08298v5</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Uli Fahrenberg, Krzysztof Ziemia\'nski</dc:creator>
    </item>
    <item>
      <title>Two or three things I know about tree transducers</title>
      <link>https://arxiv.org/abs/2409.03169</link>
      <description>arXiv:2409.03169v2 Announce Type: replace 
Abstract: You might know that the name "tree transducers" refers to various kinds of automata that compute functions on ranked trees, i.e. terms over a first-order signature.
  But have you ever wondered about how to remember what a macro tree transducer does? Or what are the connections between top-down tree(-to-string) transducers, multi bottom-up tree(-to-string) transducers, tree-walking transducers, (invisible) pebble tree transducers, monadic second-order transductions, unfoldings of rooted directed acyclic graphs (i.e. term graphs) -- and what happens when the functions that they compute are composed?
  The answers may be found in old papers (mostly coauthored by Engelfriet), but maybe you can save some time by first looking at this short note.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.03169v2</guid>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>L\^e Th\`anh D\~ung Nguy\^en</dc:creator>
    </item>
    <item>
      <title>Taking Complete Finite Prefixes To High Level, Symbolically</title>
      <link>https://arxiv.org/abs/2311.11443</link>
      <description>arXiv:2311.11443v4 Announce Type: replace-cross 
Abstract: Unfoldings are a well known partial-order semantics of P/T Petri nets that can be applied to various model checking or verification problems. For high-level Petri nets, the so-called symbolic unfolding generalizes this notion. A complete finite prefix of a P/T Petri net's unfolding contains all information to verify, e.g., reachability of markings. We unite these two concepts and define complete finite prefixes of the symbolic unfolding of high-level Petri nets. For a class of safe high-level Petri nets, we generalize the well-known algorithm by Esparza et al. for constructing small such prefixes. We evaluate this extended algorithm through a prototype implementation on four novel benchmark families. Additionally, we identify a more general class of nets with infinitely many reachable markings, for which an approach with an adapted cut-off criterion extends the complete prefix methodology, in the sense that the original algorithm cannot be applied to the P/T net represented by a high-level net.</description>
      <guid isPermaLink="false">oai:arXiv.org:2311.11443v4</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Thu, 12 Sep 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.3233/FI-242196</arxiv:DOI>
      <dc:creator>Nick W\"urdemann, Thomas Chatain, Stefan Haar, Lukas Panneke</dc:creator>
    </item>
  </channel>
</rss>
