<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 Jan 2026 02:32:06 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>The asymptotic size of finite irreducible semigroups of rational matrices</title>
      <link>https://arxiv.org/abs/2601.01236</link>
      <description>arXiv:2601.01236v1 Announce Type: new 
Abstract: We study finite semigroups of $n \times n$ matrices with rational entries. Such semigroups provide a rich generalization of transition monoids of unambiguous (and, in particular, deterministic) finite automata. In this paper we determine the maximum size of finite semigroups of rational $n \times n$ matrices, with the goal of shedding more light on the structure of such matrix semigroups.
  While in general such semigroups can be arbitrarily large in terms of $n$, a classical result of Sch\"utzenberger from 1962 implies an upper bound of $2^{O(n^2 \log n)}$ for irreducible semigroups, i.e., the only subspaces of $Q^n$ that are invariant for all matrices in the semigroup are $Q^n$ and the subspace consisting only of the zero vector. Irreducible matrix semigroups can be viewed as the building blocks of general matrix semigroups, and as such play an important role in mathematics and computer science. From the point of view of automata theory, they generalize strongly connected automata.
  Using a very different technique from that of Sch\"utzenberger, we improve the upper bound on the cardinality to $3^{n^2}$. This is the main result of the paper. The bound is in some sense tight, as we show that there exists, for every $n$, a finite irreducible semigroup with $3^{\lfloor n^2/4 \rfloor}$ rational matrices. Our main result also leads to an improvement of a bound, due to Almeida and Steinberg, on the mortality threshold. The mortality threshold is a number $\ell$ such that if the zero matrix is in the semigroup, then the zero matrix can be written as a product of at most $\ell$ matrices from any subset that generates the semigroup.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.01236v1</guid>
      <category>cs.FL</category>
      <category>math.GR</category>
      <category>math.RA</category>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Stefan Kiefer, Andrew Ryzhikov</dc:creator>
    </item>
    <item>
      <title>From Historical Puzzles to Grammatical Constraints: Circular Partitions, Generalized Run-Length Encodings, and Polynomial-Time Decidability</title>
      <link>https://arxiv.org/abs/2601.01375</link>
      <description>arXiv:2601.01375v1 Announce Type: new 
Abstract: Motivated by a historical combinatorial problem that resembles the well-known Josephus problem, we investigate circular partition algorithms and formulate problems in deterministic finite automata with practical algorithms. The historical problem involves arranging individuals on a circle and eliminating every k-th person until a desired group remains. We analyze both removal and non-removal approaches to circular partitioning, establishing conditions for balanced partitions and providing explicit algorithms. We introduce generalized run-length encodings over partitioned alphabets to capture alternating letter patterns, computing their cardinalities using Stirling numbers of the second kind. Connecting these combinatorial structures to formal language theory, we formulate an existence problem: given a context-free grammar over a dictionary and block-pattern constraints on letters, does a valid sentence exist? We prove decidability in polynomial time by showing block languages are regular and applying standard parsing techniques. Complete algorithms with complexity analysis are provided and validated through implementation on both historical and synthetic instances.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.01375v1</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Omid Khormali, Ghaya Mtimet, Nuh Aydin</dc:creator>
    </item>
    <item>
      <title>Deciding Serializability in Network Systems</title>
      <link>https://arxiv.org/abs/2601.02251</link>
      <description>arXiv:2601.02251v2 Announce Type: new 
Abstract: We present the SER modeling language for automatically verifying serializability of concurrent programs, i.e., whether every concurrent execution of the program is equivalent to some serial execution. SER programs are suitably restricted to make this problem decidable, while still allowing for an unbounded number of concurrent threads of execution, each potentially running for an unbounded number of steps. Building on prior theoretical results, we give the first automated end-to-end decision procedure that either proves serializability by producing a checkable certificate, or refutes it by producing a counterexample trace. We also present a network-system abstraction to which SER programs compile. Our decision procedure then reduces serializability in this setting to a Petri net reachability query. Furthermore, in order to scale, we curtail the search space via multiple optimizations, including Petri net slicing, semilinear-set compression, and Presburger-formula manipulation. We extensively evaluate our framework and show that, despite the theoretical hardness of the problem, it can successfully handle various models of real-world programs, including stateful firewalls, BGP routers, and more.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.02251v2</guid>
      <category>cs.FL</category>
      <category>cs.DC</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guy Amir, Mark Barbone, Nicolas Amat, Jules Jacobs</dc:creator>
    </item>
    <item>
      <title>A formal query language and automata model for aggregation in complex event recognition</title>
      <link>https://arxiv.org/abs/2601.00967</link>
      <description>arXiv:2601.00967v1 Announce Type: cross 
Abstract: Complex Event Recognition (CER) systems are used to identify complex patterns in event streams, such as those found in stock markets, sensor networks, and other similar applications. An important task in such patterns is aggregation, which involves summarizing a set of values into a single value using an algebraic function, such as the maximum, sum, or average, among others. Despite the relevance of this task, query languages in CER typically support aggregation in a restricted syntactic form, and their semantics are generally undefined.
  In this work, we present a first step toward formalizing a query language with aggregation for CER. We propose to extend Complex Event Logic (CEL), a formal query language for CER, with aggregation operations. This task requires revisiting the semantics of CEL, using a new semantics based on bags of tuples instead of sets of positions. Then, we present an extension of CEL, called Aggregation CEL (ACEL), which introduces an aggregation operator for any commutative monoid operation. The operator can be freely composed with previous CEL operators, allowing users to define complex queries and patterns. We showcase several queries in practice where ACEL proves to be natural for specifying them. From the computational side, we present a novel automata model, called Aggregation Complex Event Automata (ACEA), that extends the previous proposal of Complex Event Automata (CEA) with aggregation and filtering features. Moreover, we demonstrate that every query in ACEL can be expressed in ACEA, illustrating the effectiveness of our computational model. Finally, we study the expressiveness of ACEA through the lens of ACEL, showing that the automata model is more expressive than ACEL.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.00967v1</guid>
      <category>cs.DB</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pierre Bourhis, Cristian Riveros, Amaranta Salas</dc:creator>
    </item>
    <item>
      <title>Context-Free Recognition with Transformers</title>
      <link>https://arxiv.org/abs/2601.01754</link>
      <description>arXiv:2601.01754v1 Announce Type: cross 
Abstract: Transformers excel on tasks that process well-formed inputs according to some grammar, such as natural language and code. However, it remains unclear how they can process grammatical syntax. In fact, under standard complexity conjectures, standard transformers cannot recognize context-free languages (CFLs), a canonical formalism to describe syntax, or even regular languages, a subclass of CFLs (Merrill et al., 2022). Merrill &amp; Sabharwal (2024) show that $\mathcal{O}(\log n)$ looping layers (w.r.t. input length $n$) allows transformers to recognize regular languages, but the question of context-free recognition remained open. In this work, we show that looped transformers with $\mathcal{O}(\log n)$ looping layers and $\mathcal{O}(n^6)$ padding tokens can recognize all CFLs. However, training and inference with $\mathcal{O}(n^6)$ padding tokens is potentially impractical. Fortunately, we show that, for natural subclasses such as unambiguous CFLs, the recognition problem on transformers becomes more tractable, requiring $\mathcal{O}(n^3)$ padding. We empirically validate our results and show that looping helps on a language that provably requires logarithmic depth. Overall, our results shed light on the intricacy of CFL recognition by transformers: While general recognition may require an intractable amount of padding, natural constraints such as unambiguity yield efficient recognition algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.01754v1</guid>
      <category>cs.LG</category>
      <category>cs.CC</category>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Selim Jerad, Anej Svete, Sophie Hao, Ryan Cotterell, William Merrill</dc:creator>
    </item>
    <item>
      <title>Unambiguous Acceptance of Thin Coalgebras</title>
      <link>https://arxiv.org/abs/2510.26371</link>
      <description>arXiv:2510.26371v3 Announce Type: replace 
Abstract: Automata admitting at most one accepting run per structure, known as unambiguous automata, find applications in verification of reactive systems as they extend the class of deterministic automata whilst maintaining some of their desirable properties. In this paper, we generalise a classical construction of unambiguous automata from thin trees to thin coalgebras for analytic functors. This achieves two goals: extending the existing construction to a larger class of structures, and providing conceptual clarity and parametricity to the construction by formalising it in the coalgebraic framework. As part of the construction, we link automaton acceptance of languages of thin coalgebras to language recognition via so-called coherent algebras, which were previously introduced for studying thin coalgebras. This link also allows us to establish an automata-theoretic characterisation of languages recognised by finite coherent algebras.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.26371v3</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.46298/entics.16832</arxiv:DOI>
      <arxiv:journal_reference>Electronic Notes in Theoretical Informatics and Computer Science, Volume 5 - Proceedings of MFPS XLI (December 20, 2025) entics:16832</arxiv:journal_reference>
      <dc:creator>Anton Chernev, Corina C\^irstea, Helle Hvid Hansen, Clemens Kupke</dc:creator>
    </item>
    <item>
      <title>Formalization of Harder-Narasimhan theory</title>
      <link>https://arxiv.org/abs/2509.19632</link>
      <description>arXiv:2509.19632v2 Announce Type: replace-cross 
Abstract: The Harder-Narasimhan theory provides a canonical filtration of a vector bundle on a projective curve whose successive quotients are semistable with strictly decreasing slopes. In this article, we present the formalization of Harder-Narasimhan theory in the proof assistant Lean 4 with Mathlib. This formalization is based on a recent approach of Harder-Narasimhan theory by Chen and Jeannin, which reinterprets the theory in order-theoretic terms and avoids the classical dependence on algebraic geometry. As an application, we formalize the uniqueness of coprimary filtration of a finitely generated module over a noetherian ring, and the existence of the Jordan-H\"older filtration of a semistable Harder-Narasimhan game.
  Code available at: https://github.com/YijunYuan/HarderNarasimhan</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.19632v2</guid>
      <category>math.AG</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>math.NT</category>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yijun Yuan</dc:creator>
    </item>
  </channel>
</rss>
