<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DM updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DM</link>
    <description>cs.DM updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DM" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Apr 2024 04:00:11 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 23 Apr 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Linear Search for an Escaping Target with Unknown Speed</title>
      <link>https://arxiv.org/abs/2404.14300</link>
      <description>arXiv:2404.14300v1 Announce Type: new 
Abstract: We consider linear search for an escaping target whose speed and initial position are unknown to the searcher. A searcher (an autonomous mobile agent) is initially placed at the origin of the real line and can move with maximum speed $1$ in either direction along the line. An oblivious mobile target that is moving away from the origin with an unknown constant speed $v&lt;1$ is initially placed by an adversary on the infinite line at distance $d$ from the origin in an unknown direction. We consider two cases, depending on whether $d$ is known or unknown. The main contribution of this paper is to prove a new lower bound and give algorithms leading to new upper bounds for search in these settings. This results in an optimal (up to lower order terms in the exponent) competitive ratio in the case where $d$ is known and improved upper and lower bounds for the case where $d$ is unknown. Our results solve an open problem proposed in [Coleman et al., Proc. OPODIS 2022].</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.14300v1</guid>
      <category>cs.DM</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jared Coleman, Dmitry Ivanov, Evangelos Kranakis, Danny Krizanc, Oscar Morales-Ponce</dc:creator>
    </item>
    <item>
      <title>On multidimensional generalization of binary search</title>
      <link>https://arxiv.org/abs/2404.13193</link>
      <description>arXiv:2404.13193v1 Announce Type: cross 
Abstract: This work generalizes the binary search problem to a $d$-dimensional domain $S_1\times\cdots\times S_d$, where $S_i=\{0, 1, \ldots,n_i-1\}$ and $d\geq 1$, in the following way. Given $(t_1,\ldots,t_d)$, the target element to be found, the result of a comparison of a selected element $(x_1,\ldots,x_d)$ is the sequence of inequalities each stating that either $t_i &lt; x_i$ or $t_i&gt;x_i$, for $i\in\{1,\ldots,d\}$, for which at least one is correct, and the algorithm does not know the coordinate $i$ on which the correct direction to the target is given. Among other cases, we show asymptotically almost matching lower and upper bounds of the query complexity to be in $\Omega(n^{d-1}/d)$ and $O(n^d)$ for the case of $n_i=n$. In particular, for fixed $d$ these bounds asymptotically do match. This problem is equivalent to the classical binary search in case of one dimension and shows interesting differences for higher dimensions. For example, if one would impose that each of the $d$ inequalities is correct, then the search can be completed in $\log_2\max\{n_1,\ldots,n_d\}$ queries. In an intermediate model when the algorithm knows which one of the inequalities is correct the sufficient number of queries is $\log_2(n_1\cdot\ldots\cdot n_d)$. The latter follows from a graph search model proposed by Emamjomeh-Zadeh et al. [STOC 2016].</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.13193v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dariusz Dereniowski, Przemys{\l}aw Gordinowicz, Karolina Wr\'obel</dc:creator>
    </item>
    <item>
      <title>Minimum Spanning Tree Cycle Intersection Problem</title>
      <link>https://arxiv.org/abs/2102.13193</link>
      <description>arXiv:2102.13193v2 Announce Type: replace 
Abstract: Consider a connected graph $G$ and let $T$ be a spanning tree of $G$. Every edge $e \in G-T$ induces a cycle in $T \cup \{e\}$. The intersection of two distinct such cycles is the set of edges of $T$ that belong to both cycles. We consider the problem of finding a spanning tree that has the least number of such non-empty intersections.</description>
      <guid isPermaLink="false">oai:arXiv.org:2102.13193v2</guid>
      <category>cs.DM</category>
      <category>math.CO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1016/j.dam.2021.01.031</arxiv:DOI>
      <dc:creator>Manuel Dubinsky, C\'esar Massri, Gabriel Taubin</dc:creator>
    </item>
    <item>
      <title>Walking on Words</title>
      <link>https://arxiv.org/abs/2208.08913</link>
      <description>arXiv:2208.08913v2 Announce Type: replace 
Abstract: Take any word over some alphabet. If it is non-empty, go to any position and print out the letter being scanned. Now repeat the following any number of times (possibly zero): either stay at the current letter, or move one letter leftwards (if possible) or move one letter rightwards (if possible); then print out the letter being scanned. In effect, we are going for a walk on the input word. Let u be the infix of the input word comprising the visited positions, and w the word printed out (empty if the input word is). Since any unvisited prefix or suffix of the input word cannot influence w, we may as well discard them, and say that u generates w. We ask: given a word w, what words u generate it? The answer is surprising. Call u a primitive generator of w if u generates w and is not generated by any word shorter than u. We show that, excepting some degenerate cases, every word has precisely two primitive generators.</description>
      <guid isPermaLink="false">oai:arXiv.org:2208.08913v2</guid>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ian Pratt-Hartmann</dc:creator>
    </item>
    <item>
      <title>Three aspects of the MSTCI problem</title>
      <link>https://arxiv.org/abs/2301.07643</link>
      <description>arXiv:2301.07643v2 Announce Type: replace-cross 
Abstract: Consider a connected graph $G$ and let $T$ be a spanning tree of $G$. Every edge $e \in G-T$ induces a cycle in $T \cup \{e\}$. The intersection of two distinct such cycles is the set of edges of $T$ that belong to both cycles. The MSTCI problem consists in finding a spanning tree that has the least number of such non-empty intersections and the instersection number is the number of non-empty intersections of a solution. In this article we consider three aspects of the problem in a general context (i.e. for arbitrary connected graphs). The first presents two lower bounds of the intersection number. The second compares the intersection number of graphs that differ in one edge. The last is an attempt to generalize a recent result for graphs with a universal vertex.</description>
      <guid isPermaLink="false">oai:arXiv.org:2301.07643v2</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Manuel Dubinsky, C\'esar Massri, Gabriel Taubin</dc:creator>
    </item>
    <item>
      <title>Hypergraph dualization with FPT-delay parameterized by the degeneracy and dimension</title>
      <link>https://arxiv.org/abs/2305.06974</link>
      <description>arXiv:2305.06974v4 Announce Type: replace-cross 
Abstract: At STOC 2002, Eiter, Gottlob, and Makino presented a technique called ordered generation that yields an $n^{O(d)}$-delay algorithm listing all minimal transversals of an $n$-vertex hypergraph of degeneracy $d$. Recently at IWOCA 2019, Conte, Kant\'e, Marino, and Uno asked whether this XP-delay algorithm parameterized by $d$ could be made FPT-delay for a weaker notion of degeneracy, or even parameterized by the maximum degree $\Delta$, i.e., whether it can be turned into an algorithm with delay $f(\Delta)\cdot n^{O(1)}$ for some computable function $f$. Moreover, and as a first step toward answering that question, they note that they could not achieve these time bounds even for the particular case of minimal dominating sets enumeration. In this paper, using ordered generation, we show that an FPT-delay algorithm can be devised for minimal transversals enumeration parameterized by the degeneracy and dimension, giving a positive and more general answer to the latter question.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.06974v4</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Valentin Bartier, Oscar Defrain, Fionn Mc Inerney</dc:creator>
    </item>
    <item>
      <title>Kalai's $3^{d}$ conjecture for unconditional and locally anti-blocking polytopes</title>
      <link>https://arxiv.org/abs/2308.02909</link>
      <description>arXiv:2308.02909v3 Announce Type: replace-cross 
Abstract: Kalai's $3^d$ conjecture states that every centrally-symmetric $d$-polytope has at least $3^d$ faces. We give short proofs for two special cases: if $P$ is unconditional (that is, invariant w.r.t. reflection in any coordinate hyperplane), and more generally, if $P$ is locally anti-blocking. In both cases we show that the minimum is attained exactly for the Hanner polytopes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.02909v3</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>math.MG</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Raman Sanyal, Martin Winter</dc:creator>
    </item>
  </channel>
</rss>
