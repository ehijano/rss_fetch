<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Jan 2026 02:49:30 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Variants of Higher-Dimensional Automata</title>
      <link>https://arxiv.org/abs/2601.17537</link>
      <description>arXiv:2601.17537v1 Announce Type: new 
Abstract: The theory of higher-dimensional automata (HDAs) has seen rapid progress in recent years, and first applications, notably to Petri net analysis, are starting to show. It has, however, emerged that HDAs themselves often are too strict a formalism to use and reason about. In order to solve specific problems, weaker variants of HDAs have been introduced, such as HDAs with interfaces, partial HDAs, ST-automata or even relational HDAs.
  In this paper we collect definitions of these and a few other variants into a coherent whole and explore their properties and translations between them. We show that with regard to languages, the spectrum of variants collapses into two classes, languages closed under subsumption and those that are not. We also show that partial HDAs admit a Kleene theorem and that, contrary to HDAs, they are determinizable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.17537v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hugo Bazille, J\'er\'emy Dubut, Uli Fahrenberg, Krzysztof Ziemia\'nski</dc:creator>
    </item>
    <item>
      <title>Persistent Permutability in Choice Petri Nets</title>
      <link>https://arxiv.org/abs/2601.18004</link>
      <description>arXiv:2601.18004v1 Announce Type: new 
Abstract: Persistence is a strong, global, behavioural property of a Petri net, meaning that no activity can disable a different activity. Persistent permutability is a weaker property, pertaining to individual interleavings of a Petri net and stating that a non-persistent sequence can be permuted into a persistent one. We identify Petri net classes for which persistent permutability already suffices to imply overall persistence. These classes generalise free-choice nets and are related to Petri's concept of ``confusion'', while they are distinguished from each other by diverse restrictions on the choice structure of a net. We prove Ochmanski's conjecture to be correct for these classes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.18004v1</guid>
      <category>cs.FL</category>
      <category>cs.DM</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Eike Best, Raymond Devillers</dc:creator>
    </item>
    <item>
      <title>Adversarial Synchronization</title>
      <link>https://arxiv.org/abs/2601.18362</link>
      <description>arXiv:2601.18362v1 Announce Type: new 
Abstract: We study a variant of the synchronization game on finite deterministic automata. In this game, Alice chooses one input letter of an automaton $A$ on each of her moves while Bob may respond with an arbitrary finite word over the input alphabet of $A$; Alice wins if the word obtained by interleaving her letters with Bob's responses resets $A$. We prove that if Alice has a winning strategy in this game on $A$, then $A$ admits a reset word whose length is strictly smaller than the number of states of $A$. In contrast, for any $k\ge 1$, we exhibit automata with shortest reset-word length quadratic in the number of states, on which Alice nevertheless wins a version of the game in which Bob's responses are restricted to arbitrary words of length at most $k$. We provide polynomial-time algorithms for deciding the winner in various synchronization games, and we analyze the relationships between variants of synchronization games on fixed-size automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.18362v1</guid>
      <category>cs.FL</category>
      <category>cs.GT</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Anton E. Lipin, Mikhail V. Volkov</dc:creator>
    </item>
    <item>
      <title>Types for Grassroots Logic Programs</title>
      <link>https://arxiv.org/abs/2601.17957</link>
      <description>arXiv:2601.17957v1 Announce Type: cross 
Abstract: Grassroots Logic Programs (GLP) is a concurrent logic programming language in which logic variables are partitioned into paired readers and writers. An assignment is produced at most once via a writer and consumed at most once via its paired reader, and may contain additional readers and/or writers. This enables the concise expression of rich multidirectional communication modalities.
  ``Logic Programs as Types for Logic Programs'' (LICS'91) defined types as regular sets of paths over derivable ground atoms. Here, we define types to be regular sets of moded paths, where a mode captures directionality of communication -- whether a subterm is consumed from or produced to the environment -- enabling the typing of interactive partial computations including those that eventually deadlock or fail, or never terminate. We provide a syntactic definition of well-typing and prove that a program is well-typed iff the path abstraction of its moded-atom semantics satisfies covariance and contravariance conditions with respect to its type.
  The GLP type system was implemented in Dart by AI, starting from a mathematical specification of Typed GLP (this paper), deriving from it an English spec (written by AI), and from the spec deriving Dart code (by AI). While GLP is naturally untyped, the motivation for Typed GLP comes from programming with AI: Asking AI to program complex communication modalities in GLP (and in general) and hoping for the best is a tenuous strategy. The emerging discipline we advocate and employ is for the human designer and AI to jointly develop and agree upon (1)~GLP types; (2)~GLP procedure type declarations; (3)~informal (English) descriptions of the procedures; and only then let AI attempt to write (4)~GLP code based on those.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.17957v1</guid>
      <category>cs.PL</category>
      <category>cs.DC</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>cs.MA</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Ehud Shapiro</dc:creator>
    </item>
    <item>
      <title>A cartesian closed fibration of higher-order regular languages</title>
      <link>https://arxiv.org/abs/2601.18000</link>
      <description>arXiv:2601.18000v1 Announce Type: cross 
Abstract: We explain how to construct in two different ways a cartesian closed fibration of higher-order regular languages in the sense of Salvati. In the first construction, we use fibrational techniques to derive the cartesian closed fibration from the various categories of regular languages of $\lambda$-terms associated to finite sets of ground states. In the second construction, we take advantage of the recent notion of profinite $\lambda$-calculus to define the cartesian closed fibration by a change-of-base from the fibration of clopen subsets over the category of Stone spaces, using an elegant idea coming from Hermida. We illustrate the expressive power of the cartesian closed fibration by generalizing the notion of Brzozowski derivative to higher-order regular languages, using an Isbell-like adjunction in the sense of Melli\`es and Zeilberger.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.18000v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>math.CT</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Paul-Andr\'e Melli\`es, Vincent Moreau</dc:creator>
    </item>
    <item>
      <title>Algebraic Characterizations of Classes of Regular Languages in DynFO</title>
      <link>https://arxiv.org/abs/2601.18429</link>
      <description>arXiv:2601.18429v1 Announce Type: cross 
Abstract: This paper explores the fine-grained structure of classes of regular languages maintainable in fragments of first-order logic within the dynamic descriptive complexity framework of Patnaik and Immerman. A result by Hesse states that the class of regular languages is maintainable by first-order formulas even if only unary auxiliary relations can be used. Another result by Gelade, Marquardt,and Schwentick states that the class of regular languages coincides with the class of languages maintainable by quantifier-free formulas with binary auxiliary relations. We refine Hesse's result and show that with unary auxiliary data formulas with one quantifier alternation can maintain all regular languages. We then obtain precise algebraic characterizations of the classes of languages maintainable with quantifier-free formulas and positive existential formulas in the presence of unary auxiliary relations.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.18429v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Corentin Barloy, Felix Tschirbs, Nils Vortmeier, Thomas Zeume</dc:creator>
    </item>
    <item>
      <title>Well-quasi-ordered classes of bounded clique-width</title>
      <link>https://arxiv.org/abs/2601.18571</link>
      <description>arXiv:2601.18571v1 Announce Type: cross 
Abstract: We study classes of graphs with bounded clique-width that are well-quasi-ordered by the induced subgraph relation, in the presence of labels on the vertices. We prove that, given a finite presentation of a class of graphs, one can decide whether the class is labelled-well-quasi-ordered. This solves an open problem raised by Daligault, Rao and Thomass\'e in 2010, and answers positively to two conjectures of Pouzet in the restricted case of bounded clique-width classes. Namely, we prove that being labelled-well-quasi-ordered by a set of size 2 or by a well-quasi-ordered infinite set are equivalent conditions, and that in such cases, one can freely assume that the graphs are equipped with a total ordering on their vertices. Finally, we provide a structural characterization of those classes as those that are of bounded clique-width and do not existentially transduce the class of all finite paths.</description>
      <guid isPermaLink="false">oai:arXiv.org:2601.18571v1</guid>
      <category>math.CO</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Ma\"el Dumas, Aliaume Lopez</dc:creator>
    </item>
    <item>
      <title>Recursive Prime Factorizations: Dyck Words as Numbers</title>
      <link>https://arxiv.org/abs/2102.02777</link>
      <description>arXiv:2102.02777v3 Announce Type: replace 
Abstract: I propose a class of non-positional numeral systems where numbers are represented by Dyck words, with the systems arising from a recursive extension of prime factorization. After describing two proper subsets of the Dyck language capable of uniquely representing all natural numbers and a superset of the rational numbers respectively, I consider "Dyck-complete" languages, in which every member of the Dyck language represents a number. I conclude by suggesting possible research directions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2102.02777v3</guid>
      <category>cs.FL</category>
      <category>math.NT</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ralph L. Childress</dc:creator>
    </item>
    <item>
      <title>Higher-Dimensional Automata : Extension to Infinite Tracks</title>
      <link>https://arxiv.org/abs/2503.07881</link>
      <description>arXiv:2503.07881v2 Announce Type: replace 
Abstract: We introduce higher-dimensional automata for infinite interval ipomsets ($\omega$-HDAs). We define key concepts from different points of view, inspired from their finite counterparts. Then we explore languages recognized by $\omega$-HDAs under B\"uchi and Muller semantics. We show that Muller acceptance is more expressive than B\"uchi acceptance and, in contrast to the finite case, both semantics do not yield languages closed under subsumption. Then, we adapt the original rational operations to deal with $\omega$-HDAs and show that while languages of $\omega$-HDAs are $\omega$-rational, not all $\omega$-rational languages can be expressed by $\omega$-HDAs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.07881v2</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Luc Passemard, Amazigh Amrane, Uli Fahrenberg</dc:creator>
    </item>
    <item>
      <title>The computational inevitability of life: self-replication under resource-bounded nested algorithmic probability</title>
      <link>https://arxiv.org/abs/2010.09646</link>
      <description>arXiv:2010.09646v2 Announce Type: replace-cross 
Abstract: Recent computational experiments have demonstrated the spontaneous emergence of self-replicating programs across universal automata, artificial chemistries, and self-modifying code systems. Remarkably, these results arise without explicit fitness functions, reward shaping, or predefined objectives, indicating a gap in our formal understanding of the underlying computational process.
  In this work, we argue that self-replication is computationally inevitable under resource-bounded automata. Building on algorithmic information theory, we show that when universal inductive bias is applied under finite constraints of time, memory, and description length, programs that construct descriptions of themselves, i.e., quines, emerge as stable fixed points of nested algorithmic probability. We formalize this argument and demonstrate that self-replicating programs act as attractors in program space, independent of external optimization criteria. Thus, resource bounds transform universal induction into a competitive ecological process over programs, in which self-constructing programs dominate by stabilizing their own measure under resampling.
  We reinterpret recent results from computational life experiments and self-improving artificial agents as empirical realizations of this theoretical principle. More broadly, we propose that life is the simplest persistent structure available to constrained computation. A living system remembers itself because doing so is algorithmically and thermodynamically unavoidable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2010.09646v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.IT</category>
      <category>math.IT</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Aritra Sarkar</dc:creator>
    </item>
    <item>
      <title>Have a thing? Reasoning around recursion with dynamic typing in grounded arithmetic</title>
      <link>https://arxiv.org/abs/2510.25369</link>
      <description>arXiv:2510.25369v2 Announce Type: replace-cross 
Abstract: Neither the classical nor intuitionistic logic traditions are perfectly-aligned with the purpose of reasoning about computation, in that neither tradition can permit unconstrained recursive definitions without inconsistency: recursive logical definitions must normally be proven terminating before admission and use. We introduce grounded arithmetic or GA, a formal-reasoning foundation allowing direct expression of arbitrary recursive definitions. GA adjusts traditional inference rules so that terms that express nonterminating computations harmlessly denote no semantic value (i.e., bottom) instead of yielding inconsistency. Recursive functions may be proven terminating in GA essentially by "dynamically typing" terms, or equivalently, symbolically reverse-executing the computations they denote via GA's inference rules. Once recursive functions have been proven terminating, logical reasoning about their results reduce to the familiar classical rules. A mechanically-checked formal development of basic grounded arithmetic or BGA - a minimal kernel for GA - shows that BGA simultaneously exhibits the useful metalogical properties of being (a) semantically and syntactically consistent, (b) semantically complete, and (c) sufficiently powerful to express and prove the termination of arbitrary closed Turing-complete computations. This combination is impossible in classical logic due to G\"oel's incompleteness theorems, but our results do not contradict G\"odel's theorems because BGA is paracomplete, not classical. Leveraging BGA's power of computation and reflection, we find that grounded logical operators including quantifiers are definable as non-primitive computations in BGA, despite not being included as primitives.</description>
      <guid isPermaLink="false">oai:arXiv.org:2510.25369v2</guid>
      <category>cs.PL</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Tue, 27 Jan 2026 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Elliot Bobrow, Bryan Ford, Stefan Milenkovic</dc:creator>
    </item>
  </channel>
</rss>
