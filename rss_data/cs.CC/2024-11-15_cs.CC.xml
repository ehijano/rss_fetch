<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CC</link>
    <description>cs.CC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 Nov 2024 05:00:02 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 15 Nov 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>On the Complexity of Hazard-Free Formulas</title>
      <link>https://arxiv.org/abs/2411.09026</link>
      <description>arXiv:2411.09026v1 Announce Type: new 
Abstract: This paper studies the hazard-free formula complexity of Boolean functions.
  As our main result, we prove that unate functions are the only Boolean functions for which the monotone formula complexity of the hazard-derivative equals the hazard-free formula complexity of the function itself. Consequently, every non-unate function breaks the so-called monotone barrier, as introduced and discussed by Ikenmeyer, Komarath, and Saurabh (ITCS 2023).
  Our second main result shows that the hazard-free formula complexity of random Boolean functions is at most $2^{(1+o(1))n}$. Prior to this, no better upper bound than $O(3^n)$ was known. Notably, unlike in the general case of Boolean circuits and formulas, where the typical complexity matches that of the multiplexer function, the hazard-free formula complexity is smaller than the optimal hazard-free formula for the multiplexer by an exponential factor in $n$.
  Additionally, we explore the hazard-free formula complexity of block composition of Boolean functions and obtain a result in the hazard-free setting that is analogous to a result of Karchmer, Raz, and Wigderson (Computational Complexity, 1995) in the monotone setting. We demonstrate that our result implies a lower bound on the hazard-free formula depth of the block composition of the set covering function with the multiplexer function, which breaks the monotone barrier.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.09026v1</guid>
      <category>cs.CC</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Leah London Arazi, Amir Shpilka</dc:creator>
    </item>
    <item>
      <title>Rare-Case Hard Functions Against Various Adversaries</title>
      <link>https://arxiv.org/abs/2411.09597</link>
      <description>arXiv:2411.09597v1 Announce Type: new 
Abstract: We say that a function is rare-case hard against a given class of algorithms (the adversary) if all algorithms in the class can compute the function only on an $o(1)$-fraction of instances of size $n$ for large enough $n$. Starting from any NP-complete language, for each $k &gt; 0$, we construct a function that cannot be computed correctly on even a $1/n^k$-fraction of instances for polynomial-sized circuit families if NP $\not \subset$ P/POLY and by polynomial-time algorithms if NP $\not \subset$ BPP - functions that are rare-case hard against polynomial-time algorithms and polynomial-sized circuits. The constructed function is a number-theoretic polynomial evaluated over specific finite fields. For NP-complete languages that admit parsimonious reductions from all of NP (for example, SAT), the constructed functions are hard to compute on even a $1/n^k$-fraction of instances by polynomial-time algorithms and polynomial-sized circuit families simply if $P^{\#P} \not \subset$ BPP and $P^{\#P} \not \subset$ P/POLY, respectively. We also show that if the Randomized Exponential Time Hypothesis (RETH) is true, none of these constructed functions can be computed on even a $1/n^k$-fraction of instances in subexponential time. These functions are very hard, almost always.
  While one may not be able to efficiently compute the values of these constructed functions themselves, in polynomial time, one can verify that the evaluation of a function, $s = f(x)$, is correct simply by asking a prover to compute $f(y)$ on targeted queries.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.09597v1</guid>
      <category>cs.CC</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Tejas Nareddy, Abhishek Mishra</dc:creator>
    </item>
    <item>
      <title>Hardness Amplification via Group Theory</title>
      <link>https://arxiv.org/abs/2411.09619</link>
      <description>arXiv:2411.09619v1 Announce Type: new 
Abstract: We employ techniques from group theory to show that, in many cases, counting problems on graphs are almost as hard to solve in a small number of instances as they are in all instances. Specifically, we show the following results.
  1. Goldreich (2020) asks if, for every constant $\delta &lt; 1 / 2$, there is an $\tilde{O} \left( n^2 \right)$-time randomized reduction from computing the number of $k$-cliques modulo $2$ with a success probability of greater than $2 / 3$ to computing the number of $k$-cliques modulo $2$ with an error probability of at most $\delta$.
  In this work, we show that for almost all choices of the $\delta 2^{n \choose 2}$ corrupt answers within the average-case solver, we have a reduction taking $\tilde{O} \left( n^2 \right)$-time and tolerating an error probability of $\delta$ in the average-case solver for any constant $\delta &lt; 1 / 2$. By "almost all", we mean that if we choose, with equal probability, any subset $S \subset \{0,1\}^{n \choose 2}$ with $|S| = \delta2^{n \choose 2}$, then with a probability of $1-2^{-\Omega \left( n^2 \right)}$, we can use an average-case solver corrupt on $S$ to obtain a probabilistic algorithm.
  2. Inspired by the work of Goldreich and Rothblum in FOCS 2018 to take the weighted versions of the graph counting problems, we prove that if the RETH is true, then for a prime $p = \Theta \left( 2^n \right)$, the problem of counting the number of unique Hamiltonian cycles modulo $p$ on $n$-vertex directed multigraphs and the problem of counting the number of unique half-cliques modulo $p$ on $n$-vertex undirected multigraphs, both require exponential time to compute correctly on even a $1 / 2^{n/\log n}$-fraction of instances. Meanwhile, simply printing $0$ on all inputs is correct on at least a $\Omega \left( 1 / 2^n \right)$-fraction of instances.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.09619v1</guid>
      <category>cs.CC</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Tejas Nareddy, Abhishek Mishra</dc:creator>
    </item>
    <item>
      <title>Reducing Stochastic Games to Semidefinite Programming</title>
      <link>https://arxiv.org/abs/2411.09646</link>
      <description>arXiv:2411.09646v1 Announce Type: cross 
Abstract: We present a polynomial-time reduction from max-average constraints to the feasibility problem for semidefinite programs. This shows that Condon's simple stochastic games, stochastic mean payoff games, and in particular mean payoff games and parity games can all be reduced to semidefinite programming.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.09646v1</guid>
      <category>math.OC</category>
      <category>cs.CC</category>
      <category>cs.GT</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Manuel Bodirsky, Georg Loho, Mateusz Skomra</dc:creator>
    </item>
    <item>
      <title>Constant-depth circuits for Boolean functions and quantum memory devices using multi-qubit gates</title>
      <link>https://arxiv.org/abs/2308.08539</link>
      <description>arXiv:2308.08539v3 Announce Type: replace-cross 
Abstract: We explore the power of the unbounded Fan-Out gate and the Global Tunable gates generated by Ising-type Hamiltonians in constructing constant-depth quantum circuits, with particular attention to quantum memory devices. We propose two types of constant-depth constructions for implementing Uniformly Controlled Gates. These gates include the Fan-In gates defined by $|x\rangle|b\rangle\mapsto |x\rangle|b\oplus f(x)\rangle$ for $x\in\{0,1\}^n$ and $b\in\{0,1\}$, where $f$ is a Boolean function. The first of our constructions is based on computing the one-hot encoding of the control register $|x\rangle$, while the second is based on Boolean analysis and exploits different representations of $f$ such as its Fourier expansion. Via these constructions, we obtain constant-depth circuits for the quantum counterparts of read-only and read-write memory devices -- Quantum Random Access Memory (QRAM) and Quantum Random Access Gate (QRAG) -- of memory size $n$. The implementation based on one-hot encoding requires either $O(n\log^{(d)}{n}\log^{(d+1)}{n})$ ancillae and $O(n\log^{(d)}{n})$ Fan-Out gates or $O(n\log^{(d)}{n})$ ancillae and $16d-10$ Global Tunable gates, where $d$ is any positive integer and $\log^{(d)}{n} = \log\cdots \log{n}$ is the $d$-times iterated logarithm. On the other hand, the implementation based on Boolean analysis requires $8d-6$ Global Tunable gates at the expense of $O(n^{1/(1-2^{-d})})$ ancillae.</description>
      <guid isPermaLink="false">oai:arXiv.org:2308.08539v3</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <category>cs.ET</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jonathan Allcock, Jinge Bao, Joao F. Doriguello, Alessandro Luongo, Miklos Santha</dc:creator>
    </item>
    <item>
      <title>Program Analysis via Multiple Context Free Language Reachability</title>
      <link>https://arxiv.org/abs/2411.06383</link>
      <description>arXiv:2411.06383v2 Announce Type: replace-cross 
Abstract: Context-free language (CFL) reachability is a standard approach in static analyses, where the analysis question is phrased as a language reachability problem on a graph $G$ wrt a CFL L. While CFLs lack the expressiveness needed for high precision, common formalisms for context-sensitive languages are such that the corresponding reachability problem is undecidable. Are there useful context-sensitive language-reachability models for static analysis?
  In this paper, we introduce Multiple Context-Free Language (MCFL) reachability as an expressive yet tractable model for static program analysis. MCFLs form an infinite hierarchy of mildly context sensitive languages parameterized by a dimension $d$ and a rank $r$. We show the utility of MCFL reachability by developing a family of MCFLs that approximate interleaved Dyck reachability, a common but undecidable static analysis problem.
  We show that MCFL reachability be computed in $O(n^{2d+1})$ time on a graph of $n$ nodes when $r=1$, and $O(n^{d(r+1)})$ time when $r&gt;1$. Moreover, we show that when $r=1$, the membership problem has a lower bound of $n^{2d}$ based on the Strong Exponential Time Hypothesis, while reachability for $d=1$ has a lower bound of $n^{3}$ based on the combinatorial Boolean Matrix Multiplication Hypothesis. Thus, for $r=1$, our algorithm is optimal within a factor $n$ for all levels of the hierarchy based on $d$.
  We implement our MCFL reachability algorithm and evaluate it by underapproximating interleaved Dyck reachability for a standard taint analysis for Android. Used alongside existing overapproximate methods, MCFL reachability discovers all tainted information on 8 out of 11 benchmarks, and confirms $94.3\%$ of the reachable pairs reported by the overapproximation on the remaining 3. To our knowledge, this is the first report of high and provable coverage for this challenging benchmark set.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.06383v2</guid>
      <category>cs.PL</category>
      <category>cs.CC</category>
      <category>cs.FL</category>
      <pubDate>Fri, 15 Nov 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Giovanna Kobus Conrado, Adam Husted Kjelstr{\o}m, Andreas Pavlogiannis, Jaco van de Pol</dc:creator>
    </item>
  </channel>
</rss>
