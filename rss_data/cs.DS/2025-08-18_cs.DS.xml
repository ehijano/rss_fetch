<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Aug 2025 04:00:05 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>A Gentle Wakeup Call: Symmetry Breaking with Less Collision Cost</title>
      <link>https://arxiv.org/abs/2508.11006</link>
      <description>arXiv:2508.11006v1 Announce Type: new 
Abstract: The wakeup problem addresses the fundamental challenge of symmetry breaking. There are $n$ devices sharing a time-slotted multiple access channel. In any fixed slot, if a single device sends a packet, it succeeds; however, if two or more devices send, then there is a collision and none of the corresponding packets succeed. For the static version of wakeup, all packets are initially active (i.e., can send and listen on the channel); for the dynamic version, the packets become active at arbitrary times. In both versions, the goal is to successfully send a single packet.
  Prior results on wakeup have largely focused on the number of slots until the first success; that is, the latency. However, in many modern systems, collisions introduce significant delay, an aspect that current wakeup algorithms do not address. For instance, while existing results for static wakeup have polylogarithmic-in-$n$ latency, they can incur additional latency that is {\it linear} in the cost of a collision $C$. Thus, the total latency is large and dominated by the contributions from collisions.
  Here, we design and analyze a randomized wakeup algorithm, Aim-High. For sufficiently large $C$ and with bounded error, Aim-High has latency and expected collision cost that is nearly $O(\sqrt{C})$ for both the static and dynamic versions. Otherwise, the latency and expected collision cost are $O(\texttt{poly}{(\log n)})$ for the static setting, and $O(n\,\texttt{poly}{(\log n)})$ for the dynamic setting. We also establish lower bounds that complement these results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.11006v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Umesh Biswas, Maxwell Young</dc:creator>
    </item>
    <item>
      <title>Sampling tree-weighted partitions without sampling trees</title>
      <link>https://arxiv.org/abs/2508.11130</link>
      <description>arXiv:2508.11130v1 Announce Type: new 
Abstract: This paper gives a new algorithm for sampling tree-weighted partitions of a large class of planar graphs. Formally, the tree-weighted distribution on $k$-partitions of a graph weights $k$-partitions proportional to the product of the number of spanning trees of each partition class. Recent work on problems in computational redistricting analysis has driven special interest in the conditional distribution where all partition classes have the same size (balanced partitions). One class of Markov chains in wide use aims to sample from balanced tree-weighted $k$-partitions using a sampler for balanced tree-weighted 2-partitions. Previous implementations of this 2-partition sampler would draw a random spanning tree and check whether it contains an edge whose removal produces a balanced 2-component forest; if it does, this 2-partition is accepted, otherwise the algorithm rejects and repeats. In practice, this is a significant computational bottleneck.
  We show that in fact it is possible to sample from the balanced tree-weighted 2-partition distribution directly, without first sampling a spanning tree; the acceptance and rejection rates are the same as in previous samplers. We prove that on a wide class of planar graphs encompassing network structures typically arising from the geographic data used in computational redistricting, our algorithm takes expected linear time $O(n)$. Notably, this is asymptotically faster than the best known method to generate random trees, which is $O(n \log^2 n)$ for approximate sampling and $O(n^{1 + \log \log \log n / \log \log n})$ for exact sampling. Additionally, we show that a variant of our algorithm also gives a speedup to $O(n \log n)$ for exact sampling of uniformly random trees on these families of graphs, improving the bounds for both exact and approximate sampling.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.11130v1</guid>
      <category>cs.DS</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Sarah Cannon, Wesley Pegden, Jamie Tucker-Foltz</dc:creator>
    </item>
    <item>
      <title>Face-hitting dominating sets in planar graphs: Alternative proof and linear-time algorithm</title>
      <link>https://arxiv.org/abs/2508.11444</link>
      <description>arXiv:2508.11444v1 Announce Type: new 
Abstract: In a recent paper, Francis, Illickan, Jose and Rajendraprasad showed that every $n$-vertex plane graph $G$ has (under some natural restrictions) a vertex-partition into two sets $V_1$ and $V_2$ such that each $V_i$ is \emph{dominating} (every vertex of $G$ contains a vertex of $V_i$ in its closed neighbourhood) and \emph{face-hitting} (every face of $G$ is incident to a vertex of $V_i$). Their proof works by considering a supergraph $G'$ of $G$ that has certain properties, and among all such graphs, taking one that has the fewest edges. As such, their proof is not algorithmic. Their proof also relies on the 4-color theorem, for which a quadratic-time algorithm exists, but it would not be easy to implement.
  In this paper, we give a new proof that every $n$-vertex plane graph $G$ has (under the same restrictions) a vertex-partition into two dominating face-hitting sets. Our proof is constructive, and requires nothing more complicated than splitting a graph into 2-connected components, finding an ear decomposition, and computing a perfect matching in a 3-regular plane graph. For all these problems, linear-time algorithms are known and so we can find the vertex-partition in linear time.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.11444v1</guid>
      <category>cs.DS</category>
      <category>math.CO</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Therese Biedl</dc:creator>
    </item>
    <item>
      <title>Dyadically resolving trinomials for fast modular arithmetic</title>
      <link>https://arxiv.org/abs/2508.11043</link>
      <description>arXiv:2508.11043v1 Announce Type: cross 
Abstract: Residue number systems based on pairwise relatively prime moduli are a powerful tool for accelerating integer computations via the Chinese Remainder Theorem. We study a structured family of moduli of the form $2^n - 2^k + 1$, originally proposed for their efficient arithmetic and bit-level properties. These trinomial moduli support fast modular operations and exhibit scalable modular inverses.
  We investigate the problem of constructing large sets of pairwise relatively prime trinomial moduli of fixed bit length. By analyzing the corresponding trinomials $x^n - x^k + 1$, we establish a sufficient condition for coprimality based on polynomial resultants. This leads to a graph-theoretic model where maximal sets correspond to cliques in a compatibility graph, and we use maximum clique-finding algorithms to construct large examples in practice. Using the theory of graph colorings, resultants, and properties of cyclotomic polynomials, we also prove upper bounds on the size of such sets as a function of $n$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.11043v1</guid>
      <category>math.NT</category>
      <category>cs.DS</category>
      <category>cs.SC</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Robert Dougherty-Bliss, Mits Kobayashi, Natalya Ter-Saakov, Eugene Zima</dc:creator>
    </item>
    <item>
      <title>Towards Efficient Hash Maps in Functional Array Languages</title>
      <link>https://arxiv.org/abs/2508.11443</link>
      <description>arXiv:2508.11443v1 Announce Type: cross 
Abstract: We present a systematic derivation of a data-parallel implementation of two-level, static and collision-free hash maps, by giving a functional formulation of the Fredman et al. construction, and then flattening it. We discuss the challenges of providing a flexible, polymorphic, and abstract interface to hash maps in a functional array language, with particular attention paid to the problem of dynamically sized keys, which we address by associating each hash map with an arbitrary context. The algorithm is implemented in Futhark, and the achieved GPU execution performance is compared on simple benchmark problems. We find that our hash maps outperform conventional tree/search-based approaches. Furthermore, our implementation is compared against the state-of-the-art cuCollections library, which is significantly faster for hash map construction, and to a lesser degree for lookups. We explain to which extent the performance difference is due to low-level code generation limitation in the Futhark compiler, and to which extent it can be attributed to the data-parallel programming vocabulary not providing the constructs necessary to express the equivalent of the algorithms used by cuCollections. We end by reflecting to which extent the functional array language programming model could, or should, be extended to address these weaknesses.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.11443v1</guid>
      <category>cs.PL</category>
      <category>cs.DS</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>William Henrich Due, Martin Elsman, Troels Henriksen</dc:creator>
    </item>
    <item>
      <title>A Tight Lower Bound for Doubling Spanners</title>
      <link>https://arxiv.org/abs/2508.11555</link>
      <description>arXiv:2508.11555v1 Announce Type: cross 
Abstract: Any $n$-point set in the $d$-dimensional Euclidean space $\mathbb{R}^d$, for $d = O(1)$, admits a $(1+\epsilon)$-spanner with $\tilde{O}(n \cdot \epsilon^{-d+1})$ edges and lightness $\tilde{O}(\epsilon^{-d})$, for any $\epsilon &gt; 0$. (The {lightness} is a normalized notion of weight, where we divide the spanner weight by the MST weight. The $\tilde{O}$ and $\tilde{\Omega}$ notations hide $\texttt{polylog}(\epsilon^{-1})$ terms.) Moreover, this result is tight: For any $2 \le d = O(1)$, there exists an $n$-point set in $\mathbb{R}^d$, for which any $(1+\epsilon)$-spanner has $\tilde{\Omega}(n \cdot \epsilon^{-d+1})$ edges and lightness $\tilde{\Omega}(n \cdot \epsilon^{-d})$.
  The upper bounds for Euclidean spanners rely heavily on the spatial property of {cone partitioning} in $\mathbb{R}^d$, which does not seem to extend to the wider family of {doubling metrics}, i.e., metric spaces of constant {doubling dimension}. In doubling metrics, a {simple spanner construction from two decades ago, the {net-tree spanner}}, has $\tilde{O}(n \cdot \epsilon^{-d})$ edges, and it could be transformed into a spanner of lightness $\tilde{O}(n \cdot \epsilon^{-(d+1)})$ by pruning redundant edges. Despite a large body of work, it has remained an open question whether the superior Euclidean bounds of $\tilde{O}(n \cdot \epsilon^{-d+1})$ edges and lightness $\tilde{O}(\epsilon^{-d})$ could be achieved also in doubling metrics. We resolve this question in the negative by presenting a surprisingly simple and tight lower bound, which shows, in particular, that the net-tree spanner and its pruned version are both optimal.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.11555v1</guid>
      <category>cs.CG</category>
      <category>cs.DS</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>An La, Hung Le, Shay Solomon, Cuong Than,  Vinayak, Shuang Yang, Tianyi Zhang</dc:creator>
    </item>
    <item>
      <title>Triangle Counting with Local Edge Differential Privacy</title>
      <link>https://arxiv.org/abs/2305.02263</link>
      <description>arXiv:2305.02263v3 Announce Type: replace 
Abstract: Many deployments of differential privacy in industry are in the local model, where each party releases its private information via a differentially private randomizer. We study triangle counting in the local model with edge differential privacy (that, intuitively, requires that the outputs of the algorithm on graphs that differ in one edge be indistinguishable). In this model, each party's local view consists of the adjacency list of one vertex. We investigate both noninteractive and interactive variants of the model.
  In the noninteractive model, we prove that additive $\Omega(n^2)$ error is necessary for sufficiently small constant $\varepsilon$, where $n$ is the number of nodes and $\varepsilon$ is the privacy parameter. This lower bound is our main technical contribution. It uses a reconstruction attack with a new class of linear queries and a novel mix-and-match strategy of running the local randomizers with different completions of their adjacency lists. It matches the additive error of the algorithm based on Randomized Response, proposed by Imola, Murakami and Chaudhuri (USENIX2021) and analyzed by Imola, Murakami and Chaudhuri (CCS2022) for constant $\varepsilon$. We use a different postprocessing of Randomized Response and provide tight bounds on the variance of the resulting algorithm.
  In the interactive setting, we prove a lower bound of $\Omega(n^{3/2}/\varepsilon)$ on the additive error for $\varepsilon\leq 1$. Previously, no hardness results were known for interactive, edge-private algorithms in the local model, except for those that follow trivially from the results for the central model. Our work significantly improves on the state of the art in differentially private graph analysis in the local model.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.02263v3</guid>
      <category>cs.DS</category>
      <category>cs.CR</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Talya Eden, Quanquan C. Liu, Sofya Raskhodnikova, Adam Smith</dc:creator>
    </item>
    <item>
      <title>Near-Optimal Averaging Samplers and Matrix Samplers</title>
      <link>https://arxiv.org/abs/2411.10870</link>
      <description>arXiv:2411.10870v2 Announce Type: replace-cross 
Abstract: We present the first efficient averaging sampler that achieves asymptotically optimal randomness complexity and near-optimal sample complexity. For any $\delta &lt; \varepsilon$ and any constant $\alpha &gt; 0$, our sampler uses $m + O(\log (1 / \delta))$ random bits to output $t = O((\frac{1}{\varepsilon^2} \log \frac{1}{\delta})^{1 + \alpha})$ samples $Z_1, \dots, Z_t \in \{0, 1\}^m$ such that for any function $f: \{0, 1\}^m \to [0, 1]$, \[ \Pr\left[\left|\frac{1}{t}\sum_{i=1}^t f(Z_i) - \mathbb{E}[f]\right| \leq \varepsilon\right] \geq 1 - \delta. \] The randomness complexity is optimal up to a constant factor, and the sample complexity is optimal up to the $O((\frac{1}{\varepsilon^2} \log \frac{1}{\delta})^{\alpha})$ factor.
  Our technique generalizes to matrix samplers. A matrix sampler is defined similarly, except that $f: \{0, 1\}^m \to \mathbb{C}^{d \times d}$ and the absolute value is replaced by the spectral norm. Our matrix sampler achieves randomness complexity $m + \widetilde O (\log(d / \delta))$ and sample complexity $ O((\frac{1}{\varepsilon^2} \log \frac{d}{\delta})^{1 + \alpha})$ for any constant $\alpha &gt; 0$, both near-optimal with only a logarithmic factor in randomness complexity and an additional $\alpha$ exponent on the sample complexity.
  We use known connections with randomness extractors and list-decodable codes to give applications to these objects. Specifically, we give the first extractor construction with optimal seed length up to an arbitrarily small constant factor above 1, when the min-entropy $k = \beta n$ for a large enough constant $\beta &lt; 1$. Finally, we generalize the definition of averaging sampler to any normed vector space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.10870v2</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Mon, 18 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Zhiyang Xun, David Zuckerman</dc:creator>
    </item>
  </channel>
</rss>
