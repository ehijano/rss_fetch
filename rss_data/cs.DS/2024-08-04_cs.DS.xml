<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Aug 2024 04:00:01 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 05 Aug 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Discrepancy Algorithms for the Binary Perceptron</title>
      <link>https://arxiv.org/abs/2408.00796</link>
      <description>arXiv:2408.00796v1 Announce Type: new 
Abstract: The binary perceptron problem asks us to find a sign vector in the intersection of independently chosen random halfspaces with intercept $-\kappa$. We analyze the performance of the canonical discrepancy minimization algorithms of Lovett-Meka and Rothvoss/Eldan-Singh for the asymmetric binary perceptron problem. We obtain new algorithmic results in the $\kappa = 0$ case and in the large-$|\kappa|$ case. In the $\kappa\to-\infty$ case, we additionally characterize the storage capacity and complement our algorithmic results with an almost-matching overlap-gap lower bound.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.00796v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>math-ph</category>
      <category>math.MP</category>
      <category>math.PR</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Shuangping Li, Tselil Schramm, Kangjie Zhou</dc:creator>
    </item>
    <item>
      <title>Algorithms for Minimum Membership Dominating Set Problem</title>
      <link>https://arxiv.org/abs/2408.00797</link>
      <description>arXiv:2408.00797v1 Announce Type: new 
Abstract: Given a graph $G = (V, E)$ and an integer $k$, the Minimum Membership Dominating Set problem asks to compute a set $S \subseteq V$ such that for each $v \in V$, $1 \leq |N[v] \cap S| \leq k$. The problem is known to be NP-complete even on split graphs and planar bipartite graphs. In this paper, we approach the problem from the algorithmic standpoint and obtain several interesting results. We give an $\mathcal{O}^*(1.747^n)$ time algorithm for the problem on split graphs. Following a reduction from a special case of 1-in-3 SAT problem, we show that there is no sub-exponential time algorithm running in time $\mathcal{O}^*(2^{o(n)})$ for bipartite graphs, for any $k \geq 2$. We also prove that the problem is NP-complete when $\Delta = k+2$, for any $k\geq 5$, even for bipartite graphs. We investigate the parameterized complexity of the problem for the parameter twin cover and the combined parameter distance to cluster, membership($k$) and prove that the problem is fixed-parameter tractable. Using a dynamic programming based approach, we obtain a linear-time algorithm for trees.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.00797v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sangam Balchandar Reddy, Anjeneya Swami Kare</dc:creator>
    </item>
    <item>
      <title>On Constrained and k Shortest Paths</title>
      <link>https://arxiv.org/abs/2408.00899</link>
      <description>arXiv:2408.00899v1 Announce Type: new 
Abstract: Finding a shortest path in a graph is one of the most classic problems in algorithmic and graph theory. While we dispose of quite efficient algorithms for this ordinary problem (like the Dijkstra or Bellman-Ford algorithms), some slight variations in the problem statement can quickly lead to computationally hard problems. This article focuses specifically on two of these variants, namely the constrained shortest paths problem and the k shortest paths problem. Both problems are NP-hard, and thus it's not sure we can conceive a polynomial time algorithm (unless P = NP), ours aren't for instance. Moreover, across this article, we provide ILP formulations of these problems in order to give a different point of view to the interested reader. Although we did not try to implement these on modern ILP solvers, it can be an interesting path to explore.
  We also mention how these algorithms constitute essential ingredients in some of the most important modern applications in the field of data science, such as Isomap, whose main objective is the reduction of dimensionality of high-dimensional datasets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.00899v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Abderrahim Bendahi, Adrien Fradin</dc:creator>
    </item>
    <item>
      <title>Fully Dynamic $k$-Clustering with Fast Update Time and Small Recourse</title>
      <link>https://arxiv.org/abs/2408.01325</link>
      <description>arXiv:2408.01325v1 Announce Type: new 
Abstract: In the dynamic metric $k$-median problem, we wish to maintain a set of $k$ centers $S \subseteq V$ in an input metric space $(V, d)$ that gets updated via point insertions/deletions, so as to minimize the objective $\sum_{x \in V} \min_{y \in S} d(x, y)$. The quality of a dynamic algorithm is measured in terms of its approximation ratio, "recourse" (the number of changes in $S$ per update) and "update time" (the time it takes to handle an update). The ultimate goal in this line of research is to obtain a dynamic $O(1)$ approximation algorithm with $\tilde{O}(1)$ recourse and $\tilde{O}(k)$ update time.
  Dynamic $k$-median is a canonical example of a class of problems known as dynamic $k$-clustering, that has received significant attention in recent years. To the best of our knowledge, however, previous papers either attempt to minimize the algorithm's recourse while ignoring its update time, or minimize the algorithm's update time while ignoring its recourse. For dynamic $k$-median, we come arbitrarily close to resolving the main open question on this topic, with the following results.
  (I) We develop a new framework of randomized local search that is suitable for adaptation in a dynamic setting. For every $\epsilon &gt; 0$, this gives us a dynamic $k$-median algorithm with $O(1/\epsilon)$ approximation ratio, $\tilde{O}(k^{\epsilon})$ recourse and $\tilde{O}(k^{1+\epsilon})$ update time. This framework also generalizes to dynamic $k$-clustering with $\ell^p$-norm objectives, giving similar bounds for the dynamic $k$-means and a new trade-off for dynamic $k$-center.
  (II) If it suffices to maintain only an estimate of the value of the optimal $k$-median objective, then we obtain a $O(1)$ approximation algorithm with $\tilde{O}(k)$ update time. We achieve this result via adapting the Lagrangian Relaxation framework to the dynamic setting.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.01325v1</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sayan Bhattacharya, Mart\'in Costa, Naveen Garg, Silvio Lattanzi, Nikos Parotsidis</dc:creator>
    </item>
    <item>
      <title>Streaming approximation resistance of every ordering CSP</title>
      <link>https://arxiv.org/abs/2105.01782</link>
      <description>arXiv:2105.01782v3 Announce Type: replace 
Abstract: An ordering constraint satisfaction problem (OCSP) is defined by a family $\mathcal{F}$ of predicates mapping permutations on $\{1,\ldots,k\}$ to $\{0,1\}$. An instance of Max-OCSP($\mathcal{F}$) on $n$ variables consists of a list of constraints, each consisting of a predicate from $\mathcal{F}$ applied on $k$ distinct variables. The goal is to find an ordering of the $n$ variables that maximizes the number of constraints for which the induced ordering on the $k$ variables satisfies the predicate. OCSPs capture well-studied problems including `maximum acyclic subgraph' (MAS) and "maximum betweenness".
  In this work, we consider the task of approximating the maximum number of satisfiable constraints in the (single-pass) streaming setting, when an instance is presented as a stream of constraints. We show that for every $\mathcal{F}$, Max-OCSP($\mathcal{F}$) is approximation-resistant to $o(n)$-space streaming algorithms, i.e., algorithms using $o(n)$ space cannot distinguish streams where almost every constraint is satisfiable from streams where no ordering beats the random ordering by a noticeable amount. This space bound is tight up to polylogarithmic factors. In the case of MAS our result shows that for every $\epsilon&gt;0$, MAS is not $(1/2+\epsilon)$-approximable in $o(n)$ space. The previous best inapproximability result, due to Guruswami and Tao (APPROX'19), only ruled out $3/4$-approximations in $o(\sqrt n)$ space.
  Our results build on a recent work of Chou, Golovnev, Sudan, Velingker, and Velusamy (STOC'22), who provide a tight, linear-space inapproximability theorem for a broad class of "standard" (i.e., non-ordering) constraint satisfaction problems (CSPs) over arbitrary (finite) alphabets. We construct a family of appropriate standard CSPs from any given OCSP, apply their hardness result to this family of CSPs, and then convert back to our OCSP.</description>
      <guid isPermaLink="false">oai:arXiv.org:2105.01782v3</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.APPROX/RANDOM.2021.17 10.1007/s00037-024-00252-5</arxiv:DOI>
      <dc:creator>Noah G. Singer, Madhu Sudan, Santhoshini Velusamy</dc:creator>
    </item>
    <item>
      <title>Density-Sensitive Algorithms for $(\Delta + 1)$-Edge Coloring</title>
      <link>https://arxiv.org/abs/2307.02415</link>
      <description>arXiv:2307.02415v2 Announce Type: replace 
Abstract: Vizing's theorem asserts the existence of a $(\Delta+1)$-edge coloring for any graph $G$, where $\Delta = \Delta(G)$ denotes the maximum degree of $G$. Several polynomial time $(\Delta+1)$-edge coloring algorithms are known, and the state-of-the-art running time (up to polylogarithmic factors) is $\tilde{O}(\min\{m \cdot \sqrt{n}, m \cdot \Delta\})$, by Gabow et al.\ from 1985, where $n$ and $m$ denote the number of vertices and edges in the graph, respectively. (The $\tilde{O}$ notation suppresses polylogarithmic factors.) Recently, Sinnamon shaved off a polylogarithmic factor from the time bound of Gabow et al.
  The {arboricity} $\alpha = \alpha(G)$ of a graph $G$ is the minimum number of edge-disjoint forests into which its edge set can be partitioned, and it is a measure of the graph's "uniform density". While $\alpha \le \Delta$ in any graph, many natural and real-world graphs exhibit a significant separation between $\alpha$ and $\Delta$.
  In this work we design a $(\Delta+1)$-edge coloring algorithm with a running time of $\tilde{O}(\min\{m \cdot \sqrt{n}, m \cdot \Delta\})\cdot \frac{\alpha}{\Delta}$, thus improving the longstanding time barrier by a factor of $\frac{\alpha}{\Delta}$. In particular, we achieve a near-linear runtime for bounded arboricity graphs (i.e., $\alpha = \tilde{O}(1)$) as well as when $\alpha = \tilde{O}(\frac{\Delta}{\sqrt{n}})$. Our algorithm builds on Sinnamon's algorithm, and can be viewed as a density-sensitive refinement of it.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.02415v2</guid>
      <category>cs.DS</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sayan Bhattacharya, Mart\'in Costa, Nadav Panski, Shay Solomon</dc:creator>
    </item>
    <item>
      <title>On the instance optimality of detecting collisions and subgraphs</title>
      <link>https://arxiv.org/abs/2312.10196</link>
      <description>arXiv:2312.10196v2 Announce Type: replace 
Abstract: Suppose you are given a function $f\colon [n] \to [n]$ via (black-box) query access to the function. You are looking to find something local, like a collision (a pair $x \neq y$ s.t. $f(x)=f(y)$). The question is whether knowing the "shape" of the function helps you or not (by shape we mean that some permutation of the function is known). Formally, we investigate the unlabeled instance optimality of substructure detection problems in graphs and functions. A problem is $g(n)$-instance optimal if it admits an algorithm $A$ satisfying that for any possible input, the (randomized) query complexity of $A$ is at most $g(n)$ times larger than the query complexity of any algorithm $A'$ which solves the same problem while holding an unlabeled copy of the input (i.e., any $A'$ that "knows the structure of the input"). Our results point to a trichotomy of unlabeled instance optimality among substructure detection problems in graphs and functions:
  1. A few very simple properties have an $O(1)$-instance optimal algorithm.
  2. Most properties of graphs and functions, with examples such as containing a fixed point or a $3$-collision in functions, or a triangle in graphs, are $n^{\Omega(1)}$-far from instance optimality.
  3. The problems of collision detection in functions and finding a claw in a graph serve as a middle ground between the two regimes. We show that these two properties are $\Omega(\log n)$-far from instance optimality, and conjecture that this bound is tight. We provide evidence towards this conjecture, by proving that finding a claw in a graph is $O(\log(n))$-instance optimal among all input graphs for which the query complexity of an algorithm holding an unlabeled certificate is $O\left(\sqrt{\frac{n}{\log n}}\right)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.10196v2</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>cs.CR</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Omri Ben-Eliezer, Tomer Grossman, Moni Naor</dc:creator>
    </item>
    <item>
      <title>Infrequent Resolving Algorithm for Online Linear Programming</title>
      <link>https://arxiv.org/abs/2408.00465</link>
      <description>arXiv:2408.00465v2 Announce Type: replace 
Abstract: Online linear programming (OLP) has gained significant attention from both researchers and practitioners due to its extensive applications, such as online auction, network revenue management and advertising. Existing OLP algorithms fall into two categories: LP-based algorithms and LP-free algorithms. The former one typically guarantees better performance, even offering a constant regret, but requires solving a large number of LPs, which could be computationally expensive. In contrast, LP-free algorithm only requires first-order computations but induces a worse performance, lacking a constant regret bound. In this work, we bridge the gap between these two extremes by proposing an algorithm that achieves a constant regret while solving LPs only $O(\log\log T)$ times over the time horizon $T$. Moreover, when we are allowed to solve LPs only $M$ times, we propose an algorithm that can guarantee an $O\left(T^{(1/2+\epsilon)^{M-1}}\right)$ regret. Furthermore, when the arrival probabilities are known at the beginning, our algorithm can guarantee a constant regret by solving LPs $O(\log\log T)$ times, and an $O\left(T^{(1/2+\epsilon)^{M}}\right)$ regret by solving LPs only $M$ times. Numerical experiments are conducted to demonstrate the efficiency of the proposed algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.00465v2</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <category>math.OC</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guokai Li, Zizhuo Wang, Jingwei Zhang</dc:creator>
    </item>
  </channel>
</rss>
