<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 12 Mar 2025 04:00:12 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 12 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Higher-Dimensional Automata : Extension to Infinite Tracks</title>
      <link>https://arxiv.org/abs/2503.07881</link>
      <description>arXiv:2503.07881v1 Announce Type: new 
Abstract: We introduce higher-dimensional automata for infinite interval ipomsets ($\omega$-HDAs). We define key concepts from different points of view, inspired from their finite counterparts. Then we explore languages recognized by $\omega$-HDAs under B\"uchi and Muller semantics. We show that Muller acceptance is more expressive than B\"uchi acceptance and, in contrast to the finite case, both semantics do not yield languages closed under subsumption. Then, we adapt the original rational operations to deal with $\omega$-HDAs and show that while languages of $\omega$-HDAs are $\omega$-rational, not all $\omega$-rational languages can be expressed by $\omega$-HDAs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.07881v1</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 12 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Luc Passemard, Amazigh Amrane, Uli Fahrenberg</dc:creator>
    </item>
    <item>
      <title>Rerailing Automata</title>
      <link>https://arxiv.org/abs/2503.08438</link>
      <description>arXiv:2503.08438v1 Announce Type: new 
Abstract: In this paper, we introduce rerailing automata for $\omega$-regular languages. They generalize both deterministic parity (DPW) and minimized history-deterministic co-B\"uchi automata (with transition based acceptance, HdTbcBW) while combining their favorable properties. In particular, rerailing automata can represent arbitrary $\omega$-regular languages while allowing for polynomial-time minimization, just as HdTbcBW do. Since DPW are a special case of rerailing automata, a minimized rerailing automaton is never larger than the smallest deterministic parity automaton for the same language. We also show that rerailing automata can be used as a replacement for deterministic parity automata for the realizability check of open systems.
  The price to be paid to obtain the useful properties of rerailing automata is that the acceptance condition in such automata refers to the dominating colors along all runs for a given word, where just as in parity automata, the dominating color along a run is the lowest one occurring infinitely often along it. A rerailing automaton accepts those words for which the greatest of the dominating colors along the runs is even. Additionally, rerailing automata guarantee that every prefix of a run for a word can be extended to eventually reach a point from which all runs for the word extending the prefix have the same dominating color, and it is even if and only if the word is in the language of the automaton. We show that these properties together allow characterizing the role of each state in such an automaton in a way that relates it to state combinations in a sequence of co-B\"uchi automata for the represented language. This characterization forms the basis of the polynomial-time minimization approach in this paper.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.08438v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 12 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>R\"udiger Ehlers</dc:creator>
    </item>
    <item>
      <title>Inferring Input Grammars from Code with Symbolic Parsing</title>
      <link>https://arxiv.org/abs/2503.08486</link>
      <description>arXiv:2503.08486v1 Announce Type: cross 
Abstract: Generating effective test inputs for a software system requires that these inputs be valid, as they will otherwise be rejected without reaching actual functionality. In the absence of a specification for the input language, common test generation techniques rely on sample inputs, which are abstracted into matching grammars and/or evolved guided by test coverage. However, if sample inputs miss features of the input language, the chances of generating these features randomly are slim.
  In this work, we present the first technique for symbolically and automatically mining input grammars from the code of recursive descent parsers. So far, the complexity of parsers has made such a symbolic analysis challenging to impossible. Our realization of the symbolic parsing technique overcomes these challenges by (1) associating each parser function parse_ELEM() with a nonterminal &lt;ELEM&gt;; (2) limiting recursive calls and loop iterations, such that a symbolic analysis of parse_ELEM() needs to consider only a finite number of paths; and (3) for each path, create an expansion alternative for &lt;ELEM&gt;. Being purely static, symbolic parsing does not require seed inputs; as it mitigates path explosion, it scales to complex parsers.
  Our evaluation promises symbolic parsing to be highly accurate. Applied on parsers for complex languages such as TINY-C or JSON, our STALAGMITE implementation extracts grammars with an accuracy of 99--100%, widely improving over the state of the art despite requiring only the program code and no input samples. The resulting grammars cover the entire input space, allowing for comprehensive and effective test generation, reverse engineering, and documentation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.08486v1</guid>
      <category>cs.SE</category>
      <category>cs.FL</category>
      <pubDate>Wed, 12 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Leon Bettscheider, Andreas Zeller</dc:creator>
    </item>
    <item>
      <title>Structural Reductions and Stutter Sensitive Properties</title>
      <link>https://arxiv.org/abs/2212.04218</link>
      <description>arXiv:2212.04218v3 Announce Type: replace 
Abstract: Verification of properties expressed as $\omega$-regular languages such as LTL can benefit hugely from stutter insensitivity, using a diverse set of reduction strategies. However properties that are not stutter invariant, for instance due to the use of the neXt operator of LTL or to some form of counting in the logic, are not covered by these techniques in general. We propose in this paper to study a weaker property than stutter insensitivity. In a stutter insensitive language both adding and removing stutter to a word does not change its acceptance, any stuttering can be abstracted away; by decomposing this equivalence relation into two implications we obtain weaker conditions. We define a shortening insensitive language where any word that stutters less than a word in the language must also belong to the language. A lengthening insensitive language has the dual property. A semi-decision procedure is then introduced to reliably prove shortening insensitive properties or deny lengthening insensitive properties while working with a \emph{reduction} of a system. A reduction has the property that it can only shorten runs. Lipton's transaction reductions or Petri net agglomerations are examples of eligible structural reduction strategies. We also present an approach that can reason using a partition of a property language into its stutter insensitive, shortening insensitive, lengthening insensitive and length sensitive parts to still use structural reductions even when working with arbitrary properties. An implementation and experimental evidence is provided showing most non-random properties sensitive to stutter are actually shortening or lengthening insensitive.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.04218v3</guid>
      <category>cs.FL</category>
      <pubDate>Wed, 12 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Emmanuel Paviot-Adet, Denis Poitrenaud, Etienne Renault, Yann Thierry-Mieg</dc:creator>
    </item>
    <item>
      <title>Digital Convexity and Combinatorics on Words</title>
      <link>https://arxiv.org/abs/2502.19926</link>
      <description>arXiv:2502.19926v2 Announce Type: replace-cross 
Abstract: An upward (resp. downward) digitally convex word is a binary word that best approximates from below (resp. from above) an upward (resp. downward) convex curve in the plane. We study these words from the combinatorial point of view, formalizing their geometric properties and highlighting connections with Christoffel words and finite Sturmian words. In particular, we study from the combinatorial perspective the operations of inflation and deflation on digitally convex words.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.19926v2</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <pubDate>Wed, 12 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Alessandro De Luca, Gabriele Fici, Andrea Frosini</dc:creator>
    </item>
    <item>
      <title>Positionality of Dumont--Thomas numeration systems for integers</title>
      <link>https://arxiv.org/abs/2503.04487</link>
      <description>arXiv:2503.04487v3 Announce Type: replace-cross 
Abstract: Introduced in 2001 by Lecomte and Rigo, abstract numeration systems provide a way of expressing natural numbers with words from a language $L$ accepted by a finite automaton. As it turns out, these numeration systems are not necessarily positional, i.e., we cannot always find a sequence $U=(U_i)_{i\ge 0}$ of integers such that the value of every word in the language $L$ is determined by the position of its letters and the first few values of $U$. Finding the conditions under which an abstract numeration system is positional seems difficult in general. In this paper, we thus consider this question for a particular sub-family of abstract numeration systems called Dumont--Thomas numeration systems. They are derived from substitutions and were introduced in 1989 by Dumont and Thomas. We exhibit conditions on the underlying substitution so that the corresponding Dumont--Thomas numeration is positional. We first work in the most general setting, then particularize our results to some practical cases. Finally, we link our numeration systems to existing literature, notably properties studied by R\'{e}nyi in 1957, Parry in 1960, Bertrand-Mathis in 1989, and Fabre in 1995.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04487v3</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <pubDate>Wed, 12 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>Savinien Kreczman, S\'ebastien Labb\'e, Manon Stipulanti</dc:creator>
    </item>
  </channel>
</rss>
