<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Sep 2025 01:42:54 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Precoloring extension with demands on paths</title>
      <link>https://arxiv.org/abs/2509.18936</link>
      <description>arXiv:2509.18936v1 Announce Type: new 
Abstract: Let $G$ be a graph with a set of precolored vertices, and let us be given an integer distance parameter $d$ and a set of integer demands $d_1,\dots,d_c$. The Distance Precoloring Extension with Demands (DPED) problem is to compute a vertex $c$-coloring of $G$ such that the following three conditions hold: (i) the resulting coloring respects the colors of the precolored vertices, (ii) the distance of two vertices of the same color is at least $d$, and (iii) the number of vertices colored by color $i$ is exactly $d_i$. This problem is motivated by a program scheduling in commercial broadcast channels with constraints on content repetition and placement, which leads precisely to the DPED problem for paths.
  In this paper, we study DPED on paths and present a polynomial time exact algorithm when precolored vertices are restricted to the two ends of the path and devise an approximation algorithm for DPED with an additive approximation factor polynomially bounded by $d$ and the number of precolored vertices. Then, we prove that the Distance Precoloring Extension problem on paths, a less restrictive version of DPED without the demand constraints, and then DPED itself, is NP-complete. Motivated by this result, we further study the parameterized complexity of DPED on paths. We establish that the DPED problem on paths is $W[1]$-hard when parameterized by the number of colors and the distance. On the positive side, we devise a fixed parameter tractable (FPT) algorithm for DPED on paths when the number of colors, the distance, and the number of precolored vertices are considered as the parameters. Moreover, we prove that Distance Precoloring Extension is FPT parameterized by the distance. As a byproduct, we also obtain several results for the Distance List Coloring problem on paths.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.18936v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4230/LIPIcs.ISAAC.2025.43</arxiv:DOI>
      <dc:creator>Arun Kumar Das, Michal Opler, Tom\'a\v{s} Valla</dc:creator>
    </item>
    <item>
      <title>GraphBLAS Mathematical Opportunities: Parallel Hypersparse, Matrix Based Graph Streaming, and Complex-Index Matrices</title>
      <link>https://arxiv.org/abs/2509.18984</link>
      <description>arXiv:2509.18984v1 Announce Type: new 
Abstract: The GraphBLAS high performance library standard has yielded capabilities beyond enabling graph algorithms to be readily expressed in the language of linear algebra. These GraphBLAS capabilities enable new performant ways of thinking about algorithms that include leveraging hypersparse matrices for parallel computation, matrix-based graph streaming, and complex-index matrices. Formalizing these concepts mathematically provides additional opportunities to apply GraphBLAS to new areas. This paper formally develops parallel hypersparse matrices, matrix-based graph streaming, and complex-index matrices and illustrates these concepts with various examples to demonstrate their potential merits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.18984v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Hayden Jananthan, Jeremy Kepner, Michael Jones, Vijay Gadepally, Michael Houle, Peter Michaleas, Chasen Milner, Alex Pentland</dc:creator>
    </item>
    <item>
      <title>Optimization of Base-n Radix Sort for Skewed Datasets</title>
      <link>https://arxiv.org/abs/2509.19021</link>
      <description>arXiv:2509.19021v1 Announce Type: new 
Abstract: The importance and applications of sorting is apparent and needs no explanation. In this paper, we analyse a non-comparison sorting algorithm, Base-n Radix Sort (BNRS) and introduce an optimized vari- ant of BNRS, namely, Stable Logical Partition Radix Sort (SLPR). The complexity of these algorithms is measured by the input size $n$ and the maximum value $k$. We show that with respect to time complexity, these algorithms are more succinct than traditional comparison-based sorting algorithms for representing the sorted order of certain integer distribu- tions, specifically, when $k &lt;nlog_2^n$ is met. We also show that the SLPR optimization, which uses in-place stable partitioning to reduce the active problem size in each pass, resulting in highly effective sorting for skewed datasets that contain a majority of small numbers and mix of very large numbers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.19021v1</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Atharv Pandey, Lakshmanan Kuppusamy</dc:creator>
    </item>
    <item>
      <title>Linear Regression under Missing or Corrupted Coordinates</title>
      <link>https://arxiv.org/abs/2509.19242</link>
      <description>arXiv:2509.19242v1 Announce Type: new 
Abstract: We study multivariate linear regression under Gaussian covariates in two settings, where data may be erased or corrupted by an adversary under a coordinate-wise budget. In the incomplete data setting, an adversary may inspect the dataset and delete entries in up to an $\eta$-fraction of samples per coordinate; a strong form of the Missing Not At Random model. In the corrupted data setting, the adversary instead replaces values arbitrarily, and the corruption locations are unknown to the learner. Despite substantial work on missing data, linear regression under such adversarial missingness remains poorly understood, even information-theoretically. Unlike the clean setting, where estimation error vanishes with more samples, here the optimal error remains a positive function of the problem parameters. Our main contribution is to characterize this error up to constant factors across essentially the entire parameter range. Specifically, we establish novel information-theoretic lower bounds on the achievable error that match the error of (computationally efficient) algorithms. A key implication is that, perhaps surprisingly, the optimal error in the missing data setting matches that in the corruption setting-so knowing the corruption locations offers no general advantage.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.19242v1</guid>
      <category>cs.DS</category>
      <category>cs.LG</category>
      <category>math.ST</category>
      <category>stat.ML</category>
      <category>stat.TH</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ilias Diakonikolas, Jelena Diakonikolas, Daniel M. Kane, Jasper C. H. Lee, Thanasis Pittas</dc:creator>
    </item>
    <item>
      <title>Differentially Private Algorithms for Graphs Under Continual Observation</title>
      <link>https://arxiv.org/abs/2106.14756</link>
      <description>arXiv:2106.14756v3 Announce Type: replace 
Abstract: Differentially private algorithms protect individuals in data analysis scenarios by ensuring that there is only a weak correlation between the existence of the user in the data and the result of the analysis. Dynamic graph algorithms maintain the solution to a problem (e.g., a matching) on an evolving input, i.e., a graph where nodes or edges are inserted or deleted over time. They output the value of the solution after each update operation, i.e., continuously. We study (event-level and user-level) differentially private algorithms for graph problems under continual observation, i.e., differentially private dynamic graph algorithms. We present event-level private algorithms for partially dynamic counting-based problems such as triangle count that improve the additive error by a polynomial factor (in the length $T$ of the update sequence) on the state of the art, resulting in the first algorithms with additive error polylogarithmic in $T$.
  We also give $\varepsilon$-differentially private and partially dynamic algorithms for minimum spanning tree, minimum cut, densest subgraph, and maximum matching. The additive error of our improved MST algorithm is $O(W \log^{3/2}T / \varepsilon)$, where $W$ is the maximum weight of any edge, which, as we show, is tight up to a $(\sqrt{\log T} / \varepsilon)$-factor. For the other problems, we present a partially-dynamic algorithm with multiplicative error $(1+\beta)$ for any constant $\beta &gt; 0$ and additive error $O(W \log(nW) \log(T) / (\varepsilon \beta))$. Finally, we show that the additive error for a broad class of dynamic graph algorithms with user-level privacy must be linear in the value of the output solution's range.</description>
      <guid isPermaLink="false">oai:arXiv.org:2106.14756v3</guid>
      <category>cs.DS</category>
      <category>cs.CR</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Hendrik Fichtenberger, Monika Henzinger, Lara Ost</dc:creator>
    </item>
    <item>
      <title>Maximum Weight Independent Set in Graphs with no Long Claws in Quasi-Polynomial Time</title>
      <link>https://arxiv.org/abs/2305.15738</link>
      <description>arXiv:2305.15738v4 Announce Type: replace 
Abstract: We show that the Maximum Weight Independent Set problem (MWIS) can be solved in quasi-polynomial time on $H$-free graphs (graphs excluding a fixed graph $H$ as an induced subgraph) for every $H$ whose every connected component is a path or a subdivided claw (i.e., a tree with at most three leaves). This completes the dichotomy of the complexity of MWIS in $\mathcal{F}$-free graphs for any finite set $\mathcal{F}$ of graphs into NP-hard cases and cases solvable in quasi-polynomial time, and corroborates the conjecture that the cases not known to be NP-hard are actually polynomial-time solvable.
  The key graph-theoretic ingredient in our result is as follows. Fix an integer $t \geq 1$. Let $S_{t,t,t}$ be the graph created from three paths on $t$ edges by identifying one endpoint of each path into a single vertex. We show that, given a graph $G$, one can in polynomial time find either an induced $S_{t,t,t}$ in $G$, or a balanced separator consisting of $\mathcal{O}(\log |V(G)|)$ vertex neighborhoods in $G$, or an extended strip decomposition of $G$ (a decomposition almost as useful for recursion for MWIS as a partition into connected components) with each particle of weight multiplicatively smaller than the weight of $G$. This is a strengthening of a result of Majewski, Masa\v{r}\'ik, Novotn\'a, Okrasa, Pilipczuk, Rz\k{a}\.zewski, and Soko{\l}owski [ICALP 2022] which provided such an extended strip decomposition only after the deletion of $\mathcal{O}(\log |V(G)|)$ vertex neighborhoods. To reach the final result, we employ an involved branching strategy that relies on the structural lemma presented above.</description>
      <guid isPermaLink="false">oai:arXiv.org:2305.15738v4</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3618260.3649791</arxiv:DOI>
      <dc:creator>Peter Gartland, Daniel Lokshtanov, Tom\'a\v{s} Masa\v{r}\'ik, Marcin Pilipczuk, Micha{\l} Pilipczuk, Pawe{\l} Rz\k{a}\.zewski</dc:creator>
    </item>
    <item>
      <title>Fast and memory-efficient BWT construction of repetitive texts using Lyndon grammars</title>
      <link>https://arxiv.org/abs/2504.19123</link>
      <description>arXiv:2504.19123v2 Announce Type: replace 
Abstract: The Burrows-Wheeler Transform (BWT) serves as the basis for many important sequence indexes. On very large datasets (e.g. genomic databases), classical BWT construction algorithms are often infeasible because they usually need to have the entire dataset in main memory. Fortunately, such large datasets are often highly repetitive. It can thus be beneficial to compute the BWT from a compressed representation. We propose an algorithm for computing the BWT via the Lyndon straight-line program, a grammar based on the standard factorization of Lyndon words. Our algorithm can also be used to compute the extended BWT (eBWT) of a multiset of sequences. We empirically evaluate our implementation and find that we can compute the BWT and eBWT of very large datasets faster and/or with less memory than competing methods.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.19123v2</guid>
      <category>cs.DS</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Jannik Olbrich</dc:creator>
    </item>
    <item>
      <title>On Inapproximability of Reconfiguration Problems: PSPACE-Hardness and some Tight NP-Hardness Results</title>
      <link>https://arxiv.org/abs/2312.17140</link>
      <description>arXiv:2312.17140v3 Announce Type: replace-cross 
Abstract: Recently, Ohsaka [STACS'23] put forth the Reconfiguration Inapproximability Hypothesis (RIH), which roughly asserts that there is some $\epsilon&gt;0$ such that given as input a $k$-CSP instance (for some constant $k$) over some constant sized alphabet, and two satisfying assignments $\psi_s$ and $\psi_t$, it is PSPACE-hard to find a sequence of assignments starting from $\psi_s$ and ending at $\psi_t$ such that every assignment in the sequence satisfies at least $(1-\epsilon)$ fraction of the constraints and also that every assignment in the sequence is obtained by changing its immediately preceding assignment (in the sequence) on exactly one variable. Assuming RIH, many important reconfiguration problems have been shown to be PSPACE-hard to approximate by Ohsaka [STACS'23; SODA'24].
  In this paper, we provide a proof of RIH. Our proof uses known constructions of PCP of Proximity to create the gap, and further leverages a parallelization framework from recent parameterized inapproximability results to analyze the quantitative trade-off between $\epsilon$ and $k$ in RIH. We note that Hirahara and Ohsaka [STOC'24] have also independently proved RIH.
  We also prove that the aforementioned $k$-CSP Reconfiguration problem is NP-hard to approximate to within a factor of $1/2 + \epsilon$ (for any $\epsilon&gt;0$) when $k=2$. We complement this with a polynomial time $(1/2 - \epsilon)$-approximation algorithm, which improves upon a $(1/4 - \epsilon)$-approximation algorithm of Ohsaka [2023] (again for any $\epsilon&gt;0$). Finally, we show that Set Cover Reconfiguration is NP-hard to approximate to within a factor of $2 - \epsilon$ for any constant $\epsilon &gt; 0$, which matches the simple linear-time 2-approximation algorithm by Ito et al. [TCS'11].</description>
      <guid isPermaLink="false">oai:arXiv.org:2312.17140v3</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Venkatesan Guruswami, Karthik C. S., Pasin Manurangsi, Xuandi Ren, Kewen Wu</dc:creator>
    </item>
    <item>
      <title>Near Optimal Alphabet-Soundness Tradeoff PCPs</title>
      <link>https://arxiv.org/abs/2404.07441</link>
      <description>arXiv:2404.07441v2 Announce Type: replace-cross 
Abstract: We show that for all $\varepsilon&gt;0$, for sufficiently large $q\in\mathbb{N}$ power of $2$, for all $\delta&gt;0$, it is NP-hard to distinguish whether a given $2$-Prover-$1$-Round projection game with alphabet size $q$ has value at least $1-\delta$, or value at most $1/q^{1-\varepsilon}$. This establishes a nearly optimal alphabet-to-soundness tradeoff for $2$-query PCPs with alphabet size $q$, improving upon a result of [Chan, J.ACM 2016]. Our result has the following implications:
  1) Near optimal hardness for Quadratic Programming: it is NP-hard to approximate the value of a given Boolean Quadratic Program within factor $(\log n)^{1 - o(1)}$ under quasi-polynomial time reductions. This improves upon a result of [Khot, Safra, ToC 2013] and nearly matches the performance of the best known algorithms due to [Megretski, IWOTA 2000], [Nemirovski, Roos, Terlaky, Mathematical programming 1999] and [Charikar, Wirth, FOCS 2004] that achieve $O(\log n)$ approximation ratio.
  2) Bounded degree $2$-CSPs: under randomized reductions, for sufficiently large $d&gt;0$, it is NP-hard to approximate the value of $2$-CSPs in which each variable appears in at most $d$ constraints within factor $(1-o(1))\frac{d}{2}$, improving upon a result of [Lee, Manurangsi, ITCS 2024].
  3) Improved hardness results for connectivity problems: using results of [Laekhanukit, SODA 2014] and [Manurangsi, Inf. Process. Lett., 2019], we deduce improved hardness results for the Rooted $k$-Connectivity Problem, the Vertex-Connectivity Survivable Network Design Problem and the Vertex-Connectivity $k$-Route Cut Problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.07441v2</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dor Minzer, Kai Zhe Zheng</dc:creator>
    </item>
    <item>
      <title>Fermion-to-Fermion Low-Density Parity-Check Codes</title>
      <link>https://arxiv.org/abs/2508.15323</link>
      <description>arXiv:2508.15323v3 Announce Type: replace-cross 
Abstract: Simulating fermionic systems on qubit-based quantum computers often demands significant computational resources due to the requirement to map fermions to qubits. Thus, designing a fault-tolerant quantum computer that operates directly with fermions offers an effective solution to this challenge. Here, we introduce a protocol for fault-tolerant fermionic quantum computation utilizing fermion-to-fermion low-density parity-check (LDPC) codes. Our method employs a fermionic LDPC memory, which transfers its state to fermionic color code processors, where logical operations are subsequently performed. We propose using odd-weight logical Majorana operators to form the code space, serving as memory for the fermionic LDPC code, and provide an algorithm to identify these logical operators. We present examples showing that the coding rate of fermionic codes often matches that of qubit codes, while the logical error rate can be significantly lower than the physical error rate. Furthermore, we propose two methods for performing fermionic lattice surgery to facilitate state transfer. Finally, we simulate the dynamics of a fermionic system using our protocol, illustrating effective error suppression.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.15323v3</guid>
      <category>quant-ph</category>
      <category>cs.DS</category>
      <pubDate>Wed, 24 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Chong-Yuan Xu, Ze-Chuan Liu, Yong Xu</dc:creator>
    </item>
  </channel>
</rss>
