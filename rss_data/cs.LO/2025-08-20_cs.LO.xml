<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Aug 2025 04:00:52 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>To Zip Through the Cost Analysis of Probabilistic Programs</title>
      <link>https://arxiv.org/abs/2508.14249</link>
      <description>arXiv:2508.14249v1 Announce Type: new 
Abstract: Probabilistic programming and the formal analysis of probabilistic algorithms are active areas of research, driven by the widespread use of randomness to improve performance. While functional correctness has seen substantial progress, automated reasoning about expected runtime remains comparatively limited. In this work, we address this challenge by introducing a refinement-typed probability monad in Liquid Haskell. Our monad enables automated reasoning about expected values and costs by encoding probabilistic behaviour directly in types. Initially defined for discrete distributions over finite support, it is extended to support infinite distributions via an axiomatic approach. By leveraging Liquid Haskell's SMT-based refinement type checking, our framework provides a high degree of automation. We evaluate our approach through four case studies: meldable heaps, coupon collector, randomised quicksort, and zip trees. The first two demonstrate automation with minimal annotation overhead. The latter two showcase how our monad integrates with interactive proofs, including the first formal verification of the expected runtime of zip trees.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14249v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Matthias Hetzenberger, Georg Moser, Florian Zuleger</dc:creator>
    </item>
    <item>
      <title>Quantum Petri Nets with Event Structures semantics</title>
      <link>https://arxiv.org/abs/2508.14531</link>
      <description>arXiv:2508.14531v1 Announce Type: new 
Abstract: Classical Petri nets provide a canonical model of concurrency, with unfolding semantics linking nets, occurrence nets, and event structures. No comparable framework exists for quantum concurrency: existing ''quantum Petri nets'' lack rigorous concurrent and sound quantum semantics, analysis tools, and unfolding theory. We introduce Quantum Petri Nets (QPNs), Petri nets equipped with a quantum valuation compatible with the quantum event structure semantics of Clairambault, De Visme, and Winskel (2019). Our contributions are: (i) a local definition of Quantum Occurrence Nets (LQONs) compatible with quantum event structures, (ii) a construction of QPNs with a well-defined unfolding semantics, (iii) a compositional framework for QPNs. This establishes a semantically well grounded model of quantum concurrency, bridging Petri net theory and quantum programming.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14531v1</guid>
      <category>cs.LO</category>
      <category>quant-ph</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Julien Saan Joachim (ENS Paris Saclay, LMF, Inria), Marc de Visme (LMF, Inria, CNRS, ENS Paris Saclay), Stefan Haar (Inria)</dc:creator>
    </item>
    <item>
      <title>A Complete and Natural Rule Set for Multi-Qutrit Clifford Circuits</title>
      <link>https://arxiv.org/abs/2508.14670</link>
      <description>arXiv:2508.14670v1 Announce Type: new 
Abstract: We present a complete set of rewrite rules for n-qutrit Clifford circuits where n is any non-negative integer. This is the first completeness result for any fragment of quantum circuits in odd prime dimensions. We first generalize Selinger's normal form for n-qubit Clifford circuits to the qutrit setting. Then, we present a rewrite system by which any Clifford circuit can be reduced to this normal form. We then simplify the rewrite rules in this procedure to a small natural set of rules, giving a clean presentation of the group of qutrit Clifford unitaries in terms of generators and relations. </description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14670v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.426.2</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 426, 2025, pp. 23-78</arxiv:journal_reference>
      <dc:creator>Sarah Meng Li (University of Amsterdam, University of Waterloo), Michele Mosca (University of Waterloo), Neil J. Ross (Dalhousie University), John van de Wetering (University of Amsterdam), Yuming Zhao (University of Copenhagen, University of Waterloo)</dc:creator>
    </item>
    <item>
      <title>Emerson-Lei and Manna-Pnueli Games for LTLf+ and PPLTL+ Synthesis</title>
      <link>https://arxiv.org/abs/2508.14725</link>
      <description>arXiv:2508.14725v1 Announce Type: new 
Abstract: Recently, the Manna-Pnueli Hierarchy has been used to define the temporal logics LTLfp and PPLTLp, which allow to use finite-trace LTLf/PPLTL techniques in infinite-trace settings while achieving the expressiveness of full LTL. In this paper, we present the first actual solvers for reactive synthesis in these logics. These are based on games on graphs that leverage DFA-based techniques from LTLf/PPLTL to construct the game arena. We start with a symbolic solver based on Emerson-Lei games, which reduces lower-class properties (guarantee, safety) to higher ones (recurrence, persistence) before solving the game. We then introduce Manna-Pnueli games, which natively embed Manna-Pnueli objectives into the arena. These games are solved by composing solutions to a DAG of simpler Emerson-Lei games, resulting in a provably more efficient approach. We implemented the solvers and practically evaluated their performance on a range of representative formulas. The results show that Manna-Pnueli games often offer significant advantages, though not universally, indicating that combining both approaches could further enhance practical performance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14725v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.FL</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Hausmann, Shufang Zhu, Gianmarco Parretti, Christoph Weinhuber, Giuseppe De Giacomo, Nir Piterman</dc:creator>
    </item>
    <item>
      <title>Constraint satisfaction problems, compactness and non-measurable sets</title>
      <link>https://arxiv.org/abs/2508.14838</link>
      <description>arXiv:2508.14838v1 Announce Type: new 
Abstract: A finite relational structure A is called compact if for any infinite relational structure B of the same type, the existence of a homomorphism from B to A is equivalent to the existence of homomorphisms from all finite substructures of B to A. We show that if A has width one, then the compactness of A can be proved in the axiom system of Zermelo and Fraenkel, but otherwise, the compactness of A implies the existence of non-measurable sets in 3-space.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14838v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Claude Tardif</dc:creator>
    </item>
    <item>
      <title>Correct Black-Box Monitors for Distributed Deadlock Detection: Formalisation and Implementation (Technical Report)</title>
      <link>https://arxiv.org/abs/2508.14851</link>
      <description>arXiv:2508.14851v1 Announce Type: new 
Abstract: Many software applications rely on concurrent and distributed (micro)services that interact via message-passing and various forms of remote procedure calls (RPC). As these systems organically evolve and grow in scale and complexity, the risk of introducing deadlocks increases and their impact may worsen: even if only a few services deadlock, many other services may block while awaiting responses from the deadlocked ones. As a result, the "core" of the deadlock can be obfuscated by its consequences on the rest of the system, and diagnosing and fixing the problem can be challenging.
  In this work we tackle the challenge by proposing distributed black-box monitors that are deployed alongside each service and detect deadlocks by only observing the incoming and outgoing messages, and exchanging probes with other monitors. We present a formal model that captures popular RPC-based application styles (e.g., gen_servers in Erlang/OTP), and a distributed black-box monitoring algorithm that we prove sound and complete (i.e., identifies deadlocked services with neither false positives nor false negatives). We implement our results in a tool called DDMon for the monitoring of Erlang/OTP applications, and we evaluate its performance.
  This is the first work that formalises, proves the correctness, and implements distributed black-box monitors for deadlock detection. Our results are mechanised in Coq. DDMon is the companion artifact of this paper.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14851v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1145/3763069</arxiv:DOI>
      <arxiv:journal_reference>OOPSLA 2025</arxiv:journal_reference>
      <dc:creator>Rados{\l}aw Jan Rowicki, Adrian Francalanza, Alceste Scalas</dc:creator>
    </item>
    <item>
      <title>Logical Expressivity and Explanations for Monotonic GNNs with Scoring Functions</title>
      <link>https://arxiv.org/abs/2508.14091</link>
      <description>arXiv:2508.14091v1 Announce Type: cross 
Abstract: Graph neural networks (GNNs) are often used for the task of link prediction: predicting missing binary facts in knowledge graphs (KGs). To address the lack of explainability of GNNs on KGs, recent works extract Datalog rules from GNNs with provable correspondence guarantees. The extracted rules can be used to explain the GNN's predictions; furthermore, they can help characterise the expressive power of various GNN models. However, these works address only a form of link prediction based on a restricted, low-expressivity graph encoding/decoding method. In this paper, we consider a more general and popular approach for link prediction where a scoring function is used to decode the GNN output into fact predictions. We show how GNNs and scoring functions can be adapted to be monotonic, use the monotonicity to extract sound rules for explaining predictions, and leverage existing results about the kind of rules that scoring functions can capture. We also define procedures for obtaining equivalent Datalog programs for certain classes of monotonic GNNs with scoring functions. Our experiments show that, on link prediction benchmarks, monotonic GNNs and scoring functions perform well in practice and yield many sound rules.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14091v1</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Matthew Morris, David J. Tena Cucala, Bernardo Cuenca Grau</dc:creator>
    </item>
    <item>
      <title>Preguss: It Analyzes, It Specifies, It Verifies</title>
      <link>https://arxiv.org/abs/2508.14532</link>
      <description>arXiv:2508.14532v1 Announce Type: cross 
Abstract: Fully automated verification of large-scale software and hardware systems is arguably the holy grail of formal methods. Large language models (LLMs) have recently demonstrated their potential for enhancing the degree of automation in formal verification by, e.g., generating formal specifications as essential to deductive verification, yet exhibit poor scalability due to context-length limitations and, more importantly, the difficulty of inferring complex, interprocedural specifications. This paper outlines Preguss - a modular, fine-grained framework for automating the generation and refinement of formal specifications. Preguss synergizes between static analysis and deductive verification by orchestrating two components: (i) potential runtime error (RTE)-guided construction and prioritization of verification units, and (ii) LLM-aided synthesis of interprocedural specifications at the unit level. We envisage that Preguss paves a compelling path towards the automated verification of large-scale programs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14532v1</guid>
      <category>cs.SE</category>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-nd/4.0/</dc:rights>
      <dc:creator>Zhongyi Wang, Tengjie Lin, Mingshuai Chen, Mingqi Yang, Haokun Li, Xiao Yi, Shengchao Qin, Jianwei Yin</dc:creator>
    </item>
    <item>
      <title>Inserting Planar-Measured Qubits into MBQC Patterns while Preserving Flow</title>
      <link>https://arxiv.org/abs/2508.14671</link>
      <description>arXiv:2508.14671v1 Announce Type: cross 
Abstract: In the one-way model of measurement-based quantum computation (MBQC), computation proceeds via single-qubit measurements on a resource state. Flow conditions ensure that the overall computation is deterministic in a suitable sense, and are required for efficient translation into quantum circuits. Procedures that rewrite MBQC patterns -- e.g. for optimisation, or adapting to hardware constraints -- thus need to preserve the existence of flow. Most previous work has focused on rewrites that reduce the number of qubits in the computation, or that introduce new Pauli-measured qubits. Here, we consider the insertion of planar-measured qubits into MBQC patterns, i.e. arbitrary measurements in a plane of the Bloch sphere spanned by a pair of Pauli operators; such measurements are necessary for universal MBQC. We extend the definition of causal flow, previously restricted to XY -measurements only, to also permit YZ-measurements and derive the conditions under which a YZ-insertion preserves causal flow. Then we derive conditions for YZ-insertion into patterns with gflow or Pauli flow, in which case the argument straightforwardly extends to XZ-insertions as well. We also show that the 'vertex splitting' or 'neighbour unfusion' rule previously used in the literature can be derived from YZ-insertion and pivoting. This work contributes to understanding the broad properties of flow-preserving rewriting in MBQC and in the ZX-calculus more broadly, and it will enable more efficient optimisation, obfuscation, or routing.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.14671v1</guid>
      <category>quant-ph</category>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.426.4</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 426, 2025, pp. 100-126</arxiv:journal_reference>
      <dc:creator>Miriam Backens (Universit\'e de Lorraine, CNRS, Inria, LORIA, F-54000 Nancy, France), Thomas Perez (Inria, Palaiseau, France, LIX, CNRS, Ecole Polytechnique, Institut Polytechnique de Paris, Palaiseau, France, CPHT, CNRS, Ecole Polytechnique, Institut Polytechnique de Paris, Palaiseau, France)</dc:creator>
    </item>
    <item>
      <title>From Thin Concurrent Games to Generalized Species of Structures (Extended Version)</title>
      <link>https://arxiv.org/abs/2302.01082</link>
      <description>arXiv:2302.01082v3 Announce Type: replace 
Abstract: Two families of denotational models have emerged from the semantic analysis of linear logic: dynamic models, typically presented as game semantics, and static models, typically based on a category of relations. In this paper we introduce a formal bridge between a dynamic model and a static model: the model of thin concurrent games and strategies, based on event structures, and the model of generalized species of structures, based on distributors. A special focus of this paper is the two-dimensional nature of the dynamic-static relationship, which we formalize with double categories and bicategories.
  In the first part of the paper, we construct a symmetric monoidal oplax functor from linear concurrent strategies to distributors. We highlight two fundamental differences between the two models: the composition mechanism, and the representation of resource symmetries. In the second part of the paper, we adapt established methods from game semantics (visible strategies, payoff structure) to enforce a tighter connection between the two models. We obtain a cartesian closed pseudofunctor, which we exploit to shed new light on recent results in the theory of the lambda-calculus.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.01082v3</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Pierre Clairambault, Federico Olimpieri, Hugo Paquet</dc:creator>
    </item>
    <item>
      <title>Rewriting Modulo Traced Comonoid Structure</title>
      <link>https://arxiv.org/abs/2302.09631</link>
      <description>arXiv:2302.09631v4 Announce Type: replace 
Abstract: In this paper we adapt previous work on rewriting string diagrams using hypergraphs to the case where the underlying category has a traced comonoid structure, in which wires can be forked and the outputs of a morphism can be connected to its input. Such a structure is particularly interesting because any traced Cartesian (dataflow) category has an underlying traced comonoid structure. We show that certain subclasses of hypergraphs are fully complete for traced comonoid categories: that is to say, every term in such a category has a unique corresponding hypergraph up to isomorphism, and from every hypergraph with the desired properties, a unique term in the category can be retrieved up to the axioms of traced comonoid categories. We also show how the framework of double pushout rewriting (DPO) can be adapted for traced comonoid categories by characterising the valid pushout complements for rewriting in our setting. We conclude by presenting a case study in the form of recent work on an equational theory for sequential circuits: circuits built from primitive logic gates with delay and feedback. The graph rewriting framework allows for the definition of an operational semantics for sequential circuits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2302.09631v4</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dan R. Ghica, George Kaye</dc:creator>
    </item>
    <item>
      <title>Proto-Quipper with Reversing and Control</title>
      <link>https://arxiv.org/abs/2410.22261</link>
      <description>arXiv:2410.22261v2 Announce Type: replace 
Abstract: The quantum programming language Quipper supports circuit operations such as reversing and controlling certain quantum circuits. Additionally, Quipper provides a function called with-computed, which can be used to program circuits of the form g; f; g-dagger. The latter is a common pattern in quantum circuit design.  One benefit of using with-computed, as opposed to constructing the circuit g ; f; g-dagger directly from g, f, and g-dagger, is that it facilitates an important optimization. Namely, if the resulting circuit is later controlled, only f needs to be controlled; the circuits g and g-dagger need not even be controllable.
  In this paper, we formalize a semantics for reversible and controllable circuits, using a dagger symmetric monoidal category R to interpret reversible circuits, and a new notion we call a controllable category N, which encompasses the control and with-computed operations in Quipper. We extend the language Proto-Quipper with reversing, control and the with-computed operation.  Since not all circuits are reversible and/or controllable, we use a type system with modalities to track reversibility and controllability. This generalizes the modality of Fu-Kishida-Ross-Selinger 2023.  We give an abstract categorical semantics, and show that the type system and operational semantics are sound with respect to this semantics.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.22261v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>math.CT</category>
      <category>quant-ph</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.426.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 426, 2025, pp. 1-22</arxiv:journal_reference>
      <dc:creator>Peng Fu (University of South Carolina), Kohei Kishida (University of Illinois Urbana-Champaign), Neil J. Ross (Dalhousie University), Peter Selinger (Dalhousie University)</dc:creator>
    </item>
    <item>
      <title>A modular risk concept for complex systems</title>
      <link>https://arxiv.org/abs/2502.15482</link>
      <description>arXiv:2502.15482v2 Announce Type: replace 
Abstract: This paper motivates the views that for complex systems, risk should be controlled by enforcing constraints in a modular way at different system levels, that the constraints can be expressed as assurance contracts and that acceptable risk mitigation can be demonstrated in assurance case modules. This short paper explains how already existing methodologies can be combined to create a concept for modular risk assessment. The main novelty is the use of so-called contract-based design (CBD) contracts and refinements as risk constraints. This idea is presented here with the objective of receiving feedback from industry and academia.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.15482v2</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dag McGeorge, Jon Arne Glomsrud</dc:creator>
    </item>
    <item>
      <title>The Vampire Diary</title>
      <link>https://arxiv.org/abs/2506.03030</link>
      <description>arXiv:2506.03030v3 Announce Type: replace 
Abstract: During the past decade of continuous development, the theorem prover Vampire has become an automated solver for the combined theories of commonly-used data structures. Vampire now supports arithmetic, induction, and higher-order logic. These advances have been made to meet the demands of software verification, enabling Vampire to effectively complement SAT/SMT solvers and aid proof assistants. We explain how best to use Vampire in practice and review the main changes Vampire has undergone since its last tool presentation, focusing on the engineering principles and design choices we made during this process.</description>
      <guid isPermaLink="false">oai:arXiv.org:2506.03030v3</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Filip B\'artek, Ahmed Bhayat, Robin Coutelier, M\'arton Hajdu, Matthias Hetzenberger, Petra Hozzov\'a, Laura Kov\'acs, Jakob Rath, Michael Rawson, Giles Reger, Martin Suda, Johannes Schoisswohl, Andrei Voronkov</dc:creator>
    </item>
    <item>
      <title>Reachability is Decidable for ATM-Typable Finitary PCF with Effect Handlers</title>
      <link>https://arxiv.org/abs/2508.12572</link>
      <description>arXiv:2508.12572v2 Announce Type: replace 
Abstract: It is well known that the reachability problem for simply-typed lambda calculus with recursive definitions and finite base-type values (finitary PCF) is decidable. A recent paper by Dal Lago and Ghyselen has shown that the same problem becomes undecidable when the language is extended with algebraic effect and handlers (effect handlers). We show that, perhaps surprisingly, the problem becomes decidable even with effect handlers when the type system is extended with answer type modification (ATM). A natural intuition may find the result contradictory, because one would expect allowing ATM makes more programs typable. Indeed, this intuition is correct in that there are programs that are typable with ATM but not without it, as we shall show in the paper. However, a corollary of our decidability result is that the converse is true as well: there are programs that are typable without ATM but becomes untypable with ATM, and we will show concrete examples of such programs in the paper. Our decidability result is proven by a novel continuation passing style (CPS) transformation that transforms an ATM-typable finitary PCF program with effect handlers to a finitary PCF program without effect handlers. Additionally, as another application of our CPS transformation, we show that every recursive-function-free ATM-typable finitary PCF program with effect handlers terminates, while there are (necessarily ATM-untypable) recursive-function-free finitary PCF programs with effect handlers that may diverge. Finally, we disprove a claim made in a recent work that proved a similar but strictly weaker decidability result. We foresee our decidability result to lay a foundation for developing verification methods for programs with effect handlers, just as the decidability result for reachability of finitary PCF has done such for programs without effect handlers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.12572v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ryunosuke Endo, Tachio Terauchi</dc:creator>
    </item>
    <item>
      <title>First Order Logic on Pathwidth Revisited Again</title>
      <link>https://arxiv.org/abs/2210.09899</link>
      <description>arXiv:2210.09899v2 Announce Type: replace-cross 
Abstract: Courcelle's celebrated theorem states that all MSO-expressible properties can be decided in linear time on graphs of bounded treewidth. Unfortunately, the hidden constant implied by this theorem is a tower of exponentials whose height increases with each quantifier alternation in the formula. More devastatingly, this cannot be improved, under standard assumptions, even if we consider the much more restricted problem of deciding FO-expressible properties on trees.
  In this paper we revisit this well-studied topic and identify a natural special case where the dependence of Courcelle's theorem can, in fact, be improved. Specifically, we show that all FO-expressible properties can be decided with an elementary dependence on the input formula, if the input graph has bounded pathwidth (rather than treewidth). This is a rare example of treewidth and pathwidth having different complexity behaviors. Our result is also in sharp contrast with MSO logic on graphs of bounded pathwidth, where it is known that the dependence has to be non-elementary, under standard assumptions. Our work builds upon, and generalizes, a corresponding meta-theorem by Gajarsk{\'{y}} and Hlin{\v{e}}n{\'{y}} for the more restricted class of graphs of bounded tree-depth.</description>
      <guid isPermaLink="false">oai:arXiv.org:2210.09899v2</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <pubDate>Thu, 21 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Michael Lampis</dc:creator>
    </item>
  </channel>
</rss>
