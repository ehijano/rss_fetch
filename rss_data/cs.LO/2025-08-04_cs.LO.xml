<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Aug 2025 02:31:11 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Building Bigraphs of the real world</title>
      <link>https://arxiv.org/abs/2508.00003</link>
      <description>arXiv:2508.00003v1 Announce Type: new 
Abstract: This report proposes a formal specification for organising all buildings, streets and administrative areas in the world into a hierarchical space-partitioning tree using data from OpenStreetMap. This hierarchical structure is encoded into a bigraph, serving as a digital twin of the world and capturing complete street connectivity. It presents a tool implemented in OCaml (source code at https://github.com/royangkr/bigraph-of-the-world ) that constructs bigraphs for regions from any part of the world. In addition, it contributes algorithmic improvements to open-source bigraph-building tools that enable them to efficiently construct and transform extremely large bigraphs, achieving up to a 97x speedup among other gains.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00003v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kang Rong Roy Ang</dc:creator>
    </item>
    <item>
      <title>Reasoning under uncertainty in the game of Cops and Robbers</title>
      <link>https://arxiv.org/abs/2508.00004</link>
      <description>arXiv:2508.00004v1 Announce Type: new 
Abstract: The game of Cops and Robbers is an important model for studying computational queries in pursuit-evasion environments, among others. As recent logical explorations have shown, its structure exhibits appealing analogies with modal logic. In this paper, we enrich the game with a setting in which players may have imperfect information. We propose a new formal framework, Epistemic Logic of Cops and Robbers (ELCR), to make the core notions of the game precise, for instance, players' positions, observational power and inference. Applying ELCR to analyze the game, we obtain an automated way to track interactions between players and characterize their information updates during the game. The update mechanism is defined by a novel dynamic operator, and we compare it with some relevant paradigms from the game and logic perspectives. We study various properties of ELCR including axiomatization and decidability. To our knowledge, this is the first attempt to explore these games from a formal point of view where (partial) information available to players is taken into account.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00004v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Dazhu Li, Sujata Ghosh, Fenrong Liu</dc:creator>
    </item>
    <item>
      <title>Deciding the Value of Two-Clock Almost Non-Zeno Weighted Timed Games</title>
      <link>https://arxiv.org/abs/2508.00014</link>
      <description>arXiv:2508.00014v1 Announce Type: new 
Abstract: The Value Problem for weighted timed games (wtgs) consists in determining, given a two-player weighted timed game with a reachability objective and a rational threshold, whether or not the value of the game exceeds the threshold. When restrained to wtgs with non-negative weight, this problem is known to be undecidable for weighted timed games with three or more clocks, and decidable for one-clock wtgs. The Value Problem for two-clock non-negative wtgs, which remained stubbornly open for a decade, was recently shown to be undecidable. In this article, we show that the Value Problem is decidable when considering two-clock almost non-Zeno wtgs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00014v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Isa Vialard</dc:creator>
    </item>
    <item>
      <title>Extended Abstract: Partial-encapsulate and Its Support for Floating-point Operations in ACL2</title>
      <link>https://arxiv.org/abs/2508.00015</link>
      <description>arXiv:2508.00015v1 Announce Type: new 
Abstract: We illustrate the power of partial-encapsulate, showing how it is used in the implementation of floating-point operations in ACL2.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00015v1</guid>
      <category>cs.LO</category>
      <category>cs.MS</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.6</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 56-59</arxiv:journal_reference>
      <dc:creator>Matt Kaufmann, J Strother Moore</dc:creator>
    </item>
    <item>
      <title>Generative Logic: A New Computer Architecture for Deterministic Reasoning and Knowledge Generation</title>
      <link>https://arxiv.org/abs/2508.00017</link>
      <description>arXiv:2508.00017v1 Announce Type: new 
Abstract: We present Generative Logic (GL), a deterministic architecture that begins from user-supplied axiomatic definitions -- written in a minimalist Mathematical Programming Language (MPL) -- and systematically explores their deductive neighborhood. Definitions are compiled into a distributed grid of simple Logic Blocks (LBs) that exchange messages; any time several expressions unify under an inference rule, a new fact is emitted with full provenance to its sources, yielding replayable, auditable proof graphs.
  A prototype software implementation instantiates the workflow on first-order Peano arithmetic. Starting only from the Peano axioms, GL enumerates candidate implications, applies normalization and type filters, and automatically reconstructs machine-checkable proofs of foundational arithmetic laws including associativity and commutativity of addition, associativity and commutativity of multiplication, and distributivity. Generated proofs export to navigable HTML so that every inference step can be inspected independently.
  We outline a hardware-software co-design path toward massively parallel realizations and describe prospective integration with probabilistic models (e.g., Large Language Models (LLMs)) for autoformalization and conjecture seeding. The Python and MPL code to reproduce the Peano experiments, along with the full HTML proof graphs, are available in the project's GitHub repository at https://github.com/Generative-Logic/GL/tree/35a111ea9ba53afe051703d6050be0c3923e9724 and are permanently archived at https://doi.org/10.5281/zenodo.16408441. We invite community feedback and collaboration.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00017v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.AR</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Nikolai Sergeev</dc:creator>
    </item>
    <item>
      <title>Alignment Monitoring</title>
      <link>https://arxiv.org/abs/2508.00021</link>
      <description>arXiv:2508.00021v1 Announce Type: new 
Abstract: Formal verification provides assurances that a probabilistic system satisfies its specification--conditioned on the system model being aligned with reality. We propose alignment monitoring to watch that this assumption is justified. We consider a probabilistic model well aligned if it accurately predicts the behaviour of an uncertain system in advance. An alignment score measures this by quantifying the similarity between the model's predicted and the system's (unknown) actual distributions. An alignment monitor observes the system at runtime; at each point in time it uses the current state and the model to predict the next state. After the next state is observed, the monitor updates the verdict, which is a high-probability interval estimate for the true alignment score. We utilize tools from sequential forecasting to construct our alignment monitors. Besides a monitor for measuring the expected alignment score, we introduce a differential alignment monitor, designed for comparing two models, and a weighted alignment monitor, which permits task-specific alignment monitoring. We evaluate our monitors experimentally on the PRISM benchmark suite. They are fast, memory-efficient, and detect misalignment early.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00021v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Thomas A. Henzinger, Konstantin Kueffner, Vasu Singh, I Sun</dc:creator>
    </item>
    <item>
      <title>Ordinal Folding Index: A Computable Metric for Self-Referential Semantics</title>
      <link>https://arxiv.org/abs/2508.00151</link>
      <description>arXiv:2508.00151v1 Announce Type: new 
Abstract: The Ordinal Folding Index (OFI) is a new, fully computable yard-stick that measures how many rounds of self-reference a statement, protocol or position must unfold before its truth or outcome stabilises. By turning this abstract 'fold-back' depth into a single ordinal number, OFI forges a direct link between areas that are usually studied in isolation: the closure stages of fixed-point logics, the time-to-win values of infinite parity games, and the ordinal progressions that calibrate the strength of formal theories. We prove that OFI refines all classical game-theoretic and logical metrics while remaining algorithmically enumerable, supply a polynomial-time approximation scheme on finite arenas, and show how the index coincides exactly with the length of the shortest winning strategy in the associated evaluation game. Alongside the theory we outline five open problems from the completeness of the computable-ordinal spectrum to the possibility of 'compressing' deep self-reference that chart a research programme at the intersection of computer-aided logic, algorithmic game theory and ordinal analysis. OFI thus invites game theorists and logicians alike to view infinite play, transfinite induction and reflective reasoning through a single, intuitive lens, opening common ground for techniques.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00151v1</guid>
      <category>cs.LO</category>
      <category>cs.GT</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Faruk Alpay, Hamdi Al Alakkad</dc:creator>
    </item>
    <item>
      <title>Loop Invariant Generation: A Hybrid Framework of Reasoning optimised LLMs and SMT Solvers</title>
      <link>https://arxiv.org/abs/2508.00419</link>
      <description>arXiv:2508.00419v1 Announce Type: new 
Abstract: Loop invariants are essential for proving the correctness of programs with loops. Developing loop invariants is challenging, and fully automatic synthesis cannot be guaranteed for arbitrary programs. Some approaches have been proposed to synthesize loop invariants using symbolic techniques and more recently using neural approaches. These approaches are able to correctly synthesize loop invariants only for subsets of standard benchmarks. In this work, we investigate whether modern, reasoning-optimized large language models can do better. We integrate OpenAI's O1, O1-mini, and O3-mini into a tightly coupled generate-and-check pipeline with the Z3 SMT solver, using solver counterexamples to iteratively guide invariant refinement. We use Code2Inv benchmark, which provides C programs along with their formal preconditions and postconditions. On this benchmark of 133 tasks, our framework achieves 100% coverage (133 out of 133), outperforming the previous best of 107 out of 133, while requiring only 1-2 model proposals per instance and 14-55 seconds of wall-clock time. These results demonstrate that LLMs possess latent logical reasoning capabilities which can help automate loop invariant synthesis. While our experiments target C-specific programs, this approach should be generalizable to other imperative languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00419v1</guid>
      <category>cs.LO</category>
      <category>cs.LG</category>
      <category>cs.PL</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Varun Bharti, Shashwat Jha, Dhruv Kumar, Pankaj Jalote</dc:creator>
    </item>
    <item>
      <title>Analysing Temporal Reasoning in Description Logics Using Formal Grammars</title>
      <link>https://arxiv.org/abs/2508.00575</link>
      <description>arXiv:2508.00575v1 Announce Type: new 
Abstract: We establish a correspondence between (fragments of) $\mathcal{TEL}^\bigcirc$, a temporal extension of the $\mathcal{EL}$ description logic with the LTL operator $\bigcirc^k$, and some specific kinds of formal grammars, in particular, conjunctive grammars (context-free grammars equipped with the operation of intersection). This connection implies that $\mathcal{TEL}^\bigcirc$ does not possess the property of ultimate periodicity of models, and further leads to undecidability of query answering in $\mathcal{TEL}^\bigcirc$, closing a question left open since the introduction of $\mathcal{TEL}^\bigcirc$. Moreover, it also allows to establish decidability of query answering for some new interesting fragments of $\mathcal{TEL}^\bigcirc$, and to reuse for this purpose existing tools and algorithms for conjunctive grammars.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00575v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Camille Bourgaux, Anton Gnatenko, Micha\"el Thomazo</dc:creator>
    </item>
    <item>
      <title>Parameterized Infinite-State Reactive Synthesis</title>
      <link>https://arxiv.org/abs/2508.00613</link>
      <description>arXiv:2508.00613v1 Announce Type: new 
Abstract: We propose a method to synthesize a parameterized infinite-state systems that can be instantiated for different parameter values. The specification is given in a parameterized temporal logic that allows for data variables as well as parameter variables that encode properties of the environment. Our synthesis method runs in a counterexample-guided loop consisting of four main steps: First, we use existing techniques to synthesize concrete systems for some small parameter instantiations. Second, we generalize the concrete systems into a parameterized program. Third, we create a proof candidate consisting of an invariant and a ranking function. Fourth, we check the proof candidate for consistency with the program. If the proof succeeds, the parameterized program is valid. Otherwise, we identify a parameter value for which the proof fails and add a new concrete instance to step one. To generalize programs and create proof candidates, we use a combination of anti-unification and syntax-guided synthesis to express syntactic differences between programs as functions of the parameters. We evaluate our approach on examples from the literature that have been extended with parameters as well as new problems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00613v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Benedikt Maderbacher, Roderick Bloem</dc:creator>
    </item>
    <item>
      <title>Putting Perspective into OWL [sic]: Complexity-Neutral Standpoint Reasoning for Ontology Languages via Monodic S5 over Counting Two-Variable First-Order Logic (Extended Version with Appendix)</title>
      <link>https://arxiv.org/abs/2508.00653</link>
      <description>arXiv:2508.00653v1 Announce Type: new 
Abstract: Standpoint extensions of knowledge representation formalisms have been recently introduced as a means to incorporate multi-perspective modelling and reasoning through modal operators that attribute pieces of knowledge to specific entities or agents. In these extensions, the integration between conceptual modelling and perspective annotations can vary in strength, with monodic standpoint extensions offering a well-balanced approach. They allow for advanced modelling features, such as the expression of rigid concepts, while maintaining desirable reasoning complexity.
  We consider the extension of C2--the counting two-variable fragment of first-order logic--by monodic standpoints. At the heart of our work is a polynomial-time translation of formulas in this extended formalism into standard, standpoint-free C2, a result that relies on intricate model-theoretic arguments. Thanks to this translation, the satisfiability problem remains at the same complexity level: NExpTime-complete, as in plain C2. Since our formalism subsumes monodic S5 over C2, this result also marks a substantial advancement in the study of first-order modal logics.
  From a practical standpoint, this means that highly expressive description logics such as SHOIQBs and SROIQBs--which underpin the widely adopted OWL 1 and OWL 2 ontology languages standardised by the W3C--can be extended with monodic standpoints without increasing the standard reasoning complexity.
  We further prove that NExpTime-hardness arises even in significantly less expressive description logics, as long as they include both nominals and monodic standpoints. Moreover, we show that if the monodicity restriction is relaxed even slightly in the presence of inverse roles, functionality, and nominals, the satisfiability problem becomes undecidable.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00653v1</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Luc\'ia G\'omez \'Alvarez, Sebastian Rudolph</dc:creator>
    </item>
    <item>
      <title>Extended Abstract: Mutable Objects with Several Implementations</title>
      <link>https://arxiv.org/abs/2508.00016</link>
      <description>arXiv:2508.00016v1 Announce Type: cross 
Abstract: This extended abstract outlines an ACL2 feature, attach-stobj, that first appeared in ACL2 Version 8.6 (October, 2024). This feature supports different executable operations for a given abstract stobj, without requiring recertification of the book that introduces that stobj or theorems about it. The paper provides background as well as a user-level overview and some implementation notes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00016v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.423.7</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 423, 2025, pp. 60-64</arxiv:journal_reference>
      <dc:creator>Matt Kaufmann, Yahya Sohail, Warren A. Hunt Jr</dc:creator>
    </item>
    <item>
      <title>Hyperproperty-Constrained Secure Reinforcement Learning</title>
      <link>https://arxiv.org/abs/2508.00106</link>
      <description>arXiv:2508.00106v1 Announce Type: cross 
Abstract: Hyperproperties for Time Window Temporal Logic (HyperTWTL) is a domain-specific formal specification language known for its effectiveness in compactly representing security, opacity, and concurrency properties for robotics applications. This paper focuses on HyperTWTL-constrained secure reinforcement learning (SecRL). Although temporal logic-constrained safe reinforcement learning (SRL) is an evolving research problem with several existing literature, there is a significant research gap in exploring security-aware reinforcement learning (RL) using hyperproperties. Given the dynamics of an agent as a Markov Decision Process (MDP) and opacity/security constraints formalized as HyperTWTL, we propose an approach for learning security-aware optimal policies using dynamic Boltzmann softmax RL while satisfying the HyperTWTL constraints. The effectiveness and scalability of our proposed approach are demonstrated using a pick-up and delivery robotic mission case study. We also compare our results with two other baseline RL algorithms, showing that our proposed method outperforms them.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00106v1</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Ernest Bonnah, Luan Viet Nguyen, Khaza Anuarul Hoque</dc:creator>
    </item>
    <item>
      <title>Dynamics and Coherence for the Free Cornering with Protocol Choice</title>
      <link>https://arxiv.org/abs/2508.00633</link>
      <description>arXiv:2508.00633v1 Announce Type: cross 
Abstract: We present a term rewriting system that models the dynamic aspects of the free cornering with protocol choice of a monoidal category, which has been proposed as a categorical model of process interaction. This term rewriting system is confluent and terminating in an appropriate sense. We use this machinery to prove a coherence theorem for the free cornering with protocol choice.</description>
      <guid isPermaLink="false">oai:arXiv.org:2508.00633v1</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Chad Nester, Niels Voorneveld</dc:creator>
    </item>
    <item>
      <title>Automating Boundary Filling in Cubical Type Theories</title>
      <link>https://arxiv.org/abs/2402.12169</link>
      <description>arXiv:2402.12169v2 Announce Type: replace 
Abstract: When working in a proof assistant, automation is key to discharging routine proof goals such as equations between algebraic expressions. Homotopy type theory allows the user to reason about higher structures, such as topological spaces, using higher inductive types (HITs) and univalence. Cubical type theory provides computational support for HITs and univalence. A difficulty when working in cubical type theory is dealing with the complex combinatorics of higher structures, an infinite-dimensional generalisation of equational reasoning. To solve these higher-dimensional equations consists in constructing cubes with specified boundaries.
  We develop a simplified cubical language in which we isolate and study two automation problems: contortion solving, where we attempt to "contort" a cube to fit a given boundary, and the more general Kan solving, where we search for solutions that involve pasting multiple cubes together. Both problems are difficult in the general case-Kan solving is even undecidable-so we focus on heuristics that perform well on practical examples. Our language encompasses different variations of cubical type theory which differ in their "contortion theory", i.e., the class of contortions they support. We provide a solver for the contortion problem for the most complex contortion theories currently being researched, the Dedekind and De Morgan contortions, by utilizing a reformulation of contortions in terms of poset maps. We solve Kan problems using constraint satisfaction programming, which is applicable independently of the underlying contortion theory. We have implemented our algorithms in an experimental Haskell solver that can be used to automatically solve many goals a user of cubical type theory might face. We illustrate this with a case study establishing the Eckmann-Hilton theorem using our solver, as well as various benchmarks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.12169v2</guid>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Maximilian Dor\'e, Evan Cavallo, Anders M\"ortberg</dc:creator>
    </item>
    <item>
      <title>Cobblestone: Iterative Automation for Formal Verification</title>
      <link>https://arxiv.org/abs/2410.19940</link>
      <description>arXiv:2410.19940v2 Announce Type: replace 
Abstract: Formal verification using proof assistants, such as Coq, is an effective way of improving software quality, but requires significant effort and expertise. Machine learning can automatically synthesize proofs, but such tools are able to prove only a fraction of desired software properties. We introduce Cobblestone, a divide-and-conquer approach for proof synthesis. Cobblestone uses a large language model (LLM) to generate potential proofs, uses those proofs to break the problem into simpler parts, automatically identifies which of those parts were successfully proven, and iterates on the remaining parts to build a correct proof that is guaranteed to be sound, despite the reliance on unsound LLMs. We evaluate Cobblestone on four benchmarks of open-source Coq projects, controlling for training data leakage. Fully automatically, Cobblestone outperforms state-of-the-art non-LLM tools, and proves many theorems that other LLM-based tools cannot, and on many benchmarks, outperforms them. Each Cobblestone run costs only $1.25 and takes 14.7 minutes, on average. Cobblestone can also be used with external input, from a user or another tool, providing a proof structure or relevant lemmas. Evaluated with such an oracle, Cobblestone proves up to 58% of theorems. Overall, our research shows that tools can make use of partial progress and external input to more effectively automate formal verification.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.19940v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.PL</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Saketh Ram Kasibatla, Arpan Agarwal, Yuriy Brun, Sorin Lerner, Talia Ringer, Emily First</dc:creator>
    </item>
    <item>
      <title>Sound and Complete Neurosymbolic Reasoning with LLM-Grounded Interpretations</title>
      <link>https://arxiv.org/abs/2507.09751</link>
      <description>arXiv:2507.09751v2 Announce Type: replace-cross 
Abstract: Large language models (LLMs) have demonstrated impressive capabilities in natural language understanding and generation, but they exhibit problems with logical consistency in the output they generate. How can we harness LLMs' broad-coverage parametric knowledge in formal reasoning despite their inconsistency? We present a method for directly integrating an LLM into the interpretation function of the formal semantics for a paraconsistent logic. We provide experimental evidence for the feasibility of the method by evaluating the function using datasets created from several short-form factuality benchmarks. Unlike prior work, our method offers a theoretical framework for neurosymbolic reasoning that leverages an LLM's knowledge while preserving the underlying logic's soundness and completeness properties.</description>
      <guid isPermaLink="false">oai:arXiv.org:2507.09751v2</guid>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.LO</category>
      <pubDate>Mon, 04 Aug 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Bradley P. Allen, Prateek Chhikara, Thomas Macaulay Ferguson, Filip Ilievski, Paul Groth</dc:creator>
    </item>
  </channel>
</rss>
