<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Mar 2025 01:55:27 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Bounded Exhaustive Random Program Generation for Testing Solidity Compilers and Analyzers</title>
      <link>https://arxiv.org/abs/2503.20332</link>
      <description>arXiv:2503.20332v1 Announce Type: new 
Abstract: Random program generators often exhibit opportunism: they generate programs without a specific focus within the vast search space defined by the programming language. This opportunistic behavior hinders the effective generation of programs that trigger bugs in compilers and analyzers, even when such programs closely resemble those generated. To address this limitation, we propose bounded exhaustive random program generation, a novel method that focuses the search space of program generation with the aim of more quickly identifying bug-triggering programs. Our approach comprises two stages: 1) generating random program templates, which are incomplete test programs containing bug-related placeholders, and 2) conducting a bounded exhaustive enumeration of valid values for each placeholder within these templates. To ensure efficiency, we maintain a solvable constraint set during the template generation phase and then methodically explore all possible values of placeholders within these constraints during the exhaustive enumeration phase. We have implemented this approach for Solidity, a popular smart contract language for the Ethereum blockchain, in a tool named Erwin. Based on a recent study of Solidity compiler bugs, the placeholders used by Erwin relate to language features commonly associated with compiler bugs. Erwin has successfully identified 23 previously unknown bugs across two Solidity compilers, solc and solang, and one Solidity static analyzer, slither. Evaluation results demonstrate that Erwin outperforms state-of-the-art Solidity fuzzers in bug detection and complements developer-written test suites by covering 4,582 edges and 14,737 lines of the solc compiler that were missed by solc unit tests.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.20332v1</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Haoyang Ma, Alastair F. Donaldson, Qingchao Shen, Yongqiang Tian, Junjie Chen, Shing-Chi Cheung</dc:creator>
    </item>
    <item>
      <title>An Encoding of Interaction Nets in OCaml</title>
      <link>https://arxiv.org/abs/2503.20463</link>
      <description>arXiv:2503.20463v1 Announce Type: new 
Abstract: Interaction nets constitute a visual programming language grounded in graph transformation. Owing to their distinctive properties, they inherently facilitate parallelism in the rewriting step. This paper showcases a simple and concise approach to encoding interaction nets within the programming language OCaml, emphasising correctness guarantees. To achieve this objective, we encode not only the interaction net primitives, but also Lafont's original type system.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.20463v1</guid>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.417.1</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 417, 2025, pp. 1-16</arxiv:journal_reference>
      <dc:creator>Nikolaus Huber, Wang Yi</dc:creator>
    </item>
    <item>
      <title>Linear-Time Graph Programs without Preconditions</title>
      <link>https://arxiv.org/abs/2503.20465</link>
      <description>arXiv:2503.20465v1 Announce Type: new 
Abstract: We report on a recent breakthrough in rule-based graph programming, which allows us to reach the time complexity of imperative linear-time algorithms. In general, achieving the complexity of graph algorithms in conventional languages using graph transformation rules is challenging due to the cost of graph matching. Previous work demonstrated that with rooted rules, certain algorithms can be executed in linear time using the graph programming language GP 2. However, for non-destructive algorithms that retain the structure of input graphs, achieving linear runtime required input graphs to be connected and of bounded node degree. In this paper, we overcome these preconditions by enhancing the graph data structure generated by the GP 2 compiler and exploiting the new structure in programs. We present three case studies, a cycle detection program, a program for numbering the connected components of a graph, and a breadth-first search program. Each of these programs runs in linear time on both connected and disconnected input graphs with arbitrary node degrees. We give empirical evidence for the linear time complexity by using timings for various classes of input graphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.20465v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <category>cs.PF</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.417.3</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 417, 2025, pp. 39-54</arxiv:journal_reference>
      <dc:creator>Ziad Ismaili Alaoui (Department of Computer Science, University of Liverpool, Liverpool, United Kingdom), Detlef Plump (Department of Computer Science, University of York, York, United Kingdom)</dc:creator>
    </item>
    <item>
      <title>Pedagogy of Teaching Pointers in the C Programming Language using Graph Transformations</title>
      <link>https://arxiv.org/abs/2503.20469</link>
      <description>arXiv:2503.20469v1 Announce Type: new 
Abstract: Visual learners think in pictures rather than words and learn best when they utilize representations based on graphs, tables, charts, maps, colors and diagrams. We propose a new pedagogy for teaching pointers in the C programming language using graph transformation systems to visually simulate pointer manipulation. In an Introduction to C course, the topic of pointers is often the most difficult one for students to understand; therefore, we experiment with graph-based representations of dynamic pointer structures to reinforce the learning. Groove, a graph transformation tool, is used to illustrate the behaviour of pointers through modelling and simulation. A study is presented to evaluate the effectiveness of the approach. This paper will also provide a comparison to other teaching methods in this area.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.20469v1</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.417.7</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 417, 2025, pp. 117-133</arxiv:journal_reference>
      <dc:creator>Adwoa Donyina (University of New Haven), Reiko Heckel (University of Leicester)</dc:creator>
    </item>
    <item>
      <title>Precise Static Identification of Ethereum Storage Variables</title>
      <link>https://arxiv.org/abs/2503.20690</link>
      <description>arXiv:2503.20690v1 Announce Type: new 
Abstract: Smart contracts are small programs that run autonomously on the blockchain, using it as their persistent memory. The predominant platform for smart contracts is the Ethereum VM (EVM). In EVM smart contracts, a problem with significant applications is to identify data structures (in blockchain state, a.k.a. "storage"), given only the deployed smart contract code. The problem has been highly challenging and has often been considered nearly impossible to address satisfactorily. (For reference, the latest state-of-the-art research tool fails to recover nearly all complex data structures and scales to under 50% of contracts.) Much of the complication is that the main on-chain data structures (mappings and arrays) have their locations derived dynamically through code execution.
  We propose sophisticated static analysis techniques to solve the identification of on-chain data structures with extremely high fidelity and completeness. Our analysis scales nearly universally and recovers deep data structures. Our techniques are able to identify the exact types of data structures with 98.6% precision and at least 92.6% recall, compared to a state-of-the-art tool managing 80.8% and 68.2% respectively. Strikingly, the analysis is often more complete than the storage description that the compiler itself produces, with full access to the source code.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.20690v1</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sifis Lagouvardos, Yannis Bollanos, Michael Debono, Neville Grech, Yannis Smaragdakis</dc:creator>
    </item>
    <item>
      <title>Zippy -- Generic White-Box Proof Search with Zippers</title>
      <link>https://arxiv.org/abs/2503.20413</link>
      <description>arXiv:2503.20413v1 Announce Type: cross 
Abstract: We present a framework for tree-based proof search, called Zippy. Unlike existing proof search tools, Zippy is largely independent of concrete search tree representations, search-algorithms, states and effects. It is designed to create analysable and navigable proof searches that are open to customisation and extensions by users. Zippy is founded on concepts from functional programming theory, particularly zippers, arrows, monads, and lenses. We implemented the framework in Isabelle's metaprogramming language Isabelle/ML.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.20413v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Kevin Kappelmann</dc:creator>
    </item>
    <item>
      <title>Float Self-Tagging</title>
      <link>https://arxiv.org/abs/2411.16544</link>
      <description>arXiv:2411.16544v2 Announce Type: replace 
Abstract: Dynamic and polymorphic languages must attach information, such as types, to run time objects, and therefore adapt the memory layout of values to include space for this information. It makes it difficult to implement efficiently IEEE754 floating-point numbers as this format does not leave an easily accessible space to store the type information. The two main floating-point number encodings in-use to this day, tagged pointers and NaN-boxing, have drawbacks. Tagged pointers entail a heap-allocation of all float objects, and NaN-boxing puts additional run time costs on type checks and the handling of all other objects.
  This paper presents self-tagging, a new approach to object tagging that can attach easily accessible type information to N-bit objects while retaining the ability to use all of their N bits for data. At its core, self-tagging exploits the fact that some bit sequences appear with high probability. Superimposing tags with these frequent sequences allows encoding both N-bit data and type within a single N-bit machine word. The main application of this approach is to represent IEEE754 64-bit and 32-bit floating point numbers on 64-bit and 32-bit machines respectively. We have implemented related variants of self-tagging in one JavaScript compiler and two distinct Scheme compilers to analyze their performance and compare them to tagged pointers and NaN-boxing. Our experiments demonstrate that in practice the approach eliminates heap-allocation of IEEE754 floating-point numbers and improves the execution time of float-intensive benchmarks in Scheme by 2.4$\times$, and in JavaScript by 3.6$\times$, with a negligible performance impact on other benchmarks, which makes it a good alternative to both tagged pointers and NaN-boxing.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.16544v2</guid>
      <category>cs.PL</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Olivier Melan\c{c}on, Manuel Serrano, Marc Feeley</dc:creator>
    </item>
    <item>
      <title>Higher-Order Bialgebraic Semantics</title>
      <link>https://arxiv.org/abs/2405.16708</link>
      <description>arXiv:2405.16708v3 Announce Type: replace-cross 
Abstract: Compositionality proofs in higher-order languages are notoriously involved, and general semantic frameworks guaranteeing compositionality are hard to come by. In particular, Turi and Plotkin's bialgebraic abstract GSOS framework, which provides off-the-shelf compositionality results for first-order languages, so far does not apply to higher-order languages. In the present work, we develop a theory of abstract GSOS specifications for higher-order languages, in effect transferring the core principles of Turi and Plotkin's framework to a higher-order setting. In our theory, the operational semantics of higher-order languages is represented by certain dinatural transformations that we term \emph{(pointed) higher-order GSOS laws}. We give a general compositionality result that applies to all systems specified in this way and discuss how compositionality of combinatory logics and the $\lambda$-calculus w.r.t.\ a strong variant of Abramsky's applicative bisimilarity are obtained as instances.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.16708v3</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 27 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sergey Goncharov, Stefan Milius, Lutz Schr\"oder, Stelios Tsampas, Henning Urbat</dc:creator>
    </item>
  </channel>
</rss>
