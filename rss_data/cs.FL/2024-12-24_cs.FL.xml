<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Dec 2024 02:30:44 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>On the piecewise complexity of words</title>
      <link>https://arxiv.org/abs/2412.16560</link>
      <description>arXiv:2412.16560v1 Announce Type: new 
Abstract: The piecewise complexity $h(u)$ of a word is the minimal length of subwords needed to exactly characterise $u$. Its piecewise minimality index $\rho(u)$ is the smallest length $k$ such that $u$ is minimal among its order-$k$ class $[u]_k$ in Simon's congruence. We initiate a study of these two descriptive complexity measures. Among other results we provide efficient algorithms for computing $h(u)$ and $\rho(u)$ for a given word $u$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16560v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Philippe Schnoebelen, Isa Vialard</dc:creator>
    </item>
    <item>
      <title>The Tractability Border of Reachability in Simple Vector Addition Systems with States</title>
      <link>https://arxiv.org/abs/2412.16612</link>
      <description>arXiv:2412.16612v1 Announce Type: new 
Abstract: Vector Addition Systems with States (VASS), equivalent to Petri nets, are a well-established model of concurrency. The central algorithmic challenge in VASS is the reachability problem: is there a run from a given starting state and counter values to a given target state and counter values? When the input is encoded in binary, reachability is computationally intractable: even in dimension one, it is NP-hard.
  In this paper, we comprehensively characterise the tractability border of the problem when the input is encoded in unary. For our main result, we prove that reachability is NP-hard in unary encoded 3-VASS, even when structure is heavily restricted to be a simple linear path scheme. This improves upon a recent result of Czerwi\'nski and Orlikowski (2022), in both the number of counters and expressiveness of the considered model, as well as answers open questions of Englert, Lazi\'c, and Totzke (2016) and Leroux (2021).
  The underlying graph structure of a simple linear path scheme (SLPS) is just a path with self-loops at each node. We also study the exceedingly weak model of computation that is SPLS with counter updates in {-1,0,+1}. Here, we show that reachability is NP-hard when the dimension is bounded by O(\alpha(k)), where \alpha is the inverse Ackermann function and k bounds the size of the SLPS.
  We complement our result by presenting a polynomial-time algorithm that decides reachability in 2-SLPS when the initial and target configurations are specified in binary. To achieve this, we show that reachability in such instances is well-structured: all loops, except perhaps for a constant number, are taken either polynomially many times or almost maximally. This extends the main result of Englert, Lazi\'c, and Totzke (2016) who showed the problem is in NL when the initial and target configurations are specified in unary.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16612v1</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1109/FOCS61266.2024.00086</arxiv:DOI>
      <dc:creator>Dmitry Chistikov, Wojciech Czerwi\'nski, Filip Mazowiecki, {\L}ukasz Orlikowski, Henry Sinclair-Banks, Karol W\k{e}grzycki</dc:creator>
    </item>
    <item>
      <title>Mostowski Index via extended register games</title>
      <link>https://arxiv.org/abs/2412.16793</link>
      <description>arXiv:2412.16793v1 Announce Type: new 
Abstract: The parity index problem of tree automata asks, given a regular tree language L, what is the least number of priorities of a nondeterministic parity tree automaton that recognises L. This is a long-standing open problem, also known as the Mostowski or Rabin-Mostowski index problem, of which only a few sub-cases and variations are known to be decidable. In a significant step, Colcombet and L\"oding reduced the problem to the uniform universality of distance-parity automata. In this brief note, we present a similar result, with a simplified proof, based on on the games in Lehtinen's quasipolynomial algorithm for parity games.
  We define an extended version of these games, which we call parity transduction games, which take as parameters a parity index J and an integer bound N. We show that the language of a guidable automaton A is recognised by a nondeterministic automaton of index J if and only if there is a bound N such that the parity transduction game with parameters J and N captures membership of the language, that is, for all trees t, Eve wins the parity transduction game on the acceptance parity game of t in A if and only in t is in L(A).</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16793v1</guid>
      <category>cs.FL</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Olivier Idir, Karoliina Lehtinen</dc:creator>
    </item>
    <item>
      <title>Symbolic Infinite-State LTL Synthesis</title>
      <link>https://arxiv.org/abs/2307.09776</link>
      <description>arXiv:2307.09776v2 Announce Type: replace-cross 
Abstract: Recently interest has increased in applying reactive synthesis to more practical richer-than-Boolean domains. One of the major challenges in this area is to establish when certain repeating behaviour terminates in a desired state when the number of steps is unbounded. This isolated problem, by itself, is already undecidable, and forms part of the overall difficulty of this kind of synthesis tasks. Relatively successful approaches exist for deterministic games with at most B{\"u}chi conditions. Our contribution goes beyond, being the first effective approach for solving symbolic synthesis problems with full LTL objectives, based on novel liveness refinements guided by the underlying game. Our CEGAR-based approach relies on a sound boolean abstraction of the problem, spuriousness checking of abstract counterstrategies through invariant checking, and extracting fresh safety or liveness properties of the concrete game from counterexamples. The latter are used to refine the abstraction, which is used to re-attempt synthesis. Our discrete synthesis tool outperforms the state-of-the-art on LIA benchmarks from literature. We also introduce benchmarks that are out of scope for all other approaches.</description>
      <guid isPermaLink="false">oai:arXiv.org:2307.09776v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <category>cs.SY</category>
      <category>eess.SY</category>
      <pubDate>Tue, 24 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Shaun Azzopardi, Nir Piterman, Luca Di Stefano, Gerardo Schneider</dc:creator>
    </item>
  </channel>
</rss>
