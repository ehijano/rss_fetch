<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Sep 2025 01:21:46 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Decidability in First-Order Modal Logic with Non-Rigid Constants and Definite Descriptions</title>
      <link>https://arxiv.org/abs/2509.08165</link>
      <description>arXiv:2509.08165v1 Announce Type: new 
Abstract: While modal extensions of decidable fragments of first-order logic are usually undecidable, their monodic counterparts, in which formulas in the scope of modal operators have at most one free variable, are typically decidable. This only holds, however, under the provision that non-rigid constants, definite descriptions and non-trivial counting are not admitted. Indeed, several monodic fragments having at least one of these features are known to be undecidable. We investigate these features systematically and show that fundamental monodic fragments such as the two-variable fragment with counting and the guarded fragment of standard first-order modal logics $\mathbf{K}_{n}$ and $\mathbf{S5}_{n}$ are decidable. Tight complexity bounds are established as well. Under the expanding-domain semantics, we show decidability of the basic modal logic extended with the transitive closure operator on finite acyclic frames; this logic, however, is Ackermann-hard.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.08165v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Alessandro Artale, Christopher Hampson, Roman Kontchakov, Andrea Mazzullo, Frank Wolter</dc:creator>
    </item>
    <item>
      <title>Hammering Higher Order Set Theory</title>
      <link>https://arxiv.org/abs/2509.08264</link>
      <description>arXiv:2509.08264v1 Announce Type: new 
Abstract: We use automated theorem provers to significantly shorten a formal development in higher order set theory. The development includes many standard theorems such as the fundamental theorem of arithmetic and irrationality of square root of two. Higher order automated theorem provers are particularly useful here, since the underlying framework of higher order set theory coincides with the classical extensional higher order logic of (most) higher order automated theorem provers, so no significant translation or encoding is required. Additionally, many subgoals are first order and so first order automated provers often suffice. We compare the performance of different provers on the subgoals generated from the development. We also discuss possibilities for proof reconstruction, i.e., obtaining formal proof terms when an automated theorem prover claims to have proven the subgoal.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.08264v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Chad E. Brown, Cezary Kaliszyk, Martin Suda, Josef Urban</dc:creator>
    </item>
    <item>
      <title>Exploring Formal Math on the Blockchain: An Explorer for Proofgold</title>
      <link>https://arxiv.org/abs/2509.08267</link>
      <description>arXiv:2509.08267v1 Announce Type: new 
Abstract: Proofgold is a blockchain that supports formalized mathematics alongside standard cryptocurrency functionality. It incorporates logical constructs into the blockchain, including declarations of formal theories, definitions, propositions and proofs. It also supports placing and collecting bounties on proving these propositions, incentivizing the development of the formal libraries contained in Proofgold. In this paper, we present a web-based blockchain explorer for Proofgold. The system exposes not only the usual transactional data but also the formal mathematical components embedded in the chain and allows some interaction with them. The explorer allows users to inspect blocks, transactions, and addresses, as well as formal objects: theories, definitions, theorems and their proofs. We also support the submission of transactions to the blockchain using our interface. We describe the system architecture and its integration with the Proofgold Lava software, highlighting how the explorer supports navigation of formal content and facilitates mathematical knowledge management in a decentralized setting, as well as a number of formalizations in category theory done in the system.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.08267v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Chad E. Brown, Cezary Kaliszyk, Josef Urban</dc:creator>
    </item>
    <item>
      <title>Payment Channels with Proofs</title>
      <link>https://arxiv.org/abs/2509.08268</link>
      <description>arXiv:2509.08268v1 Announce Type: new 
Abstract: The fundamental building blocks of the Bitcoin lightning network are bidirectional payment channels. We describe an extension of payment channels in the Proofgold network which allow the two parties to bet on whether a proposition will be proven by a certain time. These provide the foundation for a Proofgold lightning network that would allow parties to request proofs (by betting there will be no proof by a certain time) and other parties to provide proofs (and be rewarded by betting there will be a proof). The bets may also provide a way to approximate the probability that a certain proposition is provable (in the given amount of time). We describe the implementation of payment channels supporting proofs in Proofgold and discuss a potential lightning network that could be built as a result. One application of such lightning network would be a large decentralized infrastructure for fast collaborative formalization projects.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.08268v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Chad E. Brown, Cezary Kaliszyk, Josef Urban</dc:creator>
    </item>
    <item>
      <title>Trace Repair for Temporal Behavior Trees</title>
      <link>https://arxiv.org/abs/2509.08610</link>
      <description>arXiv:2509.08610v1 Announce Type: new 
Abstract: We present methods for repairing traces against specifications given as temporal behavior trees (TBT). TBT are a specification formalism for action sequences in robotics and cyber-physical systems, where specifications of sub-behaviors, given in signal temporal logic, are composed using operators for sequential and parallel composition, fallbacks, and repetition. Trace repairs are useful to explain failures and as training examples that avoid the observed problems. In principle, repairs can be obtained via mixed-integer linear programming (MILP), but this is far too expensive for practical applications. We present two practical repair strategies: (1) incremental repair, which reduces the MILP by splitting the trace into segments, and (2) landmark-based repair, which solves the repair problem iteratively using TBT's robust semantics as a heuristic that approximates MILP with more efficient linear programming. In our experiments, we were able to repair traces with more than 25,000 entries in under ten minutes, while MILP runs out of memory.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.08610v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Sebastian Schirmer, Philipp Schitz, Johann C. Dauer, Bernd Finkbeiner, Sriram Sankaranarayanan</dc:creator>
    </item>
    <item>
      <title>Un cadre paraconsistant pour l'{\'e}valuation de similarit{\'e} dans les bases de connaissances</title>
      <link>https://arxiv.org/abs/2509.08433</link>
      <description>arXiv:2509.08433v1 Announce Type: cross 
Abstract: This article proposes a paraconsistent framework for evaluating similarity in knowledge bases. Unlike classical approaches, this framework explicitly integrates contradictions, enabling a more robust and interpretable similarity measure. A new measure $ S^* $ is introduced, which penalizes inconsistencies while rewarding shared properties. Paraconsistent super-categories $ \Xi_K^* $ are defined to hierarchically organize knowledge entities. The model also includes a contradiction extractor $ E $ and a repair mechanism, ensuring consistency in the evaluations. Theoretical results guarantee reflexivity, symmetry, and boundedness of $ S^* $. This approach offers a promising solution for managing conflicting knowledge, with perspectives in multi-agent systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2509.08433v1</guid>
      <category>cs.DB</category>
      <category>cs.IT</category>
      <category>cs.LO</category>
      <category>cs.SC</category>
      <category>math.CT</category>
      <category>math.IT</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jos\'e-Luis Vilchis Medina (ENSTA Bretagne, Lab-STICC, Lab-STICC_ROBEX)</dc:creator>
    </item>
    <item>
      <title>Homological Invariants of Higher-Order Equational Theories</title>
      <link>https://arxiv.org/abs/2505.10149</link>
      <description>arXiv:2505.10149v2 Announce Type: replace 
Abstract: Many first-order equational theories, such as the theory of groups or boolean algebras, can be presented by a smaller set of axioms than the original one. Recent studies showed that a homological approach to equational theories gives us inequalities to obtain lower bounds on the number of axioms. In this paper, we extend this result to higher-order equational theories. More precisely, we consider simply typed lambda calculus with product and unit types and study sets of equations between lambda terms. Then, we define homology groups of the given equational theory and show that a lower bound on the number of equations can be computed from the homology groups.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.10149v2</guid>
      <category>cs.LO</category>
      <category>math.CT</category>
      <category>math.LO</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Mirai Ikebuchi</dc:creator>
    </item>
    <item>
      <title>Stopping Criteria for Value Iteration on Concurrent Stochastic Reachability and Safety Games</title>
      <link>https://arxiv.org/abs/2505.21087</link>
      <description>arXiv:2505.21087v2 Announce Type: replace 
Abstract: We consider two-player zero-sum concurrent stochastic games (CSGs) played on graphs with reachability and safety objectives. These include degenerate classes such as Markov decision processes or turn-based stochastic games, which can be solved by linear or quadratic programming; however, in practice, value iteration (VI) outperforms the other approaches and is the most implemented method. Similarly, for CSGs, this practical performance makes VI an attractive alternative to the standard theoretical solution via the existential theory of reals.
  VI starts with an under-approximation of the sought values for each state and iteratively updates them, traditionally terminating once two consecutive approximations are $\epsilon$-close. However, this stopping criterion lacks guarantees on the precision of the approximation, which is the goal of this work. We provide bounded (a.k.a. interval) VI for CSGs: it complements standard VI with a converging sequence of over-approximations and terminates once the over- and under-approximations are $\epsilon$-close.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.21087v2</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.MA</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Marta Grobelna, Jan K\v{r}et\'insk\'y, Maximilian Weininger</dc:creator>
    </item>
    <item>
      <title>FlexFringe: Modeling Software Behavior by Learning Probabilistic Automata</title>
      <link>https://arxiv.org/abs/2203.16331</link>
      <description>arXiv:2203.16331v5 Announce Type: replace-cross 
Abstract: We present the efficient implementations of probabilistic deterministic finite automaton learning methods available in FlexFringe. These implement well-known strategies for state-merging including several modifications to improve their performance in practice. We show experimentally that these algorithms obtain competitive results and significant improvements over a default implementation. We also demonstrate how to use FlexFringe to learn interpretable models from software logs and use these for anomaly detection. Although less interpretable, we show that learning smaller more convoluted models improves the performance of FlexFringe on anomaly detection, outperforming an existing solution based on neural nets.</description>
      <guid isPermaLink="false">oai:arXiv.org:2203.16331v5</guid>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Thu, 11 Sep 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Sicco Verwer, Christian Hammerschmidt</dc:creator>
    </item>
  </channel>
</rss>
