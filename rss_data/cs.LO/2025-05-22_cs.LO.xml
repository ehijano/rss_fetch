<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 May 2025 01:45:08 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Semi-Competitive Differential Game Logic</title>
      <link>https://arxiv.org/abs/2505.14688</link>
      <description>arXiv:2505.14688v1 Announce Type: new 
Abstract: This paper introduces semi-competitive differential game logic dGLsc, which makes it possible to specify and verify games on hybrid systems with two players that may collaborate with each other when helpful and may compete when necessary. Unlike in zero-sum games, the players in the hybrid games of dGLsc have individual goals that may overlap leading to nonzero-sum games. dGLsc solves the subtlety that even though each player may benefit from knowledge of the other player's goals, e.g., concerning shared safety objectives, the resulting hybrid system would still be unsafe if every player were to mutually assume the other player would control to avoid unsafety. The syntax and semantics, as well as a sound and relatively complete proof calculus are presented for dGLsc. The relationship between dGLsc and zero-sum differential game logic dGL is discussed and the purpose of dGLsc illustrated in a canonical example.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14688v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Julia Butte, Andr\'e Platzer</dc:creator>
    </item>
    <item>
      <title>Galois Energy Games: To Solve All Kinds of Quantitative Reachability Problems</title>
      <link>https://arxiv.org/abs/2505.14691</link>
      <description>arXiv:2505.14691v1 Announce Type: new 
Abstract: We provide a generic decision procedure for energy games with energy-bounded attacker and reachability objective, moving beyond vector-valued energies and vector-addition updates. All we demand is that energies form well-founded bounded join-semilattices, and that energy updates have an upward-closed domain and can be "undone" through a Galois-connected function. We instantiate these Galois energy games to common energy games, declining energy games, multi-weighted reachability games, coverability on vector addition systems with states and shortest path problems, supported by an Isabelle-formalization and two implementations. For these instantiations, our simple algorithm is polynomial w.r.t. game graph size and exponential w.r.t. dimension.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14691v1</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Caroline Lemke, Benjamin Bisping</dc:creator>
    </item>
    <item>
      <title>Propositional Measure Logic</title>
      <link>https://arxiv.org/abs/2505.14693</link>
      <description>arXiv:2505.14693v1 Announce Type: new 
Abstract: We present a propositional logic with fundamental probabilistic semantics, in which each formula is given a real measure in the interval $[0,1]$ that represents its degree of truth. This semantics replaces the binarity of classical logic, while preserving its deductive structure. We demonstrate the soundness theorem, establishing that the proposed system is sound and suitable for reasoning under uncertainty. We discuss potential applications and avenues for future extensions of the theory. We apply probabilistic logic to a still refractory problem in Bayesian Networks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14693v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Francisco Arag\~ao</dc:creator>
    </item>
    <item>
      <title>On the Possibilities of Hypercomputing Supertasks</title>
      <link>https://arxiv.org/abs/2505.14698</link>
      <description>arXiv:2505.14698v1 Announce Type: new 
Abstract: This paper investigates the view that digital hypercomputing is a good reason for rejection or re-interpretation of the Church-Turing thesis. After suggestion that such re-interpretation is historically problematic and often involves attack on a straw man (the 'maximality thesis'), it discusses proposals for digital hypercomputing with Zeno-machines , i.e. computing machines that compute an infinite number of computing steps in finite time, thus performing supertasks. It argues that effective computing with Zeno-machines falls into a dilemma: either they are specified such that they do not have output states, or they are specified such that they do have output states, but involve contradiction. Repairs though non-effective methods or special rules for semi-decidable problems are sought, but not found. The paper concludes that hypercomputing supertasks are impossible in the actual world and thus no reason for rejection of the Church-Turing thesis in its traditional interpretation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14698v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/s11023-011-9222-6</arxiv:DOI>
      <arxiv:journal_reference>(2011) Minds and Machines, 21 (1), 83-96</arxiv:journal_reference>
      <dc:creator>Vincent C. M\"uller</dc:creator>
    </item>
    <item>
      <title>Nominal Equational Narrowing: Rewriting for Unification in Languages with Binders</title>
      <link>https://arxiv.org/abs/2505.14895</link>
      <description>arXiv:2505.14895v1 Announce Type: new 
Abstract: Narrowing extends term rewriting with the ability to search for solutions to equational problems. While first-order rewriting and narrowing are well studied, significant challenges arise in the presence of binders, freshness conditions and equational axioms such as commutativity. This is problematic for applications in programming languages and theorem proving, where reasoning modulo renaming of bound variables, structural congruence, and freshness conditions is needed. To address these issues, we present a framework for nominal rewriting and narrowing modulo equational theories that intrinsically incorporates renaming and freshness conditions. We define and prove a key property called nominal E-coherence under freshness conditions, which characterises normal forms of nominal terms modulo renaming and equational axioms. Building on this, we establish the nominal E-lifting theorem, linking rewriting and narrowing sequences in the nominal setting. This foundational result enables the development of a nominal unification procedure based on equational narrowing, for which we provide a correctness proof. We illustrate the effectiveness of our approach with examples including symbolic differentiation and simplification of first-order formulas.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14895v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Maribel Fern\'andez, Daniele Nantes-Sobrinho, Daniella Santaguida</dc:creator>
    </item>
    <item>
      <title>Lean-auto: An Interface between Lean 4 and Automated Theorem Provers</title>
      <link>https://arxiv.org/abs/2505.14929</link>
      <description>arXiv:2505.14929v1 Announce Type: new 
Abstract: Proof automation is crucial to large-scale formal mathematics and software/hardware verification projects in ITPs. Sophisticated tools called hammers have been developed to provide general-purpose proof automation in ITPs such as Coq and Isabelle, leveraging the power of ATPs. An important component of a hammer is the translation algorithm from the ITP's logical system to the ATP's logical system. In this paper, we propose a novel translation algorithm for ITPs based on dependent type theory. The algorithm is implemented in Lean 4 under the name Lean-auto. When combined with ATPs, Lean-auto provides general-purpose, ATP-based proof automation in Lean 4 for the first time. Soundness of the main translation procedure is guaranteed, and experimental results suggest that our algorithm is sufficiently complete to automate the proof of many problems that arise in practical uses of Lean 4. We also find that Lean-auto solves more problems than existing tools on Lean 4's math library Mathlib4.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14929v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yicheng Qian, Joshua Clune, Clark Barrett, Jeremy Avigad</dc:creator>
    </item>
    <item>
      <title>Integer Reasoning Modulo Different Constants in SMT</title>
      <link>https://arxiv.org/abs/2505.14998</link>
      <description>arXiv:2505.14998v1 Announce Type: new 
Abstract: This paper presents a new refutation procedure for multimodular systems of integer constraints that commonly arise when verifying cryptographic protocols. These systems, involving polynomial equalities and disequalities modulo different constants, are challenging for existing solvers due to their inability to exploit multimodular structure. To address this issue, our method partitions constraints by modulus and uses lifting and lowering techniques to share information across subsystems, supported by algebraic tools like weighted Gr\"obner bases. Our experiments show that the proposed method outperforms existing state-of-the-art solvers in verifying cryptographic implementations related to Montgomery arithmetic and zero-knowledge proofs.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14998v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Elizaveta Pertseva, Alex Ozdemir, Shankara Pailoor, Alp Bassa, Sorawee Porncharoenwase, I\c{s}il Dillig, Clark Barrett</dc:creator>
    </item>
    <item>
      <title>Owicki--Gries Logic for Timestamp Semantics</title>
      <link>https://arxiv.org/abs/2505.15053</link>
      <description>arXiv:2505.15053v1 Announce Type: new 
Abstract: Whereas an extension with non-interference of Hoare logic for sequential programs Owicki--Gries logic ensures the correctness of concurrent programs on strict consistency, it is unsound to weak memory models adopted by modern computer architectures and specifications of programming languages. This paper proposes a novel non-interference notion and provides concurrent program logic sound to timestamp semantics corresponding to a weak memory model that allows delays in the effects of store instructions. This paper reports three theoretically interesting techniques for modifying non-interference to support delays in the effects of store instructions. The techniques contribute to a better understanding of constructing concurrent program logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15053v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Tatsuya Abe</dc:creator>
    </item>
    <item>
      <title>RustSAT: A Library For SAT Solving in Rust</title>
      <link>https://arxiv.org/abs/2505.15221</link>
      <description>arXiv:2505.15221v1 Announce Type: new 
Abstract: State-of-the-art Boolean satisfiability (SAT) solvers constitute a practical and competitive approach for solving various real-world problems. To encourage their widespread adoption, the relatively high barrier of entry following from the low level syntax of SAT and the expert knowledge required to achieve tight integration with SAT solvers should be further reduced. We present RustSAT, a library with the aim of making SAT solving technology readily available in the Rust programming language. RustSAT provides functionality for helping with generating (Max)SAT instances, writing them to, or reading them from files. Furthermore, RustSAT includes interfaces to various state-of-the-art SAT solvers available with a unified Rust API. Lastly, RustSAT implements several encodings for higher level constraints (at-most-one, cardinality, and pseudo-Boolean), which are also available via a C and Python API.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15221v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Christoph Jabs</dc:creator>
    </item>
    <item>
      <title>Robust Probabilistic Bisimilarity for Labelled Markov Chains</title>
      <link>https://arxiv.org/abs/2505.15290</link>
      <description>arXiv:2505.15290v1 Announce Type: new 
Abstract: Despite its prevalence, probabilistic bisimilarity suffers from a lack of robustness under minuscule perturbations of the transition probabilities. This can lead to discontinuities in the probabilistic bisimilarity distance function, undermining its reliability in practical applications where transition probabilities are often approximations derived from experimental data. Motivated by this limitation, we introduce the notion of robust probabilistic bisimilarity for labelled Markov chains, which ensures the continuity of the probabilistic bisimilarity distance function. We also propose an efficient algorithm for computing robust probabilistic bisimilarity and show that it performs well in practice, as evidenced by our experimental results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15290v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Syyeda Zainab Fatmi, Stefan Kiefer, David Parker, Franck van Breugel</dc:creator>
    </item>
    <item>
      <title>Alpay Algebra: A Universal Structural Foundation</title>
      <link>https://arxiv.org/abs/2505.15344</link>
      <description>arXiv:2505.15344v1 Announce Type: new 
Abstract: Alpay Algebra is introduced as a universal, category-theoretic framework that unifies classical algebraic structures with modern needs in symbolic recursion and explainable AI. Starting from a minimal list of axioms, we model each algebra as an object in a small cartesian closed category $\mathcal{A}$ and define a transfinite evolution functor $\phi\colon\mathcal{A}\to\mathcal{A}$. We prove that the fixed point $\phi^{\infty}$ exists for every initial object and satisfies an internal universal property that recovers familiar constructs -- limits, colimits, adjunctions -- while extending them to ordinal-indexed folds. A sequence of theorems establishes (i) soundness and conservativity over standard universal algebra, (ii) convergence of $\phi$-iterates under regular cardinals, and (iii) an explanatory correspondence between $\phi^{\infty}$ and minimal sufficient statistics in information-theoretic AI models. We conclude by outlining computational applications: type-safe functional languages, categorical model checking, and signal-level reasoning engines that leverage Alpay Algebra's structural invariants. All proofs are self-contained; no external set-theoretic axioms beyond ZFC are required. This exposition positions Alpay Algebra as a bridge between foundational mathematics and high-impact AI systems, and provides a reference for further work in category theory, transfinite fixed-point analysis, and symbolic computation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15344v1</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>math.CT</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Faruk Alpay</dc:creator>
    </item>
    <item>
      <title>Group Order Logic</title>
      <link>https://arxiv.org/abs/2505.15359</link>
      <description>arXiv:2505.15359v1 Announce Type: new 
Abstract: We introduce an extension of fixed-point logic ($\mathsf{FP}$) with a group-order operator ($\mathsf{ord}$), that computes the size of a group generated by a definable set of permutations. This operation is a generalization of the rank operator ($\mathsf{rk}$). We show that $\mathsf{FP} + \mathsf{ord}$ constitutes a new candidate logic for the class of polynomial-time computable queries ($\mathsf{P}$). As was the case for $\mathsf{FP} + \mathsf{rk}$, the model-checking of $\mathsf{FP} + \mathsf{ord}$ formulae is polynomial-time computable. Moreover, the query separating $\mathsf{FP} + \mathsf{rk}$ from $\mathsf{P}$ exhibited by Lichter in his recent breakthrough is definable in $\mathsf{FP} + \mathsf{ord}$. Precisely, we show that $\mathsf{FP} + \mathsf{ord}$ canonizes structures with Abelian colors, a class of structures which contains Lichter's counter-example. This proof involves expressing a fragment of the group-theoretic approach to graph canonization in the logic $\mathsf{FP}+ \mathsf{ord}$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15359v1</guid>
      <category>cs.LO</category>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <category>math.GR</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anatole Dahan</dc:creator>
    </item>
    <item>
      <title>Approximate Probabilistic Bisimulation for Continuous-Time Markov Chains</title>
      <link>https://arxiv.org/abs/2505.15587</link>
      <description>arXiv:2505.15587v2 Announce Type: new 
Abstract: We introduce $(\varepsilon, \delta)$-bisimulation, a novel type of approximate probabilistic bisimulation for continuous-time Markov chains. In contrast to related notions, $(\varepsilon, \delta)$-bisimulation allows the use of different tolerances for the transition probabilities ($\varepsilon$, additive) and total exit rates ($\delta$, multiplicative) of states. Fundamental properties of the notion, as well as bounds on the absolute difference of time- and reward-bounded reachability probabilities for $(\varepsilon,\delta)$-bisimilar states, are established.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15587v2</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Timm Spork, Christel Baier, Joost-Pieter Katoen, Sascha Kl\"uppelholz, Jakob Piribauer</dc:creator>
    </item>
    <item>
      <title>First-order transducibility among classes of sparse graphs</title>
      <link>https://arxiv.org/abs/2505.15655</link>
      <description>arXiv:2505.15655v1 Announce Type: new 
Abstract: We prove several negative results about first-order transducibility for classes of sparse graphs:
  - for every $t \in \mathbb{N}$, the class of graphs of treewidth at most $t+1$ is not transducible from the class of graphs of treewidth at most $t$;
  - for every $t \in \mathbb{N}$, the class of graphs with Hadwiger number at most $t+2$ is not transducible from the class of graphs with Hadwiger number at most $t$; and
  - the class of graphs of treewidth at most $4$ is not transducible from the class of planar graphs.
  These results are obtained by combining the known upper and lower bounds on the weak coloring numbers of the considered graph classes with the following two new observations:
  - If a weakly sparse graph class $\mathscr D$ is transducible from a class $\mathscr C$ of bounded expansion, then for some $k \in \mathbb{N}$, every graph $G \in \mathscr D$ is a $k$-congested depth-$k$ minor of a graph $H^\circ$ obtained from some $H\in \mathscr C$ by adding a universal vertex.
  - The operations of adding a universal vertex and of taking $k$-congested depth-$k$ minors, for a fixed $k$, preserve the degree of the distance-$d$ weak coloring number of a graph class, understood as a polynomial in $d$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15655v1</guid>
      <category>cs.LO</category>
      <category>cs.DM</category>
      <category>math.CO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jakub Gajarsk\'y, Jeremi G{\l}adkowski, Jan Jedelsk\'y, Micha{\l} Pilipczuk, Szymon Toru\'nczyk</dc:creator>
    </item>
    <item>
      <title>Lean-SMT: An SMT tactic for discharging proof goals in Lean</title>
      <link>https://arxiv.org/abs/2505.15796</link>
      <description>arXiv:2505.15796v1 Announce Type: new 
Abstract: Lean is an increasingly popular proof assistant based on dependent type theory. Despite its success, it still lacks important automation features present in more seasoned proof assistants, such as the Sledgehammer tactic in Isabelle/HOL. A key aspect of Sledgehammer is the use of proof-producing SMT solvers to prove a translated proof goal and the reconstruction of the resulting proof into valid justifications for the original goal. We present Lean-SMT, a tactic providing this functionality in Lean. We detail how the tactic converts Lean goals into SMT problems and, more importantly, how it reconstructs SMT proofs into native Lean proofs. We evaluate the tactic on established benchmarks used to evaluate Sledgehammer's SMT integration, with promising results. We also evaluate Lean-SMT as a standalone proof checker for proofs of SMT-LIB problems. We show that Lean-SMT offers a smaller trusted core without sacrificing too much performance.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15796v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Abdalrhman Mohamed, Tomaz Mascarenhas, Harun Khan, Haniel Barbosa, Andrew Reynolds, Yicheng Qian, Cesare Tinelli, Clark Barrett</dc:creator>
    </item>
    <item>
      <title>Follow the STARs: Dynamic $\omega$-Regular Shielding of Learned Policies</title>
      <link>https://arxiv.org/abs/2505.14689</link>
      <description>arXiv:2505.14689v1 Announce Type: cross 
Abstract: This paper presents a novel dynamic post-shielding framework that enforces the full class of $\omega$-regular correctness properties over pre-computed probabilistic policies. This constitutes a paradigm shift from the predominant setting of safety-shielding -- i.e., ensuring that nothing bad ever happens -- to a shielding process that additionally enforces liveness -- i.e., ensures that something good eventually happens. At the core, our method uses Strategy-Template-based Adaptive Runtime Shields (STARs), which leverage permissive strategy templates to enable post-shielding with minimal interference. As its main feature, STARs introduce a mechanism to dynamically control interference, allowing a tunable enforcement parameter to balance formal obligations and task-specific behavior at runtime. This allows to trigger more aggressive enforcement when needed, while allowing for optimized policy choices otherwise. In addition, STARs support runtime adaptation to changing specifications or actuator failures, making them especially suited for cyber-physical applications. We evaluate STARs on a mobile robot benchmark to demonstrate their controllable interference when enforcing (incrementally updated) $\omega$-regular correctness properties over learned probabilistic policies.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.14689v1</guid>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ashwani Anand, Satya Prakash Nayak, Ritam Raha, Anne-Kathrin Schmuck</dc:creator>
    </item>
    <item>
      <title>Model Checking the Security of the Lightning Network</title>
      <link>https://arxiv.org/abs/2505.15568</link>
      <description>arXiv:2505.15568v1 Announce Type: cross 
Abstract: Payment channel networks are an approach to improve the scalability of blockchain-based cryptocurrencies. The Lightning Network is a payment channel network built for Bitcoin that is already used in practice. Because the Lightning Network is used for transfer of financial value, its security in the presence of adversarial participants should be verified. The Lightning protocol's complexity makes it hard to assess whether the protocol is secure. To enable computer-aided security verification of Lightning, we formalize the protocol in TLA+ and formally specify the security property that honest users are guaranteed to retrieve their correct balance. While model checking provides a fully automated verification of the security property, the state space of the protocol's specification is so large that model checking becomes unfeasible. We make model checking the Lightning Network possible using two refinement steps that we verify using proofs. In a first step, we prove that the model of time used in the protocol can be abstracted using ideas from the research of timed automata. In a second step, we prove that it suffices to model check the protocol for single payment channels and the protocol for multi-hop payments separately. These refinements reduce the state space sufficiently to allow for model checking Lightning with models with payments over up to four hops and two concurrent payments. These results indicate that the current specification of Lightning is secure.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.15568v1</guid>
      <category>cs.CR</category>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Matthias Grundmann, Hannes Hartenstein</dc:creator>
    </item>
    <item>
      <title>Teaching Divisibility and Binomials with Coq</title>
      <link>https://arxiv.org/abs/2404.12676</link>
      <description>arXiv:2404.12676v4 Announce Type: replace 
Abstract: The goal of this contribution is to provide worksheets in Coq for students to learn about divisibility and binomials. These basic topics are a good case study as they are widely taught in the early academic years (or before in France). We present here our technical and pedagogical choices, the numerous exercises we developed and a small experiment we conducted on two students. As expected, it required additional Coq material such as other lemmas and dedicated tactics. The worksheets are freely available and flexible in several ways.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.12676v4</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.419.8</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 419, 2025, pp. 124-139</arxiv:journal_reference>
      <dc:creator>Sylvie Boldo (TOCCATA), Fran\c{c}ois Cl\'ement (SERENA, CERMICS), David Hamelin (TOCCATA), Micaela Mayero (LIPN, TOCCATA), Pierre Rousselin (LAGA, SERENA, CERMICS)</dc:creator>
    </item>
    <item>
      <title>Deeply Optimizing the SAT Solver for the IC3 Algorithm</title>
      <link>https://arxiv.org/abs/2501.18612</link>
      <description>arXiv:2501.18612v3 Announce Type: replace 
Abstract: The IC3 algorithm, also known as PDR, is a SAT-based model checking algorithm that has significantly influenced the field in recent years due to its efficiency, scalability, and completeness. It utilizes SAT solvers to solve a series of SAT queries associated with relative induction. In this paper, we introduce several optimizations for the SAT solver in IC3 based on our observations of the unique characteristics of these SAT queries. By observing that SAT queries do not necessarily require decisions on all variables, we compute a subset of variables that need to be decided before each solving process while ensuring that the result remains unaffected. Additionally, noting that the overhead of binary heap operations in VSIDS is non-negligible, we replace the binary heap with buckets to achieve constant-time operations. Furthermore, we support temporary clauses without the need to allocate a new activation variable for each solving process, thereby eliminating the need to reset solvers. We developed a novel lightweight CDCL SAT solver, GipSAT, which integrates these optimizations. A comprehensive evaluation highlights the performance improvements achieved by GipSAT. Specifically, the GipSAT-based IC3 demonstrates an average speedup of 3.61 times in solving time compared to the IC3 implementation based on MiniSat.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.18612v3</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Yuheng Su, Qiusong Yang, Yiwei Ci, Yingcheng Li, Tianjun Bu, Ziyu Huang</dc:creator>
    </item>
    <item>
      <title>Relators and Notions of Simulation Revisited</title>
      <link>https://arxiv.org/abs/2502.01790</link>
      <description>arXiv:2502.01790v2 Announce Type: replace 
Abstract: Simulations and bisimulations are ubiquitous in the study of concurrent systems and modal logics of various types. Besides classical relational transition systems, relevant system types include, for instance, probabilistic, weighted, neighbourhood-based, and game-based systems. Universal coalgebra abstracts system types in this sense as set functors. Notions of (bi)simulation then arise by extending the functor to act on relations in a suitable manner, turning it into what may be termed a relator. We contribute to the study of relators in the broadest possible sense, in particular in relation to their induced notions of (bi)similarity. Specifically, (i) we show that every functor that preserves a very restricted type of pullbacks (termed 1/4-iso pullbacks) admits a sound and complete notion of bisimulation induced by the coBarr relator; (ii) we establish equivalences between properties of relators and closure properties of the induced notion of (bi)simulation, showing in particular that the full set of expected closure properties requires the relator to be a lax extension, and that soundness of (bi)simulations requires preservation of diagonals; and (iii) we show that functors preserving inverse images admit a greatest lax extension. In a concluding case study, we apply (iii) to obtain a novel highly permissive notion of twisted bisimulation on labelled transition systems.</description>
      <guid isPermaLink="false">oai:arXiv.org:2502.01790v2</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Sergey Goncharov, Dirk Hofmann, Pedro Nora, Lutz Schr\"oder, Paul Wild</dc:creator>
    </item>
    <item>
      <title>An Intermediate Program Representation for Optimizing Stream-Based Languages</title>
      <link>https://arxiv.org/abs/2504.21458</link>
      <description>arXiv:2504.21458v2 Announce Type: replace 
Abstract: Stream-based runtime monitors are safety assurance tools that check at runtime whether the system's behavior satisfies a formal specification. Specifications consist of stream equations, which relate input streams, containing sensor readings and other incoming information, to output streams, representing filtered and aggregated data. This paper presents a framework for the stream-based specification language RTLola. We introduce a new intermediate representation for stream-based languages, the StreamIR, which, like the specification language, operates on streams of unbounded length; while the stream equations are replaced by imperative programs. We developed a set of optimizations based on static analysis of the specification and have implemented an interpreter and a compiler for several target languages. In our evaluation, we measure the performance of several real-world case studies. The results show that using the StreamIR framework reduces the runtime significantly compared to the existing StreamIR interpreter. We evaluate the effect of the optimizations and show that significant performance gains are possible beyond the optimizations of the target language's compiler. While our current implementation is limited to RTLola, the StreamIR is designed to accommodate other stream-based languages, enabling their interpretation and compilation into all available target languages.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.21458v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jan Baumeister, Arthur Correnson, Bernd Finkbeiner, Frederik Scheerer</dc:creator>
    </item>
    <item>
      <title>Being polite is not enough (and other limits of theory combination)</title>
      <link>https://arxiv.org/abs/2505.04870</link>
      <description>arXiv:2505.04870v2 Announce Type: replace 
Abstract: In the Nelson-Oppen combination method for satisfiability modulo theories, the combined theories must be stably infinite; in gentle combination, one theory has to be gentle, and the other has to satisfy a similar yet weaker property; in shiny combination, only one has to be shiny (smooth, with a computable minimal model function and the finite model property); and for polite combination, only one has to be strongly polite (smooth and strongly finitely witnessable). For each combination method, we prove that if any of its assumptions are removed, then there is no general method to combine an arbitrary pair of theories satisfying the remaining assumptions. We also prove new theory combination results that weaken the assumptions of gentle and shiny combination.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.04870v2</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Guilherme V. Toledo, Benjamin Przybocki, Yoni Zohar</dc:creator>
    </item>
    <item>
      <title>Non-expansive Fuzzy ALC</title>
      <link>https://arxiv.org/abs/2505.09416</link>
      <description>arXiv:2505.09416v2 Announce Type: replace 
Abstract: Fuzzy description logics serve the representation of vague knowledge, typically letting concepts take truth degrees in the unit interval. Expressiveness, logical properties, and complexity vary strongly with the choice of propositional base. The Lukasiewicz propositional base is generally perceived to have preferable logical properties but often entails high complexity or even undecidability. Contrastingly, the less expressive Zadeh propositional base comes with low complexity but entails essentially no change in logical behaviour compared to the classical case. To strike a balance between these poles, we propose non-expansive fuzzy ALC, in which the Zadeh base is extended with Lukasiewicz connectives where one side is restricted to be a rational constant, that is, with constant shift operators. This allows, for instance, modelling dampened inheritance of properties along roles. We present an unlabelled tableau method for non-expansive fuzzy ALC, which allows reasoning over general TBoxes in EXPTIME like in two-valued ALC.</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.09416v2</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Stefan Gebhart, Lutz Schr\"oder, Paul Wild</dc:creator>
    </item>
    <item>
      <title>Logic and Concepts in the 2-category of Topoi</title>
      <link>https://arxiv.org/abs/2504.16690</link>
      <description>arXiv:2504.16690v2 Announce Type: replace-cross 
Abstract: We use Kan injectivity to axiomatise concepts in the 2-category of topoi. We showcase the expressivity of this language through many examples, and we establish some aspects of the formal theory of Kan extension in this 2-category (pointwise Kan extensions, fully faithful morphisms, etc.). We use this technology to introduce fragments of geometric logic, and we accommodate essentially algebraic, disjunctive, regular, and coherent logic in our framework, together with some more exotic examples. We show that each fragment $\mathcal{H}$ in our sense identifies a lax-idempotent (relative) pseudomonad $\mathsf{T}^{\mathcal{H}}$ on $\mathsf{lex}$, the $2$-category of finitely complete categories. We show that the algebras for $\mathsf{T}^{\mathcal{H}}$ admit a notion of classifying topos, for which we deliver several Diaconescu-type results. The construction of classifying topoi allows us to define conceptually complete fragments of geometric logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:2504.16690v2</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <category>math.CT</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ivan Di Liberti, Lingyuan Ye</dc:creator>
    </item>
    <item>
      <title>CLEVER: A Curated Benchmark for Formally Verified Code Generation</title>
      <link>https://arxiv.org/abs/2505.13938</link>
      <description>arXiv:2505.13938v2 Announce Type: replace-cross 
Abstract: We introduce ${\rm C{\small LEVER}}$, a high-quality, curated benchmark of 161 problems for end-to-end verified code generation in Lean. Each problem consists of (1) the task of generating a specification that matches a held-out ground-truth specification, and (2) the task of generating a Lean implementation that provably satisfies this specification. Unlike prior benchmarks, ${\rm C{\small LEVER}}$ avoids test-case supervision, LLM-generated annotations, and specifications that leak implementation logic or allow vacuous solutions. All outputs are verified post-hoc using Lean's type checker to ensure machine-checkable correctness. We use ${\rm C{\small LEVER}}$ to evaluate several few-shot and agentic approaches based on state-of-the-art language models. These methods all struggle to achieve full verification, establishing it as a challenging frontier benchmark for program synthesis and formal reasoning. Our benchmark can be found on GitHub(https://github.com/trishullab/clever) as well as HuggingFace(https://huggingface.co/datasets/amitayusht/clever). All our evaluation code is also available online(https://github.com/trishullab/clever-prover).</description>
      <guid isPermaLink="false">oai:arXiv.org:2505.13938v2</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Thu, 22 May 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Amitayush Thakur, Jasper Lee, George Tsoukalas, Meghana Sistla, Matthew Zhao, Stefan Zetzsche, Greg Durrett, Yisong Yue, Swarat Chaudhuri</dc:creator>
    </item>
  </channel>
</rss>
