<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.FL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.FL</link>
    <description>cs.FL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.FL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Aug 2024 04:03:20 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 13 Aug 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Parameterized Verification of Systems with Precise (0,1)-Counter Abstraction</title>
      <link>https://arxiv.org/abs/2408.05954</link>
      <description>arXiv:2408.05954v1 Announce Type: new 
Abstract: We introduce a new framework for verifying systems with a parametric number of concurrently running processes. The systems we consider are well-structured with respect to a specific well-quasi order. This allows us to decide a wide range of verification problems, including control-state reachability, coverability, and target, in a fixed finite abstraction of the infinite state-space, called a 01-counter system. We show that several systems from the parameterized verification literature fall into this class, including reconfigurable broadcast networks (or systems with lossy broadcast), disjunctive systems, synchronizations and systems with a fixed number of shared finite-domain variables. Our framework provides a simple and unified explanation for the properties of these systems, which have so far been investigated separately. Additionally, it extends and improves on a range of the existing results, and gives rise to other systems with similar properties.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.05954v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Paul Eichler, Swen Jacobs, Chana Weil-Kennedy</dc:creator>
    </item>
    <item>
      <title>High-order observers and high-order state-estimation-based properties of discrete-event systems</title>
      <link>https://arxiv.org/abs/2408.06141</link>
      <description>arXiv:2408.06141v1 Announce Type: new 
Abstract: State-estimation-based properties are central properties in discrete-event systems modeled by labeled finite-state automata studied over the past 3 decades. Most existing results are based on a single agent who knows the structure of a system and can observe a subset of events and estimate the system's state based on the system's structure and the agent's observation to the system. The main tool used to do state estimation and verify state-estimation-based properties is called \emph{observer} which is the powerset construction originally proposed by Rabin and Scott in 1959, used to determinize a nondeterministic finite automaton with $\varepsilon$-transitions.
  In this paper, we consider labeled finite-state automata, extend the state-estimation-based properties from a single agent to a finite ordered set of agents and also extend the original observer to \emph{high-order observer} based on the original observer and our \emph{concurrent composition}. As a result, a general framework on high-order state-estimation-based properties have been built and a basic tool has also been built to verify such properties. This general framework contains many basic properties as its members such as state-based opacity, critical observability, determinism, high-order opacity, etc. Special cases for which verification can be done more efficiently are also discussed.
  In our general framework, the system's structure is publicly known to all agents $A_1,\dots,A_n$, each agent $A_i$ has its own observable event set $E_i$, and additionally knows all its preceding agents' observable events but can only observe its own observable events. The intuitive meaning of our high-order observer is what agent $A_n$ knows about what $A_{n-1}$ knows about \dots what $A_2$ knows about $A_1$'s state estimate of the system.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.06141v1</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Kuize Zhang, Xiaoguang Han, Alessandro Giua, Carla Seatzu</dc:creator>
    </item>
    <item>
      <title>Constructing Concise Characteristic Samples for Acceptors of Omega Regular Languages</title>
      <link>https://arxiv.org/abs/2209.09336</link>
      <description>arXiv:2209.09336v4 Announce Type: replace 
Abstract: A characteristic sample for a language $L$ and a learning algorithm $\textbf{L}$ is a finite sample of words $T_L$ labeled by their membership in $L$ such that for any sample $T \supseteq T_L$ consistent with $L$, on input $T$ the learning algorithm $\textbf{L}$ returns a hypothesis equivalent to $L$. Which omega automata have characteristic sets of polynomial size, and can these sets be constructed in polynomial time? We address these questions here.
  In brief, non-deterministic omega automata of any of the common types, in particular B\"uchi, do not have characteristic samples of polynomial size. For deterministic omega automata that are isomorphic to their right congruence automata, the fully informative languages, polynomial time algorithms for constructing characteristic samples and learning from them are given.
  The algorithms for constructing characteristic sets in polynomial time for the different omega automata (of types B\"uchi, coB\"uchi, parity, Rabin, Street, or Muller), require deterministic polynomial time algorithms for (1) equivalence of the respective omega automata, and (2) testing membership of the language of the automaton in the informative classes, which we provide.</description>
      <guid isPermaLink="false">oai:arXiv.org:2209.09336v4</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dana Angluin, Dana Fisman</dc:creator>
    </item>
    <item>
      <title>An Elementary Proof of the FMP for Kleene Algebra</title>
      <link>https://arxiv.org/abs/2212.10931</link>
      <description>arXiv:2212.10931v3 Announce Type: replace 
Abstract: Kleene Algebra (KA) is a useful tool for proving that two programs are equivalent. Because KA's equational theory is decidable, it integrates well with interactive theorem provers. This raises the question: which equations can we (not) prove using the laws of KA? Moreover, which models of KA are complete, in the sense that they satisfy exactly the provable equations? Kozen (1994) answered these questions by characterizing KA in terms of its language model. Concretely, equivalences provable in KA are exactly those that hold for regular expressions.
  Pratt (1980) observed that KA is complete w.r.t. relational models, i.e., that its provable equations are those that hold for any relational interpretation. A less known result due to Palka (2005) says that finite models are complete for KA, i.e., that provable equivalences coincide with equations satisfied by all finite KAs. Phrased contrapositively, the latter is a finite model property (FMP): any unprovable equation is falsified by a finite KA. Both results can be argued using Kozen's theorem, but the implication is mutual: given that KA is complete w.r.t. finite (resp. relational) models, Palka's (resp. Pratt's) arguments show that it is complete w.r.t. the language model.
  We embark on a study of the different complete models of KA, and the connections between them. This yields a novel result subsuming those of Palka and Pratt, namely that KA is complete w.r.t. finite relational models. Next, we put an algebraic spin on Palka's techniques, which yield a new elementary proof of the finite model property, and by extension, of Kozen's and Pratt's theorems. In contrast with earlier approaches, this proof relies not on minimality or bisimilarity of automata, but rather on representing the regular expressions involved in terms of transformation automata.</description>
      <guid isPermaLink="false">oai:arXiv.org:2212.10931v3</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Tobias Kapp\'e</dc:creator>
    </item>
    <item>
      <title>A Tree Sampler for Bounded Context-Free Languages</title>
      <link>https://arxiv.org/abs/2408.01849</link>
      <description>arXiv:2408.01849v2 Announce Type: replace 
Abstract: In the following paper, we present a simple method for sampling trees with or without replacement from BCFLs. A BCFL is a context-free language (CFL) corresponding to an incomplete string with holes, which can be completed by valid terminals. To solve this problem, we introduce an algebraic datatype that compactly represents candidate parse forests for porous strings. Once constructed, sampling trees is a straightforward matter of sampling integers uniformly without replacement, then lazily decoding them into trees.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.01849v2</guid>
      <category>cs.FL</category>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Breandan Considine</dc:creator>
    </item>
    <item>
      <title>Cayley Automatic Groups and Numerical Characteristics of Turing Transducers</title>
      <link>https://arxiv.org/abs/1606.08357</link>
      <description>arXiv:1606.08357v2 Announce Type: replace-cross 
Abstract: This paper is devoted to the problem of finding characterizations for Cayley automatic groups. The concept of Cayley automatic groups was recently introduced by Kharlampovich, Khoussainov and Miasnikov. We address this problem by introducing three numerical characteristics of Turing transducers: growth functions, Folner functions and average length growth functions. These three numerical characteristics are the analogs of growth functions, Folner functions and drifts of simple random walks for Cayley graphs of groups. We study these numerical characteristics for Turing transducers obtained from automatic presentations of labeled directed graphs.</description>
      <guid isPermaLink="false">oai:arXiv.org:1606.08357v2</guid>
      <category>math.GR</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1007/978-3-662-53132-7_3</arxiv:DOI>
      <arxiv:journal_reference>Developments in Language Theory 2016, Lecture Notes in Computer Science, V. 9840, pp. 26-37 (2016)</arxiv:journal_reference>
      <dc:creator>Dmitry Berdinsky</dc:creator>
    </item>
    <item>
      <title>Online Monitoring of Metric Temporal Logic using Sequential Networks</title>
      <link>https://arxiv.org/abs/1901.00175</link>
      <description>arXiv:1901.00175v2 Announce Type: replace-cross 
Abstract: Metric Temporal Logic (MTL) is a popular formalism to specify temporal patterns with timing constraints over the behavior of cyber-physical systems with application areas ranging in property-based testing, robotics, optimization, and learning. This paper focuses on the unified construction of sequential networks from MTL specifications over discrete and dense time behaviors to provide an efficient and scalable online monitoring framework. Our core technique, future temporal marking, utilizes interval-based symbolic representations of future discrete and dense timelines. Building upon this, we develop efficient update and output functions for sequential network nodes for timed temporal operations. Finally, we extensively test and compare our proposed technique with existing approaches and runtime verification tools. Results highlight the performance and scalability advantages of our monitoring approach and sequential networks.</description>
      <guid isPermaLink="false">oai:arXiv.org:1901.00175v2</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Dogan Ulus</dc:creator>
    </item>
    <item>
      <title>Formal-LLM: Integrating Formal Language and Natural Language for Controllable LLM-based Agents</title>
      <link>https://arxiv.org/abs/2402.00798</link>
      <description>arXiv:2402.00798v4 Announce Type: replace-cross 
Abstract: Recent advancements on Large Language Models (LLMs) enable AI Agents to automatically generate and execute multi-step plans to solve complex tasks. However, since LLM's content generation process is hardly controllable, current LLM-based agents frequently generate invalid or non-executable plans, which jeopardizes the performance of the generated plans and corrupts users' trust in LLM-based agents. In response, this paper proposes a novel "Formal-LLM" framework for LLM-based agents by integrating the expressiveness of natural language and the precision of formal language. Specifically, the framework allows agent developers to express their requirements or constraints for the planning process as an automaton. A stack-based LLM plan generation process is then conducted under the supervision of the automaton to ensure that the generated plan satisfies the constraints, making the planning process controllable. We conduct experiments on both benchmark tasks and practical real-life tasks, and our framework achieves over 50% overall performance increase, which validates the feasibility and effectiveness of employing Formal-LLM to guide the plan generation of agents, preventing the agents from generating invalid and unsuccessful plans. Further, more controllable LLM-based agents can facilitate the broader utilization of LLM in application scenarios where high validity of planning is essential. The source code of this work is available at https://github.com/agiresearch/Formal-LLM.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.00798v4</guid>
      <category>cs.LG</category>
      <category>cs.AI</category>
      <category>cs.CL</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Zelong Li, Wenyue Hua, Hao Wang, He Zhu, Yongfeng Zhang</dc:creator>
    </item>
    <item>
      <title>Some Remarks on Palindromic Periodicities</title>
      <link>https://arxiv.org/abs/2407.10564</link>
      <description>arXiv:2407.10564v2 Announce Type: replace-cross 
Abstract: We say a finite word $x$ is a palindromic periodicity if there exist two palindromes $p$ and $s$ such that $|x| \geq |ps|$ and $x$ is a prefix of the word $(ps)^\omega = pspsps\cdots$. In this paper we examine the palindromic periodicities occurring in some classical infinite words, such as Sturmian words, episturmian words, the Thue-Morse word, the period-doubling word, the Rudin-Shapiro word, the paperfolding word, and the Tribonacci word, and prove a number of results about them. We also prove results about words with the smallest number of palindromic periodicities.</description>
      <guid isPermaLink="false">oai:arXiv.org:2407.10564v2</guid>
      <category>math.CO</category>
      <category>cs.DM</category>
      <category>cs.FL</category>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Gabriele Fici, Jeffrey Shallit, Jamie Simpson</dc:creator>
    </item>
  </channel>
</rss>
