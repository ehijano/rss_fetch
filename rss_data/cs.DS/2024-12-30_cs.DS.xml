<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.DS updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.DS</link>
    <description>cs.DS updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.DS" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Dec 2024 05:00:04 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Faster Semi-streaming Matchings via Alternating Trees</title>
      <link>https://arxiv.org/abs/2412.19057</link>
      <description>arXiv:2412.19057v1 Announce Type: new 
Abstract: We design a deterministic algorithm for the $(1+\epsilon)$-approximate maximum matching problem. Our primary result demonstrates that this problem can be solved in $O(\epsilon^{-6})$ semi-streaming passes, improving upon the $O(\epsilon^{-19})$ pass-complexity algorithm by [Fischer, Mitrovi\'c, and Uitto, STOC'22]. This contributes substantially toward resolving Open question~2 from [Assadi, SOSA'24]. Leveraging the framework introduced in [FMU'22], our algorithm achieves an analogous round complexity speed-up for computing a $(1+\epsilon)$-approximate maximum matching in both the Massively Parallel Computation (MPC) and CONGEST models.
  The data structures maintained by our algorithm are formulated using blossom notation and represented through alternating trees. This approach enables a simplified correctness analysis by treating specific components as if operating on bipartite graphs, effectively circumventing certain technical intricacies present in prior work.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.19057v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Slobodan Mitrovi\'c, Anish Mukherjee, Piotr Sankowski, Wen-Horng Sheu</dc:creator>
    </item>
    <item>
      <title>A Space Lower Bound for Approximate Membership with Duplicate Insertions or Deletions of Nonelements</title>
      <link>https://arxiv.org/abs/2412.19249</link>
      <description>arXiv:2412.19249v1 Announce Type: new 
Abstract: Designs of data structures for approximate membership queries with false-positive errors that support both insertions and deletions stipulate the following two conditions: (1) Duplicate insertions are prohibited, i.e., it is prohibited to insert an element $x$ if $x$ is currently a member of the dataset. (2) Deletions of nonelements are prohibited, i.e., it is prohibited to delete $x$ if $x$ is not currently a member of the dataset. Under these conditions, the space required for the approximate representation of a datasets of cardinality $n$ with a false-positive probability of $\epsilon^{+}$ is at most $(1+o(1))n\cdot\log_2 (1/\epsilon^{+}) + O(n)$ bits [Bender et al., 2018; Bercea and Even, 2019].
  We prove that if these conditions are lifted, then the space required for the approximate representation of datasets of cardinality $n$ from a universe of cardinality $u$ is at least $\frac 12 \cdot (1-\epsilon^{+} -\frac 1n)\cdot \log \binom{u}{n} -O(n)$ bits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.19249v1</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Aryan Agarwala, Guy Even</dc:creator>
    </item>
    <item>
      <title>A Matrix Logic Approach to Efficient Frequent Itemset Discovery in Large Data Sets</title>
      <link>https://arxiv.org/abs/2412.19420</link>
      <description>arXiv:2412.19420v1 Announce Type: cross 
Abstract: This paper proposes a frequent itemset mining algorithm based on the Boolean matrix method, aiming to solve the storage and computational bottlenecks of traditional frequent pattern mining algorithms in high-dimensional and large-scale transaction databases. By representing the itemsets in the transaction database as Boolean matrices, the algorithm uses Boolean logic operations such as AND and OR to efficiently calculate the support of the itemsets, avoiding the generation and storage of a large number of candidates itemsets in traditional algorithms. The algorithm recursively mines frequent itemsets through matrix operations and can flexibly adapt to different data scales and support thresholds. In the experiment, the public Groceries dataset was selected, and the running efficiency test and frequent itemset mining effect test were designed to evaluate the algorithm's performance indicators such as running time, memory usage, and number of frequent itemsets under different transaction numbers and support thresholds. The experimental results show that the algorithm can efficiently mine a large number of frequent itemsets when the support threshold is low, and focus on strong association rules with high support when the threshold is high. In addition, the changing trends of running time and memory usage show that the Boolean matrix method can still maintain good running efficiency when the number of transactions increases significantly and has high scalability and robustness. Future research can improve memory optimization and matrix block operations, and combine distributed computing and deep learning models to further enhance the algorithm's applicability and real-time processing capabilities in ultra-large-scale data environments. The algorithm has broad application potential and development prospects in the fields of market analysis, recommendation systems, and network security.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.19420v1</guid>
      <category>cs.DB</category>
      <category>cs.DS</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Xuan Li, Tingyi Ruan, Yankaiqi Li, Quanchao Lu, Xiaoxuan Sun</dc:creator>
    </item>
    <item>
      <title>Distributed Download from an External Data Source in Faulty Majority Settings</title>
      <link>https://arxiv.org/abs/2412.19649</link>
      <description>arXiv:2412.19649v1 Announce Type: cross 
Abstract: We extend the study of retrieval problems in distributed networks, focusing on improving the efficiency and resilience of protocols in the \emph{Data Retrieval (DR) Model}. The DR Model consists of a complete network (i.e., a clique) with $k$ peers, up to $\beta k$ of which may be Byzantine (for $\beta \in [0, 1)$), and a trusted \emph{External Data Source} comprising an array $X$ of $n$ bits ($n \gg k$) that the peers can query. Additionally, the peers can also send messages to each other. In this work, we focus on the Download problem that requires all peers to learn $X$. Our primary goal is to minimize the maximum number of queries made by any honest peer and additionally optimize time.
  We begin with a randomized algorithm for the Download problem that achieves optimal query complexity up to a logarithmic factor. For the stronger dynamic adversary that can change the set of Byzantine peers from one round to the next, we achieve the optimal time complexity in peer-to-peer communication but with larger messages. In broadcast communication where all peers (including Byzantine peers) are required to send the same message to all peers, with larger messages, we achieve almost optimal time and query complexities for a dynamic adversary. Finally, in a more relaxed crash fault model, where peers stop responding after crashing, we address the Download problem in both synchronous and asynchronous settings. Using a deterministic protocol, we obtain nearly optimal results for both query complexity and message sizes in these scenarios.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.19649v1</guid>
      <category>cs.DC</category>
      <category>cs.DS</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>John Augustine, Soumyottam Chatterjee, Valerie King, Manish Kumar, Shachar Meir, David Peleg</dc:creator>
    </item>
    <item>
      <title>The Online Submodular Assignment Problem</title>
      <link>https://arxiv.org/abs/2401.06981</link>
      <description>arXiv:2401.06981v2 Announce Type: replace 
Abstract: Online resource allocation is a rich and varied field. One of the most well-known problems in this area is online bipartite matching, introduced in 1990 by Karp, Vazirani, and Vazirani [KVV90]. Since then, many variants have been studied, including AdWords, the generalized assignment problem (GAP), and online submodular welfare maximization.
  In this paper, we introduce a generalization of GAP which we call the submodular assignment problem (SAP). This generalization captures many online assignment problems, including all classical online bipartite matching problems as well as broader online combinatorial optimization problems such as online arboricity, flow scheduling, and laminar restricted allocations. We present a fractional algorithm for online SAP that is $(1-\frac{1}{e})$-competitive.
  Additionally, we study several integral special cases of the problem. In particular, we provide a $(1-\frac{1}{e}-\epsilon)$-competitive integral algorithm under a small-bids assumption, and a $(1-\frac{1}{e})$-competitive integral algorithm for online submodular welfare maximization where the utility functions are given by rank functions of matroids.
  The key new ingredient for our results is the construction and structural analysis of a "water level" vector for polymatroids, which allows us to generalize the classic water-filling paradigm used in online matching problems. This construction reveals connections to submodular utility allocation markets and principal partition sequences of matroids.</description>
      <guid isPermaLink="false">oai:arXiv.org:2401.06981v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Daniel Hathcock, Billy Jin, Kalen Patton, Sherry Sarkar, Michael Zlatin</dc:creator>
    </item>
    <item>
      <title>Obstacle-Free Path Planning for Autonomous Drones Using Floyd Algorithm</title>
      <link>https://arxiv.org/abs/2409.13149</link>
      <description>arXiv:2409.13149v2 Announce Type: replace 
Abstract: This research investigates the efficiency of Floyd algorithm for obstacle-free path planning for autonomous aerial vehicles (UAVs) or drones. Floyd algorithm is used to generate the shortest paths for UAVs to fly from any place to the destination in a large-scale field with obstacles which UAVs cannot fly over. The simulation results demonstrated that Floyd algorithm effectively plans the shortest obstacle-free paths for UAVs to fly to a destination. It is verified that Floyd algorithm holds a time complexity of O(n3). This research revealed a correlation of a cubic polynomial relationship between the time cost and the size of the field, no correlation between the time cost and the number of obstacles, and no correlation between the time cost and the number of UAVs in the tested field. The applications of the research results are discussed in the paper as well.</description>
      <guid isPermaLink="false">oai:arXiv.org:2409.13149v2</guid>
      <category>cs.DS</category>
      <category>cs.RO</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Edward Yao</dc:creator>
    </item>
    <item>
      <title>Optimal Capacity Modification for Stable Matchings with Ties</title>
      <link>https://arxiv.org/abs/2411.10284</link>
      <description>arXiv:2411.10284v2 Announce Type: replace 
Abstract: We consider the Hospital/Residents (HR) problem in the presence of ties in preference lists. Among the three notions of stability, viz. weak, strong, and super stability, we focus on the notion of strong stability. Strong stability has many desirable properties, both theoretically and practically; however, its existence is not guaranteed.
  In this paper, our objective is to optimally increase the quotas of hospitals to ensure that a strongly stable matching exists in the modified instance. First, we show that if ties are allowed in residents' preference lists, it may not be possible to augment the hospital quotas to obtain an instance that admits a strongly stable matching. When residents' preference lists are strict, we explore two natural optimization criteria: (i) minimizing the total capacity increase across all hospitals (MINSUM) and (ii) minimizing the maximum capacity increase for any hospital (MINMAX). We show that the MINSUM problem admits a poly-time algorithm. However, when each hospital incurs a cost for each capacity increase, the problem becomes NP-hard, even if the costs are 0 or 1. This implies that the problem cannot be approximated to any multiplicative factor. We also consider a related problem under the MINSUM objective. Given an HR instance and a forced pair $(r^*,h^*)$, the goal is to decide if it is possible to increase hospital quotas (if necessary) to obtain a strongly stable matching that matches the pair $(r^*,h^*)$. We show a poly-time algorithm for this problem.
  We show that the MINMAX problem is NP-hard in general. When hospital preference lists have ties of length at most $\ell+1$, we give a poly-time algorithm that increases each hospital's quota by at most $\ell$. Amongst all instances obtained by at most $\ell$ augmentations per hospital, our algorithm produces a strongly stable matching that is best for residents.</description>
      <guid isPermaLink="false">oai:arXiv.org:2411.10284v2</guid>
      <category>cs.DS</category>
      <category>cs.GT</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Keshav Ranjan, Meghana Nasre, Prajakta Nimbhorkar</dc:creator>
    </item>
    <item>
      <title>Efficient Fault-Tolerant Search by Fast Indexing of Subnetworks</title>
      <link>https://arxiv.org/abs/2412.17776</link>
      <description>arXiv:2412.17776v2 Announce Type: replace 
Abstract: We design sensitivity oracles for error-prone networks. For a network problem $\Pi$, the data structure preprocesses a network $G=(V,E)$ and sensitivity parameter $f$ such that, for any set $F\subseteq V\cup E$ of up to $f$ link or node failures, it can report a solution for $\Pi$ in $G{-}F$. We study three network problems $\Pi$. $L$-Hop Shortest Path: Given $s,t \in V$, is there a shortest $s$-$t$-path in $G-F$ with at most $L$ links? $k$-Path: Does $G-F$ contain a simple path with $k$ links? $k$-Clique: Does $G-F$ contain a clique of $k$ nodes? Our main technical contribution is a new construction of $(L,f)$-replacement path coverings ($(L,f)$-RPC) in the parameter realm where $f = o(\log L)$. An $(L,f)$-RPC is a family $\mathcal{G}$ of subnetworks of $G$ which, for every $F \subseteq E$ with $|F| \le f$, contain a subfamily $\mathcal{G}_F \subseteq \mathcal{G}$ such that (i) no subnetwork in $\mathcal{G}_F$ contains a link of $F$ and (ii) for each $s,t \in V$, if $G-F$ contains a shortest $s$-$t$-path with at most $L$ links, then some subnetwork in $\mathcal{G}_F$ retains at least one such path. Our $(L, f)$-RPC has almost the same size as the one by Weimann and Yuster [ACM TALG 2013] but it improves the time to query $\mathcal{G}_F$ from $\widetilde{O}(f^2L^f)$ to $\widetilde{O}(f^{\frac{5}{2}} L^{o(1)})$. It also improves over the size and query time of the $(L,f)$-RPC by Karthik and Parter [SODA 2021] by nearly a factor of $L$. We then derive oracles for $L$-Hop Shortest Path, $k$-Path, and $k$-Clique from this. Notably, our solution for $k$-Path improves the query time of the one by Bil\`o, et al. [ITCS 2022] for $f=o(\log k)$.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.17776v2</guid>
      <category>cs.DS</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Davide Bil\`o, Keerti Choudhary, Sarel Cohen, Tobias Friedrich, Martin Schirneck</dc:creator>
    </item>
    <item>
      <title>Convergence analysis of wide shallow neural operators within the framework of Neural Tangent Kernel</title>
      <link>https://arxiv.org/abs/2412.05545</link>
      <description>arXiv:2412.05545v2 Announce Type: replace-cross 
Abstract: Neural operators are aiming at approximating operators mapping between Banach spaces of functions, achieving much success in the field of scientific computing. Compared to certain deep learning-based solvers, such as Physics-Informed Neural Networks (PINNs), Deep Ritz Method (DRM), neural operators can solve a class of Partial Differential Equations (PDEs). Although much work has been done to analyze the approximation and generalization error of neural operators, there is still a lack of analysis on their training error. In this work, we conduct the convergence analysis of gradient descent for the wide shallow neural operators within the framework of Neural Tangent Kernel (NTK). The core idea lies on the fact that over-parameterization and random initialization together ensure that each weight vector remains near its initialization throughout all iterations, yielding the linear convergence of gradient descent. In this work, we demonstrate that under the setting of over-parametrization, gradient descent can find the global minimum regardless of whether it is in continuous time or discrete time. Finally, we briefly discuss the case of physics-informed shallow neural operators.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.05545v2</guid>
      <category>cs.LG</category>
      <category>cs.DS</category>
      <category>math.OC</category>
      <pubDate>Mon, 30 Dec 2024 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Xianliang Xu, Ye Li, Zhongyi Huang</dc:creator>
    </item>
  </channel>
</rss>
