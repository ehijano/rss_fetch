<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2024 01:34:15 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 29 Aug 2024 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Unifying Model Execution and Deductive Verification with Interaction Trees in Isabelle/HOL</title>
      <link>https://arxiv.org/abs/2408.15817</link>
      <description>arXiv:2408.15817v1 Announce Type: new 
Abstract: Model execution allows us to prototype and analyse software engineering models by stepping through their possible behaviours, using techniques like animation and simulation. On the other hand, deductive verification allows us to construct formal proofs demonstrating satisfaction of certain critical properties in support of high-assurance software engineering. To ensure coherent results between execution and proof, we need unifying semantics and automation. In this paper, we mechanise Interaction Trees (ITrees) in Isabelle/HOL to produce an execution and verification framework. ITrees are coinductive structures that allow us to encode infinite labelled transition systems, yet they are inherently executable. We use ITrees to create verification tools for stateful imperative programs, concurrent programs with message passing in the form of the CSP and \Circus languages, and abstract system models in the style of the Z and B methods. We demonstrate how ITrees can account for diverse semantic presentations, such as structural operational semantics, a relational program model, and CSP's failures-divergences trace model. Finally, we demonstrate how ITrees can be executed using the Isabelle code generator to support the animation of models.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.15817v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 29 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Simon Foster, Chung-Kil Hur, Jim Woodcock</dc:creator>
    </item>
    <item>
      <title>Verifying Solutions to Semantics-Guided Synthesis Problems</title>
      <link>https://arxiv.org/abs/2408.15475</link>
      <description>arXiv:2408.15475v1 Announce Type: cross 
Abstract: Semantics-Guided Synthesis (SemGuS) provides a framework to specify synthesis problems in a solver-agnostic and domain-agnostic way, by allowing a user to provide both the syntax and semantics of the language in which the desired program should be synthesized. Because synthesis and verification are closely intertwined, the SemGuS framework raises the problem of how to verify programs in a solver and domain-agnostic way.
  We prove that the problem of verifying whether a program is a valid solution to a SemGuS problem can be reduced to proving validity of a query in the `CLP calculus, a fixed-point logic that generalizes Constrained Horn Clauses and co-Constrained Horn Clauses. Our encoding into `CLP allows us to further classify the SemGuS verification problems into ones that are reducible to validity of (i) first-order-logic formulas, (ii) Constrained Horn Clauses, (iii) co-Constrained Horn Clauses, and (iv) `CLP queries. Furthermore, our encoding shines light on some limitations of the SemGuS framework, such as its inability to model nondeterminism and reactive synthesis. We thus propose a modification to SemGuS that makes it more expressive, and for which verifying solutions is exactly equivalent to proving validity of a query in the `CLP calculus. Our implementation of SemGuS verifiers based on the above encoding can verify instances that were not even encodable in previous work. Furthermore, we use our SemGuS verifiers within an enumeration-based SemGuS solver to correctly synthesize solutions to SemGuS problems that no previous SemGuS synthesizer could solve.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.15475v1</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 29 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Charlie Murphy, Keith Johnson, Thomas Reps, Loris D'Antoni</dc:creator>
    </item>
    <item>
      <title>Weak Distributive Laws between Monads of Continuous Valuations and of Non-Deterministic Choice</title>
      <link>https://arxiv.org/abs/2408.15977</link>
      <description>arXiv:2408.15977v2 Announce Type: cross 
Abstract: We show that there is weak distributive law of the Smyth hyperspace monad $\mathcal Q_{\mathsf V}$ (resp., the Hoare hyperspace monad $\mathcal H_{\mathsf V}$, resp. the monad $\mathcal P\ell^{\mathrm q}_{\mathsf V}$ of quasi-lenses, resp. the monad $\mathcal P\ell_{\mathsf V}$ of lenses) over the continuous valuation monad $\mathbf V$, as well as over the subprobability valuation monad $\mathbf V_{\leq 1}$ and the probability valuation monad $\mathbf V_1$, on the whole category $\mathbf{Top}$ of topological spaces (resp., on certain full subcategories such as the category of locally compact spaces or of stably compact spaces). We show that the resulting weak composite monad is the author's monad of superlinear previsions (resp., sublinear previsions, resp. forks), possibly subnormalized or normalized depending on whether we consider $\mathbf V_{\leq 1}$ or $\mathbf V_1$ instead of $\mathbf V$. As a special case, we obtain a weak distributive law of the monad $\mathcal P\ell^{\mathrm q}_{\mathsf V} \cong \mathcal P\ell_{\mathsf V}$ over the monad of (sub)probability Radon measures $\mathbf R_\bullet$ on the category of stably compact spaces, which specializes further to a weak distributive laws of the Vietoris monad over $\mathbf R_\bullet$. The associated weak composite monad is the monad of (sub)normalized forks.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.15977v2</guid>
      <category>math.CT</category>
      <category>cs.LO</category>
      <category>math.GN</category>
      <category>math.PR</category>
      <pubDate>Thu, 29 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Jean Goubault-Larrecq</dc:creator>
    </item>
    <item>
      <title>Proving Confluence in the Confluence Framework with CONFident</title>
      <link>https://arxiv.org/abs/2306.16330</link>
      <description>arXiv:2306.16330v3 Announce Type: replace 
Abstract: This article describes the *Confluence Framework*, a novel framework for proving and disproving confluence using a divide-and-conquer modular strategy, and its implementation in CONFident. Using this approach, we are able to automatically prove and disprove confluence of *Generalized Term Rewriting Systems*, where (i) only selected arguments of function symbols can be rewritten and (ii) a rather general class of conditional rules can be used. This includes, as particular cases, several variants of rewrite systems such as (context-sensitive) *term rewriting systems*, *string rewriting systems*, and (context-sensitive) *conditional term rewriting systems*. The divide-and-conquer modular strategy allows us to combine in a proof tree different techniques for proving confluence, including modular decompositions, checking joinability of (conditional) critical and variable pairs, transformations, etc., and auxiliary tasks required by them, e.g., joinability of terms, joinability of conditional pairs, etc.</description>
      <guid isPermaLink="false">oai:arXiv.org:2306.16330v3</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 29 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ra\'ul Guti\'errez, Salvador Lucas, Miguel V\'itores</dc:creator>
    </item>
    <item>
      <title>Half-Positional Objectives Recognized by Deterministic B\"uchi Automata</title>
      <link>https://arxiv.org/abs/2205.01365</link>
      <description>arXiv:2205.01365v5 Announce Type: replace-cross 
Abstract: In two-player games on graphs, the simplest possible strategies are those that can be implemented without any memory. These are called positional strategies. In this paper, we characterize objectives recognizable by deterministic B\"uchi automata (a subclass of omega-regular objectives) that are half-positional, that is, for which the protagonist can always play optimally using positional strategies (both over finite and infinite graphs). Our characterization consists of three natural conditions linked to the language-theoretic notion of right congruence. Furthermore, this characterization yields a polynomial-time algorithm to decide half-positionality of an objective recognized by a given deterministic B\"uchi automaton.</description>
      <guid isPermaLink="false">oai:arXiv.org:2205.01365v5</guid>
      <category>cs.GT</category>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 29 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Patricia Bouyer, Antonio Casares, Mickael Randour, Pierre Vandenhove</dc:creator>
    </item>
    <item>
      <title>Procedural Adherence and Interpretability Through Neuro-Symbolic Generative Agents</title>
      <link>https://arxiv.org/abs/2402.16905</link>
      <description>arXiv:2402.16905v2 Announce Type: replace-cross 
Abstract: The surge in popularity of large language models (LLMs) has opened doors for new approaches to the creation of interactive agents. However, managing and interpreting the temporal behavior of such agents over the course of a potentially infinite interaction remain challenging. The stateful, long-term horizon reasoning required for coherent agent behavior does not fit well into the LLM paradigm. We propose a combination of formal logic-based program synthesis and LLM content generation to bring guarantees of procedural adherence and interpretability to generative agent behavior. To illustrate the benefit of procedural adherence and interpretability, we use Temporal Stream Logic (TSL) to generate an automaton that enforces an interpretable, high-level temporal structure on an agent. With the automaton tracking the context of the interaction and making decisions to guide the conversation accordingly, we can drive content generation in a way that allows the LLM to focus on a shorter context window. We evaluated our approach on different tasks involved in creating an interactive agent specialized for generating choose-your-own-adventure games. We found that over all of the tasks, an automaton-enhanced agent with procedural guarantees achieves at least 96% adherence to its temporal constraints, whereas a purely LLM-based agent demonstrates as low as 14.67% adherence.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.16905v2</guid>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Thu, 29 Aug 2024 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Raven Rothkopf, Hannah Tongxin Zeng, Mark Santolucito</dc:creator>
    </item>
  </channel>
</rss>
