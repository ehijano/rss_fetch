<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Mar 2025 01:47:28 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Categorical Semantics of Higher-Order Message Passing</title>
      <link>https://arxiv.org/abs/2503.19305</link>
      <description>arXiv:2503.19305v1 Announce Type: new 
Abstract: The Categorical Message Passing Language (CaMPL) is a concurrent programming language with a categorical semantics based on a linear actegory. CaMPL has a sequential and a concurrent side. The sequential side is a functional-style programming language which has a linear actegorical action on the concurrent side to produce a semantics for message passing. Concurrent processes in CaMPL talk to each other along typed channels (or protocols). The typed channels of each CaMPL process are split into input and output polarity channels, allowing processes to be plugged together by connecting an output polarity channel of one process to an input polarity channel of another (provided the channels are of the same protocol). Channel polarities can be flipped input to output with a linear logic-style negation. A desirable feature of a concurrent message-passing language, such as CaMPL, is that it should support higher-order processes. This allows processes to be passed as first-class citizens between processes. While the ability to pass concurrent processes is already present in any closed linear type system-such as CaMPL's-supporting arbitrary recursive process definitions requires reusing passed processes. Concurrent resources in CaMPL cannot be duplicated, thus, passing processes as linear closures does not provide the required flexibility. Instead, processes must be passed as sequential data, and the concurrent side must be enriched in the sequential side. This paper concerns the categorical semantics that lets us store concurrent processes as sequential data and yet use them. Abstractly, this is given by the equivalence between an actegory with hom-objects and an enriched category with copowers. In the closed symmetric case, this was studied by Kelly and Janelidze. Here, we present the proof of this equivalence for the non-symmetric, non-closed case in detail.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19305v1</guid>
      <category>cs.PL</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Robin Cockett, Melika Norouzbeygi</dc:creator>
    </item>
    <item>
      <title>Nanopass Back-Translation of Call-Return Trees for Mechanized Secure Compilation Proofs</title>
      <link>https://arxiv.org/abs/2503.19609</link>
      <description>arXiv:2503.19609v1 Announce Type: new 
Abstract: Researchers aim to build secure compilation chains enforcing that if there is no attack a source context can mount against a source program then there is also no attack an adversarial target context can mount against the compiled program. Proving that these compilation chains are secure is, however, challenging, and involves a non-trivial back-translation step: for any attack a target context mounts against the compiled program one has to exhibit a source context mounting the same attack against the source program. We describe a novel back-translation technique, which results in simpler proofs that can be more easily mechanized in a proof assistant. Given a finite set of finite trace prefixes, capturing the interaction recorded during an attack between a target context and the compiled program, we build a call-return tree that we back-translate into a source context producing the same trace prefixes. We use state in the generated source context to record the current location in the call-return tree. The back-translation is done in several small steps, each adding to the tree new information describing how the location should change depending on how the context regains control. To prove this back-translation correct we give semantics to every intermediate call-return tree language, using ghost state to store information and explicitly enforce execution invariants. We prove several small forward simulations, basically seeing the back-translation as a verified nanopass compiler. Thanks to this modular structure, we are able to mechanize this complex back-translation and its correctness proof in the Rocq prover without too much effort.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19609v1</guid>
      <category>cs.PL</category>
      <category>cs.CR</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>J\'er\'emy Thibault, Joseph Lenormand, Catalin Hritcu</dc:creator>
    </item>
    <item>
      <title>Fail Faster: Staging and Fast Randomness for High-Performance PBT</title>
      <link>https://arxiv.org/abs/2503.19797</link>
      <description>arXiv:2503.19797v1 Announce Type: new 
Abstract: Property-based testing (PBT) relies on generators for random test cases, often constructed using embedded domain specific languages, which provide expressive combinators for building and composing generators. The effectiveness of PBT depends critically on the speed of these generators. However, careful measurements show that the generator performance of widely used PBT libraries falls well short of what is possible, due principally to (1) the abstraction overhead of their combinator-heavy style and (2) suboptimal sources of randomness. We characterize, quantify, and address these bottlenecks.
  To eliminate abstraction overheads, we propose a technique based on multi-stage programming, dubbed Allegro. We apply this technique to leading generator libraries in OCaml and Scala 3, significantly improving performance. To quantify the performance impact of the randomness source, we carry out a controlled experiment, replacing the randomness in the OCaml PBT library with an optimized version. Both interventions exactly preserve the semantics of generators, enabling precise, pointwise comparisons. Together, these improvements find bugs up to $13\times$ faster.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19797v1</guid>
      <category>cs.PL</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Cynthia Richey, Joseph W. Cutler, Harrison Goldstein, Benjamin C. Pierce</dc:creator>
    </item>
    <item>
      <title>Anvil: A General-Purpose Timing-Safe Hardware Description Language</title>
      <link>https://arxiv.org/abs/2503.19447</link>
      <description>arXiv:2503.19447v1 Announce Type: cross 
Abstract: Hardware designs routinely use stateless signals which change with their underlying registers. Unintended behaviours arise when a register is mutated even when its dependent signals are expected to remain stable (unchanged). Such timing hazards are common because, with a few exceptions, existing HDLs lack the abstraction for stable values and delegate this responsibility to hardware designers, who then have to carefully decide whether a value remains unchanged, sometimes even across hardware modules. This paper proposes Anvil, an HDL which statically prevents timing hazards with a novel type system. Anvil is the only HDL we know of that guarantees timing safety without sacrificing expressiveness for cycle-level timing control or dynamic timing behaviours. Instead of abstracting away differences between registers and signals, Anvil's type system exposes them fully but captures timing relationships between register mutations and signal usages for enforcing timing safety. This, in turn, enables safe composition of communicating hardware modules by static enforcement of timing contracts that encode timing constraints on shared signals. Such timing contracts can be specified parametric on abstract time points that can vary during run-time, allowing the type system to statically express dynamic timing behaviour. We have implemented Anvil and successfully used it for implementing key timing-sensitive modules in an open-source RISC-V CPU, which demonstrates its expressiveness and practicality.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19447v1</guid>
      <category>cs.AR</category>
      <category>cs.PL</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Jason Zhijingcheng Yu, Aditya Ranjan Jha, Umang Mathur, Trevor E. Carlson, Prateek Saxena</dc:creator>
    </item>
    <item>
      <title>Proceedings of the Fourteenth and Fifteenth International Workshop on Graph Computation Models</title>
      <link>https://arxiv.org/abs/2503.19632</link>
      <description>arXiv:2503.19632v1 Announce Type: cross 
Abstract: This volume contains the post-proceedings of the Fourteenth and the Fifteenth International Workshops on Graph Computation Models (GCM 2023 and 2024). The workshops took place in Leicester, UK on 18th July 2023 and Enschede, the Netherlands on 9th July 2024, in each case as part of STAF (Software Technologies: Applications and Foundations). 
  Graphs are common mathematical structures that are visual and intuitive. They constitute a natural and seamless way for system modeling in science, engineering, and beyond, including computer science, biology, and business process modeling. Graph computation models constitute a class of very high-level models where graphs are first-class citizens. The aim of the International GCM Workshop series is to bring together researchers interested in all aspects of computation models based on graphs and graph transformation. It promotes the cross-fertilizing exchange of ideas and experiences among senior and young researchers from the different communities interested in the foundations, applications, and implementations of graph computation models and related areas. </description>
      <guid isPermaLink="false">oai:arXiv.org:2503.19632v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.4204/EPTCS.417</arxiv:DOI>
      <arxiv:journal_reference>EPTCS 417, 2025</arxiv:journal_reference>
      <dc:creator>J\"org Endrullis, Dominik Grzelak, Tobias Heindel, Jens Kosiol</dc:creator>
    </item>
    <item>
      <title>Structural temporal logic for mechanized program verification</title>
      <link>https://arxiv.org/abs/2410.14906</link>
      <description>arXiv:2410.14906v5 Announce Type: replace 
Abstract: Mechanized verification of liveness properties for infinite programs with effects and nondeterminism is challenging. Existing temporal reasoning frameworks operate at the level of models such as traces and automata. Reasoning happens at a very low-level, requiring complex nested (co-)inductive proof techniques and familiarity with proof assistant mechanics (e.g., the guardedness checker). Further, reasoning at the level of models instead of program constructs creates a verification gap that loses the benefits of modularity and composition enjoyed by structural program logics such as Hoare Logic. To address this verification gap, and the lack of compositional proof techniques for temporal specifications, we propose Ticl, a new structural temporal logic. Using ticl, we encode complex (co-)inductive proof techniques as structural lemmas and focus our reasoning on variants and invariants. We show that it is possible to perform compositional proofs of general temporal properties in a proof assistant, while working at a high level of abstraction. We demonstrate the benefits of Ticl by giving mechanized proofs of safety and liveness properties for programs with scheduling, concurrent shared memory, and distributed consensus, demonstrating a low proof-to-code ratio.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.14906v5</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Eleftherios Ioannidis, Yannick Zakowski, Steve Zdancewic, Sebastian Angel</dc:creator>
    </item>
    <item>
      <title>Linearization via Rewriting (Long Version)</title>
      <link>https://arxiv.org/abs/2503.04408</link>
      <description>arXiv:2503.04408v2 Announce Type: replace-cross 
Abstract: We introduce the structural resource lambda-calculus, a new formalism in which strongly normalizing terms of the lambda-calculus can naturally be represented, and at the same time any type derivation can be internally rewritten to its linearization. The calculus is shown to be normalizing and confluent. Noticeably, every strongly normalizable lambda-term can be represented by a type derivation. This is the first example of a system where the linearization process takes place internally, while remaining purely finitary and rewrite-based.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.04408v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Wed, 26 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ugo Dal Lago, Federico Olimpieri</dc:creator>
    </item>
  </channel>
</rss>
