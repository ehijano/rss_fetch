<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.CC updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.CC</link>
    <description>cs.CC updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.CC" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Mar 2025 15:12:36 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Minimum cost flow decomposition on arc-coloured networks</title>
      <link>https://arxiv.org/abs/2503.05895</link>
      <description>arXiv:2503.05895v1 Announce Type: new 
Abstract: A network $\mathcal{N}$ is formed by a (multi)digraph $D$ together with a \emph{capacity function} $u : A(D) \to R_+$, and it is denoted by $\mathcal{N} = (D,u)$. A flow on $\mathcal{N}$ is a function $x: A(D) \to R_+$ such that $x(a) \leq u(a)$ for all $a \in A(D)$, and it is said to be $k$-splittable if it can be decomposed into up to $k$ paths. We say that a flow is $\lambda$-uniform if its value on each arc of the network with positive flow value is exactly $\lambda$, for some $\lambda \in R_+^*$.
  Arc-coloured networks are used to model qualitative differences among different regions through which the flow will be sent. They have applications in several areas such as communication networks, multimodal transportation, molecular biology, packing etc.
  We consider the problem of decomposing a flow over an arc-coloured network with minimum cost, that is, with minimum sum of the cost of its paths, where the cost of each path is given by its number of colours. We show that this problem is NP-Hard for general flows. When we restrict the problem to $\lambda$-uniform flows, we show that it can be solved in polynomial time for networks with at most two colours, and it is NP-Hard for general networks with three colours and for acyclic networks with at least five colours.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05895v1</guid>
      <category>cs.CC</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Claudio Carvalho Neto, Ana Karolinna Maia, Cl\'audia Linhares Sales, Jonas Costa Ferreira da Silva</dc:creator>
    </item>
    <item>
      <title>On the complexity of solving equations over the symmetric group $S_4$</title>
      <link>https://arxiv.org/abs/2503.07285</link>
      <description>arXiv:2503.07285v1 Announce Type: new 
Abstract: The complexity of solving equations over finite groups has been an active area of research over the last two decades, starting with Goldmann and Russell, \emph{The complexity of solving equations over finite groups} from 1999. One important case of a group with unknown complexity is the symmetric group $S_4.$ In 2023, Idziak, Kawa{\l}ek, and Krzaczkowski published $\exp(\Omega(\log^2 n))$ lower bounds for the satisfiability and equivalence problems over $S_4$ under the Exponential Time Hypothesis. In the present note, we prove that the satisfiability problem $\textsc{PolSat}(S_4)$ can be reduced to the equivalence problem $\textsc{PolEqv}(S_4)$ and thus, the two problems have the same complexity. We provide several equivalent formulations of the problem. In particular, we prove that $\textsc{PolEqv}(S_4)$ is equivalent to the circuit equivalence problem for $\operatorname{CC}[2,3,2]$-circuits, which were introduced by Idziak, Kawe{\l}ek and Krzaczkowski. Under their strong exponential size hypothesis, such circuits cannot compute $\operatorname{AND}_n$ in size $\exp(o(\sqrt{n})).$ Our results provide an upper bound on the complexity of $\textsc{PolEqv}(S_4)$ that is based on the minimal size of $\operatorname{AND}_n$ over $\operatorname{CC}[2,3,2]$-circuits.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.07285v1</guid>
      <category>cs.CC</category>
      <category>math.RA</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Erhard Aichinger, Simon Gr\"unbacher</dc:creator>
    </item>
    <item>
      <title>Improving Merge Sort and Quick Sort Performance by Utilizing Alphadev's Sorting Networks as Base Cases</title>
      <link>https://arxiv.org/abs/2503.05934</link>
      <description>arXiv:2503.05934v1 Announce Type: cross 
Abstract: Recent work by Google DeepMind introduced assembly-optimized sorting networks that achieve faster performance for small fixed-size arrays (3-8). In this research, we investigate the integration of these networks as base cases in classical divide-and-conquer sorting algorithms, specifically Merge Sort and Quick Sort, to leverage these efficient sorting networks for small subarrays generated during the recursive process. We conducted benchmarks with 11 different optimization configurations and compared them to classical Merge Sort and Quick Sort. We tested the configurations with random, sorted and nearly sorted arrays.
  Our optimized Merge Sort, using a configuration of three sorting networks (sizes 6, 7, and 8), achieves at least 1.5x speedup for random and nearly sorted arrays, and at least 2x speedup for sorted arrays, in comparison to classical Merge Sort. This optimized Merge Sort surpasses both classical Quick Sort and similarly optimized Quick Sort variants when sorting random arrays of size 10,000 and larger.
  When comparing our optimized Quick Sort to classical Quick Sort, we observe a 1.5x speedup using the 3-to-5 configuration on sorted arrays of size 10,000. The 6-to-8 configuration maintains a consistent 1.5x improvement across sorted arrays from 25,000 to 1 million elements. Our findings demonstrate the potential of integrating AI-optimized sorting networks to enhance the performance of classical sorting algorithms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.05934v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Anas Gamal Aly, Anders E. Jensen, Hala ElAarag</dc:creator>
    </item>
    <item>
      <title>Encoding Co-Lex Orders of Finite-State Automata in Linear Space</title>
      <link>https://arxiv.org/abs/2503.07061</link>
      <description>arXiv:2503.07061v1 Announce Type: cross 
Abstract: The Burrows-Wheeler transform (BWT) is a string transformation that enhances string indexing and compressibility. Cotumaccio and Prezza [SODA '21] extended this transformation to nondeterministic finite automata (NFAs) through co-lexicographic partial orders, i.e., by sorting the states of an NFA according to the co-lexicographic order of the strings reaching them. As the BWT of an NFA shares many properties with its original string variant, the transformation can be used to implement indices for locating specific patterns on the NFA itself. The efficiency of the resulting index is influenced by the width of the partial order on the states: the smaller the width, the faster the index. The most efficient index for arbitrary NFAs currently known in the literature is based on the coarsest forward-stable co-lex (CFS) order of Becker et al. [SPIRE '24]. In this paper, we prove that this CFS order can be encoded within linear space in the number of states in the automaton. The importance of this result stems from the fact that encoding such an order in linear space represents a big first step in the direction of building the index based on this order in near-linear time -- the biggest open research question in this context. The currently most efficient known algorithm for this task run in quadratic time in the number of transitions in the NFA and are thus infeasible to be run on very large graphs (e.g., pangenome graphs). At this point, a near-linear time algorithm is solely known for the simpler case of deterministic automata [Becker et al., ESA '23] and, in fact, this algorithmic result was enabled by a linear space encoding for deterministic automata [Kim et al., CPM '23].</description>
      <guid isPermaLink="false">oai:arXiv.org:2503.07061v1</guid>
      <category>cs.DS</category>
      <category>cs.CC</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Ruben Becker, Nicola Cotumaccio, Sung-Hwan Kim, Nicola Prezza, Carlo Tosoni</dc:creator>
    </item>
    <item>
      <title>Proof complexity of positive branching programs</title>
      <link>https://arxiv.org/abs/2102.06673</link>
      <description>arXiv:2102.06673v5 Announce Type: replace 
Abstract: We investigate the proof complexity of systems based on positive branching programs, i.e. non-deterministic branching programs (NBPs) where, for any 0-transition between two nodes, there is also a 1-transition. Positive NBPs compute monotone Boolean functions, just like negation-free circuits or formulas, but constitute a positive version of (non-uniform) NL, rather than P or NC1, respectively.

The proof complexity of NBPs was investigated in previous work by Buss, Das and Knop, using extension variables to represent the dag-structure, over a language of (non-deterministic) decision trees, yielding the system eLNDT. Our system eLNDT+ is obtained by restricting their systems to a positive syntax, similarly to how the 'monotone sequent calculus' MLK is obtained from the usual sequent calculus LK by restricting to negation-free formulas.

Our main result is that eLNDT+ polynomially simulates eLNDT over positive sequents. Our proof method is inspired by a similar result for MLK by Atserias, Galesi and Pudl\'ak, that was recently improved to a bona fide polynomial simulation via works of Je\v{r}\'abek and Buss, Kabanets, Kolokolova and Kouck\'y. Along the way we formalise several properties of counting functions within eLNDT+ by polynomial-size proofs and, as a case study, give explicit polynomial-size poofs of the propositional pigeonhole principle.</description>
      <guid isPermaLink="false">oai:arXiv.org:2102.06673v5</guid>
      <category>cs.CC</category>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Anupam Das, Avgerinos Delkos</dc:creator>
    </item>
    <item>
      <title>Linear Space Streaming Lower Bounds for Approximating CSPs</title>
      <link>https://arxiv.org/abs/2106.13078</link>
      <description>arXiv:2106.13078v3 Announce Type: replace 
Abstract: We consider the approximability of constraint satisfaction problems in the streaming setting. For every constraint satisfaction problem (CSP) on $n$ variables taking values in $\{0,\ldots,q-1\}$, we prove that improving over the trivial approximability by a factor of $q$ requires $\Omega(n)$ space even on instances with $O(n)$ constraints. We also identify a broad subclass of problems for which any improvement over the trivial approximability requires $\Omega(n)$ space. The key technical core is an optimal, $q^{-(k-1)}$-inapproximability for the Max $k$-LIN-mod $q$ problem, which is the Max CSP problem where every constraint is given by a system of $k-1$ linear equations $\bmod q$ over $k$ variables.
  Our work builds on and extends the breakthrough work of Kapralov and Krachun (Proc. STOC 2019) who showed a linear lower bound on any non-trivial approximation of the MaxCut problem in graphs. MaxCut corresponds roughly to the case of Max $k$-LIN-mod $q$ with ${k=q=2}$. For general CSPs in the streaming setting, prior results only yielded $\Omega(\sqrt{n})$ space bounds. In particular no linear space lower bound was known for an approximation factor less than $1/2$ for any CSP. Extending the work of Kapralov and Krachun to Max $k$-LIN-mod $q$ to $k&gt;2$ and $q&gt;2$ (while getting optimal hardness results) is the main technical contribution of this work. Each one of these extensions provides non-trivial technical challenges that we overcome in this work.</description>
      <guid isPermaLink="false">oai:arXiv.org:2106.13078v3</guid>
      <category>cs.CC</category>
      <category>cs.DS</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Chi-Ning Chou, Alexander Golovnev, Madhu Sudan, Ameya Velingker, Santhoshini Velusamy</dc:creator>
    </item>
    <item>
      <title>A proof of P != NP (New symmetric encryption algorithm against any linear attacks and differential attacks)</title>
      <link>https://arxiv.org/abs/2203.05022</link>
      <description>arXiv:2203.05022v3 Announce Type: replace 
Abstract: P vs NP problem is the most important unresolved problem in the field of computational complexity. Its impact has penetrated into all aspects of algorithm design, especially in the field of cryptography. The security of cryptographic algorithms based on short keys depends on whether P is equal to NP. In fact, Shannon[1] strictly proved that the one-time-pad system meets unconditional security, but because the one-time-pad system requires the length of key to be at least the length of plaintext, how to transfer the key is a troublesome problem that restricts the use of the one-time-pad system in practice. Cryptography algorithms used in practice are all based on short key, and the security of the short key mechanism is ultimately based on "one-way" assumption, that is, it is assumed that a one-way function exists. In fact, the existence of one-way function can directly lead to the important conclusion P != NP. In this paper, we originally constructed a short-key block cipher algorithm. The core feature of this algorithm is that for any block, when a plaintext-ciphertext pair is known, any key in the key space can satisfy the plaintext-ciphertext pair, that is, for each block, the plaintext-ciphertext pair and the key are independence, and the independence between blocks is also easy to construct. This feature is completely different from all existing short-key cipher algorithms. Based on the above feature, we construct a problem and theoretically prove that the problem satisfies the properties of one-way functions, thereby solving the problem of the existence of one-way functions, that is, directly proving that P != NP.</description>
      <guid isPermaLink="false">oai:arXiv.org:2203.05022v3</guid>
      <category>cs.CC</category>
      <category>cs.IT</category>
      <category>math.IT</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-nc-sa/4.0/</dc:rights>
      <dc:creator>Gao Ming</dc:creator>
    </item>
    <item>
      <title>An alternative explicit circuit diagram for the quantum search algorithm by implementing a non-unitary gate</title>
      <link>https://arxiv.org/abs/2412.16514</link>
      <description>arXiv:2412.16514v5 Announce Type: replace-cross 
Abstract: Since the final quantum state in the Grover search algorithm is the normalized marked quantum state from the Gram-Schmidt process, Abrams and Lloyd[1] has shown that we can generate this vector by using a non-unitary gate. Following their ideas, in this paper, we present multiple explicit unitary implementations by using the square root of the non-unitary matrix and by a unitary matrix that mimics the Gram-Schmidt process. We also discuss the implementation through a linear combination of unitary matrices or similar methods and how these approximations may change the complexity. The reading of the marked element from the given circuits with high probability still requires multiple repetitions similar to the original algorithm. However, it gives an alternative implementations which may be useful in certain platforms.</description>
      <guid isPermaLink="false">oai:arXiv.org:2412.16514v5</guid>
      <category>quant-ph</category>
      <category>cs.CC</category>
      <pubDate>Tue, 11 Mar 2025 00:00:00 -0400</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Ammar Daskin</dc:creator>
    </item>
  </channel>
</rss>
