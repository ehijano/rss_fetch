<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.PL updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.PL</link>
    <description>cs.PL updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.PL" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Jan 2025 05:00:46 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Sunday</day>
      <day>Saturday</day>
    </skipDays>
    <item>
      <title>Corecursive Coding of High Computational Derivatives and Power Series</title>
      <link>https://arxiv.org/abs/2501.13194</link>
      <description>arXiv:2501.13194v1 Announce Type: new 
Abstract: We discuss the functional lazy techniques in generation and handling of arbitrarily long sequences of derivatives of numerical expressions in one ``variable''; the domain to which the paper belongs is usually nicknamed ``Automatic differentiation''. Two models thereof are considered, the chains of ``pure'' derivatives, and the infinite power series, similar, but algorithmically a bit different. We deal with their arithmetic/algebra, and with more convoluted procedures, such as composition and reversion. Some more specific applications of these structures are also presented.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13194v1</guid>
      <category>cs.PL</category>
      <category>cs.DS</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Jerzy Karczmarczuk</dc:creator>
    </item>
    <item>
      <title>SMILES has to go : Representation of Molecules via Algebraic Data Types</title>
      <link>https://arxiv.org/abs/2501.13633</link>
      <description>arXiv:2501.13633v1 Announce Type: new 
Abstract: This paper proposes a novel representation of molecules through Algebraic Data Types (ADTs). The representation has useful properties primarily by including type information. The representation uses the Dietz representation enabling representation of organometallics with multi-centre, multi-atom bonding and delocalised electrons, resonant structures and co-ordinate data of atoms. Furthermore, this representation goes further than any other in the literature, providing a natural data structure to represent shells, subshells and orbitals. Perks of the representation include it's natural inclusion in reaction descriptions and the ability to make molecules instances of algebraic groups. The representation is further motivated as providing guarantees for those wishing to do Bayesian machine learning (probabilistic programming) over molecular structures. A criticism of competing and commonly used representations such as SMILES and SELFIES is provided and solutions are proposed to the weaknesses of these along with an open source library, written in Haskell. An example of integrating the library with LazyPPL -- a lazy probabilistic programming library written in Haskell -- is provided, conceptually justifying the efficiency of the representation over string based representations and recent work such as SELFIES. This library distinguishes between the data and the type of data -- enabling a separation of concerns between interface and object. I solve three problems associated with the future of SELFIES, molecular programming language, 3D information, syntactic invalidity and Dietz representation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13633v1</guid>
      <category>cs.PL</category>
      <category>cs.LG</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by-sa/4.0/</dc:rights>
      <dc:creator>Oliver Goldstein</dc:creator>
    </item>
    <item>
      <title>ASDF: A Compiler for Qwerty, a Basis-Oriented Quantum Programming Language</title>
      <link>https://arxiv.org/abs/2501.13262</link>
      <description>arXiv:2501.13262v1 Announce Type: cross 
Abstract: Qwerty is a high-level quantum programming language built on bases and functions rather than circuits. This new paradigm introduces new challenges in compilation, namely synthesizing circuits from basis translations and automatically specializing adjoint or predicated forms of functions. This paper presents ASDF, an open-source compiler for Qwerty that answers these challenges in compiling basis-oriented languages. Enabled with a novel high-level quantum IR implemented in the MLIR framework, our compiler produces OpenQASM 3 or QIR for either simulation or execution on hardware. Our compiler is evaluated by comparing the fault-tolerant resource requirements of generated circuits with other compilers, finding that ASDF produces circuits with comparable cost to prior circuit-oriented compilers.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13262v1</guid>
      <category>quant-ph</category>
      <category>cs.PL</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Austin J. Adams, Sharjeel Khan, Arjun S. Bhamra, Ryan R. Abusaada, Anthony M. Cabrera, Cameron C. Hoechst, Travis S. Humble, Jeffrey S. Young, Thomas M. Conte</dc:creator>
    </item>
    <item>
      <title>Verifying Graph Algorithms in Separation Logic: A Case for an Algebraic Approach (Extended Version)</title>
      <link>https://arxiv.org/abs/2501.13603</link>
      <description>arXiv:2501.13603v1 Announce Type: cross 
Abstract: Specifying and verifying graph-manipulating programs is a well-known and persistent challenge in separation logic. We show that the obstacles in dealing with graphs are removed if one represents graphs as partial commutative monoids, and admits applying over them structure-preserving functions (i.e., morphisms), including higher-order ones (i.e., combinators).
  By distributing over the monoid operations, morphisms work in tandem with framing to propagate the low-level pointer manipulation to the more abstract level of mathematical graphs, and to reduce the reasoning about the whole graph to reasoning about sub-components. We illustrate the approach with a novel and concise proof of a well-known graph benchmark, the Schorr-Waite graph marking algorithm.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.13603v1</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Marcos Grandury, Aleksandar Nanevski, Alexander Gryzlov</dc:creator>
    </item>
    <item>
      <title>Abstract Operational Methods for Call-by-Push-Value</title>
      <link>https://arxiv.org/abs/2410.17045</link>
      <description>arXiv:2410.17045v3 Announce Type: replace 
Abstract: Levy's call-by-push-value is a comprehensive programming paradigm that combines elements from functional and imperative programming, supports computational effects and subsumes both call-by-value and call-by-name evaluation strategies. In the present work, we develop modular methods to reason about program equivalence in call-by-push-value, and in fine-grain call-by-value, which is a popular lightweight call-by-value sublanguage of the former. Our approach is based on the fundamental observation that presheaf categories of sorted sets are suitable universes to model call-by-(push)-value languages, and that natural, coalgebraic notions of program equivalence such as applicative similarity and logical relations can be developed within. Starting from this observation, we formalize fine-grain call-by-value and call-by-push-value in the higher-order abstract GSOS framework, reduce their key congruence properties to simple syntactic conditions by leveraging existing theory and argue that introducing changes to either language incurs minimal proof overhead.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.17045v3</guid>
      <category>cs.PL</category>
      <category>cs.LO</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <arxiv:DOI>10.1145/3704871</arxiv:DOI>
      <dc:creator>Sergey Goncharov, Stelios Tsampas, Henning Urbat</dc:creator>
    </item>
    <item>
      <title>CUTECat: Concolic Execution for Computational Law</title>
      <link>https://arxiv.org/abs/2410.18212</link>
      <description>arXiv:2410.18212v2 Announce Type: replace 
Abstract: Many legal computations, including the amount of tax owed by a citizen, whether they are eligible to social benefits, or the wages due to civil state servants, are specified by computational laws. Their application, however, is performed by expert computer programs intended to faithfully transcribe the law into computer code. Bugs in these programs can lead to dramatic societal impact, e.g., paying employees incorrect amounts, or not awarding benefits to families in need.
  To address this issue, we consider concolic unit testing, a combination of concrete execution with SMT-based symbolic execution, and propose CUTECat, a concolic execution tool targeting implementations of computational laws. Such laws typically follow a pattern where a base case is later refined by many exceptions in following law articles, a pattern that can be formally modeled using default logic. We show how to handle default logic inside a concolic execution tool, and implement our approach in the context of Catala, a recent domain-specific language tailored to implement computational laws. We evaluate CUTECat on several programs, including the Catala implementation of the French housing benefits and Section 132 of the US tax code. We show that CUTECat can successfully generate hundreds of thousands of testcases covering all branches of these bodies of law. Through several heuristics, we improve CUTECat's scalability and usability, making the testcases understandable by lawyers and programmers alike. We believe CUTECat thus paves the way for the use of formal methods during legislative processes.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.18212v2</guid>
      <category>cs.PL</category>
      <category>cs.SE</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Pierre Goutagny, Aymeric Fromherz, Rapha\"el Monat</dc:creator>
    </item>
    <item>
      <title>A beginner guide to Iris, Coq and separation logic</title>
      <link>https://arxiv.org/abs/2105.12077</link>
      <description>arXiv:2105.12077v2 Announce Type: replace-cross 
Abstract: Creating safe concurrent algorithms is challenging and error-prone. For this reason, a formal verification framework is necessary especially when those concurrent algorithms are used in safety-critical systems. The goal of this guide is to provide resources for beginners to get started in their journey of formal verification using the powerful tool Iris. The difference between this guide and many others is that it provides (i) an in-depth explanation of examples and tactics, (ii) an explicit discussion of separation logic, and (iii) a thorough coverage of Iris and Coq. References to other guides and to papers are included throughout to provide readers with resources through which to continue their learning.</description>
      <guid isPermaLink="false">oai:arXiv.org:2105.12077v2</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Fri, 24 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Elizabeth Dietrich</dc:creator>
    </item>
  </channel>
</rss>
