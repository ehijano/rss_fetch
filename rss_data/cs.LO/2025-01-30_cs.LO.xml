<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:arxiv="http://arxiv.org/schemas/atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>cs.LO updates on arXiv.org</title>
    <link>http://rss.arxiv.org/rss/cs.LO</link>
    <description>cs.LO updates on the arXiv.org e-print archive.</description>
    <atom:link href="http://rss.arxiv.org/rss/cs.LO" rel="self" type="application/rss+xml"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 Jan 2025 05:00:11 +0000</lastBuildDate>
    <managingEditor>rss-help@arxiv.org</managingEditor>
    <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
    <skipDays>
      <day>Saturday</day>
      <day>Sunday</day>
    </skipDays>
    <item>
      <title>Weihrauch problems as containers</title>
      <link>https://arxiv.org/abs/2501.17250</link>
      <description>arXiv:2501.17250v1 Announce Type: new 
Abstract: We note that Weihrauch problems can be regarded as containers over the category of projective represented spaces and that Weihrauch reductions correspond exactly to container morphisms. We also show that Bauer's extended Weihrauch degrees and the posetal reflection of containers over partition assemblies are equivalent. Using this characterization, we show how a number of operators over Weihrauch degrees, such as the composition product, also arise naturally from the abstract theory of polynomial functors.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.17250v1</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>C\'ecilia Pradic, Ian Price</dc:creator>
    </item>
    <item>
      <title>Formally Verifying a Transformation from MLTL Formulas to Regular Expressions</title>
      <link>https://arxiv.org/abs/2501.17444</link>
      <description>arXiv:2501.17444v1 Announce Type: new 
Abstract: Mission-time Linear Temporal Logic (MLTL), a widely used subset of popular specification logics like STL and MTL, is often used to model and verify real world systems in safety-critical contexts. As the results of formal verification are only as trustworthy as their input specifications, the WEST tool was created to facilitate writing MLTL specifications. Accordingly, it is vital to demonstrate that WEST itself works correctly. To that end, we verify the WEST algorithm, which converts MLTL formulas to (logically equivalent) regular expressions, in the theorem prover Isabelle/HOL. Our top-level result establishes the correctness of the regular expression transformation; we then generate a code export from our verified development and use this to experimentally validate the existing WEST tool. To facilitate this, we develop some verified support for checking the equivalence of two regular expressions.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.17444v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Zili Wang, Katherine Kosaian, Kristin Yvonne Rozier</dc:creator>
    </item>
    <item>
      <title>Graphs of unbounded linear cliquewidth must transduce all trees</title>
      <link>https://arxiv.org/abs/2501.17556</link>
      <description>arXiv:2501.17556v1 Announce Type: new 
Abstract: The Pathwidth Theorem states that if a class of graphs has unbounded pathwidth, then it contains all trees as graph minors. We prove a similar result for dense graphs: if a class of graphs has unbounded linear cliquewidth, then it can produce all trees via some fixed CMSO transduction.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.17556v1</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Miko{\l}aj Bojanczyk, Pierre Ohlmann</dc:creator>
    </item>
    <item>
      <title>Model-checking real-time systems: revisiting the alternating automaton route</title>
      <link>https://arxiv.org/abs/2501.17576</link>
      <description>arXiv:2501.17576v1 Announce Type: new 
Abstract: Alternating timed automata (ATA) are an extension of timed automata, that are closed under complementation and hence amenable to logic-to-automata translations. Several timed logics, including Metric Temporal Logic (MTL), can be converted to equivalent 1-clock ATAs (1-ATAs). Satisfiability of an MTL formula therefore reduces to checking emptiness of a 1-ATA. Furthermore, algorithms for 1-ATA emptiness can be adapted for model-checking timed automata models against 1-ATA specifications. However, existing emptiness algorithms for 1-ATA proceed by an extended region construction, and are not suitable for implementations.
  In this work, we improve the existing MTL-to-1-ATA construction and develop a zone based emptiness algorithm for 1-ATAs. We first introduce a deactivation operation on the 1-ATA syntax to allow an explicit deactivation of the clock in transitions. Using the deactivation operation, we improve the existing MTL-to-1-ATA conversion and present a fragment of MTL for which the equivalent 1-ATA generate a bounded number of variables. Secondly, we develop the idea of zones for 1-ATA and present an emptiness algorithm which explores a corresponding zone graph. For termination, a special entailment check between zones is necessary. Our main technical contributions are: (1) an algorithm for the entailment check using simple zone operations and (2) an NP-hardness for the entailment check in the general case. Finally, for 1-ATA which generate a bounded number of variables, we present a modified entailment check with quadratic complexity.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.17576v1</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>new</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Patricia Bouyer, B Srivathsan, Vaishnavi Vishwanath</dc:creator>
    </item>
    <item>
      <title>Loops, Inverse Limits and Non-Determinism</title>
      <link>https://arxiv.org/abs/2501.17734</link>
      <description>arXiv:2501.17734v1 Announce Type: cross 
Abstract: We introduce an operator on problems in Weihrauch complexity, which we call the inverse limit, and which corresponds to an infinite compositional product. This operation arises naturally whenever one implements algorithms that produce a sequence of results in an infinite loop, using some fixed subroutine. We prove that the corresponding operator is monotone with respect to (strong) Weihrauch reducibility but that it is not a closure operator. One of our findings is that weak K\H{o}nig's lemma is closed under inverse limits, which implies that the class of non-deterministically computable problems is also closed under this operation. Consequently, this class allows for a high degree of flexibility in programming. As our main technical tools, we present an injective version of the recursion theorem and an infinitary version of the so-called independent choice theorem. We also show that, in general, the inverse limit operator is more powerful than the composition of the diamond operator followed by the parallelization operator. However, in many practical scenarios, these compositions yield a result, which coincides with the application of the inverse limit operator. Finally, we discuss the special situation of loops for single-valued problems and for problems on Turing degrees.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.17734v1</guid>
      <category>math.LO</category>
      <category>cs.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Vasco Brattka</dc:creator>
    </item>
    <item>
      <title>Learning Concepts Definable in First-Order Logic with Counting</title>
      <link>https://arxiv.org/abs/1909.03820</link>
      <description>arXiv:1909.03820v3 Announce Type: replace 
Abstract: We study Boolean classification problems over relational background structures in the logical framework introduced by Grohe and Tur\'an (TOCS 2004). It is known (Grohe and Ritzert, LICS 2017) that classifiers definable in first-order logic over structures of polylogarithmic degree can be learned in sublinear time, where the degree of the structure and the running time are measured in terms of the size of the structure. We generalise the results to the first-order logic with counting FOCN, which was introduced by Kuske and Schweikardt (LICS 2017) as an expressive logic generalising various other counting logics. Specifically, we prove that classifiers definable in FOCN over classes of structures of polylogarithmic degree can be consistently learned in sublinear time. This can be seen as a first step towards extending the learning framework to include numerical aspects of machine learning. We extend the result to agnostic probably approximately correct (PAC) learning for classes of structures of degree at most $(\log \log n)^c$ for some constant $c$. Moreover, we show that bounding the degree is crucial to obtain sublinear-time learning algorithms. That is, we prove that, for structures of unbounded degree, learning is not possible in sublinear time, even for classifiers definable in plain first-order logic.</description>
      <guid isPermaLink="false">oai:arXiv.org:1909.03820v3</guid>
      <category>cs.LO</category>
      <category>cs.AI</category>
      <category>cs.LG</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <arxiv:DOI>10.1109/LICS.2019.8785811</arxiv:DOI>
      <arxiv:journal_reference>34th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2019, Vancouver, BC, Canada, June 24-27, 2019</arxiv:journal_reference>
      <dc:creator>Steffen van Bergerem</dc:creator>
    </item>
    <item>
      <title>Bisimilarity in fresh-register automata</title>
      <link>https://arxiv.org/abs/2005.06411</link>
      <description>arXiv:2005.06411v4 Announce Type: replace 
Abstract: Register automata are a basic model of computation over infinite alphabets. Fresh-register automata extend register automata with the capability to generate fresh symbols in order to model computational scenarios involving name creation. This paper investigates the complexity of the bisimilarity problem for classes of register and fresh-register automata. We examine all main disciplines that have appeared in the literature: general register assignments; assignments where duplicate register values are disallowed; and assignments without duplicates in which registers cannot be empty. In the general case, we show that the problem is EXPTIME-complete.
  However, the absence of duplicate values in registers enables us to identify inherent symmetries inside the associated bisimulation relations, which can be used to establish a polynomial bound on the depth of Attacker-winning strategies. Furthermore, they enable a highly succinct representation of the corresponding bisimulations. By exploiting results from group theory and computational group theory, we can then show solvability in PSPACE and NP respectively for the latter two register disciplines. In each case, we find that freshness does not affect the complexity class of the problem.
  The results allow us to close a complexity gap for language equivalence of deterministic register automata. We show that deterministic language inequivalence for the no-duplicates fragment is NP-complete, which disproves an old conjecture of Sakamoto.
  Finally, we discover that, unlike in the finite-alphabet case, the addition of pushdown store makes bisimilarity undecidable, even in the case of visibly pushdown storage.</description>
      <guid isPermaLink="false">oai:arXiv.org:2005.06411v4</guid>
      <category>cs.LO</category>
      <category>cs.FL</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Andrzej S. Murawski, Steven J. Ramsay, Nikos Tzevelekos</dc:creator>
    </item>
    <item>
      <title>Parameterized Dynamic Logic -- Towards A Cyclic Logical Framework for General Program Specification and Verification</title>
      <link>https://arxiv.org/abs/2404.18098</link>
      <description>arXiv:2404.18098v4 Announce Type: replace 
Abstract: We present a theory of parameterized dynamic logic, namely DLp, for specifying and reasoning about a rich set of program models based on their transitional behaviours. Different from most dynamic logics that deal with regular expressions or a particular type of formalisms, DLp introduces a type of labels called "program configurations" as explicit program status for symbolic executions, allowing programs and formulas to be of arbitrary forms according to interested domains. This characteristic empowers dynamic logical formulas with a direct support of symbolic-execution-based reasoning, while still maintaining reasoning based on syntactic structures in traditional dynamic logics through a rule-lifting process. We propose a proof system and build a cyclic preproof structure special for DLp, which guarantees the soundness of infinite proof trees induced by symbolically executing programs with explicit/implicit loop structures. The soundness of DLp is formally analyzed and proved. DLp provides a flexible verification framework based on the theories of dynamic logics. It helps reduce the burden of developing different dynamic-logic theories for different programs, and save the additional transformations in the derivations of non-compositional programs. We give some examples of instantiations of DLp in particular domains, showing the potential and advantages of using DLp in practical usage.</description>
      <guid isPermaLink="false">oai:arXiv.org:2404.18098v4</guid>
      <category>cs.LO</category>
      <category>cs.SE</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Yuanrui Zhang</dc:creator>
    </item>
    <item>
      <title>PolyQEnt: A Polynomial Quantified Entailment Solver</title>
      <link>https://arxiv.org/abs/2408.03796</link>
      <description>arXiv:2408.03796v3 Announce Type: replace 
Abstract: Polynomial quantified entailments with existentially and universally quantified variables arise in many problems of verification and program analysis. We present PolyQEnt which is a tool for solving polynomial quantified entailments in which variables on both sides of the implication are real valued or unbounded integers. Our tool provides a unified framework for polynomial quantified entailment problems that arise in several papers in the literature. Our experimental evaluation over a wide range of benchmarks shows the applicability of the tool as well as its benefits as opposed to simply using existing SMT solvers to solve such constraints.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.03796v3</guid>
      <category>cs.LO</category>
      <category>cs.PL</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Krishnendu Chatterjee, Amir Kafshdar Goharshady, Ehsan Kafshdar Goharshady, Mehrdad Karrabi, Milad Saadat, Maximilian Seeliger, {\DJ}or{\dj}e \v{Z}ikeli\'c</dc:creator>
    </item>
    <item>
      <title>The equational theory of the Weihrauch lattice with (iterated) composition</title>
      <link>https://arxiv.org/abs/2408.14999</link>
      <description>arXiv:2408.14999v4 Announce Type: replace 
Abstract: We study the equational theory of the Weihrauch lattice with composition and iterations, meaning the collection of equations between terms built from variables, the lattice operations $\sqcup$, $\sqcap$, the composition operator $\star$ and its iteration $(-)^\diamond$ , which are true however we substitute (slightly extended) Weihrauch degrees for the variables. We characterize them using B\"uchi games on finite graphs and give a complete axiomatization that derives them. The term signature and the axiomatization are reminiscent of Kleene algebras, except that we additionally have meets and the lattice operations do not fully distributes over composition. The game characterization also implies that it is decidable whether an equation is universally valid. We give some complexity bounds; in particular, the problem is Pspace-hard in general and we conjecture that it is solvable in Pspace.</description>
      <guid isPermaLink="false">oai:arXiv.org:2408.14999v4</guid>
      <category>cs.LO</category>
      <category>math.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/publicdomain/zero/1.0/</dc:rights>
      <dc:creator>C\'ecilia Pradic</dc:creator>
    </item>
    <item>
      <title>A Formally Verified IEEE 754 Floating-Point Implementation of Interval Iteration for MDPs</title>
      <link>https://arxiv.org/abs/2501.10127</link>
      <description>arXiv:2501.10127v2 Announce Type: replace 
Abstract: Reasoning about quantitative properties of Markov Decision Processes (MDPs) inevitably requires computations on real or rational numbers. On modern hardware, these are usually efficiently implemented by floating-point numbers. However, due to their finite precision, many floating-point operations lead to small imprecisions. Probabilistic model checkers claim trustworthiness on the ground of a solid theoretical basis, yet prior work has uncovered discrepancies between the claimed and actual accuracy of these systems. How can we trust implementations of model checkers? Our answer is an efficiently executable, formally verified implementation of interval iteration for MDPs. Our correctness proofs span the entire development from the high-level abstract semantics of MDPs to the low-level implementation in LLVM that uses floating-point arithmetic. We use the Isabelle/HOL proof assistant to verify the abstract definition of interval iteration. Next, we employ step-wise refinement to derive an efficient implementation in LLVM code. To that end, we extend the Isabelle Refinement Framework with support for reasoning about floating point arithmetic and directed rounding modes. We experimentally evaluate our implementation on a set of benchmark MDPs. Our results show that the verified implementation is competitive with state-of-the-art tools for MDPs, while providing formal guarantees on the correctness of the results.</description>
      <guid isPermaLink="false">oai:arXiv.org:2501.10127v2</guid>
      <category>cs.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Bram Kohlen, Maximilian Sch\"affeler, Mohammad Abdulaziz, Arnd Hartmanns, Peter Lammich</dc:creator>
    </item>
    <item>
      <title>Random Deterministic Automata With One Added Transition</title>
      <link>https://arxiv.org/abs/2402.06591</link>
      <description>arXiv:2402.06591v4 Announce Type: replace-cross 
Abstract: Every language recognized by a non-deterministic finite automaton can be recognized by a deterministic automaton, at the cost of a potential increase of the number of states, which in the worst case can go from $n$ states to $2^n$ states. In this article, we investigate this classical result in a probabilistic setting where we take a deterministic automaton with $n$ states uniformly at random and add just one random transition. These automata are almost deterministic in the sense that only one state has a non-deterministic choice when reading an input letter. In our model, each state has a fixed probability to be final. We prove that for any $d\geq 1$, with non-negligible probability the minimal (deterministic) automaton of the language recognized by such an automaton has more than $n^d$ states; as a byproduct, the expected size of its minimal automaton grows faster than any polynomial. Our result also holds when each state is final with some probability that depends on $n$, as long as it is not too close to $0$ and $1$, at distance at least $\Omega(\frac1{\sqrt{n}})$ to be precise, therefore allowing models with a sublinear number of final states in expectation.</description>
      <guid isPermaLink="false">oai:arXiv.org:2402.06591v4</guid>
      <category>cs.FL</category>
      <category>cs.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://creativecommons.org/licenses/by/4.0/</dc:rights>
      <dc:creator>Arnaud Carayol, Philippe Duchon, Florent Koechlin, Cyril Nicaud</dc:creator>
    </item>
    <item>
      <title>Unification in the description logic $\mathcal{FL}_\bot$</title>
      <link>https://arxiv.org/abs/2405.00912</link>
      <description>arXiv:2405.00912v4 Announce Type: replace-cross 
Abstract: Description Logics are a formalism used in the knowledge representation, where the knowledge is captured in the form of concepts constructed in a controlled way from a restricted vocabulary. This allows one to test effectively for consistency of and the subsumption between the concepts. Unification of concepts may likewise become a useful tool in analysing the relations between concepts. The unification problem has been solved for the description logics $\mathcal{FL}_0$ and $\mathcal{EL}$. These small logics do not provide any means to express negation. Here we show an algorithm solving unification in $\mathcal{FL}_\bot$, the logic that extends $\mathcal{FL}_0$ with the bottom concept. Bottom allows one to express that two concepts are disjoint. Our algorithm runs in exponential time, with respect to the size of the problem.</description>
      <guid isPermaLink="false">oai:arXiv.org:2405.00912v4</guid>
      <category>cs.SC</category>
      <category>cs.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Barbara Morawska</dc:creator>
    </item>
    <item>
      <title>Revisiting Differential Verification: Equivalence Verification with Confidence</title>
      <link>https://arxiv.org/abs/2410.20207</link>
      <description>arXiv:2410.20207v2 Announce Type: replace-cross 
Abstract: When validated neural networks (NNs) are pruned (and retrained) before deployment, it is desirable to prove that the new NN behaves equivalently to the (original) reference NN. To this end, our paper revisits the idea of differential verification which performs reasoning on differences between NNs: On the one hand, our paper proposes a novel abstract domain for differential verification admitting more efficient reasoning about equivalence. On the other hand, we investigate empirically and theoretically which equivalence properties are (not) efficiently solved using differential reasoning. Based on the gained insights, and following a recent line of work on confidence-based verification, we propose a novel equivalence property that is amenable to Differential Verification while providing guarantees for large parts of the input space instead of small-scale guarantees constructed w.r.t. predetermined input points. We implement our approach in a new tool called VeryDiff and perform an extensive evaluation on numerous old and new benchmark families, including new pruned NNs for particle jet classification in the context of CERN's LHC where we observe median speedups &gt;300x over the State-of-the-Art verifier alpha,beta-CROWN.</description>
      <guid isPermaLink="false">oai:arXiv.org:2410.20207v2</guid>
      <category>cs.LG</category>
      <category>cs.LO</category>
      <pubDate>Thu, 30 Jan 2025 00:00:00 -0500</pubDate>
      <arxiv:announce_type>replace-cross</arxiv:announce_type>
      <dc:rights>http://arxiv.org/licenses/nonexclusive-distrib/1.0/</dc:rights>
      <dc:creator>Samuel Teuber, Philipp Kern, Marvin Janzen, Bernhard Beckert</dc:creator>
    </item>
  </channel>
</rss>
